    * **Return value**: Implementations MUST return `AppResponse::Error` with an informative message if the application is already enabled.

* `EnableApp -> Ok`: Enable an app which has been awaiting, and has received, deferred membrane proofs.
    * **Notes**: If the app is awaiting deferred membrane proofs, implementations MUST NOT allow an app to be enabled until the membrane proofs has been provided.
    * **Return value**: If this call is attempted on an already running app or an app that is still awaiting membrane proofs, implementations MUST return `AppResponse::Error` with an informative message.


================================================
File: docs/specs/src/pandoc-template.latex
================================================
% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode$for(hyperrefoptions)$,$hyperrefoptions$$endfor$}{hyperref}
\PassOptionsToPackage{hyphens}{url}
$if(colorlinks)$
\PassOptionsToPackage{dvipsnames,svgnames*,x11names*}{xcolor}
$endif$
$if(dir)$
$if(latex-dir-rtl)$
\PassOptionsToPackage{RTLdocument}{bidi}
$endif$
$endif$
$if(CJKmainfont)$
\PassOptionsToPackage{space}{xeCJK}
$endif$
%
\documentclass[twocolumn,showpacs,%
  nofootinbib,aps,superscriptaddress,%
  eqsecnum,prd,notitlepage,showkeys,10pt,
$if(fontsize)$
  $fontsize$,
$endif$
$if(lang)$
  $babel-lang$,
$endif$
$if(papersize)$
  $papersize$paper,
$endif$
$if(beamer)$
  ignorenonframetext,
$if(handout)$
  handout,
$endif$
$if(aspectratio)$
  aspectratio=$aspectratio$,
$endif$
$endif$
$for(classoption)$
  $classoption$$sep$,
$endfor$
]{$documentclass$}
$if(beamer)$
$if(background-image)$
\usebackgroundtemplate{%
  \includegraphics[width=\paperwidth]{$background-image$}%
}
$endif$

\usepackage{pgfpages}
\setbeamertemplate{caption}[numbered]
\setbeamertemplate{caption label separator}{: }
\setbeamercolor{caption name}{fg=normal text.fg}
\beamertemplatenavigationsymbols$if(navigation)$$navigation$$else$empty$endif$
$for(beameroption)$
\setbeameroption{$beameroption$}
$endfor$
% Prevent slide breaks in the middle of a paragraph
\widowpenalties 1 10000
\raggedbottom
$if(section-titles)$
\setbeamertemplate{part page}{
  \centering
  \begin{beamercolorbox}[sep=16pt,center]{part title}
    \usebeamerfont{part title}\insertpart\par
  \end{beamercolorbox}
}
\setbeamertemplate{section page}{
  \centering
  \begin{beamercolorbox}[sep=12pt,center]{part title}
    \usebeamerfont{section title}\insertsection\par
  \end{beamercolorbox}
}
\setbeamertemplate{subsection page}{
  \centering
  \begin{beamercolorbox}[sep=8pt,center]{part title}
    \usebeamerfont{subsection title}\insertsubsection\par
  \end{beamercolorbox}
}
\AtBeginPart{
  \frame{\partpage}
}
\AtBeginSection{
  \ifbibliography
  \else
    \frame{\sectionpage}
  \fi
}
\AtBeginSubsection{
  \frame{\subsectionpage}
}
$endif$
$endif$
$if(beamerarticle)$
\usepackage{beamerarticle} % needs to be loaded first
$endif$
$if(fontfamily)$
\usepackage[$for(fontfamilyoptions)$$fontfamilyoptions$$sep$,$endfor$]{$fontfamily$}
$else$
\usepackage{lmodern}
$endif$
$if(linestretch)$
\usepackage{setspace}
$endif$
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[$if(fontenc)$$fontenc$$else$T1$endif$]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
$if(mathspec)$
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{unicode-math}
  \fi
$else$
  \usepackage{unicode-math}
$endif$
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
$if(mainfont)$
  \setmainfont[$for(mainfontoptions)$$mainfontoptions$$sep$,$endfor$]{$mainfont$}
$endif$
$if(sansfont)$
  \setsansfont[$for(sansfontoptions)$$sansfontoptions$$sep$,$endfor$]{$sansfont$}
$endif$
$if(monofont)$
  \setmonofont[$for(monofontoptions)$$monofontoptions$$sep$,$endfor$]{$monofont$}
$endif$
$for(fontfamilies)$
  \newfontfamily{$fontfamilies.name$}[$for(fontfamilies.options)$$fontfamilies.options$$sep$,$endfor$]{$fontfamilies.font$}
$endfor$
$if(mathfont)$
$if(mathspec)$
  \ifxetex
    \setmathfont(Digits,Latin,Greek)[$for(mathfontoptions)$$mathfontoptions$$sep$,$endfor$]{$mathfont$}
  \else
    \setmathfont[$for(mathfontoptions)$$mathfontoptions$$sep$,$endfor$]{$mathfont$}
  \fi
$else$
  \setmathfont[$for(mathfontoptions)$$mathfontoptions$$sep$,$endfor$]{$mathfont$}
$endif$
$endif$
$if(CJKmainfont)$
  \ifxetex
    \usepackage{xeCJK}
    \setCJKmainfont[$for(CJKoptions)$$CJKoptions$$sep$,$endfor$]{$CJKmainfont$}
  \fi
$endif$
$if(luatexjapresetoptions)$
  \ifluatex
    \usepackage[$for(luatexjapresetoptions)$$luatexjapresetoptions$$sep$,$endfor$]{luatexja-preset}
  \fi
$endif$
$if(CJKmainfont)$
  \ifluatex
    \usepackage[$for(luatexjafontspecoptions)$$luatexjafontspecoptions$$sep$,$endfor$]{luatexja-fontspec}
    \setmainjfont[$for(CJKoptions)$$CJKoptions$$sep$,$endfor$]{$CJKmainfont$}
  \fi
$endif$
\fi
$if(beamer)$
$if(theme)$
\usetheme[$for(themeoptions)$$themeoptions$$sep$,$endfor$]{$theme$}
$endif$
$if(colortheme)$
\usecolortheme{$colortheme$}
$endif$
$if(fonttheme)$
\usefonttheme{$fonttheme$}
$endif$
$if(mainfont)$
\usefonttheme{serif} % use mainfont rather than sansfont for slide text
$endif$
$if(innertheme)$
\useinnertheme{$innertheme$}
$endif$
$if(outertheme)$
\useoutertheme{$outertheme$}
$endif$
$endif$
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[$for(microtypeoptions)$$microtypeoptions$$sep$,$endfor$]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
$if(indent)$
$else$
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
$endif$
$if(verbatim-in-note)$
\usepackage{fancyvrb}
$endif$
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
$if(title-meta)$
  pdftitle={$title-meta$},
$endif$
$if(author-meta)$
  pdfauthor={$author-meta$},
$endif$
$if(lang)$
  pdflang={$lang$},
$endif$
$if(subject)$
  pdfsubject={$subject$},
$endif$
$if(keywords)$
  pdfkeywords={$for(keywords)$$keywords$$sep$, $endfor$},
$endif$
  hidelinks,
  pdfcreator={LaTeX via pandoc}
}

% Style links the way we want

\usepackage{soul}
% This makes it so we don't have to escape every underscore in every URL
% (which indeed we can't from Markdown)
% but leaves underscores in math intact as subscript modifiers.
\usepackage{underscore}
\NewCommandCopy\styledhyperlink\hyperlink
\renewcommand{\hyperlink}[2]{\styledhyperlink{#1}{\color{blue}\setulcolor{blue}\ul{#2}}}
\NewCommandCopy\styledhref\href
\renewcommand{\href}[2]{\styledhref{#1}{\color{blue}\setulcolor{blue}\ul{#2}}}
\urlstyle{same} % disable monospaced font for URLs
\renewcommand{\url}[1]{\styledhref{#1}{\color{blue}\setulcolor{blue}\ul{#1}}}

$if(verbatim-in-note)$
\VerbatimFootnotes % allow verbatim text in footnotes
$endif$
$if(geometry)$
$if(beamer)$
\geometry{$for(geometry)$$geometry$$sep$,$endfor$}
$else$
\usepackage[$for(geometry)$$geometry$$sep$,$endfor$]{geometry}
$endif$
$endif$
$if(beamer)$
\newif\ifbibliography
$endif$
$if(listings)$
\usepackage{listings}
\newcommand{\passthrough}[1]{#1}
\lstset{defaultdialect=[5.3]Lua}
\lstset{defaultdialect=[x86masm]Assembler}
$endif$
$if(lhs)$
\lstnewenvironment{code}{\lstset{language=Haskell,basicstyle=\small\ttfamily}}{}
$endif$
$if(highlighting-macros)$
$highlighting-macros$
$endif$
$if(tables)$
\usepackage{longtable,booktabs}
$if(beamer)$
\usepackage{caption}
% Make caption package work with longtable
\makeatletter
\newsavebox\pandoc@box
\newcommand*\pandocbounded[1]{% scales image to fit in text height/width
  \sbox\pandoc@box{#1}%
  \Gscale@div\@tempa{\textheight}{\dimexpr\ht\pandoc@box+\dp\pandoc@box\relax}%
  \Gscale@div\@tempb{\linewidth}{\wd\pandoc@box}%
  \ifdim\@tempb\p@<\@tempa\p@\let\@tempa\@tempb\fi% select the smaller of both
  \ifdim\@tempa\p@<\p@\scalebox{\@tempa}{\usebox\pandoc@box}%
  \else\usebox{\pandoc@box}%
  \fi%
}

\def\fnum@table{\tablename~\thetable}
\makeatother
$else$
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
$endif$
$endif$
$if(graphics)$
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
$endif$
$if(links-as-notes)$
% Make links footnotes instead of hotlinks:
\DeclareRobustCommand{\href}[2]{#2\footnote{\url{#1}}}
$endif$
$if(strikeout)$
\usepackage[normalem]{ulem}
% Avoid problems with \sout in headers with hyperref
\pdfstringdefDisableCommands{\renewcommand{\sout}{}}
$endif$
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
$if(numbersections)$
\setcounter{secnumdepth}{$if(secnumdepth)$$secnumdepth$$else$5$endif$}
$else$
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
$endif$
$if(beamer)$
$else$
$if(block-headings)$
% Make \paragraph and \subparagraph free-standing
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi
$endif$
$endif$
$if(pagestyle)$
\pagestyle{$pagestyle$}
$endif$
$for(header-includes)$
$header-includes$
$endfor$
$if(lang)$
\ifxetex
  % Load polyglossia as late as possible: uses bidi with RTL langages (e.g. Hebrew, Arabic)
  \usepackage{polyglossia}
  \setmainlanguage[$polyglossia-lang.options$]{$polyglossia-lang.name$}
$for(polyglossia-otherlangs)$
  \setotherlanguage[$polyglossia-otherlangs.options$]{$polyglossia-otherlangs.name$}
$endfor$
\else
  \usepackage[shorthands=off,$for(babel-otherlangs)$$babel-otherlangs$,$endfor$main=$babel-lang$]{babel}
$if(babel-newcommands)$
  $babel-newcommands$
$endif$
\fi
$endif$
$if(dir)$
\ifxetex
  % Load bidi as late as possible as it modifies e.g. graphicx
  \usepackage{bidi}
\fi
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \TeXXeTstate=1
  \newcommand{\RL}[1]{\beginR #1\endR}
  \newcommand{\LR}[1]{\beginL #1\endL}
  \newenvironment{RTL}{\beginR}{\endR}
  \newenvironment{LTR}{\beginL}{\endL}
\fi
$endif$
$if(natbib)$
\usepackage[$natbiboptions$]{natbib}
\bibliographystyle{$if(biblio-style)$$biblio-style$$else$plainnat$endif$}
$endif$
$if(biblatex)$
\usepackage[$if(biblio-style)$style=$biblio-style$,$endif$$for(biblatexoptions)$$biblatexoptions$$sep$,$endfor$]{biblatex}
$for(bibliography)$
\addbibresource{$bibliography$}
$endfor$
$endif$
$if(csl-refs)$
\newlength{\cslhangindent}
\setlength{\cslhangindent}{1.5em}
\newenvironment{cslreferences}%
  {$if(csl-hanging-indent)$\setlength{\parindent}{0pt}%
  \everypar{\setlength{\hangindent}{\cslhangindent}}\ignorespaces$endif$}%
  {\par}
$endif$
\usepackage{etoolbox}

\usepackage{svg}

\renewenvironment{figure}{\begin{figure*}}{\end{figure*}}

\usepackage{titlesec}
\titleformat{\section}{\center\normalfont\large\scshape}{\thesection}{1em}{}
\titleformat{\subsection}{\center\normalfont\scshape}{\thesubsection}{1em}{}
\titlespacing*{\subsection}{0pt}{3.25ex plus 1ex minus .2ex}{.5em}
\titleformat{\subsubsection}{\center\normalfont}{\thesubsubsection}{1em}{}
\titlespacing*{\subsubsection}{0pt}{3.25ex plus 1ex minus .2ex}{.5em}

\begin{document}

$if(title)$
\title{$title$$if(thanks)$\thanks{$thanks$}$endif$$if(subtitle)$ \\
\small $subtitle$$endif$}
$endif$
$for(author)$\author{$author$}
$endfor$
$if(date)$
\date{$date$}
$endif$
$if(beamer)$
$if(institute)$
\institute{$for(institute)$$institute$$sep$ \and $endfor$}
$endif$
$if(titlegraphic)$
\titlegraphic{\includegraphics{$titlegraphic$}}
$endif$
$if(logo)$
\logo{\includegraphics{$logo$}}
$endif$
$endif$

$if(has-frontmatter)$
\frontmatter
$endif$
$if(title)$
$if(beamer)$
\frame{\titlepage}
$else$
$if(abstract)$
\begin{abstract}
$abstract$
\end{abstract}
$endif$
\maketitle
$endif$
$endif$

$for(include-before)$
$include-before$

$endfor$
$if(toc)$
$if(toc-title)$
\renewcommand*\contentsname{$toc-title$}
$endif$
$if(beamer)$
\begin{frame}[allowframebreaks]
$if(toc-title)$
  \frametitle{$toc-title$}
$endif$
  \tableofcontents[hideallsubsections]
\end{frame}
$else$
{
\setcounter{tocdepth}{$toc-depth$}
\tableofcontents
}
$endif$
$endif$
$if(lot)$
\listoftables
$endif$
$if(lof)$
\listoffigures
$endif$
$if(linestretch)$
\setstretch{$linestretch$}
$endif$
$if(has-frontmatter)$
\mainmatter
$endif$
$body$

$if(has-frontmatter)$
\backmatter
$endif$
$if(natbib)$
$if(bibliography)$
$if(biblio-title)$
$if(has-chapters)$
\renewcommand\bibname{$biblio-title$}
$else$
\renewcommand\refname{$biblio-title$}
$endif$
$endif$
$if(beamer)$
\begin{frame}[allowframebreaks]{$biblio-title$}
  \bibliographytrue
$endif$
  \bibliography{$for(bibliography)$$bibliography$$sep$,$endfor$}
$if(beamer)$
\end{frame}
$endif$

$endif$
$endif$
$if(biblatex)$
$if(beamer)$
\begin{frame}[allowframebreaks]{$biblio-title$}
  \bibliographytrue
  \printbibliography[heading=none]
\end{frame}
$else$
\printbibliography$if(biblio-title)$[title=$biblio-title$]$endif$
$endif$

$endif$
$for(include-after)$
$include-after$

$endfor$
\end{document}



================================================
File: docs/specs/src/.gitignore
================================================
!*.svg
media/*
*.fdb_latexmk
*.synctex.gz
*.pdf
*.fls
*.tex
*.aux
*.docx
*.bib
*.bbl
*.blg
*.out
hwp.*
holochain-white-paper*
!holochain-white-paper-alpha.tex


================================================
File: docs/specs/src/diagram-1.0.0/README.md
================================================
Diagram Generator
=================

This Lua filter is used to create figures from code blocks: images
are generated from the code with the help of external programs.
The filter processes diagram code for Asymptote, Graphviz,
Mermaid, PlantUML, and Ti*k*Z.


Usage
-----

The filter modifies the internal document representation; it can
be used with many publishing systems that are based on pandoc.

### Plain pandoc

Pass the filter to pandoc via the `--lua-filter` (or `-L`) command
line option.

    pandoc --lua-filter diagram.lua ...

### Quarto

Users of Quarto can install this filter as an extension with

    quarto install extension pandoc-ext/diagram

and use it by adding `diagram` to the `filters` entry in their
YAML header.

``` yaml
---
filters:
  - diagram
---
``**

**Note**: Quarto comes with its own system for diagram generation;
we recommend to use Quarto's built-in diagram options when
possible, especially for Mermaid diagrams.

### R Markdown

Use `pandoc_args` to invoke the filter. See the [R Markdown
Cookbook](https://bookdown.org/yihui/rmarkdown-cookbook/lua-filters.html)
for details.

``` yaml
---
output:
  word_document:
    pandoc_args: ['--lua-filter=diagram.lua']
---
```

Diagram types
-------------

The table below lists the supported diagram drawing systems, the
class that must be used for the system, and the main executable
that the filter calls to generate an image from the code. The
*environment variables* column lists the names of env variables
that can be used to specify a specific executable.

| System      | code block class  | executable | env variable    |
|-------------|-------------------|------------|-----------------|
| [Asymptote] | `asymptote`       | `asy`      | `ASYMPTOTE_BIN` |
| [GraphViz]  | `dot`             | `dot`      | `DOT_BIN`       |
| [Mermaid]   | `mermaid`         | `mmdc`     | `MERMAID_BIN`   |
| [PlantUML]  | `plantuml`        | `plantuml` | `PLANTUML_BIN`  |
| [Ti*k*Z]    | `tikz`            | `pdflatex` | `PDFLATEX_BIN`  |

### Other diagram engines

The filter can be extended with local packages; see
[Configuration](#configuration) below.

[Asymptote]: https://asymptote.sourceforge.io/
[GraphViz]: https://www.graphviz.org/
[Mermaid]: https://mermaid.js.org/
[PlantUML]: https://plantuml.org/
[Ti*k*Z]: https://en.wikipedia.org/wiki/PGF/TikZ

Figure options
--------------

Options can be given using the syntax pioneered by [Quarto]:

````
``` {.dot}
//| label: fig-boring
//| fig-cap: "A boring Graphviz graph."
digraph boring {
  A -> B;
}
```
````

[Quarto]: https://quarto.org/

Configuration
-------------

The filter can be configured with the `diagram` metadata entry.

Currently supported options:

- `cache`: controls whether the images are cached. If the cache is
  enabled, then the images are recreated only when their code
  changes. This option is *disabled* by default.

- `cache-dir`: Sets the directory in which the images are cached.
  The default is to use the `pandoc-diagram-filter` subdir of the
  a common caching location. This will be, in the order of
  preference, the value of the `XDG_CACHE_HOME` environment
  variable if it is set, or alternatively `%USERPROFILE%\.cache` on
  Windows and `$HOME/.cache` on all other platforms.

  Caching is disabled if none of the environment variables
  mentioned above has been defined.

- `engine`: options for specific engines, e.g. `plantuml` or
  `mermaid`. The options must be nested below the engine name.
  Allowed settings are either `true` or `false` to enable or
  disable the engine, respectively, or a map of options.
  The available settings are:

  + `mime-type`: the output MIME type that should be produced with
    this engine. This can be used to choose a specific type, or to
    disable certain output formats. For example, the below
    disables support for PDF output in PlantUML, which can be
    useful when the necessary libraries are unavailable on a
    system:

    ``` yaml
    diagram:
      engine:
        plantuml:
          mime-type:
            application/pdf: false
    ```

  + `line_comment_start`: the character sequence that starts a
    line comment; unset or change this to disable or modify the
    syntax of user options in the diagram code.

  + `execpath`: the path to the engine's executable. Use this to
    override the default executable name listed in the table
    above.

  + `package`: if this option is set then the filter will try to
    `require` a Lua package with the given name. If the operation
    is successful, then the result will be used as the compiler
    for that diagram type.

  + Any other option is passed through to the engine. See the
    engine-specific settings below.

### Engine-specific options

Some engines accept additional options. These options can either
be passed globally as part of the respective `engine` entry, or
locally by adding `opt-NAME` as an attribute to the diagram code
block. Global options always override local options for security
reasons.

#### Ti*k*Z

The Ti*k*Z engine accepts the `header-includes` and
`additional-packages` options. Both options are added to the
intermediary TeX file that is used to produce the output file. The
options differ only in how string values are handled, with bare
strings in `header-includes` being escaped and those in
`additional-packages` being treated as TeX code.

While mentioned above, it should be highlighted that the
`execpath` option can be used to select a specific LaTeX engine.
The default is `pdflatex`.

Example:

``` yaml
---
diagram:
  engine:
    tikz:
      execpath: lualatex
      include-headers:
        - '\usepackage{adjustbox}'
        - '\usetikzlibrary{arrows, shapes}'
---
```

Security
--------

This filter **should not** be used with **untrusted documents**,
***unless*** local configs prevent the setting of filter options
in the metadata: An attacker that can set the execpath for an
engine can execute any binary on the system with the user's
permissions. It is hence recommended to review any document before
using it with this filter to avoid malicious and misuse of the
filter.

The security is improved considerably if the `diagram` metadata
field is unset or set to a predefined value before this filter is
called, e.g., via another filter or a defaults file.

Here is an example defaults file that configures the filter such
that the configs cannot be overwritten by the document.

``` yaml
# file: diagram-filter.yaml
filters: ['diagram.lua']
metadata:
  engine:
    # enable dot/GraphViz and PlantUML with default options
    dot: true
    plantuml: true

    # disable processing of asymptote and Mermaid diagrams
    asymptote: false
    mermaid: false

    # Use LuaLaTeX to compile TikZ, define headers
    tikz:
      execpath: lualatex
      additional-packages: |
        \usepackage{adjustbox}
        \usetikzlibrary{arrows, shapes}
```

Usage:

    pandoc -d diagram-filter ...



================================================
File: docs/specs/src/diagram-1.0.0/_extensions/diagram/diagram.lua
================================================
--[[
diagram-generator – create images and figures from code blocks.

See copyright notice in file LICENSE.
]]
-- Module pandoc.system is required and was added in version 2.7.3
PANDOC_VERSION:must_be_at_least '3.0'

-- Report Lua warnings to stderr
if warn then
  warn '@on'
else
  warn = function (...) io.stderr:write(string.concat({...})) end
end

local system = require 'pandoc.system'
local utils = require 'pandoc.utils'
local stringify = utils.stringify
local with_temporary_directory = system.with_temporary_directory
local with_working_directory = system.with_working_directory

--- Returns a filter-specific directory in which cache files can be
--- stored, or nil if no such directory is available.
local function cachedir ()
  local cache_home = os.getenv 'XDG_CACHE_HOME'
  if not cache_home or cache_home == '' then
    local user_home = system.os == 'windows'
      and os.getenv 'USERPROFILE'
      or os.getenv 'HOME'

    if not user_home or user_home == '' then
      return nil
    end
    cache_home = pandoc.path.join{user_home, '.cache'} or nil
  end

  -- Create filter cache directory
  return pandoc.path.join{cache_home, 'pandoc-diagram-filter'}
end

--- Path holding the image cache, or `nil` if the cache is not used.
local image_cache = nil

local mimetype_for_extension = {
  jpeg = 'image/jpeg',
  jpg = 'image/jpeg',
  pdf = 'application/pdf',
  png = 'image/png',
  svg = 'image/svg+xml',
}

local extension_for_mimetype = {
  ['application/pdf'] = 'pdf',
  ['image/jpeg'] = 'jpg',
  ['image/png'] = 'png',
  ['image/svg+xml'] = 'svg',
}

--- Converts a list of format specifiers to a set of MIME types.
local function mime_types_set (tbl)
  local set = {}
  local mime_type
  for _, image_format_spec in ipairs(tbl) do
    mime_type = mimetype_for_extension[image_format_spec] or image_format_spec
    set[mime_type] = true
  end
  return set
end

--- Reads the contents of a file.
local function read_file (filepath)
  local fh = io.open(filepath, 'rb')
  local contents = fh:read('a')
  fh:close()
  return contents
end

--- Writes the contents into a file at the given path.
local function write_file (filepath, content)
  local fh = io.open(filepath, 'wb')
  fh:write(content)
  fh:close()
end

--
-- Diagram Engines
--

-- PlantUML engine; assumes that there's a `plantuml` binary.
local plantuml = {
  line_comment_start =  [[']],
  mime_types = mime_types_set{'pdf', 'png', 'svg'},
  compile = function (self, puml)
    local mime_type = self.mime_type or 'image/svg+xml'
    -- PlantUML format identifiers correspond to common file extensions.
    local format = extension_for_mimetype[mime_type]
    if not format then
      format, mime_type = 'svg', 'image/svg+xml'
    end
    local args = {'-t' .. format, "-pipe", "-charset", "UTF8"}
    return pandoc.pipe(self.execpath or 'plantuml', args, puml), mime_type
  end,
}

--- GraphViz engine for the dot language
local graphviz = {
  line_comment_start = '//',
  mime_types = mime_types_set{'jpg', 'pdf', 'png', 'svg'},
  mime_type = 'image/svg+xml',
  compile = function (self, code)
    local mime_type = self.mime_type
    -- GraphViz format identifiers correspond to common file extensions.
    local format = extension_for_mimetype[mime_type]
    if not format then
      format, mime_type = 'svg', 'image/svg+xml'
    end
    return pandoc.pipe(self.execpath or 'dot', {"-T"..format}, code), mime_type
  end,
}

--- Mermaid engine
local mermaid = {
  line_comment_start = '%%',
  mime_types = mime_types_set{'pdf', 'png', 'svg'},
  compile = function (self, code)
    local mime_type = self.mime_type or 'image/svg+xml'
    local file_extension = extension_for_mimetype[mime_type]
    return with_temporary_directory("diagram", function (tmpdir)
      return with_working_directory(tmpdir, function ()
        local infile = 'diagram.mmd'
        local outfile = 'diagram.' .. file_extension
        write_file(infile, code)
        pandoc.pipe(
          self.execpath or 'mmdc',
          {"--pdfFit", "--input", infile, "--output", outfile},
          ''
        )
        return read_file(outfile), mime_type
      end)
    end)
  end,
}

--- TikZ
--

--- LaTeX template used to compile TikZ images. Takes additional
--- packages as the first, and the actual TikZ code as the second
--- argument.
local tikz_template = pandoc.template.compile [[
\documentclass{standalone}
\usepackage{tikz}
$for(header-includes)$
$it$
$endfor$
$additional-packages$
\begin{document}
$body$
\end{document}
]]

--- The TikZ engine uses pdflatex to compile TikZ code to an image
local tikz = {
  line_comment_start = '%%',

  mime_types = {
    ['application/pdf'] = true,
  },

  --- Compile LaTeX with TikZ code to an image
  compile = function (self, src, user_opts)
    return with_temporary_directory("tikz", function (tmpdir)
      return with_working_directory(tmpdir, function ()
        -- Define file names:
        local file_template = "%s/tikz-image.%s"
        local tikz_file = file_template:format(tmpdir, "tex")
        local pdf_file = file_template:format(tmpdir, "pdf")

        -- Treat string values as raw LaTeX
        local meta = {
          ['header-includes'] = user_opts['header-includes'],
          ['additional-packages'] = {pandoc.RawInline(
            'latex',
            stringify(user_opts['additional-packages'] or '')
          )},
        }
        local tex_code = pandoc.write(
          pandoc.Pandoc({pandoc.RawBlock('latex', src)}, meta),
          'latex',
          {template = tikz_template}
        )
        write_file(tikz_file, tex_code)

        -- Execute the LaTeX compiler:
        pandoc.pipe(
          self.execpath or 'pdflatex',
          {'-output-directory', tmpdir, tikz_file},
          ''
        )

        return read_file(pdf_file), 'application/pdf'
      end)
    end)
  end
}

--- Asymptote diagram engine
local asymptote = {
  line_comment_start = '%%',
  mime_types = {
    ['application/pdf'] = true,
  },
  compile = function (self, code)
    return with_temporary_directory("asymptote", function(tmpdir)
      return with_working_directory(tmpdir, function ()
        local pdf_file = "pandoc_diagram.pdf"
        local args = {'-tex', 'pdflatex', "-o", "pandoc_diagram", '-'}
        pandoc.pipe(self.execpath or 'asy', args, code)
        return read_file(pdf_file), 'application/pdf'
      end)
    end)
  end,
}

local default_engines = {
  asymptote = asymptote,
  dot       = graphviz,
  mermaid   = mermaid,
  plantuml  = plantuml,
  tikz      = tikz,
}

--
-- Configuration
--

--- Options for the output format of the given name.
local function format_options (name)
  local pdf2svg = name ~= 'latex' and name ~= 'context'
  local preferred_mime_types = pandoc.List{'application/pdf', 'image/png'}
  -- Prefer SVG for non-PDF output formats
  if pdf2svg then
    preferred_mime_types:insert(1, 'image/svg+xml')
  end
  return {
    name = name,
    pdf2svg = pdf2svg,
    preferred_mime_types = preferred_mime_types,
    best_mime_type = function (self, supported_mime_types, requested)
      return self.preferred_mime_types:find_if(function (preferred)
          return supported_mime_types[preferred] and
            (not requested or
             (pandoc.utils.type(requested) == 'List' and
              requested:includes(preferred)) or
             (pandoc.utils.type(requested) == 'table' and
              requested[preferred]) or

             -- Assume string, Inlines, and Blocks values specify the only
             -- acceptable MIME type.
             stringify(requested) == preferred)
      end)
    end
  }
end

--- Returns a configured diagram engine.
local function get_engine (name, engopts, format)
  local engine = default_engines[name] or
    select(2, pcall(require, stringify(engopts.package)))

  -- Sanity check
  if not engine then
    warn(PANDOC_SCRIPT_FILE, ": No such engine '", name, "'.")
    return nil
  elseif engopts == false then
    -- engine is disabled
    return nil
  elseif engopts == true then
    -- use default options
    return engine
  end

  local execpath = engopts.execpath
    and stringify(engopts.execpath)
    or os.getenv(name:upper() .. '_BIN')

  local mime_type = format:best_mime_type(
    engine.mime_types,
    engopts['mime-type'] or engopts['mime-types']
  )
  if not mime_type then
    warn(PANDOC_SCRIPT_FILE, ": Cannot use ", name, " with ", format.name)
    return nil
  end

  return {
    execpath = execpath,
    compile = engine.compile,
    line_comment_start = engine.line_comment_start,
    mime_type = mime_type,
    opt = engopts or {},
  }
end

--- Returns the diagram engine configs.
local function configure (meta, format_name)
  local conf = meta.diagram or {}
  local format = format_options(format_name)
  meta.diagram = nil

  -- cache for image files
  if conf.cache then
    image_cache = conf['cache-dir']
      and stringify(conf['cache-dir'])
      or cachedir()
    pandoc.system.make_directory(image_cache, true)
  end

  -- engine configs
  local engine = {}
  for name, engopts in pairs(conf.engine or default_engines) do
    engine[name] = get_engine(name, engopts, format)
  end

  return {
    engine = engine,
    format = format,
    cache = image_cache and true,
    image_cache = image_cache,
  }
end


--
-- Format conversion
--

--- Converts a PDF to SVG.
local pdf2svg = function (imgdata)
  local pdf_file = os.tmpname() .. '.pdf'
  write_file(pdf_file, imgdata)
  local args = {
    '--export-type=svg',
    '--export-plain-svg',
    '--export-filename=-',
    pdf_file
  }
  return pandoc.pipe('inkscape', args, ''), os.remove(pdf_file)
end

local function properties_from_code (code, comment_start)
  local props = {}
  local pattern = comment_start:gsub('%p', '%%%1') .. '| ' ..
    '([-_%w]+): ([^\n]*)\n'
  for key, value in code:gmatch(pattern) do
    if key == 'fig-cap' then
      props['caption'] = value
    else
      props[key] = value
    end
  end
  return props
end

local function diagram_options (cb, comment_start)
  local attribs = comment_start
    and properties_from_code(cb.text, comment_start)
    or {}
  for key, value in pairs(cb.attributes) do
    attribs[key] = value
  end

  -- Read caption attribute as Markdown
  local caption = attribs.caption
    and pandoc.read(attribs.caption).blocks
    or nil
  local fig_attr = {
    id = cb.identifier ~= '' and cb.identifier or attribs.label,
    name = attribs.name,
  }
  local user_opt = {}

  for k, v in pairs(attribs) do
    local prefix, key = k:match '^(%a+)%-(%a[-%w]*)$'
    if prefix == 'fig' then
      fig_attr[key] = v
    elseif prefix == 'opt' then
      user_opt[key] = v
    end
  end

  return {
    ['alt'] = attribs.alt or
      (caption and pandoc.utils.blocks_to_inlines(caption)) or
      {},
    ['caption'] = caption,
    ['fig-attr'] = fig_attr,
    ['filename'] = attribs.filename,
    ['image-attr'] = {
      height = attribs.height,
      width = attribs.width,
      style = attribs.style,
    },
    ['opt'] = user_opt,
  }
end

local function get_cached_image (hash, mime_type)
  if not image_cache then
    return nil
  end
  local filename = hash .. '.' .. extension_for_mimetype[mime_type]
  local imgpath = pandoc.path.join{image_cache, filename}
  local success, imgdata = pcall(read_file, imgpath)
  if success then
    return imgdata, mime_type
  end
  return nil
end

local function cache_image (codeblock, imgdata, mimetype)
  -- do nothing if caching is disabled or not possible.
  if not image_cache then
    return
  end
  local ext = extension_for_mimetype[mimetype]
  local filename = pandoc.sha1(codeblock.text) .. '.' .. ext
  local imgpath = pandoc.path.join{image_cache, filename}
  write_file(imgpath, imgdata)
end

-- Executes each document's code block to find matching code blocks:
local function code_to_figure (conf)
  return function (block)
    -- Check if a converter exists for this block. If not, return the block
    -- unchanged.
    local diagram_type = block.classes[1]
    if not diagram_type then
      return nil
    end

    local engine = conf.engine[diagram_type]
    if not engine then
      return nil
    end

    -- Unified properties.
    local dgr_opt = diagram_options(block, engine.line_comment_start)
    for optname, value in pairs(engine.opt or {}) do
      dgr_opt.opt[optname] = dgr_opt.opt[optname] or value
    end

    local run_pdf2svg = engine.mime_type == 'application/pdf'
      and conf.format.pdf2svg

    -- Try to retrieve the image data from the cache.
    local imgdata, imgtype
    if conf.cache then
      imgdata, imgtype = get_cached_image(
        pandoc.sha1(block.text),
        run_pdf2svg and 'image/svg+xml' or engine.mime_type
      )
    end

    if not imgdata or not imgtype then
      -- No cached image; call the converter
      local success
      success, imgdata, imgtype =
        pcall(engine.compile, engine, block.text, dgr_opt.opt)

      -- Bail if an error occurred; imgdata contains the error message
      -- when that happens.
      if not success then
        warn(PANDOC_SCRIPT_FILE, ': ', tostring(imgdata))
        return nil
      elseif not imgdata then
        warn(PANDOC_SCRIPT_FILE, ': Diagram engine returned no image data.')
        return nil
      elseif not imgtype then
        warn(PANDOC_SCRIPT_FILE, ': Diagram engine did not return a MIME type.')
        return nil
      end

      -- Convert SVG if necessary.
      if imgtype == 'application/pdf' and conf.format.pdf2svg then
        imgdata, imgtype = pdf2svg(imgdata), 'image/svg+xml'
      end

      -- If we got here, then the transformation went ok and `img` contains
      -- the image data.
      cache_image(block, imgdata, imgtype)
    end

    -- Use the block's filename attribute or create a new name by hashing the
    -- image content.
    local basename, _extension = pandoc.path.split_extension(
      dgr_opt.filename or pandoc.sha1(imgdata)
    )
    local fname = basename .. '.' .. extension_for_mimetype[imgtype]

    -- Store the data in the media bag:
    pandoc.mediabag.insert(fname, imgtype, imgdata)

    -- Create the image object.
    local image = pandoc.Image(dgr_opt.alt, fname, "", dgr_opt['image-attr'])

    -- Create a figure if the diagram has a caption; otherwise return
    -- just the image.
    return dgr_opt.caption and
      pandoc.Figure(
        pandoc.Plain{image},
        dgr_opt.caption,
        dgr_opt['fig-attr']
      ) or
      pandoc.Plain{image}
  end
end

function Pandoc (doc)
  local conf = configure(doc.meta, FORMAT)
  return doc:walk {
    CodeBlock = code_to_figure(conf),
  }
end



================================================
File: docs/specs/src/diagram-1.0.0/LICENSE
================================================
MIT License

Copyright © 2019-2023 Albert Krewinkel
Copyright © 2019 Thorsten Sommer
Copyright © 2018 Florian Schätzig
Copyright © 2018 John MacFarlane

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
File: docs/specs/src/diagram-1.0.0/Makefile
================================================
FILTER_FILE := $(wildcard *.lua)
PANDOC ?= pandoc
DIFF ?= diff

.PHONY: test
test: test-asymptote test-dot test-mermaid test-plantuml test-tikz \
	test-no-alt-or-caption

test-%: test/test-%.yaml test/input-%.md $(FILTER_FILE)
	@$(PANDOC) --defaults test/test-$*.yaml | \
	  $(DIFF) test/expected-$*.html -

sample.html: sample.md diagram.lua
	@$(PANDOC) --self-contained \
	    --lua-filter=diagram.lua \
	    --metadata=pythonPath:"python3" \
	    --metadata=title:"README" \
	    --output=$@ $<

clean:
	@rm -f sample.html
	@rm -rf tmp-latex



================================================
File: docs/specs/src/diagram-1.0.0/_extensions/diagram/_extension.yaml
================================================
title: diagram
author: Albert Krewinkel
version: 1.0.0
quarto-required: ">=1.3"
contributes:
  filters:
    - diagram.lua



================================================
File: holonix/README.md
================================================
# Holonix

this implementation of holonix uses the flake- and crane-based nix expressions.

more advanced customization features are now possible via the flake's native
input override feature.

## recommended versioning specification in a consumer's flake.nix

#### use the "versions" flake as a separate input in their flake.nix and configuring the holochain flake to follow the versions flake, as in:

```nix
inputs = {
  holochain-versions.url = "github:holochain/holochain?dir=versions/0_2";

  holochain-flake.url = "github:holochain/holochain";
  holochain-flake.inputs.versions.follows = "holochain-versions";
};
```

#### override single components either via the holochain versions flake:

```nix
inputs = {
  holochain-versions.url = "github:holochain/holochain?dir=versions/0_2";
  holochain-versions.inputs.holochain.url = "github:holochain/holochain/holochain-0.2.6";

  holochain-flake.url = "github:holochain/holochain";
  holochain-flake.inputs.versions.follows = "holochain-versions";
};
```

or via their the toplevel component input:

```nix
inputs = {
  holochain-versions.url = "github:holochain/holochain?dir=versions/0_2";

  holochain-flake.url = "github:holochain/holochain";
  holochain-flake.inputs.versions.follows = "holochain-versions";

  holochain-flake.inputs.holochain.url = "github:holochain/holochain/holochain-0.2.6";
};
```

please see the following examples to learn more about common and more specific use cases:

* [specifying custom component versions](examples/custom_versions/flake.nix)

## Customizing the holochain binary build parameters

The top-level flake output `packages.holochain` and `devShells.holonix` are customisable by means of [nixpkgs.lib.makeOverridable](https://nixos.org/manual/nixpkgs/stable/#sec-lib-makeOverridable).

### Example: pass `--features chc` to holochain's `cargo build` command

This means that you can pass e.g. `holochain.override { cargoExtraArgs = " --feature chc"; }` or any other desirable attribute to override the attributes that are passed to [craneLib.buildPackage](https://crane.dev/API.html#cranelibbuildpackage).

In a devShell based on holonix, this can be achieved by specifying `holonix.override { holochainOverrides = { cargoExtraArgs = "--features chc"; }}`.
Please see [this flake](examples/custom_holochain_feature/flake.nix) for a complete example.


================================================
File: holonix/default.nix
================================================
{ system ? builtins.currentSystem, ... } @ args:
let
  deprecatedArgs = [
    "config"
    "holochain-nixpkgs"
    "rustc"
    "holochainVersion"
    "include"
    "isIncludedFn"
    "includeHolochainBinaries"
  ];
  unsupportedArgs = [ "holochainVersionId" ];
  ignoredArgs = [ "inNixShell" ];

  deprecatedArgs' =
    builtins.filter
      (arg:
        if builtins.hasAttr arg args
        then
          builtins.trace
            "[WARNING] the argument '${arg}' has been deprecated and rendered ineffective."
            true
        else false)
      deprecatedArgs;
  unsupportedArgs' =
    builtins.filter
      (arg:
        if builtins.hasAttr arg args
        then
          builtins.trace
            "[WARNING] the argument '${arg}' is currently unimplemented. it will either be implemented or deprecated in the near future."
            true
        else false)
      unsupportedArgs;
  filteredArgs =
    builtins.removeAttrs args
      (unsupportedArgs' ++ deprecatedArgs' ++ ignoredArgs);

  flake-compat = import ../nix/compat.nix;
  devShellsSystem = flake-compat.devShells.${system};

  fn = { devShellId ? "holonix" }:
    devShellsSystem.${devShellId}.overrideAttrs (attrs:
      attrs
      // {
        passthru =
          (attrs.passthru or { })
          // {
            pkgs = flake-compat.legacyPackages.${system};
            main = devShellsSystem.${devShellId};

            internal = {
              inherit flake-compat;
            };
          };
      });
in
(fn filteredArgs)



================================================
File: holonix/VERSIONS.md
================================================
# Holonix Version Information

## Common binaries
The following binaries are the same version regardless of the _holochainVersionId_ argument.

- rustc: rustc 1.75.0 (82e1608df 2023-12-21)
- cargo fmt: rustfmt 1.7.0-stable (82e1608 2023-12-21)
- cargo clippy: clippy 0.1.75 (82e1608 2023-12-21)
- perf-5.15.92: mirror://kernel/linux/kernel/v5.x/linux-5.15.92.tar.xz

## Available _holochainVersionId_ options
Each of the following headings represent one pre-built _holochainVersionId_ and their corresponding holochain version information.

### develop
- hc-0.1.0-beta-rc.3: https://github.com/holochain/holochain/tree/3b292847a74c9d91c20876ddad8ef6c9997d770f
- holochain-0.1.0-beta-rc.3: https://github.com/holochain/holochain/tree/3b292847a74c9d91c20876ddad8ef6c9997d770f
- kitsune-p2p-tx2-proxy-0.1.0-beta-rc.1: https://github.com/holochain/holochain/tree/3b292847a74c9d91c20876ddad8ef6c9997d770f
- lair-keystore-0.2.3: https://github.com/holochain/lair/tree/lair_keystore_api-v0.2.3
- launcher-0.0.5: https://github.com/holochain/launcher/tree/holochain_cli_launch-0.0.5
- scaffolding-0.0.6: https://github.com/holochain/scaffolding/tree/holochain_scaffolding_cli-v0.0.6

### v0_1_0
- hc-0.1.0: https://github.com/holochain/holochain/tree/holochain-0.1.0
- holochain-0.1.0: https://github.com/holochain/holochain/tree/holochain-0.1.0
- kitsune-p2p-tx2-proxy-0.1.0: https://github.com/holochain/holochain/tree/holochain-0.1.0
- lair-keystore-0.2.3: https://github.com/holochain/lair/tree/lair_keystore_api-v0.2.3
- launcher-0.0.9: https://github.com/holochain/launcher/tree/holochain_cli_launch-0.0.9
- scaffolding-0.1.4: https://github.com/holochain/scaffolding/tree/holochain_scaffolding_cli-v0.1.4

### v0_1_3
- hc-0.1.3: https://github.com/holochain/holochain/tree/holochain-0.1.3
- holochain-0.1.3: https://github.com/holochain/holochain/tree/holochain-0.1.3
- kitsune-p2p-tx2-proxy-0.1.2: https://github.com/holochain/holochain/tree/holochain-0.1.3
- lair-keystore-0.2.3: https://github.com/holochain/lair/tree/lair_keystore_api-v0.2.3
- launcher-0.0.9: https://github.com/holochain/launcher/tree/holochain_cli_launch-0.0.9
- scaffolding-0.1.5: https://github.com/holochain/scaffolding/tree/holochain_scaffolding_cli-v0.1.5



================================================
File: holonix/examples/custom_holochain_feature/flake.lock
================================================
{
  "nodes": {
    "cargo-chef": {
      "flake": false,
      "locked": {
        "lastModified": 1672901199,
        "narHash": "sha256-MHTuR4aQ1rQaBKx1vWDy2wbvcT0ZAzpkVB2zylSC+k0=",
        "owner": "LukeMathWalker",
        "repo": "cargo-chef",
        "rev": "5c9f11578a2e0783cce27666737d50f84510b8b5",
        "type": "github"
      },
      "original": {
        "owner": "LukeMathWalker",
        "ref": "main",
        "repo": "cargo-chef",
        "type": "github"
      }
    },
    "cargo-rdme": {
      "flake": false,
      "locked": {
        "lastModified": 1675118998,
        "narHash": "sha256-lrYWqu3h88fr8gG3Yo5GbFGYaq5/1Os7UtM+Af0Bg4k=",
        "owner": "orium",
        "repo": "cargo-rdme",
        "rev": "f9dbb6bccc078f4869f45ae270a2890ac9a75877",
        "type": "github"
      },
      "original": {
        "owner": "orium",
        "ref": "v1.1.0",
        "repo": "cargo-rdme",
        "type": "github"
      }
    },
    "crane": {
      "inputs": {
        "flake-compat": "flake-compat",
        "flake-utils": "flake-utils",
        "nixpkgs": [
          "holochain-flake",
          "nixpkgs"
        ],
        "rust-overlay": "rust-overlay"
      },
      "locked": {
        "lastModified": 1675475924,
        "narHash": "sha256-KWdfV9a6+zG6Ij/7PZYLnomjBZZUu8gdRy+hfjGrrJQ=",
        "owner": "ipetkov",
        "repo": "crane",
        "rev": "1bde9c762ebf26de9f8ecf502357c92105bc4577",
        "type": "github"
      },
      "original": {
        "owner": "ipetkov",
        "repo": "crane",
        "type": "github"
      }
    },
    "crate2nix": {
      "flake": false,
      "locked": {
        "lastModified": 1693149153,
        "narHash": "sha256-HUszQcnIal1FFRAWraODDbxTp0HECwczRTD+Zf0v9o0=",
        "owner": "kolloch",
        "repo": "crate2nix",
        "rev": "8749f46953b46d44fd181b002399e4a20371f323",
        "type": "github"
      },
      "original": {
        "owner": "kolloch",
        "repo": "crate2nix",
        "type": "github"
      }
    },
    "empty": {
      "flake": false,
      "locked": {
        "lastModified": 1683792623,
        "narHash": "sha256-pQpattmS9VmO3ZIQUFn66az8GSmB4IvYhTTCFn6SUmo=",
        "owner": "steveej",
        "repo": "empty",
        "rev": "8e328e450e4cd32e072eba9e99fe92cf2a1ef5cf",
        "type": "github"
      },
      "original": {
        "owner": "steveej",
        "repo": "empty",
        "type": "github"
      }
    },
    "flake-compat": {
      "flake": false,
      "locked": {
        "lastModified": 1673956053,
        "narHash": "sha256-4gtG9iQuiKITOjNQQeQIpoIB6b16fm+504Ch3sNKLd8=",
        "owner": "edolstra",
        "repo": "flake-compat",
        "rev": "35bb57c0c8d8b62bbfd284272c928ceb64ddbde9",
        "type": "github"
      },
      "original": {
        "owner": "edolstra",
        "repo": "flake-compat",
        "type": "github"
      }
    },
    "flake-compat_2": {
      "flake": false,
      "locked": {
        "lastModified": 1673956053,
        "narHash": "sha256-4gtG9iQuiKITOjNQQeQIpoIB6b16fm+504Ch3sNKLd8=",
        "owner": "edolstra",
        "repo": "flake-compat",
        "rev": "35bb57c0c8d8b62bbfd284272c928ceb64ddbde9",
        "type": "github"
      },
      "original": {
        "owner": "edolstra",
        "repo": "flake-compat",
        "type": "github"
      }
    },
    "flake-parts": {
      "inputs": {
        "nixpkgs-lib": "nixpkgs-lib"
      },
      "locked": {
        "lastModified": 1675295133,
        "narHash": "sha256-dU8fuLL98WFXG0VnRgM00bqKX6CEPBLybhiIDIgO45o=",
        "owner": "hercules-ci",
        "repo": "flake-parts",
        "rev": "bf53492df08f3178ce85e0c9df8ed8d03c030c9f",
        "type": "github"
      },
      "original": {
        "id": "flake-parts",
        "type": "indirect"
      }
    },
    "flake-utils": {
      "locked": {
        "lastModified": 1667395993,
        "narHash": "sha256-nuEHfE/LcWyuSWnS8t12N1wc105Qtau+/OdUAjtQ0rA=",
        "owner": "numtide",
        "repo": "flake-utils",
        "rev": "5aed5285a952e0b949eb3ba02c12fa4fcfef535f",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "flake-utils",
        "type": "github"
      }
    },
    "flake-utils_2": {
      "inputs": {
        "systems": "systems"
      },
      "locked": {
        "lastModified": 1681202837,
        "narHash": "sha256-H+Rh19JDwRtpVPAWp64F+rlEtxUWBAQW28eAi3SRSzg=",
        "owner": "numtide",
        "repo": "flake-utils",
        "rev": "cfacdce06f30d2b68473a46042957675eebb3401",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "flake-utils",
        "type": "github"
      }
    },
    "holochain": {
      "flake": false,
      "locked": {
        "lastModified": 1694632043,
        "narHash": "sha256-5QWUpWnwuzUi3hROrOZyQNla8iGdr+oGCH2nniRePBE=",
        "owner": "holochain",
        "repo": "holochain",
        "rev": "1f59d33623031eefe76b5f3573970c9c33f21877",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.2.2",
        "repo": "holochain",
        "type": "github"
      }
    },
    "holochain-flake": {
      "inputs": {
        "cargo-chef": "cargo-chef",
        "cargo-rdme": "cargo-rdme",
        "crane": "crane",
        "crate2nix": "crate2nix",
        "empty": "empty",
        "flake-compat": "flake-compat_2",
        "flake-parts": "flake-parts",
        "holochain": [
          "holochain-flake",
          "empty"
        ],
        "lair": [
          "holochain-flake",
          "empty"
        ],
        "launcher": [
          "holochain-flake",
          "empty"
        ],
        "nix-filter": "nix-filter",
        "nixpkgs": "nixpkgs",
        "pre-commit-hooks-nix": "pre-commit-hooks-nix",
        "repo-git": "repo-git",
        "rust-overlay": "rust-overlay_2",
        "scaffolding": [
          "holochain-flake",
          "empty"
        ],
        "versions": [
          "versions"
        ]
      },
      "locked": {
        "lastModified": 1696352368,
        "narHash": "sha256-Qoii1abMuyNs//TgJsA4IZlpDCw6d8KMe+gA4zrpcyM=",
        "owner": "holochain",
        "repo": "holochain",
        "rev": "74aa25d4aa3abbd69d24f64f92c82a5c8105e2c6",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "repo": "holochain",
        "type": "github"
      }
    },
    "lair": {
      "flake": false,
      "locked": {
        "lastModified": 1691746070,
        "narHash": "sha256-CHsTI4yIlkfnYWx2sNgzAoDBvKTLIChybzyJNbB1sMU=",
        "owner": "holochain",
        "repo": "lair",
        "rev": "6ab41b60744515f1760669db6fc5272298a5f324",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "lair_keystore-v0.3.0",
        "repo": "lair",
        "type": "github"
      }
    },
    "launcher": {
      "flake": false,
      "locked": {
        "lastModified": 1684183666,
        "narHash": "sha256-rOE/W/BBYyZKOyypKb8X9Vpc4ty1TNRoI/fV5+01JPw=",
        "owner": "holochain",
        "repo": "launcher",
        "rev": "75ecdd0aa191ed830cc209a984a6030e656042ff",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.2",
        "repo": "launcher",
        "type": "github"
      }
    },
    "nix-filter": {
      "locked": {
        "lastModified": 1675361037,
        "narHash": "sha256-CTbDuDxFD3U3g/dWUB+r+B/snIe+qqP1R+1myuFGe2I=",
        "owner": "numtide",
        "repo": "nix-filter",
        "rev": "e1b2f96c2a31415f362268bc48c3fccf47dff6eb",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "nix-filter",
        "type": "github"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1696019113,
        "narHash": "sha256-X3+DKYWJm93DRSdC5M6K5hLqzSya9BjibtBsuARoPco=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "f5892ddac112a1e9b3612c39af1b72987ee5783a",
        "type": "github"
      },
      "original": {
        "id": "nixpkgs",
        "ref": "nixos-unstable",
        "type": "indirect"
      }
    },
    "nixpkgs-lib": {
      "locked": {
        "dir": "lib",
        "lastModified": 1675183161,
        "narHash": "sha256-Zq8sNgAxDckpn7tJo7V1afRSk2eoVbu3OjI1QklGLNg=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "e1e1b192c1a5aab2960bf0a0bd53a2e8124fa18e",
        "type": "github"
      },
      "original": {
        "dir": "lib",
        "owner": "NixOS",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "pre-commit-hooks-nix": {
      "flake": false,
      "locked": {
        "lastModified": 1676513100,
        "narHash": "sha256-MK39nQV86L2ag4TmcK5/+r1ULpzRLPbbfvWbPvIoYJE=",
        "owner": "cachix",
        "repo": "pre-commit-hooks.nix",
        "rev": "5f0cba88ac4d6dd8cad5c6f6f1540b3d6a21a798",
        "type": "github"
      },
      "original": {
        "owner": "cachix",
        "repo": "pre-commit-hooks.nix",
        "type": "github"
      }
    },
    "repo-git": {
      "flake": false,
      "locked": {
        "narHash": "sha256-d6xi4mKdjkX2JFicDIv5niSzpyI0m/Hnm8GGAIU04kY=",
        "type": "file",
        "url": "file:/dev/null"
      },
      "original": {
        "type": "file",
        "url": "file:/dev/null"
      }
    },
    "root": {
      "inputs": {
        "flake-parts": [
          "holochain-flake",
          "flake-parts"
        ],
        "holochain-flake": "holochain-flake",
        "nixpkgs": [
          "holochain-flake",
          "nixpkgs"
        ],
        "versions": "versions"
      }
    },
    "rust-overlay": {
      "inputs": {
        "flake-utils": [
          "holochain-flake",
          "crane",
          "flake-utils"
        ],
        "nixpkgs": [
          "holochain-flake",
          "crane",
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1675391458,
        "narHash": "sha256-ukDKZw922BnK5ohL9LhwtaDAdCsJL7L6ScNEyF1lO9w=",
        "owner": "oxalica",
        "repo": "rust-overlay",
        "rev": "383a4acfd11d778d5c2efcf28376cbd845eeaedf",
        "type": "github"
      },
      "original": {
        "owner": "oxalica",
        "repo": "rust-overlay",
        "type": "github"
      }
    },
    "rust-overlay_2": {
      "inputs": {
        "flake-utils": "flake-utils_2",
        "nixpkgs": [
          "holochain-flake",
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1696299134,
        "narHash": "sha256-RS77cAa0N+Sfj5EmKbm5IdncNXaBCE1BSSQvUE8exvo=",
        "owner": "oxalica",
        "repo": "rust-overlay",
        "rev": "611ccdceed92b4d94ae75328148d84ee4a5b462d",
        "type": "github"
      },
      "original": {
        "owner": "oxalica",
        "repo": "rust-overlay",
        "type": "github"
      }
    },
    "scaffolding": {
      "flake": false,
      "locked": {
        "lastModified": 1695674679,
        "narHash": "sha256-IwgQbgitUo61ZXYSXBAro5ThfYy/yMGmzZGTb3c6sT0=",
        "owner": "holochain",
        "repo": "scaffolding",
        "rev": "821439b8dd49d5ce594be04c4720df25e88a4dbc",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.2",
        "repo": "scaffolding",
        "type": "github"
      }
    },
    "systems": {
      "locked": {
        "lastModified": 1681028828,
        "narHash": "sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=",
        "owner": "nix-systems",
        "repo": "default",
        "rev": "da67096a3b9bf56a91d16901293e51ba5b49a27e",
        "type": "github"
      },
      "original": {
        "owner": "nix-systems",
        "repo": "default",
        "type": "github"
      }
    },
    "versions": {
      "inputs": {
        "holochain": "holochain",
        "lair": "lair",
        "launcher": "launcher",
        "scaffolding": "scaffolding"
      },
      "locked": {
        "dir": "versions/0_2",
        "lastModified": 1696352368,
        "narHash": "sha256-Qoii1abMuyNs//TgJsA4IZlpDCw6d8KMe+gA4zrpcyM=",
        "owner": "holochain",
        "repo": "holochain",
        "rev": "74aa25d4aa3abbd69d24f64f92c82a5c8105e2c6",
        "type": "github"
      },
      "original": {
        "dir": "versions/0_2",
        "owner": "holochain",
        "repo": "holochain",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}



================================================
File: holonix/examples/custom_holochain_feature/flake.nix
================================================
{
  description = "Template for Holochain app development that uses a custom holochain compilation feature";

  inputs = {
    versions.url = "github:holochain/holochain?dir=versions/0_2";

    holochain-flake.url = "github:holochain/holochain";
    holochain-flake.inputs.versions.follows = "versions";

    nixpkgs.follows = "holochain-flake/nixpkgs";
    flake-parts.follows = "holochain-flake/flake-parts";
  };

  outputs = inputs:
    inputs.flake-parts.lib.mkFlake { inherit inputs; }
      {
        systems = builtins.attrNames inputs.holochain-flake.devShells;

        perSystem =
          { inputs'
          , config
          , pkgs
          , system
          , ...
          }: {

            devShells.default = pkgs.mkShell {
              inputsFrom = [
                (inputs'.holochain-flake.devShells.holonix.override
                  {
                    holochainOverrides = {
                      cargoExtraArgs = " --features chc";
                    };
                  }
                )
              ];
              packages = [
                pkgs.nodejs-18_x
                # more packages go here
              ];
            };
          };
      };
}



================================================
File: holonix/examples/custom_versions/flake.lock
================================================
{
  "nodes": {
    "cargo-chef": {
      "flake": false,
      "locked": {
        "lastModified": 1672901199,
        "narHash": "sha256-MHTuR4aQ1rQaBKx1vWDy2wbvcT0ZAzpkVB2zylSC+k0=",
        "owner": "LukeMathWalker",
        "repo": "cargo-chef",
        "rev": "5c9f11578a2e0783cce27666737d50f84510b8b5",
        "type": "github"
      },
      "original": {
        "owner": "LukeMathWalker",
        "ref": "main",
        "repo": "cargo-chef",
        "type": "github"
      }
    },
    "cargo-rdme": {
      "flake": false,
      "locked": {
        "lastModified": 1675118998,
        "narHash": "sha256-lrYWqu3h88fr8gG3Yo5GbFGYaq5/1Os7UtM+Af0Bg4k=",
        "owner": "orium",
        "repo": "cargo-rdme",
        "rev": "f9dbb6bccc078f4869f45ae270a2890ac9a75877",
        "type": "github"
      },
      "original": {
        "owner": "orium",
        "ref": "v1.1.0",
        "repo": "cargo-rdme",
        "type": "github"
      }
    },
    "crane": {
      "inputs": {
        "flake-compat": "flake-compat",
        "flake-utils": "flake-utils",
        "nixpkgs": [
          "holochain-flake",
          "nixpkgs"
        ],
        "rust-overlay": "rust-overlay"
      },
      "locked": {
        "lastModified": 1675475924,
        "narHash": "sha256-KWdfV9a6+zG6Ij/7PZYLnomjBZZUu8gdRy+hfjGrrJQ=",
        "owner": "ipetkov",
        "repo": "crane",
        "rev": "1bde9c762ebf26de9f8ecf502357c92105bc4577",
        "type": "github"
      },
      "original": {
        "owner": "ipetkov",
        "repo": "crane",
        "type": "github"
      }
    },
    "crate2nix": {
      "flake": false,
      "locked": {
        "lastModified": 1675642992,
        "narHash": "sha256-uDBDZuiq7qyg82Udp82/r4zg5HKfIzBQqgl2U9THiQM=",
        "owner": "kolloch",
        "repo": "crate2nix",
        "rev": "45fc83132c8c91c77a1cd61fe0c945411d1edba8",
        "type": "github"
      },
      "original": {
        "owner": "kolloch",
        "repo": "crate2nix",
        "type": "github"
      }
    },
    "flake-compat": {
      "flake": false,
      "locked": {
        "lastModified": 1673956053,
        "narHash": "sha256-4gtG9iQuiKITOjNQQeQIpoIB6b16fm+504Ch3sNKLd8=",
        "owner": "edolstra",
        "repo": "flake-compat",
        "rev": "35bb57c0c8d8b62bbfd284272c928ceb64ddbde9",
        "type": "github"
      },
      "original": {
        "owner": "edolstra",
        "repo": "flake-compat",
        "type": "github"
      }
    },
    "flake-compat_2": {
      "flake": false,
      "locked": {
        "lastModified": 1673956053,
        "narHash": "sha256-4gtG9iQuiKITOjNQQeQIpoIB6b16fm+504Ch3sNKLd8=",
        "owner": "edolstra",
        "repo": "flake-compat",
        "rev": "35bb57c0c8d8b62bbfd284272c928ceb64ddbde9",
        "type": "github"
      },
      "original": {
        "owner": "edolstra",
        "repo": "flake-compat",
        "type": "github"
      }
    },
    "flake-parts": {
      "inputs": {
        "nixpkgs-lib": "nixpkgs-lib"
      },
      "locked": {
        "lastModified": 1675295133,
        "narHash": "sha256-dU8fuLL98WFXG0VnRgM00bqKX6CEPBLybhiIDIgO45o=",
        "owner": "hercules-ci",
        "repo": "flake-parts",
        "rev": "bf53492df08f3178ce85e0c9df8ed8d03c030c9f",
        "type": "github"
      },
      "original": {
        "id": "flake-parts",
        "type": "indirect"
      }
    },
    "flake-utils": {
      "locked": {
        "lastModified": 1667395993,
        "narHash": "sha256-nuEHfE/LcWyuSWnS8t12N1wc105Qtau+/OdUAjtQ0rA=",
        "owner": "numtide",
        "repo": "flake-utils",
        "rev": "5aed5285a952e0b949eb3ba02c12fa4fcfef535f",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "flake-utils",
        "type": "github"
      }
    },
    "flake-utils_2": {
      "inputs": {
        "systems": "systems"
      },
      "locked": {
        "lastModified": 1681202837,
        "narHash": "sha256-H+Rh19JDwRtpVPAWp64F+rlEtxUWBAQW28eAi3SRSzg=",
        "owner": "numtide",
        "repo": "flake-utils",
        "rev": "cfacdce06f30d2b68473a46042957675eebb3401",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "flake-utils",
        "type": "github"
      }
    },
    "holochain": {
      "flake": false,
      "locked": {
        "narHash": "sha256-d6xi4mKdjkX2JFicDIv5niSzpyI0m/Hnm8GGAIU04kY=",
        "type": "file",
        "url": "file:///dev/null"
      },
      "original": {
        "type": "file",
        "url": "file:///dev/null"
      }
    },
    "holochain-flake": {
      "inputs": {
        "cargo-chef": "cargo-chef",
        "cargo-rdme": "cargo-rdme",
        "crane": "crane",
        "crate2nix": "crate2nix",
        "flake-compat": "flake-compat_2",
        "flake-parts": "flake-parts",
        "holochain": "holochain",
        "lair": "lair",
        "launcher": "launcher",
        "nix-filter": "nix-filter",
        "nixpkgs": "nixpkgs",
        "pre-commit-hooks-nix": "pre-commit-hooks-nix",
        "rust-overlay": "rust-overlay_2",
        "scaffolding": "scaffolding",
        "versions": [
          "versions"
        ]
      },
      "locked": {
        "lastModified": 1683444768,
        "narHash": "sha256-9e0+YSafThk4qSh9tO2VsoeLfw4/rXIih9rqVeayrDI=",
        "owner": "holochain",
        "repo": "holochain",
        "rev": "cf29f234341470d2421bbc1cc4ba6b7457a98ce0",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "develop",
        "repo": "holochain",
        "type": "github"
      }
    },
    "holochain_2": {
      "flake": false,
      "locked": {
        "lastModified": 1682362638,
        "narHash": "sha256-pL+3zQo6/4ctj/hEI0vihAPpBRiZ+9n7Vxl0fDRZc3g=",
        "owner": "holochain",
        "repo": "holochain",
        "rev": "9242f34515dfaeaf722629f9550d064b7f248121",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.1.4",
        "repo": "holochain",
        "type": "github"
      }
    },
    "lair": {
      "flake": false,
      "locked": {
        "narHash": "sha256-d6xi4mKdjkX2JFicDIv5niSzpyI0m/Hnm8GGAIU04kY=",
        "type": "file",
        "url": "file:///dev/null"
      },
      "original": {
        "type": "file",
        "url": "file:///dev/null"
      }
    },
    "lair_2": {
      "flake": false,
      "locked": {
        "lastModified": 1670953460,
        "narHash": "sha256-cqOr7iWzsNeomYQiiFggzG5Dr4X0ysnTkjtA8iwDLAQ=",
        "owner": "holochain",
        "repo": "lair",
        "rev": "cbfbefefe43073904a914c8181a450209a74167b",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "lair_keystore-v0.2.3",
        "repo": "lair",
        "type": "github"
      }
    },
    "launcher": {
      "flake": false,
      "locked": {
        "narHash": "sha256-d6xi4mKdjkX2JFicDIv5niSzpyI0m/Hnm8GGAIU04kY=",
        "type": "file",
        "url": "file:///dev/null"
      },
      "original": {
        "type": "file",
        "url": "file:///dev/null"
      }
    },
    "launcher_2": {
      "flake": false,
      "locked": {
        "lastModified": 1677270906,
        "narHash": "sha256-/xT//6nqhjpKLMMv41JE0W3H5sE9jKMr8Dedr88D4N8=",
        "owner": "holochain",
        "repo": "launcher",
        "rev": "1ad188a43900c139e52df10a21e3722f41dfb967",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.1",
        "repo": "launcher",
        "type": "github"
      }
    },
    "nix-filter": {
      "locked": {
        "lastModified": 1675361037,
        "narHash": "sha256-CTbDuDxFD3U3g/dWUB+r+B/snIe+qqP1R+1myuFGe2I=",
        "owner": "numtide",
        "repo": "nix-filter",
        "rev": "e1b2f96c2a31415f362268bc48c3fccf47dff6eb",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "nix-filter",
        "type": "github"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1683286087,
        "narHash": "sha256-xseOd7W7xwF5GOF2RW8qhjmVGrKoBz+caBlreaNzoeI=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "3e313808bd2e0a0669430787fb22e43b2f4bf8bf",
        "type": "github"
      },
      "original": {
        "id": "nixpkgs",
        "ref": "nixos-unstable",
        "type": "indirect"
      }
    },
    "nixpkgs-lib": {
      "locked": {
        "dir": "lib",
        "lastModified": 1675183161,
        "narHash": "sha256-Zq8sNgAxDckpn7tJo7V1afRSk2eoVbu3OjI1QklGLNg=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "e1e1b192c1a5aab2960bf0a0bd53a2e8124fa18e",
        "type": "github"
      },
      "original": {
        "dir": "lib",
        "owner": "NixOS",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "pre-commit-hooks-nix": {
      "flake": false,
      "locked": {
        "lastModified": 1676513100,
        "narHash": "sha256-MK39nQV86L2ag4TmcK5/+r1ULpzRLPbbfvWbPvIoYJE=",
        "owner": "cachix",
        "repo": "pre-commit-hooks.nix",
        "rev": "5f0cba88ac4d6dd8cad5c6f6f1540b3d6a21a798",
        "type": "github"
      },
      "original": {
        "owner": "cachix",
        "repo": "pre-commit-hooks.nix",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "flake-parts": [
          "holochain-flake",
          "flake-parts"
        ],
        "holochain-flake": "holochain-flake",
        "nixpkgs": [
          "holochain-flake",
          "nixpkgs"
        ],
        "versions": "versions"
      }
    },
    "rust-overlay": {
      "inputs": {
        "flake-utils": [
          "holochain-flake",
          "crane",
          "flake-utils"
        ],
        "nixpkgs": [
          "holochain-flake",
          "crane",
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1675391458,
        "narHash": "sha256-ukDKZw922BnK5ohL9LhwtaDAdCsJL7L6ScNEyF1lO9w=",
        "owner": "oxalica",
        "repo": "rust-overlay",
        "rev": "383a4acfd11d778d5c2efcf28376cbd845eeaedf",
        "type": "github"
      },
      "original": {
        "owner": "oxalica",
        "repo": "rust-overlay",
        "type": "github"
      }
    },
    "rust-overlay_2": {
      "inputs": {
        "flake-utils": "flake-utils_2",
        "nixpkgs": [
          "holochain-flake",
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1683426137,
        "narHash": "sha256-iqLjaJDMppvK1ae1eL55b2r7EX+rbUuEnssFOe9eOm8=",
        "owner": "oxalica",
        "repo": "rust-overlay",
        "rev": "546a8209ce0965475495dd422e4ab3c6de7a268c",
        "type": "github"
      },
      "original": {
        "owner": "oxalica",
        "repo": "rust-overlay",
        "type": "github"
      }
    },
    "scaffolding": {
      "flake": false,
      "locked": {
        "narHash": "sha256-d6xi4mKdjkX2JFicDIv5niSzpyI0m/Hnm8GGAIU04kY=",
        "type": "file",
        "url": "file:///dev/null"
      },
      "original": {
        "type": "file",
        "url": "file:///dev/null"
      }
    },
    "scaffolding_2": {
      "flake": false,
      "locked": {
        "lastModified": 1682016510,
        "narHash": "sha256-U6V453QPUGI6PhtO7kkQCFxEB9WZPiU6hjwyPUdEHaE=",
        "owner": "holochain",
        "repo": "scaffolding",
        "rev": "85997cbc4c92f0fea87447d7c7daed1245b47700",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.1",
        "repo": "scaffolding",
        "type": "github"
      }
    },
    "systems": {
      "locked": {
        "lastModified": 1681028828,
        "narHash": "sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=",
        "owner": "nix-systems",
        "repo": "default",
        "rev": "da67096a3b9bf56a91d16901293e51ba5b49a27e",
        "type": "github"
      },
      "original": {
        "owner": "nix-systems",
        "repo": "default",
        "type": "github"
      }
    },
    "versions": {
      "inputs": {
        "holochain": "holochain_2",
        "lair": "lair_2",
        "launcher": "launcher_2",
        "scaffolding": "scaffolding_2"
      },
      "locked": {
        "dir": "versions/0_1",
        "lastModified": 1683440412,
        "narHash": "sha256-PFn0VRHOmjI3Y4XIfFFylTaX1GyUN1J2FBEJCmmxIvs=",
        "owner": "holochain",
        "repo": "holochain",
        "rev": "7b4601be260f62e1012659b6c63384a18bb09a97",
        "type": "github"
      },
      "original": {
        "dir": "versions/0_1",
        "owner": "holochain",
        "repo": "holochain",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}



================================================
File: holonix/examples/custom_versions/flake.nix
================================================
{
  description = "Template for Holochain app development that uses a specific versions set";

  # this example is equivalent to the following CLI invocation:
  #
  # nix develop \
  #   github:holochain/holochain#holonix \
  #   --override-input versions 'github:holochain/holochain/?dir=versions/0_2' \
  #   --override-input versions/holochain 'github:holochain/holochain/holochain-0.2.6'

  inputs = {
    versions.url = "github:holochain/holochain?dir=versions/0_2";
    versions.inputs.holochain.url = "github:holochain/holochain/holochain-0.2.6";

    holochain-flake.url = "github:holochain/holochain";
    holochain-flake.inputs.versions.follows = "versions";

    nixpkgs.follows = "holochain-flake/nixpkgs";
    flake-parts.follows = "holochain-flake/flake-parts";
  };

  outputs = inputs:
    inputs.flake-parts.lib.mkFlake { inherit inputs; }
      {
        systems = builtins.attrNames inputs.holochain-flake.devShells;

        perSystem =
          { inputs'
          , config
          , pkgs
          , system
          , ...
          }: {

            devShells.default = pkgs.mkShell {
              inputsFrom = [ inputs'.holochain-flake.devShells.holonix ];
              packages = [
                pkgs.nodejs-18_x
                # more packages go here
              ];
            };
          };
      };
}



================================================
File: holonix/legacy/default.nix
================================================
let
  holonixPath = ../.; # points to the current state of the Holochain repository
  holonix = import holonixPath {
    holochainVersionId = "v0_1_0"; # specifies the Holochain version
  };
  nixpkgs = holonix.pkgs;
in
nixpkgs.mkShell {
  inputsFrom = [ holonix.main ];
  packages = with nixpkgs; [
    niv
    nodejs-18_x
    # any additional packages needed for this project, e. g. Nodejs
  ];
}



================================================
File: holonix/test/hc-sandbox.bats
================================================

#!/usr/bin/env bats

setup() {
  BATS_TMPDIR="$(mktemp -d)"
  cd "${BATS_TMPDIR:?}"
}

teardown() {
  cd ..
  rm -rf "${BATS_TMPDIR:?}"
}

@test "expected hc-sandbox to be available" {
  result="$(type -f hc-sandbox)"
  echo $result
  [[ "$result" == *"hc-sandbox" ]]
}



================================================
File: holonix/test/holochain-binaries.bats
================================================
#!/usr/bin/env bats

@test "expected holochain available" {
  result="$(holochain --version)"
  echo $result
  [[ "$result" == "holochain"* ]]
}

@test "expected hc version available" {
  result="$(hc --version)"
  echo $result
  [[ "$result" == "holochain_cli"* ]]
}

@test "expected lair-keystore available" {
  result="$(lair-keystore --version)"
  echo $result
  [[ "$result" =~ ^lair[-_]keystore.* ]]
}



================================================
File: holonix/test/launcher.bats
================================================
#!/usr/bin/env bats

setup() {
  BATS_TMPDIR="$(mktemp -d)"
  cd "${BATS_TMPDIR:?}"
}

teardown() {
  cd ..
  rm -rf "${BATS_TMPDIR:?}"
}

@test "expected hc-launch to be available" {
  result="$(hc-launch --version)"
  echo $result
  [[ "$result" == "holochain_cli_launch"* ]]
}



================================================
File: holonix/test/mold_openssl.bats
================================================
#!/usr/bin/env bats

setup() {
  BATS_TMPDIR="$(mktemp --directory --dry-run)"
  cp -LRv ./test/mold_openssl "${BATS_TMPDIR}"
  find "${BATS_TMPDIR}/." -exec chmod +w {} \;
  mkdir "${BATS_TMPDIR}"/.cargo
  cp -LRv ${CARGO_VENDOR_DIR:?}/config.toml "${BATS_TMPDIR}"/.cargo/
  cd "${BATS_TMPDIR}"
}

teardown() {
  cd ..
  rm -rf "${BATS_TMPDIR:?}"
}

@test "main binary runs successfully" {
    cargo run --offline --locked
}

@test "library compiles to wasm32" {
    cargo build --offline --locked --lib --target wasm32-unknown-unknown
}



================================================
File: holonix/test/rust.bats
================================================
#!/usr/bin/env bats

# rustc reports the version that needs to match https://rust-lang.github.io/rustup-components-history/
@test "rustc version" {
 result="$( rustc --version )"
 echo $result
 [[ "$result" == * ]]
}

# fmt should exist
@test "fmt version" {
 result="$( cargo fmt --version )"
 echo $result
 [[ "$result" == *-stable* ]]
}

# importantly clippy should exist
@test "clippy version" {
 result="$( cargo clippy --version )"
 echo $result
 [[ "$result" == *.* ]]
}



================================================
File: holonix/test/scaffolding.bats
================================================
#!/usr/bin/env bats

setup() {
  BATS_TMPDIR="$(mktemp -d)"
  cd "${BATS_TMPDIR:?}"
}

teardown() {
  cd ..
  rm -rf "${BATS_TMPDIR:?}"
}

@test "expected hc-scaffold to be available" {
  result="$(hc-scaffold --version)"
  echo $result
  [[ "$result" == "holochain_scaffolding_cli"* ]]
}

@test "expected scaffold an example to succeed" {
  set -e
  hc scaffold example forum -t vue
}



================================================
File: holonix/test/shell-setup-linux.bats
================================================
#!/usr/bin/env bats

@test "mold is available" {
    mold --version
}


================================================
File: holonix/test/shell-setup.bats
================================================
#!/usr/bin/env bats

@test "shellHook is evaluated" {
    [ -n "$HOLOCHAIN_DEVSHELL" ]
}


================================================
File: holonix/test/mold_openssl/Cargo.lock
================================================
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "bitflags"
version = "2.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "327762f6e5a765692301e5bb513e0d9fef63be86bbc14528052b1cd3e6f03e07"

[[package]]
name = "cc"
version = "1.0.83"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f1174fb0b6ec23863f8b971027804a42614e347eafb0a95bf0b12cdae21fc4d0"
dependencies = [
 "libc",
]

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "foreign-types"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1"
dependencies = [
 "foreign-types-shared",
]

[[package]]
name = "foreign-types-shared"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b"

[[package]]
name = "holonix_mold_ssl"
version = "0.1.0"
dependencies = [
 "openssl",
]

[[package]]
name = "libc"
version = "0.2.150"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "89d92a4743f9a61002fae18374ed11e7973f530cb3a3255fb354818118b2203c"

[[package]]
name = "once_cell"
version = "1.18.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dd8b5dd2ae5ed71462c540258bedcb51965123ad7e7ccf4b9a8cafaa4a63576d"

[[package]]
name = "openssl"
version = "0.10.59"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a257ad03cd8fb16ad4172fedf8094451e1af1c4b70097636ef2eac9a5f0cc33"
dependencies = [
 "bitflags",
 "cfg-if",
 "foreign-types",
 "libc",
 "once_cell",
 "openssl-macros",
 "openssl-sys",
]

[[package]]
name = "openssl-macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a948666b637a0f465e8564c73e89d4dde00d72d4d473cc972f390fc3dcee7d9c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "openssl-sys"
version = "0.9.95"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40a4130519a360279579c2053038317e40eff64d13fd3f004f9e1b72b8a6aaf9"
dependencies = [
 "cc",
 "libc",
 "pkg-config",
 "vcpkg",
]

[[package]]
name = "pkg-config"
version = "0.3.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26072860ba924cbfa98ea39c8c19b4dd6a4a25423dbdf219c1eca91aa0cf6964"

[[package]]
name = "proc-macro2"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "134c189feb4956b20f6f547d2cf727d4c0fe06722b20a0eec87ed445a97f92da"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.33"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5267fca4496028628a95160fc423a33e8b2e6af8a5302579e322e4b520293cae"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "syn"
version = "2.0.39"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "23e78b90f2fcf45d3e842032ce32e3f2d1545ba6636271dcbf24fa306d87be7a"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "unicode-ident"
version = "1.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b"

[[package]]
name = "vcpkg"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "accd4ea62f7bb7a82fe23066fb0957d48ef677f6eeb8215f372f52e48bb32426"



================================================
File: holonix/test/mold_openssl/Cargo.toml
================================================
[workspace]

[package]
name = "holonix_mold_ssl"
version = "0.1.0"
edition = "2021"

[[bin]]
name = "holonix_mold_ssl"
path = "src/main.rs"

[lib]
path = "src/lib.rs"
crate-type = ["cdylib", "rlib"]

[target.'cfg(not(all(target_arch = "wasm32", target_os = "unknown")))'.dependencies]
openssl = { version = "0.10", features = [] }



================================================
File: holonix/test/mold_openssl/.gitignore
================================================
.cargo



================================================
File: holonix/test/mold_openssl/src/lib.rs
================================================
pub fn is_favorite(n: usize) -> bool {
    (n % 7 == 0) || (n % 3 == 0)
}



================================================
File: holonix/test/mold_openssl/src/main.rs
================================================
fn main() {
    use openssl::encrypt::{Decrypter, Encrypter};
    use openssl::pkey::PKey;
    use openssl::rsa::{Padding, Rsa};

    // Generate a keypair
    let keypair = Rsa::generate(2048).unwrap();
    let keypair = PKey::from_rsa(keypair).unwrap();

    let data = b"hello, world!";

    // Encrypt the data with RSA PKCS1
    let mut encrypter = Encrypter::new(&keypair).unwrap();
    encrypter.set_rsa_padding(Padding::PKCS1).unwrap();
    // Create an output buffer
    let buffer_len = encrypter.encrypt_len(data).unwrap();
    let mut encrypted = vec![0; buffer_len];
    // Encrypt and truncate the buffer
    let encrypted_len = encrypter.encrypt(data, &mut encrypted).unwrap();
    encrypted.truncate(encrypted_len);

    // Decrypt the data
    let mut decrypter = Decrypter::new(&keypair).unwrap();
    decrypter.set_rsa_padding(Padding::PKCS1).unwrap();
    // Create an output buffer
    let buffer_len = decrypter.decrypt_len(&encrypted).unwrap();
    let mut decrypted = vec![0; buffer_len];
    // Encrypt and truncate the buffer
    let decrypted_len = decrypter.decrypt(&encrypted, &mut decrypted).unwrap();
    decrypted.truncate(decrypted_len);
    assert_eq!(&*decrypted, data);

    println!("{decrypted:#?}");
}



================================================
File: nix/compat.nix
================================================
(import
  (
    let lock = builtins.fromJSON (builtins.readFile ../flake.lock); in
    fetchTarball {
      url = "https://github.com/edolstra/flake-compat/archive/${lock.nodes.flake-compat.locked.rev}.tar.gz";
      sha256 = lock.nodes.flake-compat.locked.narHash;
    }
  )
  { src = ../.; }
).defaultNix



================================================
File: nix/default.nix
================================================
{ ... }@args:

let
  deprecatedArgs = [
    "config"
    "holochain-nixpkgs"
    "rustc"
    "holochainVersion"
    "include"
    "includeHolochainBinaries"
    "isIncludedFn"
  ];

  ignoredArgs = [ "inNixShell" ];

  # TODO: filter args
  filteredArgs = args;
in
(

  {
    # either one listed in VERSIONS.md or "custom". when "custom" is set, `holochainVersion` needs to be specified
    holochainVersionId ? "main"
  , rustVersion ? { }
  , devShellId ? "holonix"
  }:

  let
    flake = (import ./compat.nix);
    devShellsSystem = flake.devShells.${builtins.currentSystem};
  in
  devShellsSystem."${devShellId}".overrideAttrs (attrs:
  attrs // {
    passthru = (attrs.passthru or { }) // {
      internal = {
        inherit flake;
        inherit devShellsSystem;
      };
    };
  })

) filteredArgs



================================================
File: nix/shells.nix
================================================
{ lib
, stdenv
, mkShell
, rustup
, coreutils
, cargo-nextest
, crate2nix

, holonix
, hcToplevelDir
, nixEnvPrefixEval
, pkgs
}:

let
  hcMkShell = input: mkShell {
    # mkShell reverses the inputs list, which breaks order-sensitive shellHooks
    inputsFrom = lib.reverseList [
      { shellHook = nixEnvPrefixEval; }

      holonix.main

      {
        shellHook = ''
          >&2 echo Using "$NIX_ENV_PREFIX" as target prefix...

          export HC_TEST_WASM_DIR="$CARGO_TARGET_DIR/.wasm_target"
          mkdir -p $HC_TEST_WASM_DIR

          export HC_WASM_CACHE_PATH="$CARGO_TARGET_DIR/.wasm_cache"
          mkdir -p $HC_WASM_CACHE_PATH
        ''
        # workaround to make cargo-nextest work on darwin
        # see: https://github.com/nextest-rs/nextest/issues/267
        + (lib.strings.optionalString stdenv.isDarwin ''
          export DYLD_FALLBACK_LIBRARY_PATH="$(rustc --print sysroot)/lib"
        '')
        ;
      }

      input
    ];
  };
in

rec {
  # shell for HC core development. included dependencies:
  # * everything needed to compile this repos' crates
  # * CI scripts
  coreDev = hcMkShell {
    nativeBuildInputs = builtins.attrValues (pkgs.core)
      ++ [
      cargo-nextest
    ]
      ++ (with holonix.pkgs;[
      sqlcipher
      gdb
      gh
      nixpkgs-fmt
      cargo-sweep
    ])
      ++ (lib.optionals stdenv.isDarwin
      (with holonix.pkgs.darwin; [
        Security
        IOKit
        apple_sdk_11_0.frameworks.CoreFoundation
      ])
    );
  };

  release = coreDev.overrideAttrs (attrs: {
    nativeBuildInputs = attrs.nativeBuildInputs ++ (with holonix.pkgs; [
      niv
      (import ../crates/release-automation/default.nix { })
    ]);
  });

  ci = hcMkShell {
    inputsFrom = [
      (builtins.removeAttrs coreDev [ "shellHook" ])
    ];
    nativeBuildInputs = builtins.attrValues pkgs.ci;
  };

  happDev = hcMkShell {
    inputsFrom = [
      (builtins.removeAttrs coreDev [ "shellHook" ])
    ];
    nativeBuildInputs = builtins.attrValues pkgs.happ
      ++ (with holonix.pkgs; [
      sqlcipher
      binaryen
      gdb
    ])
    ;
  };

  coreDevRustup = coreDev.overrideAttrs (attrs: {
    buildInputs = attrs.buildInputs ++ [
      rustup
    ];
  });
}



================================================
File: nix/sources.json
================================================
{
    "crate2nix": {
        "branch": "master",
        "description": "nix build file generator for rust crates",
        "homepage": "",
        "owner": "kolloch",
        "repo": "crate2nix",
        "rev": "8241d5f1069cd0fc2b8eb8b69b13d68933834373",
        "sha256": "1m4ggqczfjgzn9vyih6j89km8dgnasl0526sk1ahlp9vq2bdgwfv",
        "type": "tarball",
        "url": "https://github.com/kolloch/crate2nix/archive/8241d5f1069cd0fc2b8eb8b69b13d68933834373.tar.gz",
        "url_template": "https://github.com/<owner>/<repo>/archive/<rev>.tar.gz"
    },
    "holochain-nixpkgs": {
        "branch": "develop",
        "description": null,
        "homepage": null,
        "owner": "holochain",
        "repo": "holochain-nixpkgs",
        "rev": "3f65731f306d5f67b5c4c68651e5008b58db9d41",
        "sha256": "03sr8djgci2jvvc70bchdjwkxaazy9wisssknamx9s0aini11klz",
        "type": "tarball",
        "url": "https://github.com/holochain/holochain-nixpkgs/archive/3f65731f306d5f67b5c4c68651e5008b58db9d41.tar.gz",
        "url_template": "https://github.com/<owner>/<repo>/archive/<rev>.tar.gz"
    },
    "nextest": {
        "branch": "main",
        "description": "A next-generation test runner for Rust.",
        "homepage": "https://nexte.st",
        "owner": "nextest-rs",
        "repo": "nextest",
        "rev": "cc1ebea104e5705097c9f8da69023bf80d03dd6a",
        "sha256": "1in972hzhy2zrf18v7a5m2pgll4znk9ipyzv1nih9vp5m2sg5nlx",
        "type": "tarball",
        "url": "https://github.com/nextest-rs/nextest/archive/cc1ebea104e5705097c9f8da69023bf80d03dd6a.tar.gz",
        "url_template": "https://github.com/<owner>/<repo>/archive/<rev>.tar.gz"
    },
    "nixos-unstable": {
        "branch": "nixos-unstable",
        "description": "Nix Packages collection",
        "homepage": "",
        "owner": "nixos",
        "repo": "nixpkgs",
        "rev": "1d7db1b9e4cf1ee075a9f52e5c36f7b9f4207502",
        "sha256": "1w7nrdq5pgmyc5p8lb86ljb3by02dhcmrc008hvaa4s45mf6p8qn",
        "type": "tarball",
        "url": "https://github.com/nixos/nixpkgs/archive/1d7db1b9e4cf1ee075a9f52e5c36f7b9f4207502.tar.gz",
        "url_template": "https://github.com/<owner>/<repo>/archive/<rev>.tar.gz"
    }
}



================================================
File: nix/sources.nix
================================================
# This file has been generated by Niv.

let

  #
  # The fetchers. fetch_<type> fetches specs of type <type>.
  #

  fetch_file = pkgs: name: spec:
    let
      name' = sanitizeName name + "-src";
    in
    if spec.builtin or true then
      builtins_fetchurl { inherit (spec) url sha256; name = name'; }
    else
      pkgs.fetchurl { inherit (spec) url sha256; name = name'; };

  fetch_tarball = pkgs: name: spec:
    let
      name' = sanitizeName name + "-src";
    in
    if spec.builtin or true then
      builtins_fetchTarball { name = name'; inherit (spec) url sha256; }
    else
      pkgs.fetchzip { name = name'; inherit (spec) url sha256; };

  fetch_git = name: spec:
    let
      ref =
        if spec ? ref then spec.ref else
        if spec ? branch then "refs/heads/${spec.branch}" else
        if spec ? tag then "refs/tags/${spec.tag}" else
        abort "In git source '${name}': Please specify `ref`, `tag` or `branch`!";
      submodules = if spec ? submodules then spec.submodules else false;
      submoduleArg =
        let
          nixSupportsSubmodules = builtins.compareVersions builtins.nixVersion "2.4" >= 0;
          emptyArgWithWarning =
            if submodules == true
            then
              builtins.trace
                (
                  "The niv input \"${name}\" uses submodules "
                  + "but your nix's (${builtins.nixVersion}) builtins.fetchGit "
                  + "does not support them"
                )
                { }
            else { };
        in
        if nixSupportsSubmodules
        then { inherit submodules; }
        else emptyArgWithWarning;
    in
    builtins.fetchGit
      ({ url = spec.repo; inherit (spec) rev; inherit ref; } // submoduleArg);

  fetch_local = spec: spec.path;

  fetch_builtin-tarball = name: throw
    ''[${name}] The niv type "builtin-tarball" is deprecated. You should instead use `builtin = true`.
        $ niv modify ${name} -a type=tarball -a builtin=true'';

  fetch_builtin-url = name: throw
    ''[${name}] The niv type "builtin-url" will soon be deprecated. You should instead use `builtin = true`.
        $ niv modify ${name} -a type=file -a builtin=true'';

  #
  # Various helpers
  #

  # https://github.com/NixOS/nixpkgs/pull/83241/files#diff-c6f540a4f3bfa4b0e8b6bafd4cd54e8bR695
  sanitizeName = name:
    (
      concatMapStrings (s: if builtins.isList s then "-" else s)
        (
          builtins.split "[^[:alnum:]+._?=-]+"
            ((x: builtins.elemAt (builtins.match "\\.*(.*)" x) 0) name)
        )
    );

  # The set of packages used when specs are fetched using non-builtins.
  mkPkgs = sources: system:
    let
      sourcesNixpkgs =
        import (builtins_fetchTarball { inherit (sources.nixpkgs) url sha256; }) { inherit system; };
      hasNixpkgsPath = builtins.any (x: x.prefix == "nixpkgs") builtins.nixPath;
      hasThisAsNixpkgsPath = <nixpkgs> == ./.;
    in
    if builtins.hasAttr "nixpkgs" sources
    then sourcesNixpkgs
    else if hasNixpkgsPath && ! hasThisAsNixpkgsPath then
      import <nixpkgs> { }
    else
      abort
        ''
          Please specify either <nixpkgs> (through -I or NIX_PATH=nixpkgs=...) or
          add a package called "nixpkgs" to your sources.json.
        '';

  # The actual fetching function.
  fetch = pkgs: name: spec:

    if ! builtins.hasAttr "type" spec then
      abort "ERROR: niv spec ${name} does not have a 'type' attribute"
    else if spec.type == "file" then fetch_file pkgs name spec
    else if spec.type == "tarball" then fetch_tarball pkgs name spec
    else if spec.type == "git" then fetch_git name spec
    else if spec.type == "local" then fetch_local spec
    else if spec.type == "builtin-tarball" then fetch_builtin-tarball name
    else if spec.type == "builtin-url" then fetch_builtin-url name
    else
      abort "ERROR: niv spec ${name} has unknown type ${builtins.toJSON spec.type}";

  # If the environment variable NIV_OVERRIDE_${name} is set, then use
  # the path directly as opposed to the fetched source.
  replace = name: drv:
    let
      saneName = stringAsChars (c: if isNull (builtins.match "[a-zA-Z0-9]" c) then "_" else c) name;
      ersatz = builtins.getEnv "NIV_OVERRIDE_${saneName}";
    in
    if ersatz == "" then drv else
      # this turns the string into an actual Nix path (for both absolute and
      # relative paths)
    if builtins.substring 0 1 ersatz == "/" then /. + ersatz else /. + builtins.getEnv "PWD" + "/${ersatz}";

  # Ports of functions for older nix versions

  # a Nix version of mapAttrs if the built-in doesn't exist
  mapAttrs = builtins.mapAttrs or (
    f: set: with builtins;
    listToAttrs (map (attr: { name = attr; value = f attr set.${attr}; }) (attrNames set))
  );

  # https://github.com/NixOS/nixpkgs/blob/0258808f5744ca980b9a1f24fe0b1e6f0fecee9c/lib/lists.nix#L295
  range = first: last: if first > last then [ ] else builtins.genList (n: first + n) (last - first + 1);

  # https://github.com/NixOS/nixpkgs/blob/0258808f5744ca980b9a1f24fe0b1e6f0fecee9c/lib/strings.nix#L257
  stringToCharacters = s: map (p: builtins.substring p 1 s) (range 0 (builtins.stringLength s - 1));

  # https://github.com/NixOS/nixpkgs/blob/0258808f5744ca980b9a1f24fe0b1e6f0fecee9c/lib/strings.nix#L269
  stringAsChars = f: s: concatStrings (map f (stringToCharacters s));
  concatMapStrings = f: list: concatStrings (map f list);
  concatStrings = builtins.concatStringsSep "";

  # https://github.com/NixOS/nixpkgs/blob/8a9f58a375c401b96da862d969f66429def1d118/lib/attrsets.nix#L331
  optionalAttrs = cond: as: if cond then as else { };

  # fetchTarball version that is compatible between all the versions of Nix
  builtins_fetchTarball = { url, name ? null, sha256 }@attrs:
    let
      inherit (builtins) lessThan nixVersion fetchTarball;
    in
    if lessThan nixVersion "1.12" then
      fetchTarball ({ inherit url; } // (optionalAttrs (!isNull name) { inherit name; }))
    else
      fetchTarball attrs;

  # fetchurl version that is compatible between all the versions of Nix
  builtins_fetchurl = { url, name ? null, sha256 }@attrs:
    let
      inherit (builtins) lessThan nixVersion fetchurl;
    in
    if lessThan nixVersion "1.12" then
      fetchurl ({ inherit url; } // (optionalAttrs (!isNull name) { inherit name; }))
    else
      fetchurl attrs;

  # Create the final "sources" from the config
  mkSources = config:
    mapAttrs
      (
        name: spec:
          if builtins.hasAttr "outPath" spec
          then
            abort
              "The values in sources.json should not have an 'outPath' attribute"
          else
            spec // { outPath = replace name (fetch config.pkgs name spec); }
      )
      config.sources;

  # The "config" used by the fetchers
  mkConfig =
    { sourcesFile ? if builtins.pathExists ./sources.json then ./sources.json else null
    , sources ? if isNull sourcesFile then { } else builtins.fromJSON (builtins.readFile sourcesFile)
    , system ? builtins.currentSystem
    , pkgs ? mkPkgs sources system
    }: rec {
      # The sources, i.e. the attribute set of spec name to spec
      inherit sources;

      # The "pkgs" (evaluated nixpkgs) to use for e.g. non-builtin fetchers
      inherit pkgs;
    };

in
mkSources (mkConfig { }) // { __functor = _: settings: mkSources (mkConfig settings); }



================================================
File: nix/update.sh
================================================
#! /usr/bin/env nix-shell 
#! nix-shell -p niv -i bash
niv update



================================================
File: nix/modules/_template.nix
================================================
{ self, lib, ... }: {
  perSystem = { config, self', inputs', pkgs, ... }: { };
  flake = { };
}



================================================
File: nix/modules/cargo-chef.nix
================================================
# Definitions can be imported from a separate file like this one

{ self, inputs, lib, ... }@flake: {
  perSystem = { config, self', inputs', system, pkgs, ... }:
    let
      rustToolchain = config.rustHelper.mkRust {
        track = "stable";
        version = "latest";
      };

      craneLib = (inputs.crane.mkLib pkgs).overrideToolchain rustToolchain;

      cargo-chef = craneLib.buildPackage {
        src = inputs.cargo-chef;
        doCheck = false;
      };

    in
    {
      packages = {
        inherit cargo-chef;
      };
    };
}



================================================
File: nix/modules/cargo-rdme.nix
================================================
# Definitions can be imported from a separate file like this one

{ self, inputs, lib, ... }@flake: {
  perSystem = { config, self', inputs', system, pkgs, ... }:
    let
      rustToolchain = config.rustHelper.mkRust {
        track = "stable";
        version = "latest";
      };

      craneLib = (inputs.crane.mkLib pkgs).overrideToolchain rustToolchain;

      cargo-rdme = craneLib.buildPackage {
        src = inputs.cargo-rdme;
        doCheck = false;
      };

    in
    {
      packages = {
        inherit cargo-rdme;
      };
    };
}



================================================
File: nix/modules/darwin.nix
================================================
{ self
, lib
, ...
} @ flake: {
  perSystem =
    { config
    , system
    , pkgs
    , ...
    }: {
      legacyPackages.apple_sdk' = lib.attrsets.optionalAttrs pkgs.stdenv.isDarwin
        (
          # aarch64 only uses 11.0 and x86_64 mixes them
          if system == "x86_64-darwin"
          then pkgs.darwin.apple_sdk_10_12
          else pkgs.darwin.apple_sdk_11_0
        );
    };
}



================================================
File: nix/modules/devShells.nix
================================================
{ self, lib, inputs, ... }: {
  perSystem = { config, self', inputs', pkgs, system, ... }:
    let
      holonixPackages = { holochainOverrides ? { } }:
        with self'.packages; [
          (holochain.override holochainOverrides)
          lair-keystore
          hc-scaffold
        ] ++ (lib.optionals (system != "x86_64-darwin") [ hc-launch ]);
      versionsFileText = builtins.concatStringsSep "\n"
        (
          builtins.map
            (package: ''
              echo ${package.pname} \($(${package}/bin/${package.pname} -V)\): ${package.src.rev or "na"}'')
            (holonixPackages { })
        );
      hn-introspect =
        pkgs.writeShellScriptBin "hn-introspect" versionsFileText;
    in
    {
      packages = {
        inherit hn-introspect;
      };

      devShells = {
        default = self'.devShells.holonix;
        holonix = pkgs.lib.makeOverridable
          ({ holochainOverrides }: (if inputs.versions.stub or false then pkgs.mkShell {
            shellHook = ''
                echo "This Holochain version is not supported on the current Holonix version. Please migrate to the new Holonix"
                echo "See the instructions here: https://developer.holochain.org/resources/upgrade/upgrade-new-holonix/"
                echo "Alternatively, you can use the quickstart guide provided with the updated Holonix: https://github.com/holochain/holonix"
                exit 1;
            '';
          } else lib.warn "\n\nThis version of Holonix is being deprecated, please consider migrating: https://developer.holochain.org/resources/upgrade/upgrade-new-holonix/" pkgs.mkShell {
            inputsFrom = [ self'.devShells.rustDev ];
            packages = (holonixPackages { inherit holochainOverrides; }) ++ [ hn-introspect ];
            shellHook = ''
              echo Holochain development shell spawned. Type 'exit' to leave.
              export PS1='\n\[\033[1;34m\][holonix:\w]\$\[\033[0m\] '
            '';
          }))
          {
            holochainOverrides = { };
          };

        holochainBinaries = pkgs.mkShell {
          inputsFrom = [ self'.devShells.rustDev ];
          packages = [ self'.packages.holochain self'.packages.lair-keystore ];
          shellHook = ''
            export PS1='\n\[\033[1;34m\][holochainBinaries:\w]\$\[\033[0m\] '
          '';
        };

        release = pkgs.mkShell {
          inputsFrom = [ self'.devShells.rustDev ];

          packages = (with self'.packages;
            [ release-automation cargo-rdme ])
          ++ (with pkgs; [ cargo-readme cargo-sweep gh gitFull cacert ]);
        };

        coreDev =
          let
            holochainTestDrvs =
              (
                lib.attrsets.filterAttrs
                  (name: package:
                    (builtins.match "^build-holochain-tests.*" name) != null
                  )
                  self'.packages
              );

            mkTestScript = name: package:
              pkgs.writeShellScriptBin (builtins.replaceStrings [ "build-" ] [ "script-" ] name)
                (
                  ''
                    set -xue
                  ''
                  # remove the craneLib internals that are part of the checkPhase and
                  # some characters that would prevent the passing of args
                  + (
                    let
                      cleanCmd = cmd:
                        (builtins.replaceStrings
                          [ "cargo --version" "cargoWithProfile" "runHook preCheck" "runHook postCheck" "runHook preBuild" "runHook postBuild" "\n" "\\" "  " ]
                          [ "" "cargo" "" "" "" "" "" "" " " ]
                          cmd);

                      checkPhaseClean = cleanCmd (package.checkPhase or "");
                      buildPhaseClean = cleanCmd (package.buildPhase or "");
                      checkOrBuildPhase =
                        if checkPhaseClean != "" then checkPhaseClean
                        else buildPhaseClean;
                    in
                    if checkOrBuildPhase != "" then
                      ''${checkOrBuildPhase} ''${@}''
                    else if (package.passthru.dependencies or null) != null then
                    # recursive call to generate one script call per dependency
                      builtins.concatStringsSep "\n" (builtins.map (pkg: "${mkTestScript pkg.name pkg}/bin/${pkg.name}") package.passthru.dependencies)
                    else
                      throw ''${name} has neither of these
                              - checkPhase: (${checkPhaseClean})
                              - buildPhase: (${buildPhaseClean})
                              - passthru.dependencies
                            ''
                  )
                );

          in
          pkgs.mkShell {
            inputsFrom = [ self'.devShells.rustDev ] ++ (
              # filter out the holochain binary crates from the shell because it's at best unnecessary in local development
              # it's currently a nativeBuildInput because one of the unit tests requires `holochain` and `hc-sandbox` in PATH
              builtins.map
                (testDrv:
                  if (testDrv.overrideDerivation or null) != null
                  then
                    testDrv.overrideDerivation
                      (testDrvAttrs: {
                        nativeBuildInputs =
                          builtins.filter
                            (nativeBuildInput:
                              !lib.lists.any (unwantedPackage: nativeBuildInput == unwantedPackage)
                                [
                                  self'.packages.holochain
                                ]
                            )
                            (testDrvAttrs.nativeBuildInputs or [ ])
                        ;
                      })
                  else testDrv
                )
                (builtins.attrValues holochainTestDrvs)
            )
            ;

            packages = with pkgs; [
              cargo-nextest
              graph-easy

              self'.packages.scripts-cargo-regen-lockfiles
              self'.packages.scripts-cargo-update
            ]

            # generate one script for each of the "holochain-tests-" prefixed derivations by reusing their checkPhase
            ++ builtins.attrValues (builtins.mapAttrs mkTestScript holochainTestDrvs)
            ;

            shellHook = ''
              export PS1='\n\[\033[1;34m\][coreDev:\w]\$\[\033[0m\] '

              export HC_TEST_WASM_DIR="$CARGO_TARGET_DIR/.wasm_target"
              mkdir -p $HC_TEST_WASM_DIR

              export HC_WASM_CACHE_PATH="$CARGO_TARGET_DIR/.wasm_cache"
              mkdir -p $HC_WASM_CACHE_PATH

              # Enables the pre-commit hooks
              ${config.pre-commit.installationScript}
            '';
          };

        rustDev = pkgs.mkShell {
          inputsFrom = [
            self'.packages.holochain
          ];

          packages = (lib.lists.optionals pkgs.stdenv.isLinux [
            pkgs.mold
            pkgs.pkgsStatic.openssl
          ]);

          shellHook = ''
            export HOLOCHAIN_DEVSHELL="rustDev"
            export CARGO_HOME="$PWD/.cargo"
            export CARGO_INSTALL_ROOT="$PWD/.cargo"
            export CARGO_TARGET_DIR="$PWD/target"
            export CARGO_CACHE_RUSTC_INFO=1
            export PATH="$CARGO_INSTALL_ROOT/bin:$PATH"
            export NIX_PATH="nixpkgs=${pkgs.path}"
            export PS1='\n\[\033[1;34m\][rustDev:\w]\$\[\033[0m\] '
            export LIBCLANG_PATH="${pkgs.llvmPackages.libclang.lib}/lib"
            echo Rust development shell spawned. Type 'exit' to leave.
          ''
          + (lib.strings.optionalString pkgs.stdenv.isDarwin ''
            export DYLD_FALLBACK_LIBRARY_PATH="$(rustc --print sysroot)/lib"
          '')
          + (lib.strings.optionalString pkgs.stdenv.isLinux ''
            export CARGO_TARGET_X86_64_UNKNOWN_LINUX_GNU_RUSTFLAGS="$CARGO_TARGET_X86_64_UNKNOWN_LINUX_GNU_RUSTFLAGS -Clink-arg=-fuse-ld=mold"
          '')
          ;
        };

        nixDev =
          pkgs.mkShell
            {
              inputsFrom = [
                self'.devShells.rustDev
              ];

              packages = [
                pkgs.llvmPackages.bintools
              ];
            };
      };
    };
}



================================================
File: nix/modules/formatter.nix
================================================
{ self, lib, ... }: {
  perSystem = { config, self', inputs', pkgs, ... }: {
    # define formatter used by `nix fmt`
    formatter = pkgs.nixpkgs-fmt;
  };
}



================================================
File: nix/modules/go.nix
================================================
{ self
, lib
, inputs
, ...
} @ flake: {
  perSystem =
    { config
    , self'
    , inputs'
    , system
    , pkgs
    , ...
    }: {
      packages = {
        goWrapper =
          let
            go = pkgs.go;
          in
          # there is interference only in this specific case, we assemble a go derivationt that not propagate anything but still has everything available required for our specific use-case
            #
            # the wrapper inherits preconfigured environment variables from the
            # derivation that depends on the propagating go
          if pkgs.stdenv.isDarwin && pkgs.system == "x86_64-darwin" then
            pkgs.darwin.apple_sdk_11_0.stdenv.mkDerivation
              {
                name = "go";

                nativeBuildInputs = [
                  pkgs.makeBinaryWrapper
                  go
                ];

                dontBuild = true;
                dontUnpack = true;

                installPhase = ''
                  makeWrapper ${pkgs.go}/bin/go $out/bin/go \
                    ${builtins.concatStringsSep " " (
                      builtins.map (var: "--set ${var} \"\$${var}\"") 
                      [
                        "NIX_BINTOOLS_WRAPPER_TARGET_HOST_x86_64_apple_darwin"
                        "NIX_LDFLAGS"
                        "NIX_CFLAGS_COMPILE_FOR_BUILD"
                        "NIX_CFLAGS_COMPILE"

                        # confirmed needed above here

                        # unsure between here
                        # and here

                        # confirmed unneeded below here

                        # "NIX_CC"
                        # "NIX_CC_FOR_BUILD"
                        # "NIX_LDFLAGS_FOR_BUILD"
                        # "NIX_BINTOOLS"
                        # "NIX_CC_WRAPPER_TARGET_HOST_x86_64_apple_darwin"
                        # "NIX_CC_WRAPPER_TARGET_BUILD_x86_64_apple_darwin"
                        # "NIX_ENFORCE_NO_NATIVE"
                        # "NIX_DONT_SET_RPATH"
                        # "NIX_BINTOOLS_FOR_BUILD"
                        # "NIX_DONT_SET_RPATH_FOR_BUILD"
                        # "NIX_NO_SELF_RPATH"
                        # "NIX_IGNORE_LD_THROUGH_GCC"
                        # "NIX_PKG_CONFIG_WRAPPER_TARGET_HOST_x86_64_apple_darwin"
                        # "NIX_COREFOUNDATION_RPATH"
                        # "NIX_BINTOOLS_WRAPPER_TARGET_BUILD_x86_64_apple_darwin"
                      ]
                    )}
                '';
              }
          else go;
      };
    };
}



================================================
File: nix/modules/holochain-nix-integration-test.nix
================================================
{ self, lib, ... }: {
  perSystem = { config, pkgs, ... }:
    {
      apps.holochain-nix-integration-test.type = "app";
      apps.holochain-nix-integration-test.program = builtins.toString
        (pkgs.writeShellScript "script.sh" ''
          set -xeu

          export PATH="${
            lib.makeBinPath (with pkgs; [ gitFull coreutils nix niv ])
          }:$PATH"

          # remove everything that wouldn't be on github either
          git clean -fdx

          # we use this git daemon to not rely on the published tag
          git daemon --reuseaddr --base-path=. --export-all --verbose --detach

          git clone "''${HOLOCHAIN_NIXPKGS_URL}" "''${HOLOCHAIN_NIXPKGS_REPO}" -b ''${HOLOCHAIN_NIXPKGS_SOURCE_BRANCH} --depth=1
          cd "''${HOLOCHAIN_NIXPKGS_REPO}"

          git checkout -b "''${RELEASE_BRANCH}"

          if grep --quiet ''${VERSION_COMPAT} packages/holochain/versions/update_config.toml; then
            export VERSION_COMPAT="''${VERSION_COMPAT}-ci"
            export TAG="''${TAG}-ci"
            git -C "''${HOLOCHAIN_REPO}" tag --force "''${TAG}"
          fi

          # TODO: use a util from the holochain-nixpkgs repo to make this change as this can get out of sync
          cat <<EOF >> packages/holochain/versions/update_config.toml

          [''${VERSION_COMPAT}]
          git-src = "revision:''${TAG}"
          git-repo = "git://localhost/"
          EOF

          # regenerate the nix sources
          ./scripts/ci-git-config.sh

          nix-shell \
            --pure \
            --keep VERSION_COMPAT \
            --arg flavors '["release"]' \
            --run 'hnixpkgs-update-single ''${VERSION_COMPAT}'
          nix-build . -A packages.holochain.holochainAllBinariesWithDeps.''${VERSION_COMPAT} --no-link

          cd "''${HOLONIX_REPO}"

          niv drop holochain-nixpkgs
          niv add local --path "''${HOLOCHAIN_NIXPKGS_REPO}" --name holochain-nixpkgs

          # this should be the same as ''${TAG}
          nix eval -f ./ holochain-nixpkgs.packages.holochain.holochainAllBinariesWithDeps.''${VERSION_COMPAT}.holochain.src.rev

          # TODO: replace the following by 'nix run .#holonix-integration-test'
          nix-shell \
            --pure \
            --argstr holochainVersionId "''${VERSION_COMPAT}" \
            --arg include '{ test = true; }' \
            --run '
              holochain --version
              hn-test
            '
        '');
    };
}



================================================
File: nix/modules/holochain.nix
================================================
# Definitions can be imported from a separate file like this one

{ self, inputs, lib, ... }@flake: {
  perSystem = { config, self', inputs', system, pkgs, ... }:
    let
      rustToolchain = config.rustHelper.mkRust {
        track = "stable";
        version = inputs.versions.rustVersion;
      };

      craneLib = (inputs.crane.mkLib pkgs).overrideToolchain rustToolchain;

      commonArgs = {
        RUST_SODIUM_LIB_DIR = "${pkgs.libsodium}/lib";
        RUST_SODIUM_SHARED = "1";

        pname = "holochain";
        src = flake.config.srcCleanedHolochain;

        version = "workspace";

        CARGO_PROFILE = "";

        buildInputs = (with pkgs; [
          openssl
          self'.packages.opensslStatic
          sqlcipher
          cmake
        ])
        ++ (lib.optionals pkgs.stdenv.isDarwin
          (with pkgs.darwin.apple_sdk_11_0.frameworks; [
            AppKit
            CoreFoundation
            CoreServices
            Security
            IOKit
          ]));

        nativeBuildInputs = (with pkgs; [
          makeWrapper
          perl
          pkg-config
          self'.packages.goWrapper
          # These packages and env vars are required to build holochain with the 'wasmer_wamr' feature 
          clang
          llvmPackages.libclang.lib
          ninja
        ])
        ++ lib.optionals pkgs.stdenv.isDarwin
          (with pkgs; [ xcbuild libiconv ]);

        stdenv = config.rustHelper.defaultStdenv pkgs;
      };

      # derivation building all dependencies
      holochainDeps = craneLib.buildDepsOnly (commonArgs // {
        src = flake.config.srcCleanedHolochain;
        doCheck = false;
      });

      holochainDepsRelease = craneLib.buildDepsOnly (commonArgs // {
        CARGO_PROFILE = "release";
        src = flake.config.srcCleanedHolochain;
        doCheck = false;
      });

      # derivation with the main crates
      holochain = lib.makeOverridable craneLib.buildPackage (commonArgs // {
        CARGO_PROFILE = "release";
        cargoArtifacts = holochainDepsRelease;
        src = flake.config.srcCleanedHolochain;
        doCheck = false;
        passthru.src.rev = flake.config.reconciledInputs.holochain.rev;
      });

      holochain_chc = holochain.override { cargoExtraArgs = " --features chc"; };

      holochainNextestDeps = craneLib.buildDepsOnly (commonArgs // {
        pname = "holochain-tests-nextest";
        CARGO_PROFILE = "fast-test";
        nativeBuildInputs = commonArgs.nativeBuildInputs ++ [ pkgs.cargo-nextest ];
        buildPhase = ''
          cargo nextest run --no-run \
          ${import ../../.config/test-args.nix} \
          ${import ../../.config/nextest-args.nix} \
        '';
        dontCheck = true;
      });

      holochainTestsNextestArgs =
        (commonArgs // {
          __noChroot = pkgs.stdenv.isLinux;
          cargoArtifacts = holochainNextestDeps;

          pname = "holochain-tests-nextest";

          preCheck = ''
            export DYLD_FALLBACK_LIBRARY_PATH=$(rustc --print sysroot)/lib
          '';

          cargoExtraArgs = ''
            --profile ci \
            --config-file ${../../.config/nextest.toml} \
            ${import ../../.config/test-args.nix} \
            ${import ../../.config/nextest-args.nix}
          '';

          cargoNextestExtraArgs = builtins.getEnv "NEXTEST_EXTRA_ARGS";

          dontPatchELF = true;
          dontFixup = true;

          nativeBuildInputs = commonArgs.nativeBuildInputs ++ [ holochain ];

          installPhase = ''
            mkdir -p $out
            cp -vL target/.rustc_info.json $out/
            find target -name "junit.xml" -exec cp -vLb {} $out/ \;
          '';
        });

      build-holochain-tests-unit = lib.makeOverridable craneLib.cargoNextest holochainTestsNextestArgs;

      build-holochain-tests-static-fmt = craneLib.cargoFmt (commonArgs // {
        src = flake.config.srcCleanedHolochain;
        cargoArtifacts = null;
        doCheck = false;

        dontPatchELF = true;
        dontFixup = true;
      });

      build-holochain-tests-static-clippy = craneLib.cargoClippy (commonArgs // {
        pname = "holochain-tests-clippy";
        src = flake.config.srcCleanedHolochain;
        cargoArtifacts = holochainDeps;
        doCheck = false;

        cargoClippyExtraArgs =
          let
            # contains a set with items like 'nursery = allow'
            workspaceClippyLints = (builtins.fromTOML (builtins.readFile "${self}/Cargo.toml")).workspace.lints.clippy;
            workspaceClippyLints1 = builtins.mapAttrs
              (name: value:
                builtins.concatStringsSep " " [
                  (
                    if builtins.typeOf value == "string" then
                      if value == "allow" then "-A"
                      else if value == "deny" then "-D"
                      else throw "unsupported lint level: ${name} = ${value}"
                    else if builtins.typeOf value == "set" && builtins.typeOf value.level == "string" then
                      if value.level == "allow" then "-A"
                      else if value.level == "deny" then "-D"
                      else throw "unsupported lint level: ${name}.level = ${value.level}"
                    else throw "unsupported value for lint: ${name}"
                  )
                  "clippy::${name}"
                ]
              )
              workspaceClippyLints
            ;

            # contains a list of e.g. "-A clippy::nursery"
            workspaceClippyLints2 = builtins.attrValues workspaceClippyLints1;

            # contains the final argument string
            workspaceClippyLints3 = builtins.concatStringsSep " " workspaceClippyLints2;
          in
          # the outcome will be: "-- -A clippy::nursery -D ..."
          "-- ${workspaceClippyLints3}"
        ;

        dontPatchELF = true;
        dontFixup = true;

        installPhase = ''
          mkdir -p $out
          cp -vL target/.rustc_info.json  $out/
        '';
      });

      holochainWasmArgs = (commonArgs // {
        pname = "holochain-tests-wasm";

        postConfigure = ''
          export CARGO_TARGET_DIR=''${CARGO_TARGET_DIR:-$PWD/target}
        '';

        cargoExtraArgs =
          "--lib --all-features --manifest-path=crates/test_utils/wasm/wasm_workspace/Cargo.toml";

        cargoLock = "${flake.config.srcCleanedHolochain}/crates/test_utils/wasm/wasm_workspace/Cargo.lock";
      });

      holochainDepsWasm = craneLib.buildDepsOnly (holochainWasmArgs // {
        cargoArtifacts = null;
      });

      build-holochain-tests-unit-wasm = craneLib.cargoTest (holochainWasmArgs // {
        cargoArtifacts = holochainDepsWasm;

        dontPatchELF = true;
        dontFixup = true;

        installPhase = ''
          mkdir -p $out
          cp -vL target/.rustc_info.json  $out/
        '';
      });

      build-holochain-tests-static-doc = craneLib.cargoDoc (commonArgs // {
        pname = "holochain-tests-docs";
        cargoArtifacts = holochainDeps;
      });



      # meta packages to build multiple test packages at once
      build-holochain-tests-unit-all = config.lib.mkMetaPkg "holochain-tests-unit-all" [
        build-holochain-tests-unit
        build-holochain-tests-unit-wasm
      ];

      build-holochain-tests-static-all = config.lib.mkMetaPkg "holochain-tests-static-all" [
        build-holochain-tests-static-doc
        build-holochain-tests-static-fmt
        build-holochain-tests-static-clippy
      ];

      build-holochain-tests-all = config.lib.mkMetaPkg "build-holochain-tests-all" [
        build-holochain-tests-unit-all
        build-holochain-tests-static-all
      ];

    in
    {
      packages =
        {
          inherit
            holochain
            holochain_chc

            build-holochain-tests-unit
            build-holochain-tests-unit-wasm
            build-holochain-tests-unit-all

            build-holochain-tests-static-doc
            build-holochain-tests-static-fmt
            build-holochain-tests-static-clippy
            build-holochain-tests-static-all

            build-holochain-tests-all
            ;
        };
    };
}



================================================
File: nix/modules/holonix-integration-test.nix
================================================
{ self
, lib
, inputs
, ...
} @ flake: {
  perSystem =
    { self'
    , config
    , pkgs
    , system
    , ...
    }:
    let

      rustToolchain = config.rustHelper.mkRust {
        track = "stable";
        version = inputs.versions.rustVersion;
      };
      craneLib = (inputs.crane.mkLib pkgs).overrideToolchain rustToolchain;
      moldOpensslDeps = craneLib.vendorCargoDeps {
        src = "${flake.config.srcCleanedHolonix}/holonix/test/mold_openssl";
      };
    in
    {
      packages.build-holonix-tests-integration = pkgs.mkShell {
        inputsFrom = [ self'.devShells.holonix ];
        phases = [
          "buildPhase"
          "checkPhase"
        ];

        doCheck = true;

        nativeCheckInputs = [
          pkgs.coreutils
          pkgs.procps
          pkgs.killall
          pkgs.bats
        ];

        checkPhase = ''
          # output to console and to logfile
          exec >> >(tee $out) 2>&1

          eval "$shellHook"

          echo =============== TESTSCRIPT OUTPUT STARTS HERE ===============
          set -Eeuo pipefail

          cd ${flake.config.srcCleanedHolonix}/holonix

          bats ./test/shell-setup.bats
          bats ./test/holochain-binaries.bats
          ${ if system != "x86_64-darwin" then "bats ./test/launcher.bats" else "" }
          bats ./test/scaffolding.bats
          bats ./test/rust.bats
          bats ./test/hc-sandbox.bats

          env CARGO_VENDOR_DIR="${moldOpensslDeps}" \
            bats ./test/mold_openssl.bats
        '' + lib.strings.optionalString pkgs.stdenv.isLinux ''
          bats ./test/shell-setup-linux.bats
        ''
        ;

        preferLocalBuild = false;
      };
    };
}



================================================
File: nix/modules/lair.nix
================================================
# Definitions can be imported from a separate file like this one

{ self, inputs, lib, ... }@flake: {
  perSystem = { config, self', inputs', system, pkgs, ... }:
    let
      rustToolchain = config.rustHelper.mkRust {
        track = "stable";
        version = inputs.versions.rustVersion;
      };

      craneLib = (inputs.crane.mkLib pkgs).overrideToolchain rustToolchain;

      crateInfo = craneLib.crateNameFromCargoToml { cargoToml = flake.config.reconciledInputs.lair + "/crates/lair_keystore/Cargo.toml"; };

      commonArgs = {

        pname = "lair-keystore";
        src = flake.config.reconciledInputs.lair;

        # We are asking Crane to build a binary from the workspace and that's the only way we can build it because
        # the workspace defines the dependencies, so we can't just build the member crate. But then we need to tell
        # Crate what the version is, so we look it up directly from the member's Cargo.toml.
        version = crateInfo.version;

        CARGO_PROFILE = "release";

        cargoExtraArgs = "--bin lair-keystore";

        buildInputs = (with pkgs; [ openssl ])
          ++ (lib.optionals pkgs.stdenv.isDarwin
          (with pkgs.darwin.apple_sdk_11_0.frameworks; [
            AppKit
            CoreFoundation
            CoreServices
            Security
          ]));

        nativeBuildInputs = (with pkgs; [ perl pkg-config ])
          ++ lib.optionals pkgs.stdenv.isDarwin
          (with pkgs; [ xcbuild libiconv ]);

        doCheck = false;
      };

      # derivation building all dependencies
      deps = craneLib.buildDepsOnly (commonArgs // { });

      # derivation with the main crates
      package = lib.makeOverridable craneLib.buildPackage (commonArgs // {
        cargoArtifacts = deps;
      });

    in
    { packages = { lair-keystore = package; }; };
}



================================================
File: nix/modules/launcher.nix
================================================
# Definitions can be imported from a separate file like this one

{ self, inputs, lib, ... }@flake: {
  perSystem = { config, self', inputs', system, pkgs, ... }:
    let
      rustToolchain = config.rustHelper.mkRust {
        track = "stable";
        version = inputs.versions.rustVersion;
      };

      craneLib = (inputs.crane.mkLib pkgs).overrideToolchain rustToolchain;

      crateInfo = craneLib.crateNameFromCargoToml { cargoToml = flake.config.reconciledInputs.launcher + "/crates/hc_launch/src-tauri/Cargo.toml"; };

      commonArgs = {

        pname = "hc-launch";
        src = flake.config.reconciledInputs.launcher;

        # We are asking Crane to build a binary from the workspace and that's the only way we can build it because
        # the workspace defines the dependencies, so we can't just build the member crate. But then we need to tell
        # Crate what the version is, so we look it up directly from the member's Cargo.toml.
        version = crateInfo.version;

        CARGO_PROFILE = "release";

        cargoExtraArgs = "--bin hc-launch";

        buildInputs = (with pkgs; [
          openssl

          # this is required for glib-networking
          glib
        ])
        ++ (lib.optionals pkgs.stdenv.isLinux
          (with pkgs; [
            webkitgtk.dev
            gdk-pixbuf
            gtk3
          ]))
        ++ lib.optionals pkgs.stdenv.isDarwin
          (with self'.legacyPackages.apple_sdk'.frameworks; [
            AppKit
            CoreFoundation
            CoreServices
            Security
            IOKit
            WebKit
          ])
        ;

        nativeBuildInputs = (with pkgs; [
          perl
          pkg-config

          # currently needed to build tx5
          self'.packages.goWrapper
        ])
        ++ (lib.optionals pkgs.stdenv.isLinux
          (with pkgs; [
            wrapGAppsHook
          ]))
        ++ (lib.optionals pkgs.stdenv.isDarwin [
          pkgs.xcbuild
          pkgs.libiconv
        ])
        ;

        doCheck = false;
      };

      # derivation building all dependencies
      deps = craneLib.buildDepsOnly (commonArgs // { });

      # derivation with the main crates
      package = craneLib.buildPackage (commonArgs // {
        cargoArtifacts = deps;

        nativeBuildInputs = commonArgs.nativeBuildInputs ++ [
          pkgs.makeBinaryWrapper
        ];

        preFixup = ''
          gappsWrapperArgs+=(
            --set WEBKIT_DISABLE_COMPOSITING_MODE 1
          )

          # without this the DevTools will just display an unparsed HTML file (see https://github.com/tauri-apps/tauri/issues/5711#issuecomment-1336409601)
          gappsWrapperArgs+=(
            --prefix XDG_DATA_DIRS : "${pkgs.shared-mime-info}/share"
          )
        '';
      });

    in
    {
      packages = {
        hc-launch = package;
      };
    };
}



================================================
File: nix/modules/lib.nix
================================================
{ self, lib, ... }: {
  perSystem = { config, self', inputs', pkgs, ... }: {
    options.lib = lib.mkOption { type = lib.types.raw; };
    config.lib.mkMetaPkg = name: dependencies: pkgs.stdenv.mkDerivation {
      inherit name;
      dontUnpack = true;
      installPhase = ''
        mkdir $out
      '' + builtins.concatStringsSep "\n" (builtins.map (pkg: "${pkgs.coreutils}/bin/ln -sf ${pkg} $out/${pkg.name or pkg.pname}")
        dependencies
      );

      passthru = { inherit dependencies; };
    };


  };
  flake = { };
}



================================================
File: nix/modules/pre-commit.nix
================================================
{ self, lib, ... }: {
  perSystem = { config, self', inputs', pkgs, ... }:
    {
      # makes all pre-commit hooks become part of `nix flake check`
      pre-commit.check.enable = true;

      # enables the nixpkgs-fmt module for pre-commit-hooks
      pre-commit.settings.hooks.nixpkgs-fmt.enable = true;
    };
}



================================================
File: nix/modules/reconciledInputs.nix
================================================
{ self, lib, inputs, ... }:

{
  options.reconciledInputs = lib.mkOption { type = lib.types.raw; };
  config.reconciledInputs = lib.genAttrs (builtins.attrNames inputs.versions.inputs)
    (name:
      let
        input =
          if builtins.pathExists (inputs."${name}" + "/Cargo.toml")
          then inputs."${name}"
          else
            inputs.versions.inputs."${name}";
        rev = input.rev or (self.rev or "unknown");
      in
      (input // { inherit rev; })
    );
}



================================================
File: nix/modules/release-automation.nix
================================================
# Definitions can be imported from a separate file like this one

{ self, inputs, lib, ... }@flake: {
  perSystem = { config, self', inputs', system, pkgs, ... }:
    let
      rustToolchain = config.rustHelper.mkRust {
        track = "stable";
        version = "1.77.2";
      };

      craneLib = (inputs.crane.mkLib pkgs).overrideToolchain rustToolchain;

      commonArgs = {
        pname = "release-automation";
        version = "workspace";
        src = flake.config.srcCleanedReleaseAutomationRepo;

        buildInputs = (with pkgs; [ openssl ])
          ++ (lib.optionals pkgs.stdenv.isDarwin
          (with pkgs.darwin.apple_sdk_11_0.frameworks; [
            AppKit
            CoreFoundation
            CoreServices
            Security
          ]));

        nativeBuildInputs = (with pkgs;
          [ perl pkg-config ])
        ++ lib.optionals pkgs.stdenv.isDarwin
          (with pkgs; [ xcbuild libiconv ]);
      };

      # derivation building all dependencies
      deps = craneLib.buildDepsOnly (commonArgs // {
        doCheck = false;
      });

      # derivation with the main crates
      package = craneLib.buildPackage (commonArgs // {
        cargoArtifacts = deps;
        doCheck = false;
      });

      tests = craneLib.cargoNextest (commonArgs // {
        src = flake.config.srcCleanedReleaseAutomationWithTestsRepo;
        pname = "${commonArgs.pname}-tests";
        __noChroot = pkgs.stdenv.isLinux;

        cargoArtifacts = deps;

        buildInputs = commonArgs.buildInputs ++ [ pkgs.cacert ];
        nativeBuildInputs = commonArgs.nativeBuildInputs ++
          [
            package

            rustToolchain
            pkgs.gitFull
            pkgs.coreutils
          ];

        cargoNextestExtraArgs =
          let
            nextestToml = builtins.toFile "nextest.toml" ''
              [profile.default]
              retries = { backoff = "exponential", count = 3, delay = "1s", jitter = true }
              status-level = "skip"
              final-status-level = "flaky"

            '';
          in
          '' \
            --config-file=${nextestToml} \
          '' + builtins.getEnv "NEXTEST_EXTRA_ARGS";

        dontPatchELF = true;
        dontFixup = true;
        installPhase = ''
          mkdir -p $out
          cp -vL target/.rustc_info.json $out/
        '';
      });

      packagePath = lib.makeBinPath [ package ];

    in
    {
      packages = {
        release-automation = package;

        build-release-automation-tests-unit = tests;

        # check the state of the repository
        # this is using a dummy input like this:
        # ```nix
        #     repo-git.url = "file+file:/dev/null";
        #     repo-git.flake = false;
        # ```
        # and then the test derivation is built it relies on that input being the local repo path. see the "holochain-build-and-test.yml" workflow.
        build-release-automation-tests-repo =
          let
            release-script = self'.packages.scripts-release-automation-check-and-bump;
            readmes-script = self'.packages.scripts-ci-generate-readmes;
          in
          pkgs.runCommand
            "release-automation-tests-repo"
            {
              __noChroot = pkgs.stdenv.isLinux;
              nativeBuildInputs = self'.packages.holochain.nativeBuildInputs ++ [
                pkgs.coreutils
                pkgs.gitFull
              ];
              buildInputs = self'.packages.holochain.buildInputs ++ [
                pkgs.cacert
              ];
            } ''
            set -xeuo pipefail

            export HOME="$(mktemp -d)"
            export TEST_WORKSPACE="''${HOME:?}/src"

            git config --global --add safe.directory ${inputs.repo-git}
            git clone --single-branch ${inputs.repo-git} ''${TEST_WORKSPACE}

            cd ''${TEST_WORKSPACE:?}
            ${../../scripts/ci-git-config.sh}
            git status
            git switch -c repo-test

            ${readmes-script}/bin/${readmes-script.name}
            ${release-script}/bin/${release-script.name} ''${TEST_WORKSPACE}

            set +e
            git clean -ffdx
            mv ''${TEST_WORKSPACE} $out
            echo use "nix-store --realise $out" to retrieve the result.
          '';
      };
    };
}



================================================
File: nix/modules/rust.nix
================================================
{ self
, lib
, inputs
, ...
} @ flake: {
  perSystem =
    { config
    , self'
    , inputs'
    , system
    , pkgs
    , ...
    }: {
      config.packages = {
        opensslStatic =
          if system == "x86_64-darwin"
          then pkgs.openssl # pkgsStatic is considered a cross build
          # and this is not yet supported
          else pkgs.pkgsStatic.openssl;
      };

      options.rustHelper = lib.mkOption { type = lib.types.raw; };

      config.rustHelper =
        let
          rustPkgs = import inputs.nixpkgs {
            inherit system;
            overlays = [ (import inputs.rust-overlay) ];
          };
        in
        {
          defaultTrack = "stable";
          defaultVersion = "1.77.2";

          defaultExtensions = [
            "rust-src"
            "rust-analyzer"
            "clippy"
            "rustfmt"
          ];

          defaultTargets = [
            "wasm32-unknown-unknown"
          ];

          defaultStdenv = pkgs:
            if pkgs.stdenv.isLinux
            then pkgs.stdenvAdapters.useMoldLinker pkgs.stdenv
            else pkgs.stdenv;

          mkRust =
            { track ? config.rustHelper.defaultTrack
            , version ? config.rustHelper.defaultVersion
            , extensions ? config.rustHelper.defaultExtensions
            , targets ? config.rustHelper.defaultTargets
            }: (rustPkgs.rust-bin."${track}"."${version}".minimal.override ({
              inherit extensions targets;
            }));

          customBuildRustCrateForPkgs = pkgs: pkgs.buildRustCrate.override {
            stdenv = config.rustHelper.defaultStdenv pkgs;

            defaultCrateOverrides = pkgs.lib.attrsets.recursiveUpdate pkgs.defaultCrateOverrides
              ({
                tx5-go-pion-sys = _: { nativeBuildInputs = with pkgs; [ go ]; };
                tx5-go-pion-turn = _: { nativeBuildInputs = with pkgs; [ go ]; };
              });
          };

          # `nix flake show` is incompatible with IFD by default
          # This works around the issue by making the name of the package
          #   discoverable without IFD.
          mkNoIfdPackage = name: pkg: {
            inherit name;
            inherit (pkg) drvPath outPath;
            type = "derivation";
            orig = pkg;
          };
        };
    };
}



================================================
File: nix/modules/scaffolding.nix
================================================
# Definitions can be imported from a separate file like this one

{ self, inputs, lib, ... }@flake: {
  perSystem = { config, self', inputs', system, pkgs, ... }:
    let
      rustToolchain = config.rustHelper.mkRust {
        track = "stable";
        version = inputs.versions.rustVersion;
      };
      craneLib = (inputs.crane.mkLib pkgs).overrideToolchain rustToolchain;

      commonArgs = {

        pname = "hc-scaffold";
        src = flake.config.reconciledInputs.scaffolding;

        CARGO_PROFILE = "release";

        cargoExtraArgs = "--bin hc-scaffold";

        buildInputs =
          (with pkgs; [
            openssl
          ]) ++ (lib.optionals pkgs.stdenv.isDarwin
            (with self'.legacyPackages.apple_sdk'.frameworks; [
              AppKit
              CoreFoundation
              CoreServices
              Security
            ])
          )
        ;

        nativeBuildInputs =
          (with pkgs; [
            perl
            pkg-config
            makeBinaryWrapper
            self'.packages.goWrapper
          ])
          ++ lib.optionals pkgs.stdenv.isDarwin (with pkgs; [
            xcbuild
            libiconv
          ]);

        doCheck = false;
      };

      # derivation building all dependencies
      deps = craneLib.buildDepsOnly (commonArgs // { });

      # derivation with the main crates
      package = craneLib.buildPackage (commonArgs // {
        cargoArtifacts = deps;

        preFixup = ''
          wrapProgram $out/bin/hc-scaffold \
            --prefix PATH : ${rustToolchain}/bin
        '';
      });
    in
    {
      packages = {
        hc-scaffold = package;
      };
    };
}



================================================
File: nix/modules/scripts.nix
================================================
{ self, lib, ... }: {
  perSystem = { config, self', inputs', pkgs, ... }: {
    # Definitions like this are entirely equivalent to the ones
    # you may have directly in flake.nix.
    packages = {
      scripts-ci-cachix-helper =
        let
          pathPrefix = lib.makeBinPath (with pkgs; [ cachix ]);
        in
        pkgs.writeShellScript "scripts-ci-cachix-helper" ''
            #! /usr/bin/env nix-shell
            set -euo pipefail

          export PATH=${pathPrefix}:$PATH

          export PATHS_PREBUILD_FILE="''${HOME}/.store-path-pre-build"

          case ''${1} in
            setup)
              if [[ -n ''${CACHIX_AUTH_TOKEN:-} ]]; then
                  echo Using CACHIX_AUTH_TOKEN
                  cachix --verbose authtoken ''${CACHIX_AUTH_TOKEN}
              fi
              cachix --verbose use -m user-nixconf ''${CACHIX_NAME:?}
              nix path-info --all > "''${PATHS_PREBUILD_FILE}"
              ;;

            push)
              comm -13 <(sort "''${PATHS_PREBUILD_FILE}" | grep -v '\.drv$') <(nix path-info --all | grep -v '\.drv$' | sort) | cachix --verbose push ''${CACHIX_NAME:?}
              ;;
          esac
        '';

      scripts-repo-flake-update = pkgs.writeShellScriptBin "scripts-repo-flake-update" ''
        set -xeuo pipefail
        trap "cd $PWD" EXIT

        export VERSIONS_DIR="versions/''${1}"

        (
          cd "$VERSIONS_DIR"
          nix flake update --refresh
        )

        if [[ $(git diff -- "$VERSIONS_DIR"/flake.lock | grep -E '^[+-]\s+"' | grep -v lastModified --count) -eq 0 ]]; then
          echo got no actual source changes, reverting modifications..
          git checkout $VERSIONS_DIR/flake.lock
        else
          git add "$VERSIONS_DIR"/flake.lock
        fi

        # Want to update the root flake.lock if we're updating the version that is currently the default.
        if grep -qE "versions\.url = \".+\?dir=''${VERSIONS_DIR}\"" flake.nix; then
          nix flake update --refresh versions

          nix flake update --refresh versions/holochain
          nix flake update --refresh versions/lair
          nix flake update --refresh versions/launcher
          nix flake update --refresh versions/scaffolding
        fi

        if [[ $(git diff -- flake.lock | grep -E '^[+-]\s+"' | grep -v lastModified --count) -eq 0 ]]; then
          echo got no actual source changes in the toplevel flake.lock, reverting modifications..
          git checkout flake.lock
        else
          git add flake.lock
        fi

        set +e
        git diff --staged --quiet
        ANY_CHANGED=$?
        set -e
        if [[ "$ANY_CHANGED" -eq 1 ]]; then
          echo committing changes..
          git commit -m "chore(flakes): update $VERSIONS_DIR"
        fi
      '';

      scripts-release-automation-check-and-bump = pkgs.writeShellScriptBin "scripts-release-automation-check-and-bump" ''
        set -xeuo pipefail

        export WORKSPACE_PATH=''${1}

        ${self'.packages.release-automation}/bin/release-automation \
            --workspace-path=''${WORKSPACE_PATH} \
            --log-level=debug \
            crate detect-missing-releaseheadings

        ${self'.packages.release-automation}/bin/release-automation \
          --workspace-path=''${WORKSPACE_PATH} \
          --log-level=debug \
          --match-filter="^(holochain|holochain_cli|hcterm|hc_service_check)$" \
          release \
            --force-tag-creation \
            --force-branch-creation \
            --additional-manifests="crates/test_utils/wasm/wasm_workspace/Cargo.toml" \
            --allowed-semver-increment-modes="!pre_minor dev" \
            --steps=CreateReleaseBranch,BumpReleaseVersions

        ${self'.packages.release-automation}/bin/release-automation \
            --workspace-path=''${WORKSPACE_PATH} \
            --log-level=debug \
            release \
              --dry-run \
              --steps=PublishToCratesIo
      '';

      scripts-ci-generate-readmes =
        let
          pathPrefix = lib.makeBinPath [
            self'.packages.cargo-rdme
            pkgs.cargo
            pkgs.rustc
            pkgs.gitFull
          ];

          crates = [
            "hdi"
            "hdk"
            "holochain_keystore"
            "holochain_state"
          ];
        in
        pkgs.writeShellScriptBin "scripts-ci-generate-readmes" ''
          set -xeuo pipefail

          export PATH=${pathPrefix}:$PATH

          crates_to_document=(${builtins.concatStringsSep " " crates})

          for crate in "''${crates_to_document[@]}"; do
            echo 'generating README for crate' "$crate"
            cargo-rdme -w $crate --intralinks-strip-links --force
          done

          # have any READMEs been updated?
          changed_readmes=$(git diff --exit-code --name-only '**README.md' || :)
          if [[ -n "$changed_readmes" ]]; then
            echo 'READMEs have been updated, committing changes'
            ${../../scripts/ci-git-config.sh}
            git commit -m "docs(crate-level): generate readmes from doc comments" $changed_readmes
          fi
        '';

      scripts-cargo-regen-lockfiles = pkgs.writeShellApplication {
        name = "scripts-cargo-regen-lockfiles";
        runtimeInputs = [
          pkgs.cargo
        ];
        text = ''
          set -xeu -o pipefail

          cargo fetch --locked
          cargo generate-lockfile --offline --manifest-path=crates/test_utils/wasm/wasm_workspace/Cargo.toml
          cargo generate-lockfile --offline
          cargo generate-lockfile --offline --manifest-path=crates/test_utils/wasm/wasm_workspace/Cargo.toml
        '';
      };


      scripts-cargo-update =
        pkgs.writeShellApplication {
          name = "scripts-cargo-update";
          runtimeInputs = [
            pkgs.cargo
          ];
          text = ''
            set -xeu -o pipefail

            # Update the Holochain project Cargo.lock
            cargo update --manifest-path Cargo.toml
            # Update the WASM workspace Cargo.lock
            cargo update --manifest-path crates/test_utils/wasm/wasm_workspace/Cargo.toml
          '';
        };
    };

  };
}



================================================
File: nix/modules/sources.nix
================================================
{ self, lib, ... }: {
  options.sources = lib.mkOption { type = lib.types.raw; };
  config.sources =
    let
      sourcesJSON =
        builtins.fromJSON (builtins.readFile (self + /nix/sources.json));

      holonix = self + /holonix;

      holochain-nixpkgs = builtins.fetchTarball {
        inherit (sourcesJSON.holochain-nixpkgs) url sha256;
      };

      holochainNixpkgsSourcesJSON =
        builtins.fromJSON (
          builtins.readFile
            ("${holochain-nixpkgs}/nix/nvfetcher/_sources/generated.json")
        );

      nixpkgs = builtins.fetchTarball {
        inherit (holochainNixpkgsSourcesJSON.nixpkgs.src) url sha256;
      };
    in
    {
      inherit
        holonix
        holochain-nixpkgs
        nixpkgs
        ;
    };
}



================================================
File: nix/modules/srcCleaned.nix
================================================
{ self, lib, inputs, config, ... }@flake:

let
  # Filter out files or folders with this infix
  matchInfix = infix:
    root: path: type:
      lib.strings.hasInfix infix path;

  includeCommon =
    [ "crates" "Cargo.toml" "Cargo.lock" "rustfmt.toml" "nextest.toml" ];
  excludeCommon = [
    (inputs.nix-filter.lib.matchExt "md")
    (matchInfix "LICENSE")
    (inputs.nix-filter.lib.matchName ".gitignore")
  ];

in
{
  options.srcCleanedRepo = lib.mkOption { type = lib.types.raw; };
  config.srcCleanedRepo = inputs.nix-filter.lib {
    include = includeCommon;
    exclude = excludeCommon;
    root = self;
  };

  options.srcCleanedHolochain = lib.mkOption { type = lib.types.raw; };
  config.srcCleanedHolochain = inputs.nix-filter.lib {
    include = includeCommon;
    exclude = excludeCommon;
    root = flake.config.reconciledInputs.holochain;
  };

  options.srcCleanedReleaseAutomationRepo = lib.mkOption { type = lib.types.raw; };
  config.srcCleanedReleaseAutomationRepo = inputs.nix-filter.lib {
    include = includeCommon ++ [
      "src"
      "examples"
    ];
    exclude = excludeCommon ++
      [
        "src/lib/tests"
        "src/lib/crate_selection/tests"
      ];
    root = "${self}/crates/release-automation";
  };

  options.srcCleanedReleaseAutomationWithTestsRepo = lib.mkOption { type = lib.types.raw; };
  config.srcCleanedReleaseAutomationWithTestsRepo = inputs.nix-filter.lib {
    include = includeCommon ++ [
      "src"
      "examples"
    ];
    exclude = excludeCommon;
    root = "${self}/crates/release-automation";
  };

  options.srcCleanedHolonix = lib.mkOption { type = lib.types.raw; };
  config.srcCleanedHolonix = inputs.nix-filter.lib {
    include = [
      "holonix"
    ];
    exclude = excludeCommon;
    root = self;
  };
}



================================================
File: nix/modules/writers.nix
================================================
{
  perSystem =
    { config
    , lib
    , pkgs
    , ...
    }: {
      options.writers = {
        writePureShellScript =
          lib.mkOption { type = lib.types.functionTo lib.types.anything; };
        writePureShellScriptBin =
          lib.mkOption { type = lib.types.functionTo lib.types.anything; };
      };

      /*
        create a script that runs in a `pure` environment, in the sense that:
        - PATH only contains exactly the packages passed via the PATH arg
        - NIX_PATH is set to the path of the current `pkgs`
        - TMPDIR is set up and cleaned up even if the script fails
        - all environment variables are unset, except:
        - the ones listed in `keepVars` below
        - ones listed via the KEEP_VARS variable
        - the behavior is similar to `nix-shell --pure`
      */
      config.writers =
        let
          mkScript = PATH: script: ''
            #!${pkgs.bash}/bin/bash
            set -Eeuo pipefail

            export PATH="${lib.makeBinPath PATH}"
            export NIX_PATH=nixpkgs=${pkgs.path}

            export TMPDIR=$(${pkgs.coreutils}/bin/mktemp -d)

            trap "${pkgs.coreutils}/bin/chmod -R +w '$TMPDIR'; ${pkgs.coreutils}/bin/rm -rf '$TMPDIR'" EXIT

            if [ -z "''${IMPURE:-}" ]; then
              ${cleanEnv}
            fi

            ${script}
          '';

          # list taken from nix source: src/nix-build/nix-build.cc
          keepVars = lib.concatStringsSep " " [
            "HOME"
            "XDG_RUNTIME_DIR"
            "USER"
            "LOGNAME"
            "DISPLAY"
            "WAYLAND_DISPLAY"
            "WAYLAND_SOCKET"
            "PATH"
            "TERM"
            "IN_NIX_SHELL"
            "NIX_SHELL_PRESERVE_PROMPT"
            "TZ"
            "PAGER"
            "NIX_BUILD_SHELL"
            "SHLVL"
            "http_proxy"
            "https_proxy"
            "ftp_proxy"
            "all_proxy"
            "no_proxy"

            # We want to keep out own variables as well
            "IMPURE"
            "KEEP_VARS"
            "NIX_PATH"
            "TMPDIR"
          ];

          cleanEnv = ''

        KEEP_VARS="''${KEEP_VARS:-}"

        unsetVars=$(
          ${pkgs.coreutils}/bin/comm \
            <(${pkgs.gawk}/bin/awk 'BEGIN{for(v in ENVIRON) print v}' | ${pkgs.coreutils}/bin/cut -d = -f 1 | ${pkgs.coreutils}/bin/sort) \
            <(echo "${keepVars} $KEEP_VARS" | ${pkgs.coreutils}/bin/tr " " "\n" | ${pkgs.coreutils}/bin/sort) \
            -2 \
            -3
        )

        unset $unsetVars
      '';
        in
        {
          writePureShellScript = PATH: script:
            pkgs.writeScript "script.sh" (mkScript PATH script);

          writePureShellScriptBin = binName: PATH: script:
            pkgs.writeScriptBin binName (mkScript PATH script);
        };
    };
}



================================================
File: nix/pkgs/core.nix
================================================
{ stdenv
, callPackage
, lib
, writeShellScriptBin
, crate2nix
, holonix
, holonixPath
, hcToplevelDir
, releaseAutomation
}:

rec {
  hcTest = writeShellScriptBin "hc-test" ''
    set -euxo pipefail
    export RUST_BACKTRACE=1

    hc-test-standard
    hc-test-slow
    hc-test-wasm
  '';

  hcStandardTests = writeShellScriptBin "hc-test-standard" ''
    set -euxo pipefail
    export RUST_BACKTRACE=1

    # run all the non-glacial cargo tests
    cargo build --features 'build' -p holochain_wasm_test_utils
    cargo test ''${CARGO_TEST_ARGS:-} --workspace --features slow_tests,chc,test_utils,build_wasms,sqlite-encrypted --lib --tests --profile fast-test ''${1-} -- --nocapture
  '';

  hcStandardTestsNextest = writeShellScriptBin "hc-test-standard-nextest" ''
    set -euxo pipefail
    export RUST_BACKTRACE=1

    # run all the cargo tests
    cargo build --features 'build' -p holochain_wasm_test_utils
    cargo nextest ''${CARGO_NEXTEST_ARGS:-run} ${
      import ../../.config/nextest-args.nix
    } ''${1-}
  '';

  hcWasmTests = writeShellScriptBin "hc-test-wasm" ''
    set -euxo pipefail
    export RUST_BACKTRACE=1

    # run all the wasm tests (within wasm) with the conductor mocked
    cargo test ''${CARGO_TEST_ARGS:-} --lib --manifest-path=crates/test_utils/wasm/wasm_workspace/Cargo.toml --all-features -- --nocapture
  '';

  hcStaticChecks =
    let
      pathPrefix = lib.makeBinPath (builtins.attrValues {
        inherit (holonix.pkgs) hnRustClippy hnRustFmtCheck hnRustFmtFmt;
      });
    in
    writeShellScriptBin "hc-static-checks" ''
      export PATH=${pathPrefix}:$PATH

      set -euxo pipefail
      export RUST_BACKTRACE=1
      hn-rust-fmt-check
      hn-rust-clippy
    '';

  hcMergeTest = writeShellScriptBin "hc-merge-test" ''
    set -euxo pipefail
    export RUST_BACKTRACE=1
    hc-static-checks
    hc-test
  '';

  hcReleaseTest = writeShellScriptBin "hc-test-release" ''
    set -euxo pipefail
    export RUST_BACKTRACE=1

    ${hcReleaseAutomationTest}/bin/hc-test-release-automation
    ${hcReleaseAutomationTestRepo}/bin/hc-test-release-automation-repo
  '';

  hcSpeedTest = writeShellScriptBin "hc-speed-test" ''
    cargo test speed_test_prep --test speed_tests --release --manifest-path=crates/holochain/Cargo.toml --features "build_wasms" -- --ignored
    cargo test speed_test_all --test speed_tests --release --manifest-path=crates/holochain/Cargo.toml --features "build_wasms" -- --ignored --nocapture
  '';

  hcFlakyTest = writeShellScriptBin "hc-flaky-test" ''
    set -euxo pipefail
    export RUST_BACKTRACE=1

    for i in {0..100}
    do
      cargo test --manifest-path=crates/holochain/Cargo.toml --features slow_tests,chc,build_wasms -- --nocapture
    done
    for i in {0..100}
    do
      cargo test --workspace --exclude holochain -- --nocapture
    done
    for i in {0..100}
    do
      cargo test --lib --manifest-path=crates/test_utils/wasm/wasm_workspace/Cargo.toml --all-features -- --nocapture
    done
  '';

  hcDoctor = writeShellScriptBin "hc-doctor" ''
    echo "### holochain doctor ###"
    echo

    echo "if you have installed holochain directly using hc-install it should be in the cargo root"
    echo "if that is what you want it may be worth running hc-install to 'refresh' it as HEAD moves quickly"
    echo
    echo "if you are using the more stable binaries provided by holonix it should be in /nix/store/../bin"
    echo

    echo "cargo install root:"
    echo $CARGO_INSTALL_ROOT
    echo

    echo "holochain binary installation:"
    command -v holochain
    echo

    echo "hc binary installation"
    command -v hc
    echo
  '';

  hcBench = writeShellScriptBin "hc-bench" ''
    cargo bench --bench bench
  '';

  hcFmtAll = writeShellScriptBin "hc-fmt-all" ''
    fd Cargo.toml crates | xargs -L 1 cargo fmt --manifest-path
  '';

  hcBenchGithub = writeShellScriptBin "hc-bench-github" ''
    set -x

    # the first arg is the authentication token for github
    # @todo this is only required because the repo is currently private
    token=''${1}

    # set the target dir to somewhere it is less likely to be accidentally deleted
    CARGO_TARGET_DIR=$BENCH_OUTPUT_DIR

    # run benchmarks from a github archive based on any ref github supports
    # @param ref: the github ref to benchmark
    function bench {

      ## vars
      ref=$1
      dir="$TMP/$ref"
      tarball="$dir/tarball.tar.gz"

      ## process

      ### fresh start
      mkdir -p $dir
      rm -f $dir/$tarball

      ### fetch code to bench
      curl -L --cacert $SSL_CERT_FILE -H "Authorization: token $token" "https://github.com/holochain/holochain/archive/$ref.tar.gz" > $tarball
      tar -zxvf $tarball -C $dir

      ### bench code
      cd $dir/holochain-$ref
      cargo bench --bench bench -- --save-baseline $ref

    }

    # load an existing report and push it as a comment to github
    function add_comment_to_commit {
      ## convert the report to POST-friendly json and push to github comment API
      jq \
      -n \
      --arg report \
      "\`\`\`$( cargo bench --bench bench -- --baseline $1 --load-baseline $2 )\`\`\`" \
      '{body: $report}' \
      | curl \
      -L \
      --cacert $SSL_CERT_FILE \
      -H "Authorization: token $token" \
      -X POST \
      -H "Accept: application/vnd.github.v3+json" \
      https://api.github.com/repos/holochain/holochain/commits/$2/comments \
      -d@-
    }

    commit=''${2}
    bench $commit

    # @todo make this flexible based on e.g. the PR base on github
    compare=develop
    bench $compare
    add_comment_to_commit $compare $commit
  '';
} // (if stdenv.isLinux then {
  hcCoverageTest = writeShellScriptBin "hc-coverage-test" ''
    set -euxo pipefail

    # kcov does not work with the global /holochain-rust/target
    mkdir -p target

    # actually kcov does not work with workspace target either
    # we need to use targets in each crate - but that is slow
    # use symlinks so we don't have to recompile deps over and over
    for i in $(find crates -maxdepth 1 -mindepth 1 -type d | sort); do
      # skip some crates that aren't ready yet
      case "$i" in
        "crates/dpki" | "crates/keystore" )
          continue
          ;;
      esac

      # delete all other test binaries so they don't get run multiple times
      rm -rf $(find target/debug -maxdepth 1 -mindepth 1 -type f)

      echo "-------"
      echo "coverage for '$i'"
      echo "-------"

      # ensure we use the shared target dir
      export CARGO_TARGET_DIR=$(readlink -f ./target)

      # cd into crate dir
      # create temporary local target symlink
      # build the test binaries
      # run the code coverage
      # remove the temporary local target symlink
      (
        cd $i && \
        rm -rf target && \
        ln -s ../../target target && \
        cargo test --no-run && \
        cargo make coverage-kcov && \
        rm -rf target
      )
    done

    # we cannot do codecov.io right now with the private repo
    # so we'll just open the coverage report in a browser
    xdg-open target/coverage/index.html
  '';
} else
  { })



================================================
File: nix/pkgs/default.nix
================================================
{ callPackage
, writeShellScriptBin
, hcToplevelDir
, nixEnvPrefixEval
, jq
,
}:
let
  hcRunCrate = writeShellScriptBin "hc-run-crate" ''
    set -x
    ${nixEnvPrefixEval}

    crate=''${1:?The first argument needs to define the crate name}
    shift

    binary=$(cargo build \
      --locked \
      --target-dir=''${NIX_ENV_PREFIX:-?}/target \
      --manifest-path=${hcToplevelDir}/crates/$crate/Cargo.toml \
      --bin=$crate --message-format=json | \
        ${jq}/bin/jq \
          --slurp \
          --raw-output \
          'map(select(.executable != null))[0].executable' \
      )

    $binary $@
  '';

  hcCrateBinaryPath = writeShellScriptBin "hc-crate-binary-path" ''
    set -x
    ${nixEnvPrefixEval}

    crate=''${1:?The first argument needs to define the crate name}

    echo $(cargo build \
      --locked \
      --target-dir=''${NIX_ENV_PREFIX:-?}/target \
      --manifest-path=${hcToplevelDir}/crates/$crate/Cargo.toml \
      --bin=$crate --message-format=json | \
        ${jq}/bin/jq \
          --slurp \
          --raw-output \
          'map(select(.executable != null))[0].executable' \
      )
  '';

  mkHolochainBinaryScript = crate:
    writeShellScriptBin (builtins.replaceStrings [ "_" ] [ "-" ] crate) ''
      exec ${hcRunCrate}/bin/hc-run-crate ${crate} $@
    '';

  hcReleaseAutomation = writeShellScriptBin "hc-ra" ''
    exec ${hcRunCrate}/bin/hc-run-crate "release-automation" $@
  '';

  ci = callPackage ./ci.nix { };
  core =
    callPackage ./core.nix
      {
        inherit hcToplevelDir;
        releaseAutomation = "${hcReleaseAutomation}/bin/hc-ra";
      }
    // {
      inherit hcReleaseAutomation;
    };
  happ = {
    holochain = mkHolochainBinaryScript "holochain";
    hc = mkHolochainBinaryScript "hc";
  };

  all = {
    inherit
      core
      ci
      happ
      ;
  };
in
builtins.mapAttrs
  (
    k: v:
    builtins.removeAttrs v [ "override" "overrideDerivation" ]
  )
  all



================================================
File: nix/release/default.nix
================================================
{ pkgs, config }:
{
  buildInputs = [ ]

    ++ (pkgs.callPackage ./hook {
    config = config;
  }).buildInputs
  ;
}



================================================
File: nix/release/hook/default.nix
================================================
{ pkgs, config }:
{
  buildInputs = [ ]

    ++ (pkgs.callPackage ./version {
    config = config;
  }).buildInputs
  ;
}



================================================
File: nix/release/hook/version/default.nix
================================================
{ pkgs, config }:
let
  name = "hcp-release-hook-version";

  script = pkgs.writeShellScriptBin name ''
    echo "bumping holochain_2020 dependency versions to ${config.release.version.current} in all Cargo.toml"
    find . \
     -name "Cargo.toml" \
     -not -path "**/target/**" \
     -not -path "**/.git/**" \
     -not -path "**/.cargo/**" | xargs -I {} \
     sed -i 's/^holochain_2020 = { version = "=[0-9]\+.[0-9]\+.[0-9]\+\(-alpha[0-9]\+\)\?"/holochain_2020 = { version = "=${config.release.version.current}"/g' {}
  '';
in
{
  buildInputs = [ script ];
}



================================================
File: scripts/cargo-all.sh
================================================

if [ $# -gt 1 ]
then
    cargo $1 --manifest-path Cargo.toml ${@:2}
    cargo $1 --manifest-path crates/release-automation/Cargo.toml ${@:2}
    cargo $1 --manifest-path crates/test_utils/wasm/wasm_workspace/Cargo.toml ${@:2}
else
    cargo $1 --manifest-path Cargo.toml
    cargo $1 --manifest-path crates/release-automation/Cargo.toml
    cargo $1 --manifest-path crates/test_utils/wasm/wasm_workspace/Cargo.toml
fi


================================================
File: scripts/ci-gh-release.sh
================================================
#!/usr/bin/env bash
set -eux

# a positive condition means the current holochain version has already been released, hence this release doesn't contain holochain
if gh release view "${LATEST_HOLOCHAIN_RELEASE_TAG}"; then
  export RELEASE_TAG=${RELEASE_BRANCH}
  export IS_HOLOCHAIN_RELEASE="false"
else
  export RELEASE_TAG=${LATEST_HOLOCHAIN_RELEASE_TAG}
  export IS_HOLOCHAIN_RELEASE="true"
fi

# this configuers a single, hardcoded branch to publish "latest" release's
# this makes the release stand out on the right side in the github repository landing page
if [[ "${HOLOCHAIN_TARGET_BRANCH}" == "main-0.1" && "${IS_HOLOCHAIN_RELEASE}" == "true" ]]; then
  export IS_LATEST="true"
else
  export IS_LATEST="false"
fi

# simply check for the delimeter between the version number and a pre-release suffix
if [[ "${LATEST_HOLOCHAIN_RELEASE_VERSION}" == *"-"* ]]; then
  export IS_PRE_RELEASE="true"
else
  export IS_PRE_RELEASE="false"
fi

cmd=(
   gh api
   --method POST
   /repos/holochain/holochain/releases
   -H "Accept: application/vnd.github+json"
   -f tag_name="${RELEASE_TAG}"
   -f target_commitish="${HOLOCHAIN_TARGET_BRANCH}"
   -f name="holochain ${LATEST_HOLOCHAIN_RELEASE_VERSION} (${RELEASE_BRANCH#*-})"
   -f body="***Please read [this release's top-level CHANGELOG](https://github.com/holochain/holochain/blob/${HOLOCHAIN_TARGET_BRANCH}/CHANGELOG.md#$(sed -E 's/(release-|\.)//g' <<<"${RELEASE_BRANCH}")) to see the full list of crates that were released together.***" \
   -F draft=false
   -F generate_release_notes=false
   -F prerelease="${IS_PRE_RELEASE}"
   -f make_latest="${IS_LATEST}"
)

if [[ "${DRY_RUN:-true}" == "false" ]]; then
    "${cmd[@]}"
else
    echo "${cmd[@]}"
fi



================================================
File: scripts/ci-git-config.sh
================================================
#!/bin/sh
set -xe

if ! (
        (git config --global user.email && git config --global user.name) ||
        (git config --local user.email && git config --local user.name)
    ); then
    echo setting git config..
    git config --local user.email "hra+gh@holochain.org"
    git config --local user.name "Holochain Release Automation"
fi


================================================
File: scripts/format-toml.sh
================================================
#!/usr/bin/env nix-shell
#! nix-shell -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/nixos-23.11.tar.gz -i bash --pure --packages taplo

# Usage to format: ./scripts/format-toml.sh
# Usage to check: ./scripts/format-toml.sh --check

set -eux

EXTRA_ARG=${1:-}

taplo format "$EXTRA_ARG" ./*.toml
taplo format "$EXTRA_ARG" ./crates/**/*.toml



================================================
File: scripts/local-static.sh
================================================
#!/bin/sh

name="./scripts/$(basename $0)"
if test ! -f "$name"; then
  echo "ERROR: run from root holochain directory: '$name'"
  exit 127
fi

cargo fmt --check && cargo clippy -- $(xargs <.config/clippy-args.nix)



================================================
File: scripts/local-test.sh
================================================
#!/bin/sh

name="./scripts/$(basename $0)"
if test ! -f "$name"; then
  echo "ERROR: run from root holochain directory: '$name'"
  exit 127
fi

cmd="cargo nextest --config-file .config/nextest.toml run $(xargs <.config/test-args.nix) $(xargs <.config/nextest-args.nix)"
$cmd



================================================
File: scripts/local-tx5-test.sh
================================================
#!/bin/sh

name="./scripts/$(basename $0)"
if test ! -f "$name"; then
  echo "ERROR: run from root holochain directory: '$name'"
  exit 127
fi

cmd="cargo nextest --config-file .config/nextest.toml run $(xargs <.config/test-args.nix) $(xargs <.config/nextest-args.nix) --features tx5"
$cmd



================================================
File: scripts/nix_path.sh
================================================
#!/bin/sh
nix eval --impure --raw --expr '(import (import ./nix/sources.nix {}).holonix {}).pkgs.path'



================================================
File: scripts/test-hc-launch.sh
================================================
#!/usr/bin/env bash

# TODO: build the hc-launch-test.webhapp file from source
echo pass | nix develop .#holonix --command hc-launch --piped -n1 ./hc-launch-test.webhapp network mdns



================================================
File: scripts/update-holonix-version.sh
================================================
#!/usr/bin/env bash

set -euox pipefail

VERSION_STR=$1

cd "$(git rev-parse --show-toplevel)"

if [ ! -f "./versions/$VERSION_STR/flake.nix" ]; then
    echo "File not found: ./versions/$VERSION_STR/flake.nix"
    exit 1
fi

SEP_COUNT=$(echo "$VERSION_STR" | tr -d -c '_' | awk '{ print length; }')

SEARCH_PATTERN="no-tag"
if [ "$SEP_COUNT" == "1" ]; then
    # Matched format 0_X
    SEARCH_PATTERN=$(echo "$VERSION_STR" | awk -F _ 'BEGIN { OFS="" } {print "^holochain-", $1, ".", $2, ".[0-9]+$"}')
elif [ "$SEP_COUNT" == "2" ] && [[ "$VERSION_STR" =~ rc$ ]]; then
    # Matched format 0_X_rc
  SEARCH_PATTERN=$(echo "$VERSION_STR" | awk -F _ 'BEGIN { OFS="" } {print "^holochain-", $1, ".", $2, ".[0-9]+-rc.[0-9]+$"}')
elif [ "$VERSION_STR" == "weekly" ]; then
  # Special case, weekly tracks the latest pre-release version
  SEARCH_PATTERN="^holochain-[0-9]+.[0-9]+.[0-9]+-dev.[0-9]+$"
else
    echo "Invalid version format: $VERSION_STR"
    exit 1
fi

echo "Looking for tags matching pattern: $SEARCH_PATTERN"

LATEST_MATCHING_TAG=$(git tag --list --sort=version:refname | { grep -E "$SEARCH_PATTERN" || printf ""; } | tail -n 1)

if [ -z "$LATEST_MATCHING_TAG" ]; then
    echo "No matching tag found for: $VERSION_STR"
    exit 1
fi

echo "Latest matching tag: $LATEST_MATCHING_TAG"

sed --in-place "s#holochain/holochain/holochain-.*\"#holochain/holochain/$LATEST_MATCHING_TAG\"#" "./versions/$VERSION_STR/flake.nix"



================================================
File: versions/0_1/flake.lock
================================================
{
  "nodes": {
    "holochain": {
      "flake": false,
      "locked": {
        "lastModified": 1706624893,
        "narHash": "sha256-J/MfVeLO9K4XXNEt1yqu7NdTA3REX014NZg0TjD5IHU=",
        "owner": "holochain",
        "repo": "holochain",
        "rev": "48e239689b4e6a3c0b8b6d9c09608cfabe2b0ab5",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.1.8",
        "repo": "holochain",
        "type": "github"
      }
    },
    "lair": {
      "flake": false,
      "locked": {
        "lastModified": 1706550351,
        "narHash": "sha256-psVjtb+zj0pZnHTj1xNP2pGBd5Ua1cSwdOAdYdUe3yQ=",
        "owner": "holochain",
        "repo": "lair",
        "rev": "b11e65eff11c8ac3bf938607946f5c7201298a65",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "lair_keystore-v0.4.2",
        "repo": "lair",
        "type": "github"
      }
    },
    "launcher": {
      "flake": false,
      "locked": {
        "lastModified": 1677270906,
        "narHash": "sha256-/xT//6nqhjpKLMMv41JE0W3H5sE9jKMr8Dedr88D4N8=",
        "owner": "holochain",
        "repo": "launcher",
        "rev": "1ad188a43900c139e52df10a21e3722f41dfb967",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.1",
        "repo": "launcher",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "holochain": "holochain",
        "lair": "lair",
        "launcher": "launcher",
        "scaffolding": "scaffolding"
      }
    },
    "scaffolding": {
      "flake": false,
      "locked": {
        "lastModified": 1708195673,
        "narHash": "sha256-laG52M49vVUUTiB0B75MOz4rk4N6K7lNFc/CBg8R2gA=",
        "owner": "holochain",
        "repo": "scaffolding",
        "rev": "31d0a1189b282058ec5da29968cc53aaca71f0e5",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.1",
        "repo": "scaffolding",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}



================================================
File: versions/0_1/flake.nix
================================================
{
  inputs =
    {
      holochain = {
        url = "github:holochain/holochain/holochain-0.1.8";
        flake = false;
      };

      lair = {
        url = "github:holochain/lair/lair_keystore-v0.4.2";
        flake = false;
      };

      # holochain_cli_launch
      launcher = {
        url = "github:holochain/hc-launch/holochain-0.1";
        flake = false;
      };

      # holochain_scaffolding_cli
      scaffolding = {
        url = "github:holochain/scaffolding/holochain-0.1";
        flake = false;
      };
    };

  outputs = { ... }: {
    rustVersion = "1.71.1";
  };
}



================================================
File: versions/0_2/flake.lock
================================================
{
  "nodes": {
    "holochain": {
      "flake": false,
      "locked": {
        "lastModified": 1714468636,
        "narHash": "sha256-3pdzVmU2uKh7ikcD1K2/YbbYiZGVvWiR46mkdYx3ZbA=",
        "owner": "holochain",
        "repo": "holochain",
        "rev": "5b5c177dab35582b6190209762fc57c20d8f157a",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.2.8",
        "repo": "holochain",
        "type": "github"
      }
    },
    "lair": {
      "flake": false,
      "locked": {
        "lastModified": 1706550351,
        "narHash": "sha256-psVjtb+zj0pZnHTj1xNP2pGBd5Ua1cSwdOAdYdUe3yQ=",
        "owner": "holochain",
        "repo": "lair",
        "rev": "b11e65eff11c8ac3bf938607946f5c7201298a65",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "lair_keystore-v0.4.2",
        "repo": "lair",
        "type": "github"
      }
    },
    "launcher": {
      "flake": false,
      "locked": {
        "lastModified": 1684183666,
        "narHash": "sha256-rOE/W/BBYyZKOyypKb8X9Vpc4ty1TNRoI/fV5+01JPw=",
        "owner": "holochain",
        "repo": "hc-launch",
        "rev": "75ecdd0aa191ed830cc209a984a6030e656042ff",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.2",
        "repo": "hc-launch",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "holochain": "holochain",
        "lair": "lair",
        "launcher": "launcher",
        "scaffolding": "scaffolding"
      }
    },
    "scaffolding": {
      "flake": false,
      "locked": {
        "lastModified": 1718795177,
        "narHash": "sha256-TES8dHfS/Y5j5UwcfAoDGnqkXgITQlmIsPWa/SZimio=",
        "owner": "holochain",
        "repo": "scaffolding",
        "rev": "c6acd6663c88fcc824f0682d881071e5d3a7ebd2",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.2",
        "repo": "scaffolding",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}



================================================
File: versions/0_2/flake.nix
================================================
{
  inputs =
    {
      holochain = {
        url = "github:holochain/holochain/holochain-0.2.8";
        flake = false;
      };

      lair = {
        url = "github:holochain/lair/lair_keystore-v0.4.2";
        flake = false;
      };

      # holochain_cli_launch
      launcher = {
        url = "github:holochain/hc-launch/holochain-0.2";
        flake = false;
      };

      # holochain_scaffolding_cli
      scaffolding = {
        url = "github:holochain/scaffolding/holochain-0.2";
        flake = false;
      };
    };

  outputs = { ... }: {
    rustVersion = "1.77.2";
  };
}



================================================
File: versions/0_2_rc/flake.lock
================================================
{
  "nodes": {
    "holochain": {
      "flake": false,
      "locked": {
        "lastModified": 1714045730,
        "narHash": "sha256-nTBFYswsMQfRNJgTq67rakdeLXYiEXskDcWa/98VYr8=",
        "owner": "holochain",
        "repo": "holochain",
        "rev": "0958f8cf199746c21bb003b800c49c3eef1a95ed",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.2.8-rc.1",
        "repo": "holochain",
        "type": "github"
      }
    },
    "lair": {
      "flake": false,
      "locked": {
        "lastModified": 1706550351,
        "narHash": "sha256-psVjtb+zj0pZnHTj1xNP2pGBd5Ua1cSwdOAdYdUe3yQ=",
        "owner": "holochain",
        "repo": "lair",
        "rev": "b11e65eff11c8ac3bf938607946f5c7201298a65",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "lair_keystore-v0.4.2",
        "repo": "lair",
        "type": "github"
      }
    },
    "launcher": {
      "flake": false,
      "locked": {
        "lastModified": 1684183666,
        "narHash": "sha256-rOE/W/BBYyZKOyypKb8X9Vpc4ty1TNRoI/fV5+01JPw=",
        "owner": "holochain",
        "repo": "hc-launch",
        "rev": "75ecdd0aa191ed830cc209a984a6030e656042ff",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.2",
        "repo": "hc-launch",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "holochain": "holochain",
        "lair": "lair",
        "launcher": "launcher",
        "scaffolding": "scaffolding"
      }
    },
    "scaffolding": {
      "flake": false,
      "locked": {
        "lastModified": 1718795177,
        "narHash": "sha256-TES8dHfS/Y5j5UwcfAoDGnqkXgITQlmIsPWa/SZimio=",
        "owner": "holochain",
        "repo": "scaffolding",
        "rev": "c6acd6663c88fcc824f0682d881071e5d3a7ebd2",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.2",
        "repo": "scaffolding",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}



================================================
File: versions/0_2_rc/flake.nix
================================================
{
  inputs =
    {
      holochain = {
        url = "github:holochain/holochain/holochain-0.2.8-rc.1";
        flake = false;
      };

      lair = {
        url = "github:holochain/lair/lair_keystore-v0.4.2";
        flake = false;
      };

      # holochain_cli_launch
      launcher = {
        url = "github:holochain/hc-launch/holochain-0.2";
        flake = false;
      };

      # holochain_scaffolding_cli
      scaffolding = {
        url = "github:holochain/scaffolding/holochain-0.2";
        flake = false;
      };
    };

  outputs = { ... }: {
    rustVersion = "1.77.2";
  };
}



================================================
File: versions/0_3/flake.lock
================================================
{
  "nodes": {
    "holochain": {
      "flake": false,
      "locked": {
        "lastModified": 1733145535,
        "narHash": "sha256-fDDdYFkkN1kJA32vVF+HKIbLCZTaMBPmZYah9iqB18E=",
        "owner": "holochain",
        "repo": "holochain",
        "rev": "eba9927d03edd8f27a827f8cc0026916b493c9ea",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.3.6",
        "repo": "holochain",
        "type": "github"
      }
    },
    "lair": {
      "flake": false,
      "locked": {
        "lastModified": 1732711885,
        "narHash": "sha256-kpMkLPHEAarG6MPFdJMQQnTk7YkXk9mFcWLyvbBEUVo=",
        "owner": "holochain",
        "repo": "lair",
        "rev": "6e8938a1d574bd2f8d2f66d1983b58951d700774",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "lair_keystore-v0.4.7",
        "repo": "lair",
        "type": "github"
      }
    },
    "launcher": {
      "flake": false,
      "locked": {
        "lastModified": 1733246036,
        "narHash": "sha256-/UpB+zK5Yqhpoo+6I+4yl7D0DPTmh5gOOzipakjpJAA=",
        "owner": "holochain",
        "repo": "hc-launch",
        "rev": "f6f980801f820f036ef133b6dc31efbef6dd0f99",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.3",
        "repo": "hc-launch",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "holochain": "holochain",
        "lair": "lair",
        "launcher": "launcher",
        "scaffolding": "scaffolding"
      }
    },
    "scaffolding": {
      "flake": false,
      "locked": {
        "lastModified": 1733422567,
        "narHash": "sha256-X7MUZ6wXPcsF6cFC4AK27UiUWpVzhdlrnL+1znfzVfM=",
        "owner": "holochain",
        "repo": "scaffolding",
        "rev": "4d97985a8a93db93c25326a4d75aac0a3ea40a06",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.3",
        "repo": "scaffolding",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}



================================================
File: versions/0_3/flake.nix
================================================
{
  inputs =
    {
      holochain = {
        url = "github:holochain/holochain/holochain-0.3.6";
        flake = false;
      };

      lair = {
        url = "github:holochain/lair/lair_keystore-v0.4.7";
        flake = false;
      };

      # holochain_cli_launch
      launcher = {
        url = "github:holochain/hc-launch/holochain-0.3";
        flake = false;
      };

      # holochain_scaffolding_cli
      scaffolding = {
        url = "github:holochain/scaffolding/holochain-0.3";
        flake = false;
      };
    };

  outputs = { ... }: {
    rustVersion = "1.78.0";
  };
}



================================================
File: versions/0_3_rc/flake.lock
================================================
{
  "nodes": {
    "holochain": {
      "flake": false,
      "locked": {
        "lastModified": 1732817524,
        "narHash": "sha256-Mf/HQ4Rx3CH7Or84gdg1BVT9mg4dt+euI/5i/IVXqsg=",
        "owner": "holochain",
        "repo": "holochain",
        "rev": "3080f45eb6afd92113d5ee8c9be5ef6804309e1f",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.3.6-rc.0",
        "repo": "holochain",
        "type": "github"
      }
    },
    "lair": {
      "flake": false,
      "locked": {
        "lastModified": 1732711885,
        "narHash": "sha256-kpMkLPHEAarG6MPFdJMQQnTk7YkXk9mFcWLyvbBEUVo=",
        "owner": "holochain",
        "repo": "lair",
        "rev": "6e8938a1d574bd2f8d2f66d1983b58951d700774",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "lair_keystore-v0.4.7",
        "repo": "lair",
        "type": "github"
      }
    },
    "launcher": {
      "flake": false,
      "locked": {
        "lastModified": 1732572623,
        "narHash": "sha256-0ngmQAAr47faheMMIlgeYIJWHhHPWyVp4YQ+TBMr984=",
        "owner": "holochain",
        "repo": "hc-launch",
        "rev": "2c35edd0f1b016ab2b44a78060a69cee784d2d1d",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.3",
        "repo": "hc-launch",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "holochain": "holochain",
        "lair": "lair",
        "launcher": "launcher",
        "scaffolding": "scaffolding"
      }
    },
    "scaffolding": {
      "flake": false,
      "locked": {
        "lastModified": 1732649902,
        "narHash": "sha256-mRu+axcvRc2iLTCVa+C2aMJrCeuySlT96sZdORYAkBs=",
        "owner": "holochain",
        "repo": "scaffolding",
        "rev": "07b559f262cd47e9939b87d7af953b3efd4d10c3",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.3",
        "repo": "scaffolding",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}



================================================
File: versions/0_3_rc/flake.nix
================================================
{
  inputs =
    {
      holochain = {
        url = "github:holochain/holochain/holochain-0.3.6-rc.0";
        flake = false;
      };

      lair = {
        url = "github:holochain/lair/lair_keystore-v0.4.7";
        flake = false;
      };

      # holochain_cli_launch
      launcher = {
        url = "github:holochain/hc-launch/holochain-0.3";
        flake = false;
      };

      # holochain_scaffolding_cli
      scaffolding = {
        url = "github:holochain/scaffolding/holochain-0.3";
        flake = false;
      };
    };

  outputs = { ... }: {
    rustVersion = "1.78.0";
  };
}



================================================
File: versions/0_4/flake.lock
================================================
{
  "nodes": {
    "holochain": {
      "flake": false,
      "locked": {
        "lastModified": 1736527914,
        "narHash": "sha256-XB6IX7kZINE37irDne6ArHz5WHvVoUsfBisrfwpZU1Q=",
        "owner": "holochain",
        "repo": "holochain",
        "rev": "1e68775160192a21d4e3e9cfbb4a92121e59a6db",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.4.1-rc.0",
        "repo": "holochain",
        "type": "github"
      }
    },
    "lair": {
      "flake": false,
      "locked": {
        "lastModified": 1732721902,
        "narHash": "sha256-D8sXIpOptaXib5bc6zS7KsGzu4D08jaL8Fx1W/mlADE=",
        "owner": "holochain",
        "repo": "lair",
        "rev": "e82937521ae9b7bdb30c8b0736c13cd4220a0223",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "lair_keystore-v0.5.3",
        "repo": "lair",
        "type": "github"
      }
    },
    "launcher": {
      "flake": false,
      "locked": {
        "lastModified": 1734474851,
        "narHash": "sha256-OtXwvb97Qt+xh/K4+voy60kMnpPZvEoqoe2Bgkn+Nro=",
        "owner": "holochain",
        "repo": "hc-launch",
        "rev": "ca598033225d8ee3df7911c1cbde6004182e84eb",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.4",
        "repo": "hc-launch",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "holochain": "holochain",
        "lair": "lair",
        "launcher": "launcher",
        "scaffolding": "scaffolding"
      }
    },
    "scaffolding": {
      "flake": false,
      "locked": {
        "lastModified": 1736433291,
        "narHash": "sha256-9c8+BgZb0YFZDIyZG9zsJj5of6jks5IfGMjciXwDQms=",
        "owner": "holochain",
        "repo": "scaffolding",
        "rev": "658aaf5c1a60e7531f2aabf9ad80120c7b1d2ac9",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.4",
        "repo": "scaffolding",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}



================================================
File: versions/0_4/flake.nix
================================================
{
  inputs =
    {
      holochain = {
        url = "github:holochain/holochain/holochain-0.4.1-rc.0";
        flake = false;
      };

      lair = {
        url = "github:holochain/lair/lair_keystore-v0.5.3";
        flake = false;
      };

      # holochain_cli_launch
      launcher = {
        url = "github:holochain/hc-launch/holochain-0.4";
        flake = false;
      };

      # holochain_scaffolding_cli
      scaffolding = {
        url = "github:holochain/scaffolding/holochain-0.4";
        flake = false;
      };
    };

  outputs = { ... }: {
    stub = true;
    rustVersion = "1.81.0";
  };
}



================================================
File: versions/0_4_rc/flake.lock
================================================
{
  "nodes": {
    "holochain": {
      "flake": false,
      "locked": {
        "lastModified": 1736527914,
        "narHash": "sha256-XB6IX7kZINE37irDne6ArHz5WHvVoUsfBisrfwpZU1Q=",
        "owner": "holochain",
        "repo": "holochain",
        "rev": "1e68775160192a21d4e3e9cfbb4a92121e59a6db",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.4.1-rc.0",
        "repo": "holochain",
        "type": "github"
      }
    },
    "lair": {
      "flake": false,
      "locked": {
        "lastModified": 1732721902,
        "narHash": "sha256-D8sXIpOptaXib5bc6zS7KsGzu4D08jaL8Fx1W/mlADE=",
        "owner": "holochain",
        "repo": "lair",
        "rev": "e82937521ae9b7bdb30c8b0736c13cd4220a0223",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "lair_keystore-v0.5.3",
        "repo": "lair",
        "type": "github"
      }
    },
    "launcher": {
      "flake": false,
      "locked": {
        "lastModified": 1734474851,
        "narHash": "sha256-OtXwvb97Qt+xh/K4+voy60kMnpPZvEoqoe2Bgkn+Nro=",
        "owner": "holochain",
        "repo": "hc-launch",
        "rev": "ca598033225d8ee3df7911c1cbde6004182e84eb",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.4",
        "repo": "hc-launch",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "holochain": "holochain",
        "lair": "lair",
        "launcher": "launcher",
        "scaffolding": "scaffolding"
      }
    },
    "scaffolding": {
      "flake": false,
      "locked": {
        "lastModified": 1736433291,
        "narHash": "sha256-9c8+BgZb0YFZDIyZG9zsJj5of6jks5IfGMjciXwDQms=",
        "owner": "holochain",
        "repo": "scaffolding",
        "rev": "658aaf5c1a60e7531f2aabf9ad80120c7b1d2ac9",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.4",
        "repo": "scaffolding",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}



================================================
File: versions/0_4_rc/flake.nix
================================================
{
  inputs =
    {
      holochain = {
        url = "github:holochain/holochain/holochain-0.4.1-rc.0";
        flake = false;
      };

      lair = {
        url = "github:holochain/lair/lair_keystore-v0.5.3";
        flake = false;
      };

      # holochain_cli_launch
      launcher = {
        url = "github:holochain/hc-launch/holochain-0.4";
        flake = false;
      };

      # holochain_scaffolding_cli
      scaffolding = {
        url = "github:holochain/scaffolding/holochain-0.4";
        flake = false;
      };
    };

  outputs = { ... }: {
    rustVersion = "1.81.0";
  };
}



================================================
File: versions/weekly/flake.lock
================================================
{
  "nodes": {
    "holochain": {
      "flake": false,
      "locked": {
        "lastModified": 1741007205,
        "narHash": "sha256-t3L5PrXSfq+47cvDQgJMxZ+W7q2UNhkKRiAZuMv//Lo=",
        "owner": "holochain",
        "repo": "holochain",
        "rev": "5025fb1c3969f9284e31511889e88cabed933ffe",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.5.0-dev.21",
        "repo": "holochain",
        "type": "github"
      }
    },
    "lair": {
      "flake": false,
      "locked": {
        "lastModified": 1732721902,
        "narHash": "sha256-D8sXIpOptaXib5bc6zS7KsGzu4D08jaL8Fx1W/mlADE=",
        "owner": "holochain",
        "repo": "lair",
        "rev": "e82937521ae9b7bdb30c8b0736c13cd4220a0223",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "lair_keystore-v0.5.3",
        "repo": "lair",
        "type": "github"
      }
    },
    "launcher": {
      "flake": false,
      "locked": {
        "lastModified": 1727250978,
        "narHash": "sha256-6u/VjFRV4eQQS4H0he7C0n7uNjzBBtkeoyN46jTO0mc=",
        "owner": "holochain",
        "repo": "hc-launch",
        "rev": "92afce654187be5abef67d34df20bd6464524cf3",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-weekly",
        "repo": "hc-launch",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "holochain": "holochain",
        "lair": "lair",
        "launcher": "launcher",
        "scaffolding": "scaffolding"
      }
    },
    "scaffolding": {
      "flake": false,
      "locked": {
        "lastModified": 1738683444,
        "narHash": "sha256-nLCdB9Gs09XLcfXYuLPfAhyuuZylg/011WoAL1fomTE=",
        "owner": "holochain",
        "repo": "scaffolding",
        "rev": "a375473e19be608c5ec8325285ca6d84377ccb49",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-weekly",
        "repo": "scaffolding",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}



================================================
File: versions/weekly/flake.nix
================================================
{
  inputs =
    {
      holochain = {
        url = "github:holochain/holochain/holochain-0.5.0-dev.21";
        flake = false;
      };

      lair = {
        url = "github:holochain/lair/lair_keystore-v0.5.3";
        flake = false;
      };

      # holochain_cli_launch
      launcher = {
        url = "github:holochain/hc-launch/holochain-weekly";
        flake = false;
      };

      # holochain_scaffolding_cli
      scaffolding = {
        url = "github:holochain/scaffolding/holochain-weekly";
        flake = false;
      };
    };

  outputs = { ... }: {
    rustVersion = "1.83.0";
  };
}



================================================
File: .config/nextest-args.nix
================================================
"--cargo-profile fast-test"



================================================
File: .config/nextest.toml
================================================
[test-groups]
holochain-process = { max-threads = 1 }

[profile.default]

# "retries" defines the number of times a test should be retried. If set to a
# non-zero value, tests that succeed on a subsequent attempt will be marked as
# flaky. Can be overridden through the `--retries` option.
retries = 1

# this will display all of fail, retry, slow
# see https://nexte.st/book/other-options.html?highlight=failure-output#--status-level-and---final-status-level
status-level = "skip"

# Treat a test that takes longer than this period as slow, and print a message.
# Given a non-zero positive integer, shutdown the tests when the number periods
# have passed.
slow-timeout = { period = "30s", terminate-after = 4 }

# * "immediate-final": output failures as soon as they happen and at the end of
#   the test run
failure-output = "immediate-final"

# Do not cancel the test run on the first failure.
fail-fast = false

test-threads = 2

[[profile.default.overrides]]
filter = 'package(holochain_cli_sandbox)'
test-group = 'holochain-process'

[profile.ci.junit]
path = "junit.xml"
store-success-output = true
store-failure-output = true



================================================
File: .config/test-args.nix
================================================
"--workspace --features slow_tests,build_wasms,sqlite-encrypted,chc,unstable-dpki,unstable-sharding,unstable-warrants,unstable-functions,unstable-countersigning --lib --tests --bins"



================================================
File: .github/pull_request_template.md
================================================
### Summary



### TODO:
- [ ] CHANGELOGs updated with appropriate info
- [ ] All code changes are reflected in docs, including module-level docs


================================================
File: .github/actions/common-post/action.yml
================================================
name: 'Common Test Teardown Actions'
runs:
  using: 'composite'
  steps:
    - name: cargo sweep file
      shell: bash
      run: cargo sweep --file



================================================
File: .github/actions/common-pre/action.yml
================================================
name: 'Common Test Setup Actions'
runs:
  using: 'composite'
  steps:
    - name: free disk space
      if: matrix.os == 'ubuntu-latest'
      uses: jlumbroso/free-disk-space@main
      with:
        tool-cache: false

    - name: go toolchain
      uses: actions/setup-go@v5
      with:
        go-version: '=1.20.0'

    - name: rust cache
      uses: Swatinem/rust-cache@v2

    - name: cargo sweep stamp
      shell: bash
      run: |
        cargo install cargo-sweep
        cargo sweep --stamp

    - name: install vcpkg packages
      if: matrix.os == 'windows-latest'
      uses: johnwason/vcpkg-action@v6
      id: vcpkg
      with:
        triplet: x64-windows-release
        token: ${{ github.token }}
        manifest-dir: ${{ github.workspace }}/.github/manifest
        github-binarycache: true



================================================
File: .github/actions/extend-space/action.yml
================================================
# Extends disk space on github hosted runners


name: "Extend space"
description: "Teases out as much free space as possible"

runs:
  using: "composite"
  steps:
    - name: Create mountpoint for extended space
      shell: "bash"
      run: sudo mkdir /mnt/extended

    - name: Maximize build space
      uses: easimon/maximize-build-space@v6
      # uses: AdityaGarg8/remove-unwanted-software@v1
      with:
        remove-dotnet: true
        remove-android: true
        remove-haskell: true
        build-mount-path: /mnt/extended
        root-reserve-mb: 512
        swap-size-mb: 1024

    # after we've got the extended space mounted, we can use overlayfs and bind
    # mounts as appropriate to make this space available to all paths that are
    # expected to be written to.
    #
    # for new directories (such as /nix), a bind mount is enough for existing
    # directories (such as $HOME and /tmp), we use an overlay to preserve access
    # to the existing files, while redirecting changes to the extended space.
    - name: Use extended space for /nix, /tmp, /var/tmp, and $HOME
      shell: "bash"
      run: |
        export EXTENDED_PATH=/mnt/extended
        sudo mkdir $EXTENDED_PATH/{tmp,nix,home}

        sudo mkdir $EXTENDED_PATH/tmp/{upper,work}
        sudo mv /tmp{,_lower}
        sudo mkdir /tmp
        sudo mount -t overlay overlay \
          -o lowerdir=/tmp_lower,upperdir=$EXTENDED_PATH/tmp/upper,workdir=$EXTENDED_PATH/tmp/work \
          /tmp
        sudo chown $(id -u):$(id -g) /tmp

        sudo mkdir -p $EXTENDED_PATH/var/tmp/{upper,work}
        sudo mv /var/tmp{,_lower}
        sudo mkdir -p /var/tmp
        sudo mount -t overlay overlay \
          -o lowerdir=/var/tmp_lower,upperdir=$EXTENDED_PATH/var/tmp/upper,workdir=$EXTENDED_PATH/var/tmp/work \
          /var/tmp
        sudo chown $(id -u):$(id -g) /var/tmp

        sudo mkdir /nix
        sudo mount -o bind $EXTENDED_PATH/nix /nix

        sudo mkdir $EXTENDED_PATH/home/{upper,work}
        sudo mv ${HOME} ${HOME}_lower
        sudo mkdir ${HOME}
        sudo chown $(id -u):$(id -g) $HOME
        sudo mount -t overlay overlay \
          -o lowerdir=${HOME}_lower,upperdir=$EXTENDED_PATH/home/upper,workdir=$EXTENDED_PATH/home/work \
          $HOME
        sudo chown $(id -u):$(id -g) $HOME

        df -h



================================================
File: .github/actions/update/action.yml
================================================
# Generic update action to be imported in other workflows.
# Runs a specified update command and creates a pull request.

name: "update"

inputs:
  branch:
    description: ""
    required: true
  update_source:
    description: "passed to ./nix/update.sh"
    required: true
  update_cmd:
    description: "verbatim command to run"
    required: true
  GITHUB_TOKEN:
    description: ""
    required: true
  HRA_GITHUB_TOKEN:
    description: ""
    required: true
  CACHIX_SIGNING_KEY:
    description: ""
    required: true
  CACHIX_AUTH_TOKEN:
    description: ""
    required: true

runs:
  using: "composite"
  steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        ref: ${{ inputs.branch }}
    - name: Install nix
      uses: cachix/install-nix-action@v27
      with:
        install_url: https://releases.nixos.org/nix/nix-2.23.3/install
        extra_nix_config: |
          access-tokens = github.com=${{ inputs.GITHUB_TOKEN }}
    - name: Setup cachix
      uses: cachix/cachix-action@v15
      with:
        name: holochain-ci
        signingKey: "${{ inputs.CACHIX_SIGNING_KEY }}"
        authToken: "${{ inputs.CACHIX_AUTH_TOKEN }}"
    - name: set up git config
      shell: bash
      run: |
        ./scripts/ci-git-config.sh
    - name: update source ${{ inputs.update_source }}
      shell: bash
      run: |
        ${{ inputs.update_cmd }}
      env:
        GITHUB_TOKEN: ${{ inputs.HRA_GITHUB_TOKEN }}
    - name: create pull request
      uses: peter-evans/create-pull-request@v6
      id: cpr1
      with:
        token: ${{ inputs.HRA_GITHUB_TOKEN }}
