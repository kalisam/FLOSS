/// and updating the key.
#[cfg(feature = "unstable-functions")]
pub fn get_agent_key_lineage(
    agent_key: holo_hash::AgentPubKey,
) -> hdi::prelude::ExternResult<Vec<holo_hash::AgentPubKey>> {
    crate::hdk::HDK.with(|h| h.borrow().get_agent_key_lineage(agent_key))
}



================================================
File: crates/hdk/src/capability.rs
================================================
use crate::prelude::*;

/// Create capability claims on the local source chain.
///
/// Wraps the [`create`] HDK function with system type parameters set.
/// This guards against sending application entry data or setting the wrong entry type.
///
/// Capability claims are grant _secrets_ that have been received from someone else.
/// The grant entry is never sent, only the associated secret.
/// The claim should be created on the local source chain so that it can be retrieved for later use.
///
/// Grantees of [`CapGrant`] secrets use [`CapClaim`] entries to save the secret.
///
/// The [`CapClaim`] contains the secret, tag and issuing agent.
/// Only the secret should ever be sent back to the issuing agent, everything else is only for local
/// administering, querying and filtering.
///
/// There is no guarantee that any [`CapClaim`] is currently usable without trying it.
/// The author of the corresponding CapGrant can revoke it at any time or be unreachable on the network.
///
/// Any [`crate::p2p::call_remote`] will return a [`ZomeCallResponse::Unauthorized`] when the grantor considers the
/// secret invalid for the call. The caller is expected to handle this gracefully.
///
/// If the author of the [`CapGrant`] is reachable on the network and has not revoked the grant they will allow any
/// agent with a valid secret and pubkey to [`crate::p2p::call_remote`] externs on the grant author's machine.
///
/// Commits to the grantor's source chain will be signed by the grantor, even if initiated.
/// by a claimant.
/// Delegating agency to grantee claimants is a serious responsibility!
pub fn create_cap_claim(cap_claim_entry: CapClaimEntry) -> ExternResult<ActionHash> {
    create(CreateInput::new(
        EntryDefLocation::CapClaim,
        EntryVisibility::Private,
        Entry::CapClaim(cap_claim_entry),
        ChainTopOrdering::default(),
    ))
}

/// Create a capability grant.
///
/// Wraps the [`create`] HDK function with system type parameters set.
/// This guards against sending application entry data or setting the wrong entry type.
///
/// Capability grants are explicit entries in the local source chain that grant access to functions running in the current conductor.
/// The grant must be sent (e.g. with a [` crate::p2p::call_remote `]) to the grantees so they can commit a claim and then call back with it in the future.
///
/// When an agent wants to expose zome functions to be called remotely by other agents they need to select
/// a security model and probably generate a secret.
///
/// The input needs to evalute to a [`ZomeCallCapGrant`] struct which defines the tag, access and
/// granted zome/function pairs. The access is a [`CapAccess`] enum with variants [`CapAccess::Unrestricted`],
/// [`CapAccess::Transferable`], and [`CapAccess::Assigned`].
///
/// The tag is an arbitrary [`String`] that developers or users can use to categorise and administer
/// grants committed to the chain. The tag should also match the [`CapClaim`] tags committed on the
/// recipient chain when a [`CapGrant`] is committed and shared. The tags are not checked or compared
/// in any security sensitive contexts.
///
/// Provided the grant author agent is reachable on the network:
///
/// - [`CapAccess::Unrestricted`] access means any external agent can call the extern
/// - [`CapAccess::Transferable`] access means any external agent with a valid secret can call the extern
/// - [`CapAccess::Assigned`] access means only explicitly approved agents with a valid secret can call the extern
///
/// The authoring agent itself always has an implicit capability which grants access to its own externs,
/// and needs no special capability grant.
///
/// All logic runs on the author agent's machine against their own source chain:
///
/// - New entries are committed to the author's chain with the author's signature
/// - Signals are emmitted to the author's system and GUI
/// - The author must be online from the perspective of the caller
/// - The author can chain `call_remote` back to the caller or any other agent
///
/// The happ developer needs to plan carefully to ensure auditability and accountability is
/// maintained for all writes and network calls if this is important to the integrity of the happ.
///
/// Multiple [`CapGrant`] entries can be relevant to a single attempted zome call invocation.
/// The most specific and strict [`CapGrant`] that validates will be used. For example, if a user
/// provided a valid transferable secret to a function that is currently unrestricted, the zome
/// call will be executed with the stricter transferable access.
//
// @todo this is more relevant when partial application exists in the future
// @todo predictably disambiguate multiple CapGrants of the same specificity
///       (also potentially not needed when we enforce uniqueness - see below)
///
/// [`CapGrant`] entries can be updated and deleted in the same way as standard app entries.
/// The CRUD model for [`CapGrant`] is much simpler than app entries:
///
/// - versions are always local to a single source chain so partitions can never happen
/// - updates function like delete+create so that old grants are immediately revoked by a new grant
/// - deletes immediately revoke the referenced grant
/// - version histories are linear so there can never be a branching history of updates and deletes
//
// @todo ensure linear history in sys validation
///
/// Secrets must be unique across all grants and claims in a source chain and should be generated
/// using the [`generate_cap_secret`] function that sources the correct number of cryptographically
/// strong random bytes from the host.
//
// @todo ensure uniqueness of secrets in sys validation
///
/// If _any_ [`CapGrant`] is valid for a zome call invocation it will execute. Given that secrets must
/// be unique across all grants and claims this is easy to ensure for assigned and transferable
/// access. Special care is required for Unrestricted grants as several may apply to a single
/// extern at one time, or may apply in addition to a stricter grant. In this case, revoking a
/// stricter grant, or failing to revoke all Unrestricted grants will leave the function open.
//
// @todo administration functions to query active grants
///
/// There is an apparent "chicken or the egg" situation where [`CapGrant`] are required for remote
/// agents to call externs, so how does an agent request a grant in the first place?
/// The simplest pattern is for agents to create an extern dedicated to assess incoming grant
/// requests and to apply [`CapAccess::Unrestricted`] access to it during the zome's `init` callback.
/// If Alice wants access to Bob's `foo` function she first grants Bob `Assigned` access to her own
/// `accept_foo_grant` extern and sends her grant's secret to Bob's `issue_foo_grant` function. Bob
/// receives Alice's request and, if he is willing to grant Alice access, he commits Alice's secret
/// as a [`CapClaim`] to his chain. Bob then generates a new secret and commits it in a [`CapGrant`]
/// for `foo`, most likely explicitly `Assigned` to Alice, and sends his secret and Alice's secret
/// to Alice's `accept_foo_grant` extern. Alice checks her grant, which matches Bob's public key
/// and the secret Bob received from her, then she commits a new CapClaim including the secret that
/// Bob generated. Now Alice can call `foo` on Bob's machine any time he is online, and because all
/// the secrets are [`CapAccess::Assigned`] Bob can track and update exactly who has access to his externs.
pub fn create_cap_grant(cap_grant_entry: CapGrantEntry) -> ExternResult<ActionHash> {
    create(CreateInput::new(
        EntryDefLocation::CapGrant,
        EntryVisibility::Private,
        Entry::CapGrant(cap_grant_entry),
        ChainTopOrdering::default(),
    ))
}

/// Delete a capability grant.
///
/// Wraps the [`delete`] HDK function with system type parameters set.
/// This guards against deleting application entries or setting the wrong entry type.
///
/// Capability grants can be deleted like other entries.
/// Unlike most other entries, deleting a grant is linear, there is no branching tree of CRUD history because only grants on the local source chain can be deleted.
///
/// Once a capability grant is deleted any incoming function call requests with associated capability claims will immediately begin to fail as [`ZomeCallResponse::Unauthorized`].
/// There is no `undo` for deletes, a new grant must be created and distributed to reinstate access after a grant deletion.
/// Immediately means after the wasm successfully completes with no errors or rollbacks as extern calls are transactional/atomic.
///
/// The input to [`delete_cap_grant`] is the [`ActionHash`] of the [`CapGrant`] record to delete and optionally an argument to
/// specify the [`ChainTopOrdering`]. Refer to [`DeleteInput`] for details.
///
/// Deletes can reference both [`CapGrant`] creates and updates.
pub fn delete_cap_grant<I, E>(delete_input: I) -> ExternResult<ActionHash>
where
    DeleteInput: TryFrom<I, Error = E>,
    WasmError: From<E>,
{
    delete(delete_input)
}

/// Generate secrets for capability grants.
///
/// Wraps the [`random_bytes`] HDK function with appropriate parameters set.
/// Generates 512 bits of cryptographic strength randomness to form the secret for a capability grant.
///
/// It is strongly recommended to always use this function for generating capability grant secrets.
/// There is negligible benefit to decreasing or increasing the bits of entropy, or changing the algorithm.
/// There may be security risks in shortening the secret or changing its generation logic.
///
/// Capability secrets must be unique within and across all chains.
/// Using this function consistently guarantees uniqueness.
///
/// If an attacker can guess a secret to masquerade as another agent and execute [`CapAccess::Transferable`] code.
///
/// Re-using secrets is forbidden within and across all claims and grants.
pub fn generate_cap_secret() -> ExternResult<CapSecret> {
    random_bytes(CAP_SECRET_BYTES as u32).map(|bytes| {
        // Always a fatal error if our own bytes generation has the wrong number of bytes.
        assert_eq!(CAP_SECRET_BYTES, bytes.len());
        let mut inner = [0; CAP_SECRET_BYTES];
        inner.copy_from_slice(bytes.as_ref());
        CapSecret::from(inner)
    })
}

/// Update a capability grant.
///
/// Wraps the [`update`] HDK function with system type parameters set.
/// This guards against updating application entries or setting the wrong entry types.
///
/// Capability grant updates work exactly as a delete+create of the old+new grant entries.
///
/// The first argument is the action hash of the old grant being deleted as per [`delete_cap_grant`].
/// The second argument is the entry value of the new grant to create as per [`create_cap_grant`].
pub fn update_cap_grant(
    old_grant_action_hash: ActionHash,
    new_grant_value: CapGrantEntry,
) -> ExternResult<ActionHash> {
    update(UpdateInput {
        original_action_address: old_grant_action_hash,
        entry: Entry::CapGrant(new_grant_value),
        chain_top_ordering: ChainTopOrdering::default(),
    })
}



================================================
File: crates/hdk/src/chain.rs
================================================
use crate::prelude::*;
pub use hdi::chain::*;

/// Query the _actions_ of a remote agent's chain.
///
/// The agent activity is only the actions of their source chain.
/// The agent activity is held by the neighbourhood of the agent's public key, rather than a content hash like the rest of the DHT.
///
/// The agent activity can be filtered with [ `ChainQueryFilter` ] like a local chain query.
pub fn get_agent_activity(
    agent: AgentPubKey,
    query: ChainQueryFilter,
    request: ActivityRequest,
) -> ExternResult<AgentActivity> {
    HDK.with(|h| {
        h.borrow()
            .get_agent_activity(GetAgentActivityInput::new(agent, query, request))
    })
}

/// Walks the source chain in ascending order (oldest to latest) filtering by action and/or entry type
///
/// Given an action and entry type, returns an [ `Vec<Record>` ]
///
// @todo document this better with examples after we make query do all the things we want.
// @todo implement cap grant/claim usage in terms of query
// @todo have ability to hash-bound query other agent's chains based on agent activity
// @todo tie query into validation so we track dependencies e.g. validation packages
// @todo decide which direction we want to iterate in (paramaterise query?)
// @todo more expresivity generally?
pub fn query(filter: ChainQueryFilter) -> ExternResult<Vec<Record>> {
    HDK.with(|h| h.borrow().query(filter))
}



================================================
File: crates/hdk/src/clone.rs
================================================
use crate::prelude::HDK;
use hdi::map_extern::ExternResult;
use holochain_zome_types::clone::{
    ClonedCell, CreateCloneCellInput, DeleteCloneCellInput, DisableCloneCellInput,
    EnableCloneCellInput,
};

/// Create a new cell in the current app based on the DNA of an existing cell in this app.
///
/// # Returns
///
/// A struct with the created cell's clone id and cell id.
pub fn create_clone_cell(input: CreateCloneCellInput) -> ExternResult<ClonedCell> {
    HDK.with(|h| h.borrow().create_clone_cell(input))
}

/// Disable a clone cell in the current app.
pub fn disable_clone_cell(input: DisableCloneCellInput) -> ExternResult<()> {
    HDK.with(|h| h.borrow().disable_clone_cell(input))
}

/// Enable a disabled clone cell in the current app.
///
/// # Returns
///
/// A struct with the enabled cell's clone id and cell id.
pub fn enable_clone_cell(input: EnableCloneCellInput) -> ExternResult<ClonedCell> {
    HDK.with(|h| h.borrow().enable_clone_cell(input))
}

/// Delete a clone cell in the current app.
pub fn delete_clone_cell(input: DeleteCloneCellInput) -> ExternResult<()> {
    HDK.with(|h| h.borrow().delete_clone_cell(input))
}



================================================
File: crates/hdk/src/countersigning.rs
================================================
use crate::prelude::*;

/// Locks the local chain to commence a countersigning session.
///
/// The `PreflightRequestAcceptance` MUST be sent back to the session initiator
/// so that the corresponding entry can be built for everyone to sign.
/// This function MUST be called by every signer in the signing session.
/// It doesn't matter how, although concurrent remote calls are probably the
/// simplest mechanism to distribute and accept preflight requests before the
/// session times out.
pub fn accept_countersigning_preflight_request(
    preflight_request: PreflightRequest,
) -> ExternResult<PreflightRequestAcceptance> {
    // Host should:
    // - Check system constraints on request
    // - Freeze chain for session end
    // - Build response
    HDK.with(|h| {
        h.borrow()
            .accept_countersigning_preflight_request(preflight_request)
    })
}

/// Wrapper function around `sys_time` to build `CounterSigningSessionTimes`.
/// These session times are included in the `PreflightRequest` and bound the
/// countersigning session temporally.
/// This function starts the session "now" in the opinion of the session
/// initiator and ends it after `ms` milliseconds relative to "now".
/// The countersigning parties will check these times as part of accepting the
/// preflight request so all system clocks need to be roughly aligned and the
/// ambient network latency must fit comfortably within the session duration.
pub fn session_times_from_millis(ms: u64) -> ExternResult<CounterSigningSessionTimes> {
    let start = sys_time()?;
    let end = start + core::time::Duration::from_millis(ms);
    CounterSigningSessionTimes::try_new(
        start,
        end.map_err(|e| wasm_error!(WasmErrorInner::Guest(e.to_string())))?,
    )
    .map_err(|e| wasm_error!(WasmErrorInner::Guest(e.to_string())))
}



================================================
File: crates/hdk/src/ed25519.rs
================================================
use crate::prelude::*;

pub use hdi::ed25519::*;

/// Sign something that is serializable using the private key for the passed public key.
///
/// Serde convenience for [ `sign_raw `].
pub fn sign<K, D>(key: K, data: D) -> ExternResult<Signature>
where
    K: Into<AgentPubKey>,
    D: serde::Serialize + std::fmt::Debug,
{
    HDK.with(|h| {
        h.borrow()
            .sign(Sign::new(key.into(), data).map_err(|e| wasm_error!(e))?)
    })
}

/// Sign some data using the private key for the passed public key.
///
/// Assuming the private key for the provided pubkey exists in lair this will work.
/// If we don't have the private key for the public key then we can't sign anything!
///
/// See [ `sign` ]
pub fn sign_raw<K>(key: K, data: Vec<u8>) -> ExternResult<Signature>
where
    K: Into<AgentPubKey>,
{
    HDK.with(|h| h.borrow().sign(Sign::new_raw(key.into(), data)))
}

/// Sign N serializable things using an ephemeral private key.
///
/// Serde convenience for [ `sign_ephemeral_raw` ].
pub fn sign_ephemeral<D>(datas: Vec<D>) -> ExternResult<EphemeralSignatures>
where
    D: serde::Serialize + std::fmt::Debug,
{
    HDK.with(|h| {
        h.borrow()
            .sign_ephemeral(SignEphemeral::new(datas).map_err(|e| wasm_error!(e))?)
    })
}

/// Sign N data using an ephemeral private key.
///
/// This is a complement to [ `sign_raw` ] in case we don't have a meaningful key for the input.
/// __The generated private half of the key is discarded immediately upon signing__.
///
/// The signatures output are pairwise ordered the same as the input data.
/// It is up to the caller to construct meaning for ephemeral signatures in some cryptographic system.
pub fn sign_ephemeral_raw(datas: Vec<Vec<u8>>) -> ExternResult<EphemeralSignatures> {
    HDK.with(|h| h.borrow().sign_ephemeral(SignEphemeral::new_raw(datas)))
}



================================================
File: crates/hdk/src/entry.rs
================================================
use crate::prelude::*;

pub use hdi::entry::*;

/// General function that can create any entry type.
///
/// This is used under the hood by [`create_entry`], [`create_cap_grant`] and [`create_cap_claim`].
///
/// The host builds a [`Create`] action for the passed entry value and commits a new record to the
/// chain.
///
/// Usually you don't need to use this function directly; it is the most general way to create an
/// entry and standardizes the internals of higher level create functions.
pub fn create(create_input: CreateInput) -> ExternResult<ActionHash> {
    HDK.with(|h| h.borrow().create(create_input))
}

/// General function that can update any entry type.
///
/// This is used under the hood by [`update_entry`], [`update_cap_grant`] and `update_cap_claim`.
//
// @todo implement update_cap_claim
///
/// The host builds an [`Update`] action for the passed entry value and commits a new update to the
/// chain.
///
/// Usually you don't need to use this function directly; it is the most general way to update an
/// entry and standardizes the internals of higher level update functions.
pub fn update(input: UpdateInput) -> ExternResult<ActionHash> {
    HDK.with(|h| h.borrow().update(input))
}

/// General function that can delete any entry type.
///
/// This is used under the hood by [`delete_entry`], [`delete_cap_grant`] and `delete_cap_claim`.
//
// @todo implement delete_cap_claim
///
/// The host builds a [`Delete`] action for the passed entry and commits a new record to the chain.
///
/// Usually you don't need to use this function directly; it is the most general way to delete an
/// entry and standardizes the internals of higher level delete functions.
pub fn delete<I, E>(delete_input: I) -> ExternResult<ActionHash>
where
    DeleteInput: TryFrom<I, Error = E>,
    WasmError: From<E>,
{
    HDK.with(|h| h.borrow().delete(DeleteInput::try_from(delete_input)?))
}

/// Create an app entry. Also see [`create`].
///
/// Apps define app entries by registering entry def ids with the `entry_defs` callback and serialize the
/// entry content when committing to the source chain.
///
/// This function accepts any input that implements [`TryInto<CreateInput>`].
/// The implementations of the #[hdk_entry_helper] macro includes this.
///
/// With generic type handling it may make sense to directly construct [`CreateInput`] and [`create`].
///
/// e.g.
/// ```ignore
/// #[hdk_entry_helper]
/// pub struct Foo(u32);
///
/// #[hdk_entry_types]
/// pub enum EntryTypes {
///    Foo(Foo)
/// }
/// create_entry(EntryTypes::Foo(Foo(50)))?;
/// ```
///
/// See [`get`] and [`get_details`] for more information on CRUD.
pub fn create_entry<I, E, E2>(input: I) -> ExternResult<ActionHash>
where
    ScopedEntryDefIndex: for<'a> TryFrom<&'a I, Error = E2>,
    EntryVisibility: for<'a> From<&'a I>,
    Entry: TryFrom<I, Error = E>,
    WasmError: From<E>,
    WasmError: From<E2>,
{
    let ScopedEntryDefIndex {
        zome_index,
        zome_type: entry_def_index,
    } = (&input).try_into()?;
    let visibility = EntryVisibility::from(&input);
    let create_input = CreateInput::new(
        EntryDefLocation::app(zome_index, entry_def_index),
        visibility,
        input.try_into()?,
        ChainTopOrdering::default(),
    );
    create(create_input)
}

/// Delete an app entry. Also see [`delete`].
///
/// This function accepts the [`ActionHash`] of the record to delete and optionally an argument to
/// specify the [`ChainTopOrdering`]. Refer to [`DeleteInput`] for details.
///
/// ```ignore
/// #[hdk_entry_helper]
/// struct Foo(u32);
///
/// #[hdk_entry_types]
/// pub enum EntryTypes {
///    Foo(Foo)
/// }
///
/// let action_hash = create_entry(EntryTypes::Foo(Foo(50)))?;
/// let delete_entry_action_hash = delete_entry(action_hash.clone())?;
/// ```
///
/// with a specific [`ChainTopOrdering`]:
/// ```ignore
/// delete_entry(DeleteInput::new(action_hash.clone(), ChainTopOrdering::Relaxed))?;
/// ```
pub fn delete_entry<I, E>(delete_input: I) -> ExternResult<ActionHash>
where
    DeleteInput: TryFrom<I, Error = E>,
    WasmError: From<E>,
{
    delete(delete_input)
}

/// Update an app entry. Also see [`update`].
///
/// The hash is the [`ActionHash`] of the updated record, the input is a [`TryInto<CreateInput>`].
///
/// Updates can reference Records which contain Entry data -- namely, Creates and other Updates -- but
/// not Deletes or system Records.
///
/// As updates can reference records on other agent's source chains across unpredictable network
/// topologies, they are treated as a tree structure.
///
/// Many updates can point to a single create/update and continue to accumulate as long as agents
/// author them against that record. It is up to happ developers to decide how to ensure the tree
/// branches are walked appropriately and that updates point to the correct record, whatever that
/// means for the happ.
///
/// ```ignore
/// #[hdk_entry_helper]
/// pub struct Foo(u32);
///
/// #[hdk_entry_types]
/// pub enum EntryTypes {
///    Foo(Foo)
/// }
///
/// let foo_zero_action_hash: ActionHash = create_entry(EntryTypes::Foo(Foo(0)))?;
/// let foo_ten_update_action_hash: ActionHash = update_entry(foo_zero_action_hash, EntryTypes::Foo(Foo(10)))?;
/// ```
//
// @todo in the future this will be true because we will have the concept of 'redirects':
// Works as an app entry delete+create.
///
/// See [`create_entry`]
/// See [`update`]
/// See [`delete_entry`]
pub fn update_entry<I, E>(hash: ActionHash, input: I) -> ExternResult<ActionHash>
where
    Entry: TryFrom<I, Error = E>,
    WasmError: From<E>,
{
    let input = UpdateInput {
        original_action_address: hash,
        entry: input.try_into()?,
        chain_top_ordering: ChainTopOrdering::default(),
    };
    update(input)
}

/// Gets a record for a given entry or action hash.
///
/// The behaviour of get changes subtly per the _type of the passed hash_.
/// An action hash returns the record for that action, i.e. action+entry or action+None.
/// An entry hash returns the "oldest live" record, i.e. action+entry.
///
/// An record is no longer live once it is referenced by a valid delete record.
/// An update to a record does not change its liveness.
/// See [`get_details`] for more information about how CRUD records reference each other.
///
/// Note: [`get`] __always triggers and blocks on a network call__.
//       @todo implement a 'get optimistic' that returns based on the current opinion of the world
//       and performs network calls in the background so they are available 'next time'.
///
/// Note: Deletes are considered in the liveness but Updates are not currently followed
///       automatically due to the need for the happ to disambiguate update logic.
//       @todo implement 'redirect' logic so that updates are followed by [`get`].
///
/// Note: Updates typically point to a different entry hash than what they are updating but not
///       always, e.g. consider changing `foo` to `bar` back to `foo`. The entry hashes in a crud
///       tree can be circular but the action hashes are never circular.
///       In this case, deleting the create for foo would make the second update pointing to foo
///       the "oldest live" record.
///
/// Note: "oldest live" only relates to disambiguating many creates and updates from many authors
///       pointing to a single entry, it is not the "current value" of an entry in a CRUD sense.
///       e.g. If "foo" is created then updated to "bar", a [`get`] on the hash of "foo" will return
///            "foo" as part of a record with the "oldest live" action.
///            To discover "bar" the agent needs to call `get_details` and decide how it wants to
///            collapse many potential creates, updates and deletes down into a single or filtered
///            set of updates, to "walk the tree".
///       e.g. Updates could include a proof of work and a tree would collapse to a simple
///            blockchain if the agent follows the "heaviest chain".
///       e.g. Updates could represent turns in a 2-player game and the update with the newest
///            timestamp countersigned by both players represents an opt-in chain of updates with
///            support for casual "undo" with player's consent.
///       e.g. Domain/user names could be claimed on a "first come, first serve" basis with only
///            creates and deletes allowed by validation rules, the "oldest live" record _does_
///            represent the record pointing at the first agent to claim a name, but it could also
///            be checked manually by the app with `get_details`.
///
/// Note: "oldest live" is only as good as the information available to the authorities the agent
///       contacts on their current network partition, there could always be an older live entry
///       on another partition, and of course the oldest live entry could be deleted and no longer
///       be live.
pub fn get<H>(hash: H, options: GetOptions) -> ExternResult<Option<Record>>
where
    AnyDhtHash: From<H>,
{
    Ok(HDK
        .with(|h| {
            h.borrow()
                .get(vec![GetInput::new(AnyDhtHash::from(hash), options)])
        })?
        .into_iter()
        .next()
        .unwrap())
}

/// Get a record and its details for the entry or action hash passed in.
/// Returns [`None`] if the entry/action does not exist.
/// The details returned are a contextual mix of records and action hashes.
///
/// Note: The return details will be inferred by the hash type passed in, be careful to pass in the
///       correct hash type for the details you want.
///
/// This is implemented in the [`RecordDetails`] variants:
///
/// [`Details::Record`] for an action hash returns:
/// - the record for this action hash if it exists
/// - all update and delete _records_ that reference that specified action
///
/// [`Details::Entry`] for an entry hash returns:
/// - all creates, updates and delete _records_ that reference that entry hash
/// - all update and delete _records_ that reference the records that reference the entry hash
///
/// If an action hash is passed in, the action's record will be returned.
/// If an entry hash is passed in, all the actions and records for that entry are returned.
/// The details returned include relevant creates, updates and deletes for the hash passed in.
///
/// Creates are initial action/entry combinations (records) produced by create_entry and cannot
/// reference other actions.
/// Updates and deletes both reference a specific action+entry combination.
/// Updates must reference another create or update action+entry.
/// Deletes must reference a create or update action+entry (nothing can reference a delete).
///
/// Full records are returned for direct references to the passed hash.
/// Action hashes are returned for references to references to the passed hash.
///
/// [`Details::Record`] for an action hash return:
/// - the record for this action hash if it exists
/// - all update and delete _records_ that reference that specified action
///
/// [`Details::Entry`] for an entry hash return:
/// - all creates, updates and delete _records_ that reference that entry hash
/// - all update and delete _records_ that reference the records that reference the entry hash
///
/// Note: Entries are just values, so can be referenced by many CRUD actions by many authors.
///       e.g. the number 1 or string "foo" can be referenced by anyone publishing CRUD actions at
///       any time they need to represent 1 or "foo" for a create, update or delete.
///       If you need to disambiguate entry values, provide uniqueness in the entry value such as
///       a unique hash (e.g. current chain head), timestamp (careful about collisions!), or random
///       bytes/uuid (see random_bytes() and the uuid rust crate that supports uuids from bytes).
///
/// Note: There are multiple action types that exist and operate entirely outside of CRUD records
///       so they cannot reference or be referenced by CRUD, so are immutable or have their own
///       mutation logic (e.g. link create/delete) and will not be included in [`get_details`] results
///       e.g. the DNA itself, links, migrations, etc.
///       However the record will still be returned by [`get_details`] if an action hash is passed,
///       these non-entry records will have [`None`] as the entry value.
pub fn get_details<H: Into<AnyDhtHash>>(
    hash: H,
    options: GetOptions,
) -> ExternResult<Option<Details>> {
    Ok(HDK
        .with(|h| {
            h.borrow()
                .get_details(vec![GetInput::new(hash.into(), options)])
        })?
        .into_iter()
        .next()
        .unwrap())
}

/// Implements a whole lot of sane defaults for a struct or enum that should behave as an entry.
/// All the entry def fields are available as dedicated methods on the type and matching From impls
/// are provided for each. This allows for both Foo::entry_types() and EntryDef::from(Foo::new())
/// style logic which are both useful in different scenarios.
///
/// For example, the Foo::entry_types() style works best in the entry_types callback as it doesn't
/// require an instantiated Foo in order to get the definition.
/// On the other hand, EntryDef::from(Foo::new()) works better when e.g. using create_entry() as
/// an instance of Foo already exists and we need the entry def id back for creates and updates.
///
/// If you don't want to use the macro you can simply implement similar fns youself.
///
/// This is not a trait at the moment, it could be in the future but for now these functions and
/// impls are just a loose set of conventions.
///
/// It's actually entirely possible to interact with core directly without any of these.
/// e.g. [`create_entry`] is just building a tuple of [`EntryDefId`] and [`Entry::App`] under the hood.
///
/// This requires that TryFrom and TryInto [`derive@SerializedBytes`] is implemented for the entry type,
/// which implies that [`serde::Serialize`] and [`serde::Deserialize`] is also implemented.
/// These can all be derived and there is an attribute macro that both does the default defines.
///
///  e.g. the following are equivalent
///
/// ```ignore
/// #[hdk_entry(id = "foo", visibility = "private", required_validations = 6, )]
/// pub struct Foo;
/// ```
///
/// ```ignore
/// #[derive(SerializedBytes, serde::Serialize, serde::Deserialize)]
/// pub struct Foo;
/// entry_def!(Foo EntryDef {
///   id: "foo".into(),
///   visibility: EntryVisibility::Private,
///   ..Default::default()
/// });
/// ```
#[macro_export]
macro_rules! entry_type {
    ( $t:ident $def:expr ) => {
        $crate::prelude::hdi::app_entry!($t);
        $crate::prelude::hdi::register_entry!($t $def);
    };
}



================================================
File: crates/hdk/src/hash.rs
================================================
//! For more details see [`hdi::hash`].

#[doc(no_inline)]
pub use hdi::hash;

#[doc(inline)]
pub use hdi::hash::*;



================================================
File: crates/hdk/src/hash_path.rs
================================================
/// The anchor pattern implemented in terms of [Path](hdi::prelude::Path).
///
/// The anchor pattern predates the path crate.
///
/// It is conceptually:
///
/// - A two level Path tree
/// - Each level of the path is defined as strings not binary data
/// - The top level is the "type" and the second level is the "text"
/// - The second level is optional as `Option<String>`
pub mod anchor;

/// The generic [Path](hdi::prelude::Path) pattern.
///
/// As explained in the parent module documentation the [Path](hdi::prelude::Path) defines a tree structure.
///
/// The path is _not_ an entire tree but simply one path from the root to the current depth of the tree.
///
/// A -> B -> C
///  \-> D
///
/// All possible paths for the above tree:
///
/// - `[]`
/// - `[ A ]`
/// - `[ A B ]`
/// - `[ A B C ]`
/// - `[ A D ]`
///
/// Note:
///
/// - The [Path](hdi::prelude::Path) must always start at the root
/// - [Path](hdi::prelude::Path)s are sequential and contigious
/// - [Path](hdi::prelude::Path)s may be empty
/// - [Path](hdi::prelude::Path)s only track one branch
///
/// Applications can discover all links from a path to all children by constructing the known path components.
///
/// For example if an application knows `[ A ]` then links to `B` and `D` will be discoverable.
///
/// If an application knows `[ A B ]` then a link to `C` will be discoverable.
pub mod path;



================================================
File: crates/hdk/src/hdk.rs
================================================
use crate::prelude::*;
use hdi::hdi::HdiT;

pub const HDK_NOT_REGISTERED: &str = "HDK not registered";

/// This is a cell so it can be set many times.
/// Every test needs its own mock so each test needs to set it.
use core::cell::RefCell;
use std::rc::Rc;

#[cfg(any(feature = "mock", not(target_arch = "wasm32")))]
thread_local!(pub static HDK: RefCell<Rc<dyn HdkT>> = RefCell::new(Rc::new(ErrHdk)));

#[cfg(all(not(feature = "mock"), target_arch = "wasm32"))]
thread_local!(pub static HDK: RefCell<Rc<dyn HdkT>> = RefCell::new(Rc::new(HostHdk)));

/// When mocking is enabled the mockall crate automatically builds a MockHdkT for us.
/// ```ignore
/// let mut mock = MockHdkT::new();
/// mock_hdk.expect_foo().times(1).etc().etc();
/// set_hdk(mock_hdk);
/// ```
pub trait HdkT: HdiT {
    // Chain
    fn get_agent_activity(
        &self,
        get_agent_activity_input: GetAgentActivityInput,
    ) -> ExternResult<AgentActivity>;
    fn query(&self, filter: ChainQueryFilter) -> ExternResult<Vec<Record>>;
    // Ed25519
    fn sign(&self, sign: Sign) -> ExternResult<Signature>;
    fn sign_ephemeral(&self, sign_ephemeral: SignEphemeral) -> ExternResult<EphemeralSignatures>;
    // Entry
    fn create(&self, create_input: CreateInput) -> ExternResult<ActionHash>;
    fn update(&self, update_input: UpdateInput) -> ExternResult<ActionHash>;
    fn delete(&self, delete_input: DeleteInput) -> ExternResult<ActionHash>;
    fn get(&self, get_input: Vec<GetInput>) -> ExternResult<Vec<Option<Record>>>;
    fn get_details(&self, get_input: Vec<GetInput>) -> ExternResult<Vec<Option<Details>>>;
    // CounterSigning
    #[cfg(feature = "unstable-countersigning")]
    fn accept_countersigning_preflight_request(
        &self,
        preflight_request: PreflightRequest,
    ) -> ExternResult<PreflightRequestAcceptance>;
    // DPKI
    #[cfg(feature = "unstable-functions")]
    fn get_agent_key_lineage(&self, agent_key: AgentPubKey) -> ExternResult<Vec<AgentPubKey>>;
    // Info
    fn agent_info(&self, agent_info_input: ()) -> ExternResult<AgentInfo>;
    fn call_info(&self, call_info_input: ()) -> ExternResult<CallInfo>;
    // Link
    fn create_link(&self, create_link_input: CreateLinkInput) -> ExternResult<ActionHash>;
    fn delete_link(&self, delete_link_input: DeleteLinkInput) -> ExternResult<ActionHash>;
    fn get_links(&self, get_links_input: Vec<GetLinksInput>) -> ExternResult<Vec<Vec<Link>>>;
    fn get_link_details(
        &self,
        get_links_input: Vec<GetLinksInput>,
    ) -> ExternResult<Vec<LinkDetails>>;
    fn count_links(&self, query: LinkQuery) -> ExternResult<usize>;
    // P2P
    #[cfg(feature = "unstable-functions")]
    fn block_agent(&self, block_agent_input: BlockAgentInput) -> ExternResult<()>;
    #[cfg(feature = "unstable-functions")]
    fn unblock_agent(&self, unblock_agent_input: BlockAgentInput) -> ExternResult<()>;
    fn call(&self, call: Vec<Call>) -> ExternResult<Vec<ZomeCallResponse>>;
    fn emit_signal(&self, app_signal: AppSignal) -> ExternResult<()>;
    fn send_remote_signal(&self, remote_signal: RemoteSignal) -> ExternResult<()>;
    // Random
    fn random_bytes(&self, number_of_bytes: u32) -> ExternResult<Bytes>;
    // Time
    fn sys_time(&self, sys_time_input: ()) -> ExternResult<Timestamp>;
    #[cfg(feature = "unstable-functions")]
    fn schedule(&self, scheduled_fn: String) -> ExternResult<()>;
    // XSalsa20Poly1305
    fn x_salsa20_poly1305_shared_secret_create_random(
        &self,
        key_ref: Option<XSalsa20Poly1305KeyRef>,
    ) -> ExternResult<XSalsa20Poly1305KeyRef>;
    fn x_salsa20_poly1305_shared_secret_export(
        &self,
        x_salsa20_poly1305_shared_secret_export: XSalsa20Poly1305SharedSecretExport,
    ) -> ExternResult<XSalsa20Poly1305EncryptedData>;
    fn x_salsa20_poly1305_shared_secret_ingest(
        &self,
        x_salsa20_poly1305_shared_secret_ingest: XSalsa20Poly1305SharedSecretIngest,
    ) -> ExternResult<XSalsa20Poly1305KeyRef>;
    fn x_salsa20_poly1305_encrypt(
        &self,
        x_salsa20_poly1305_encrypt: XSalsa20Poly1305Encrypt,
    ) -> ExternResult<XSalsa20Poly1305EncryptedData>;
    fn create_x25519_keypair(&self, create_x25519_keypair_input: ()) -> ExternResult<X25519PubKey>;
    fn x_25519_x_salsa20_poly1305_encrypt(
        &self,
        x_25519_x_salsa20_poly1305_encrypt: X25519XSalsa20Poly1305Encrypt,
    ) -> ExternResult<XSalsa20Poly1305EncryptedData>;
    fn ed_25519_x_salsa20_poly1305_encrypt(
        &self,
        ed_25519_x_salsa20_poly1305_encrypt: Ed25519XSalsa20Poly1305Encrypt,
    ) -> ExternResult<XSalsa20Poly1305EncryptedData>;
    // Cloning
    fn create_clone_cell(&self, input: CreateCloneCellInput) -> ExternResult<ClonedCell>;
    fn disable_clone_cell(&self, input: DisableCloneCellInput) -> ExternResult<()>;
    fn enable_clone_cell(&self, input: EnableCloneCellInput) -> ExternResult<ClonedCell>;
    fn delete_clone_cell(&self, input: DeleteCloneCellInput) -> ExternResult<()>;
    // Migrate DNA
    fn close_chain(&self, input: CloseChainInput) -> ExternResult<ActionHash>;
    fn open_chain(&self, input: OpenChainInput) -> ExternResult<ActionHash>;
    // Validation receipts
    fn get_validation_receipts(
        &self,
        input: GetValidationReceiptsInput,
    ) -> ExternResult<Vec<ValidationReceiptSet>>;
}

#[cfg(feature = "mock")]
mockall::mock! {
    pub HdkT {}

    impl HdkT for HdkT {
        // Chain
        fn get_agent_activity(
            &self,
            get_agent_activity_input: GetAgentActivityInput,
        ) -> ExternResult<AgentActivity>;
        fn query(&self, filter: ChainQueryFilter) -> ExternResult<Vec<Record>>;
        // Ed25519
        fn sign(&self, sign: Sign) -> ExternResult<Signature>;
        fn sign_ephemeral(&self, sign_ephemeral: SignEphemeral) -> ExternResult<EphemeralSignatures>;
        // Entry
        fn create(&self, create_input: CreateInput) -> ExternResult<ActionHash>;
        fn update(&self, update_input: UpdateInput) -> ExternResult<ActionHash>;
        fn delete(&self, delete_input: DeleteInput) -> ExternResult<ActionHash>;
        fn get(&self, get_input: Vec<GetInput>) -> ExternResult<Vec<Option<Record>>>;
        fn get_details(&self, get_input: Vec<GetInput>) -> ExternResult<Vec<Option<Details>>>;
        // CounterSigning
        fn accept_countersigning_preflight_request(
            &self,
            preflight_request: PreflightRequest,
        ) -> ExternResult<PreflightRequestAcceptance>;
        // Info
        fn agent_info(&self, agent_info_input: ()) -> ExternResult<AgentInfo>;
        fn call_info(&self, call_info_input: ()) -> ExternResult<CallInfo>;
        // Link
        fn create_link(&self, create_link_input: CreateLinkInput) -> ExternResult<ActionHash>;
        fn delete_link(&self, delete_link_input: DeleteLinkInput) -> ExternResult<ActionHash>;
        fn get_links(&self, get_links_input: Vec<GetLinksInput>) -> ExternResult<Vec<Vec<Link>>>;
        fn get_link_details(
            &self,
            get_links_input: Vec<GetLinksInput>,
        ) -> ExternResult<Vec<LinkDetails>>;
        fn count_links(&self, query: LinkQuery) -> ExternResult<usize>;
        // P2P
        fn block_agent(&self, block_agent_input: BlockAgentInput) -> ExternResult<()>;
        fn unblock_agent(&self, unblock_agent_input: BlockAgentInput) -> ExternResult<()>;
        fn call(&self, call: Vec<Call>) -> ExternResult<Vec<ZomeCallResponse>>;
        fn emit_signal(&self, app_signal: AppSignal) -> ExternResult<()>;
        fn send_remote_signal(&self, remote_signal: RemoteSignal) -> ExternResult<()>;
        // Random
        fn random_bytes(&self, number_of_bytes: u32) -> ExternResult<Bytes>;
        // Time
        fn sys_time(&self, sys_time_input: ()) -> ExternResult<Timestamp>;
        fn schedule(&self, scheduled_fn: String) -> ExternResult<()>;
        // XSalsa20Poly1305
        fn x_salsa20_poly1305_shared_secret_create_random(
            &self,
            key_ref: Option<XSalsa20Poly1305KeyRef>,
        ) -> ExternResult<XSalsa20Poly1305KeyRef>;
        fn x_salsa20_poly1305_shared_secret_export(
            &self,
            x_salsa20_poly1305_shared_secret_export: XSalsa20Poly1305SharedSecretExport,
        ) -> ExternResult<XSalsa20Poly1305EncryptedData>;
        fn x_salsa20_poly1305_shared_secret_ingest(
            &self,
            x_salsa20_poly1305_shared_secret_ingest: XSalsa20Poly1305SharedSecretIngest,
        ) -> ExternResult<XSalsa20Poly1305KeyRef>;
        fn x_salsa20_poly1305_encrypt(
            &self,
            x_salsa20_poly1305_encrypt: XSalsa20Poly1305Encrypt,
        ) -> ExternResult<XSalsa20Poly1305EncryptedData>;
        fn create_x25519_keypair(&self, create_x25519_keypair_input: ()) -> ExternResult<X25519PubKey>;
        fn x_25519_x_salsa20_poly1305_encrypt(
            &self,
            x_25519_x_salsa20_poly1305_encrypt: X25519XSalsa20Poly1305Encrypt,
        ) -> ExternResult<XSalsa20Poly1305EncryptedData>;
        fn ed_25519_x_salsa20_poly1305_encrypt(
            &self,
            ed_25519_x_salsa20_poly1305_encrypt: Ed25519XSalsa20Poly1305Encrypt,
        ) -> ExternResult<XSalsa20Poly1305EncryptedData>;
        fn create_clone_cell(&self, input: CreateCloneCellInput) -> ExternResult<ClonedCell>;
        fn disable_clone_cell(&self, input: DisableCloneCellInput) -> ExternResult<()>;
        fn enable_clone_cell(&self, input: EnableCloneCellInput) -> ExternResult<ClonedCell>;
        fn delete_clone_cell(&self, input: DeleteCloneCellInput) -> ExternResult<()>;
        fn close_chain(&self, input: CloseChainInput) -> ExternResult<ActionHash>;
        fn open_chain(&self, input: OpenChainInput) -> ExternResult<ActionHash>;
        fn get_validation_receipts(&self, input: GetValidationReceiptsInput) -> ExternResult<Vec<ValidationReceiptSet>>;
        fn get_agent_key_lineage(&self, agent_key: AgentPubKey) -> ExternResult<Vec<AgentPubKey>>;
    }

    impl HdiT for HdkT {
        fn verify_signature(&self, verify_signature: VerifySignature) -> ExternResult<bool>;
        fn hash(&self, hash_input: HashInput) -> ExternResult<HashOutput>;
        fn must_get_entry(&self, must_get_entry_input: MustGetEntryInput) -> ExternResult<EntryHashed>;
        fn must_get_action(
            &self,
            must_get_action_input: MustGetActionInput,
        ) -> ExternResult<SignedActionHashed>;
        fn must_get_valid_record(
            &self,
            must_get_valid_record_input: MustGetValidRecordInput,
        ) -> ExternResult<Record>;
        fn must_get_agent_activity(
            &self,
            must_get_agent_activity_input: MustGetAgentActivityInput,
        ) -> ExternResult<Vec<RegisterAgentActivity>>;
        // Info
        fn dna_info(&self, dna_info_input: ()) -> ExternResult<DnaInfo>;
        fn zome_info(&self, zome_info_input: ()) -> ExternResult<ZomeInfo>;
        // Trace
        fn trace(&self, trace_msg: TraceMsg) -> ExternResult<()>;
        // XSalsa20Poly1305
        fn x_salsa20_poly1305_decrypt(
            &self,
            x_salsa20_poly1305_decrypt: XSalsa20Poly1305Decrypt,
        ) -> ExternResult<Option<XSalsa20Poly1305Data>>;
        fn x_25519_x_salsa20_poly1305_decrypt(
            &self,
            x_25519_x_salsa20_poly1305_decrypt: X25519XSalsa20Poly1305Decrypt,
        ) -> ExternResult<Option<XSalsa20Poly1305Data>>;
        fn ed_25519_x_salsa20_poly1305_decrypt(
            &self,
            ed_25519_x_salsa20_poly1305_decrypt: Ed25519XSalsa20Poly1305Decrypt,
        ) -> ExternResult<XSalsa20Poly1305Data>;
        fn is_same_agent(&self, key1: AgentPubKey, key2: AgentPubKey) -> ExternResult<bool>;
    }

}

/// Used as a placeholder before any other Hdk is registered.
/// Generally only useful for testing but technically can be set any time.
pub struct ErrHdk;

impl ErrHdk {
    fn err<T>() -> ExternResult<T> {
        Err(wasm_error!(WasmErrorInner::Guest(
            HDK_NOT_REGISTERED.to_string()
        )))
    }
}

/// Every call is an error for the ErrHdk.
impl HdiT for ErrHdk {
    fn verify_signature(&self, _verify_signature: VerifySignature) -> ExternResult<bool> {
        Self::err()
    }

    fn hash(&self, _hash_input: HashInput) -> ExternResult<HashOutput> {
        Self::err()
    }

    fn must_get_entry(
        &self,
        _must_get_entry_input: MustGetEntryInput,
    ) -> ExternResult<EntryHashed> {
        Self::err()
    }

    fn must_get_action(
        &self,
        _must_get_action_input: MustGetActionInput,
    ) -> ExternResult<SignedActionHashed> {
        Self::err()
    }

    fn must_get_valid_record(
        &self,
        _must_get_valid_record_input: MustGetValidRecordInput,
    ) -> ExternResult<Record> {
        Self::err()
    }

    fn must_get_agent_activity(
        &self,
        _: MustGetAgentActivityInput,
    ) -> ExternResult<Vec<RegisterAgentActivity>> {
        Self::err()
    }

    #[cfg(feature = "unstable-functions")]
    fn is_same_agent(&self, _: AgentPubKey, _: AgentPubKey) -> ExternResult<bool> {
        Self::err()
    }

    fn dna_info(&self, _dna_info_input: ()) -> ExternResult<DnaInfo> {
        Self::err()
    }

    fn zome_info(&self, _zome_info_input: ()) -> ExternResult<ZomeInfo> {
        Self::err()
    }

    fn trace(&self, _: TraceMsg) -> ExternResult<()> {
        Self::err()
    }

    fn x_salsa20_poly1305_decrypt(
        &self,
        _x_salsa20_poly1305_decrypt: XSalsa20Poly1305Decrypt,
    ) -> ExternResult<Option<XSalsa20Poly1305Data>> {
        Self::err()
    }

    fn x_25519_x_salsa20_poly1305_decrypt(
        &self,
        _x_25519_x_salsa20_poly1305_decrypt: X25519XSalsa20Poly1305Decrypt,
    ) -> ExternResult<Option<XSalsa20Poly1305Data>> {
        Self::err()
    }

    fn ed_25519_x_salsa20_poly1305_decrypt(
        &self,
        _ed_25519_x_salsa20_poly1305_decrypt: Ed25519XSalsa20Poly1305Decrypt,
    ) -> ExternResult<XSalsa20Poly1305Data> {
        Self::err()
    }
}

/// Every call is an error for the ErrHdk.
impl HdkT for ErrHdk {
    fn get_agent_activity(&self, _: GetAgentActivityInput) -> ExternResult<AgentActivity> {
        Self::err()
    }
    fn query(&self, _: ChainQueryFilter) -> ExternResult<Vec<Record>> {
        Self::err()
    }
    fn sign(&self, _: Sign) -> ExternResult<Signature> {
        Self::err()
    }
    fn sign_ephemeral(&self, _: SignEphemeral) -> ExternResult<EphemeralSignatures> {
        Self::err()
    }
    fn create(&self, _: CreateInput) -> ExternResult<ActionHash> {
        Self::err()
    }
    fn update(&self, _: UpdateInput) -> ExternResult<ActionHash> {
        Self::err()
    }
    fn delete(&self, _: DeleteInput) -> ExternResult<ActionHash> {
        Self::err()
    }
    fn get(&self, _: Vec<GetInput>) -> ExternResult<Vec<Option<Record>>> {
        Self::err()
    }
    fn get_details(&self, _: Vec<GetInput>) -> ExternResult<Vec<Option<Details>>> {
        Self::err()
    }
    // CounterSigning
    #[cfg(feature = "unstable-countersigning")]
    fn accept_countersigning_preflight_request(
        &self,
        _: PreflightRequest,
    ) -> ExternResult<PreflightRequestAcceptance> {
        Self::err()
    }
    fn agent_info(&self, _: ()) -> ExternResult<AgentInfo> {
        Self::err()
    }
    fn call_info(&self, _: ()) -> ExternResult<CallInfo> {
        Self::err()
    }
    // DPKI
    #[cfg(feature = "unstable-functions")]
    fn get_agent_key_lineage(&self, _: AgentPubKey) -> ExternResult<Vec<AgentPubKey>> {
        Self::err()
    }
    // Link
    fn create_link(&self, _: CreateLinkInput) -> ExternResult<ActionHash> {
        Self::err()
    }
    fn delete_link(&self, _: DeleteLinkInput) -> ExternResult<ActionHash> {
        Self::err()
    }
    fn get_links(&self, _: Vec<GetLinksInput>) -> ExternResult<Vec<Vec<Link>>> {
        Self::err()
    }
    fn get_link_details(&self, _: Vec<GetLinksInput>) -> ExternResult<Vec<LinkDetails>> {
        Self::err()
    }
    fn count_links(&self, _: LinkQuery) -> ExternResult<usize> {
        Self::err()
    }
    // P2P
    #[cfg(feature = "unstable-functions")]
    fn block_agent(&self, _: BlockAgentInput) -> ExternResult<()> {
        Self::err()
    }
    #[cfg(feature = "unstable-functions")]
    fn unblock_agent(&self, _: BlockAgentInput) -> ExternResult<()> {
        Self::err()
    }
    fn call(&self, _: Vec<Call>) -> ExternResult<Vec<ZomeCallResponse>> {
        Self::err()
    }
    fn emit_signal(&self, _: AppSignal) -> ExternResult<()> {
        Self::err()
    }
    fn send_remote_signal(&self, _: RemoteSignal) -> ExternResult<()> {
        Self::err()
    }
    // Random
    fn random_bytes(&self, _: u32) -> ExternResult<Bytes> {
        Self::err()
    }
    // Time
    fn sys_time(&self, _: ()) -> ExternResult<Timestamp> {
        Self::err()
    }
    #[cfg(feature = "unstable-functions")]
    fn schedule(&self, _: String) -> ExternResult<()> {
        Self::err()
    }

    // XSalsa20Poly1305
    fn x_salsa20_poly1305_shared_secret_create_random(
        &self,
        _key_ref: Option<XSalsa20Poly1305KeyRef>,
    ) -> ExternResult<XSalsa20Poly1305KeyRef> {
        Self::err()
    }

    fn x_salsa20_poly1305_shared_secret_export(
        &self,
        _x_salsa20_poly1305_shared_secret_export: XSalsa20Poly1305SharedSecretExport,
    ) -> ExternResult<XSalsa20Poly1305EncryptedData> {
        Self::err()
    }

    fn x_salsa20_poly1305_shared_secret_ingest(
        &self,
        _x_salsa20_poly1305_shared_secret_ingest: XSalsa20Poly1305SharedSecretIngest,
    ) -> ExternResult<XSalsa20Poly1305KeyRef> {
        Self::err()
    }

    fn x_salsa20_poly1305_encrypt(
        &self,
        _x_salsa20_poly1305_encrypt: XSalsa20Poly1305Encrypt,
    ) -> ExternResult<XSalsa20Poly1305EncryptedData> {
        Self::err()
    }

    fn create_x25519_keypair(
        &self,
        _create_x25519_keypair_input: (),
    ) -> ExternResult<X25519PubKey> {
        Self::err()
    }

    fn x_25519_x_salsa20_poly1305_encrypt(
        &self,
        _x_25519_x_salsa20_poly1305_encrypt: X25519XSalsa20Poly1305Encrypt,
    ) -> ExternResult<XSalsa20Poly1305EncryptedData> {
        Self::err()
    }

    fn ed_25519_x_salsa20_poly1305_encrypt(
        &self,
        _ed_25519_x_salsa20_poly1305_encrypt: Ed25519XSalsa20Poly1305Encrypt,
    ) -> ExternResult<XSalsa20Poly1305EncryptedData> {
        Self::err()
    }

    // Cloning
    fn create_clone_cell(&self, _input: CreateCloneCellInput) -> ExternResult<ClonedCell> {
        Self::err()
    }

    fn disable_clone_cell(&self, _input: DisableCloneCellInput) -> ExternResult<()> {
        Self::err()
    }

    fn enable_clone_cell(&self, _input: EnableCloneCellInput) -> ExternResult<ClonedCell> {
        Self::err()
    }

    fn delete_clone_cell(&self, _input: DeleteCloneCellInput) -> ExternResult<()> {
        Self::err()
    }

    // Migrate DNA
    fn close_chain(&self, _input: CloseChainInput) -> ExternResult<ActionHash> {
        Self::err()
    }

    fn open_chain(&self, _input: OpenChainInput) -> ExternResult<ActionHash> {
        Self::err()
    }

    // Validation receipts
    fn get_validation_receipts(
        &self,
        _input: GetValidationReceiptsInput,
    ) -> ExternResult<Vec<ValidationReceiptSet>> {
        Self::err()
    }
}

/// The HDK implemented as externs provided by the host.
pub struct HostHdk;

#[cfg(all(not(feature = "mock"), target_arch = "wasm32"))]
use hdi::hdi::HostHdi;

#[cfg(all(not(feature = "mock"), target_arch = "wasm32"))]
impl HdiT for HostHdk {
    fn verify_signature(&self, verify_signature: VerifySignature) -> ExternResult<bool> {
        HostHdi::new().verify_signature(verify_signature)
    }
    fn hash(&self, hash_input: HashInput) -> ExternResult<HashOutput> {
        HostHdi::new().hash(hash_input)
    }
    fn must_get_entry(&self, must_get_entry_input: MustGetEntryInput) -> ExternResult<EntryHashed> {
        HostHdi::new().must_get_entry(must_get_entry_input)
    }
    fn must_get_action(
        &self,
        must_get_action_input: MustGetActionInput,
    ) -> ExternResult<SignedActionHashed> {
        HostHdi::new().must_get_action(must_get_action_input)
    }
    fn must_get_valid_record(
        &self,
        must_get_valid_record_input: MustGetValidRecordInput,
    ) -> ExternResult<Record> {
        HostHdi::new().must_get_valid_record(must_get_valid_record_input)
    }
    fn must_get_agent_activity(
        &self,
        must_get_agent_activity_input: MustGetAgentActivityInput,
    ) -> ExternResult<Vec<RegisterAgentActivity>> {
        HostHdi::new().must_get_agent_activity(must_get_agent_activity_input)
    }
    fn dna_info(&self, _: ()) -> ExternResult<DnaInfo> {
        HostHdi::new().dna_info(())
    }
    fn zome_info(&self, _: ()) -> ExternResult<ZomeInfo> {
        HostHdi::new().zome_info(())
    }
    #[cfg(feature = "unstable-functions")]
    fn is_same_agent(&self, key_1: AgentPubKey, key_2: AgentPubKey) -> ExternResult<bool> {
        HostHdi::new().is_same_agent(key_1, key_2)
    }
    fn trace(&self, m: TraceMsg) -> ExternResult<()> {
        HostHdi::new().trace(m)
    }
    fn x_salsa20_poly1305_decrypt(
        &self,
        x_salsa20_poly1305_decrypt: XSalsa20Poly1305Decrypt,
    ) -> ExternResult<Option<XSalsa20Poly1305Data>> {
        HostHdi::new().x_salsa20_poly1305_decrypt(x_salsa20_poly1305_decrypt)
    }
    fn x_25519_x_salsa20_poly1305_decrypt(
        &self,
        x_25519_x_salsa20_poly1305_decrypt: X25519XSalsa20Poly1305Decrypt,
    ) -> ExternResult<Option<XSalsa20Poly1305Data>> {
        HostHdi::new().x_25519_x_salsa20_poly1305_decrypt(x_25519_x_salsa20_poly1305_decrypt)
    }
    fn ed_25519_x_salsa20_poly1305_decrypt(
        &self,
        ed_25519_x_salsa20_poly1305_decrypt: Ed25519XSalsa20Poly1305Decrypt,
    ) -> ExternResult<XSalsa20Poly1305Data> {
        HostHdi::new().ed_25519_x_salsa20_poly1305_decrypt(ed_25519_x_salsa20_poly1305_decrypt)
    }
}

/// The real hdk implements `host_call` for every hdk function.
/// This is deferring to the standard `holochain_wasmer_guest` crate functionality.
/// Every function works exactly the same way with the same basic signatures and patterns.
/// Elsewhere in the hdk are more high level wrappers around this basic trait.
#[cfg(all(not(feature = "mock"), target_arch = "wasm32"))]
impl HdkT for HostHdk {
    fn get_agent_activity(
        &self,
        get_agent_activity_input: GetAgentActivityInput,
    ) -> ExternResult<AgentActivity> {
        host_call::<GetAgentActivityInput, AgentActivity>(
            __hc__get_agent_activity_1,
            get_agent_activity_input,
        )
    }
    fn query(&self, filter: ChainQueryFilter) -> ExternResult<Vec<Record>> {
        host_call::<ChainQueryFilter, Vec<Record>>(__hc__query_1, filter)
    }
    fn sign(&self, sign: Sign) -> ExternResult<Signature> {
        host_call::<Sign, Signature>(__hc__sign_1, sign)
    }
    fn sign_ephemeral(&self, sign_ephemeral: SignEphemeral) -> ExternResult<EphemeralSignatures> {
        host_call::<SignEphemeral, EphemeralSignatures>(__hc__sign_ephemeral_1, sign_ephemeral)
    }
    fn create(&self, create_input: CreateInput) -> ExternResult<ActionHash> {
        host_call::<CreateInput, ActionHash>(__hc__create_1, create_input)
    }
    fn update(&self, update_input: UpdateInput) -> ExternResult<ActionHash> {
        host_call::<UpdateInput, ActionHash>(__hc__update_1, update_input)
    }
    fn delete(&self, hash: DeleteInput) -> ExternResult<ActionHash> {
        host_call::<DeleteInput, ActionHash>(__hc__delete_1, hash)
    }
    fn get(&self, get_inputs: Vec<GetInput>) -> ExternResult<Vec<Option<Record>>> {
        host_call::<Vec<GetInput>, Vec<Option<Record>>>(__hc__get_1, get_inputs)
    }
    fn get_details(&self, get_inputs: Vec<GetInput>) -> ExternResult<Vec<Option<Details>>> {
        host_call::<Vec<GetInput>, Vec<Option<Details>>>(__hc__get_details_1, get_inputs)
    }
    #[cfg(feature = "unstable-countersigning")]
    // CounterSigning
    fn accept_countersigning_preflight_request(
        &self,
        preflight_request: PreflightRequest,
    ) -> ExternResult<PreflightRequestAcceptance> {
        host_call::<PreflightRequest, PreflightRequestAcceptance>(
            __hc__accept_countersigning_preflight_request_1,
            preflight_request,
        )
    }
    // DPKI
    #[cfg(feature = "unstable-functions")]
    fn get_agent_key_lineage(&self, agent_key: AgentPubKey) -> ExternResult<Vec<AgentPubKey>> {
        host_call::<AgentPubKey, Vec<AgentPubKey>>(__hc__get_agent_key_lineage_1, agent_key)
    }
    fn agent_info(&self, _: ()) -> ExternResult<AgentInfo> {
        host_call::<(), AgentInfo>(__hc__agent_info_1, ())
    }
    fn call_info(&self, _: ()) -> ExternResult<CallInfo> {
        host_call::<(), CallInfo>(__hc__call_info_1, ())
    }
    fn create_link(&self, create_link_input: CreateLinkInput) -> ExternResult<ActionHash> {
        host_call::<CreateLinkInput, ActionHash>(__hc__create_link_1, create_link_input)
    }
    fn delete_link(&self, delete_link_input: DeleteLinkInput) -> ExternResult<ActionHash> {
        host_call::<DeleteLinkInput, ActionHash>(__hc__delete_link_1, delete_link_input)
    }
    fn get_links(&self, get_links_input: Vec<GetLinksInput>) -> ExternResult<Vec<Vec<Link>>> {
        host_call::<Vec<GetLinksInput>, Vec<Vec<Link>>>(__hc__get_links_1, get_links_input)
    }
    fn get_link_details(
        &self,
        get_links_input: Vec<GetLinksInput>,
    ) -> ExternResult<Vec<LinkDetails>> {
        host_call::<Vec<GetLinksInput>, Vec<LinkDetails>>(__hc__get_link_details_1, get_links_input)
    }
    fn count_links(&self, query: LinkQuery) -> ExternResult<usize> {
        host_call::<LinkQuery, usize>(__hc__count_links_1, query)
    }
    #[cfg(feature = "unstable-functions")]
    fn block_agent(&self, block_agent_input: BlockAgentInput) -> ExternResult<()> {
        host_call::<BlockAgentInput, ()>(__hc__block_agent_1, block_agent_input)
    }
    #[cfg(feature = "unstable-functions")]
    fn unblock_agent(&self, unblock_agent_input: BlockAgentInput) -> ExternResult<()> {
        host_call::<BlockAgentInput, ()>(__hc__unblock_agent_1, unblock_agent_input)
    }
    fn call(&self, call_input: Vec<Call>) -> ExternResult<Vec<ZomeCallResponse>> {
        host_call::<Vec<Call>, Vec<ZomeCallResponse>>(__hc__call_1, call_input)
    }
    fn emit_signal(&self, app_signal: AppSignal) -> ExternResult<()> {
        host_call::<AppSignal, ()>(__hc__emit_signal_1, app_signal)
    }
    fn send_remote_signal(&self, remote_signal: RemoteSignal) -> ExternResult<()> {
        host_call::<RemoteSignal, ()>(__hc__send_remote_signal_1, remote_signal)
    }
    fn random_bytes(&self, number_of_bytes: u32) -> ExternResult<Bytes> {
        host_call::<u32, Bytes>(__hc__random_bytes_1, number_of_bytes)
    }
    fn sys_time(&self, _: ()) -> ExternResult<Timestamp> {
        host_call::<(), Timestamp>(__hc__sys_time_1, ())
    }
    #[cfg(feature = "unstable-functions")]
    fn schedule(&self, scheduled_fn: String) -> ExternResult<()> {
        host_call::<String, ()>(__hc__schedule_1, scheduled_fn)
    }

    fn x_salsa20_poly1305_shared_secret_create_random(
        &self,
        key_ref: Option<XSalsa20Poly1305KeyRef>,
    ) -> ExternResult<XSalsa20Poly1305KeyRef> {
        host_call::<Option<XSalsa20Poly1305KeyRef>, XSalsa20Poly1305KeyRef>(
            __hc__x_salsa20_poly1305_shared_secret_create_random_1,
            key_ref,
        )
    }

    fn x_salsa20_poly1305_shared_secret_export(
        &self,
        x_salsa20_poly1305_shared_secret_export: XSalsa20Poly1305SharedSecretExport,
    ) -> ExternResult<XSalsa20Poly1305EncryptedData> {
        host_call::<XSalsa20Poly1305SharedSecretExport, XSalsa20Poly1305EncryptedData>(
            __hc__x_salsa20_poly1305_shared_secret_export_1,
            x_salsa20_poly1305_shared_secret_export,
        )
    }

    fn x_salsa20_poly1305_shared_secret_ingest(
        &self,
        x_salsa20_poly1305_shared_secret_ingest: XSalsa20Poly1305SharedSecretIngest,
    ) -> ExternResult<XSalsa20Poly1305KeyRef> {
        host_call::<XSalsa20Poly1305SharedSecretIngest, XSalsa20Poly1305KeyRef>(
            __hc__x_salsa20_poly1305_shared_secret_ingest_1,
            x_salsa20_poly1305_shared_secret_ingest,
        )
    }

    fn x_salsa20_poly1305_encrypt(
        &self,
        x_salsa20_poly1305_encrypt: XSalsa20Poly1305Encrypt,
    ) -> ExternResult<XSalsa20Poly1305EncryptedData> {
        host_call::<XSalsa20Poly1305Encrypt, XSalsa20Poly1305EncryptedData>(
            __hc__x_salsa20_poly1305_encrypt_1,
            x_salsa20_poly1305_encrypt,
        )
    }

    fn create_x25519_keypair(&self, _: ()) -> ExternResult<X25519PubKey> {
        host_call::<(), X25519PubKey>(__hc__create_x25519_keypair_1, ())
    }

    fn x_25519_x_salsa20_poly1305_encrypt(
        &self,
        x_25519_x_salsa20_poly1305_encrypt: X25519XSalsa20Poly1305Encrypt,
    ) -> ExternResult<XSalsa20Poly1305EncryptedData> {
        host_call::<X25519XSalsa20Poly1305Encrypt, XSalsa20Poly1305EncryptedData>(
            __hc__x_25519_x_salsa20_poly1305_encrypt_1,
            x_25519_x_salsa20_poly1305_encrypt,
        )
    }

    fn ed_25519_x_salsa20_poly1305_encrypt(
        &self,
        ed_25519_x_salsa20_poly1305_encrypt: Ed25519XSalsa20Poly1305Encrypt,
    ) -> ExternResult<XSalsa20Poly1305EncryptedData> {
        host_call::<Ed25519XSalsa20Poly1305Encrypt, XSalsa20Poly1305EncryptedData>(
            __hc__ed_25519_x_salsa20_poly1305_encrypt_1,
            ed_25519_x_salsa20_poly1305_encrypt,
        )
    }

    fn create_clone_cell(&self, input: CreateCloneCellInput) -> ExternResult<ClonedCell> {
        host_call::<CreateCloneCellInput, ClonedCell>(__hc__create_clone_cell_1, input)
    }

    fn disable_clone_cell(&self, input: DisableCloneCellInput) -> ExternResult<()> {
        host_call::<DisableCloneCellInput, ()>(__hc__disable_clone_cell_1, input)
    }

    fn enable_clone_cell(&self, input: EnableCloneCellInput) -> ExternResult<ClonedCell> {
        host_call::<EnableCloneCellInput, ClonedCell>(__hc__enable_clone_cell_1, input)
    }

    fn delete_clone_cell(&self, input: DeleteCloneCellInput) -> ExternResult<()> {
        host_call::<DeleteCloneCellInput, ()>(__hc__delete_clone_cell_1, input)
    }

    fn close_chain(&self, input: CloseChainInput) -> ExternResult<ActionHash> {
        host_call::<CloseChainInput, ActionHash>(__hc__close_chain_1, input)
    }

    fn open_chain(&self, input: OpenChainInput) -> ExternResult<ActionHash> {
        host_call::<OpenChainInput, ActionHash>(__hc__open_chain_1, input)
    }

    fn get_validation_receipts(
        &self,
        input: GetValidationReceiptsInput,
    ) -> ExternResult<Vec<ValidationReceiptSet>> {
        host_call::<GetValidationReceiptsInput, Vec<ValidationReceiptSet>>(
            __hc__get_validation_receipts_1,
            input,
        )
    }
}

/// At any time the global HDK can be set to a different hdk.
/// Generally this is only useful during rust unit testing.
/// When executing wasm without the `mock` feature, the host will be assumed.
pub fn set_hdk<H>(hdk: H)
where
    H: HdkT + 'static,
{
    let hdk = Rc::new(hdk);
    let hdk2 = hdk.clone();
    HDK.with(|h| {
        *h.borrow_mut() = hdk2;
    });
    hdi::hdi::HDI.with(|h| {
        *h.borrow_mut() = hdk;
    });
}



================================================
File: crates/hdk/src/info.rs
================================================
use crate::prelude::*;
pub use hdi::info::*;

/// Trivial wrapper for `__agent_info` host function.
/// Agent info input struct is `()` so the function call simply looks like this:
///
/// ```ignore
/// let agent_info = agent_info()?;
/// ```
///
/// the [AgentInfo] is the current agent's original pubkey/address that they joined the network with
/// and their most recent pubkey/address.
pub fn agent_info() -> ExternResult<AgentInfo> {
    HDK.with(|h| h.borrow().agent_info(()))
}

/// Get the context for a zome call, including the provenance and chain head.
///
/// See [CallInfo] for more details of what is returned.
///
/// Call info input struct is `()` so the function call simply looks like this:
///
/// ```ignore
/// let call_info = call_info()?;
/// ```
pub fn call_info() -> ExternResult<CallInfo> {
    HDK.with(|h| h.borrow().call_info(()))
}



================================================
File: crates/hdk/src/lib.rs
================================================
//! The Holochain Development Kit (HDK) provides high and low level functions for writing Holochain applications.
//!
//! Holochain is built as a client-server architecture. The Conductor, Holochain's runtime, acts as the server.
//! Its [Conductor API](https://docs.rs/holochain_conductor_api/latest/holochain_conductor_api) can be queried
//! by a client to manage hApps and send requests to hApp functions.
//! [Read more on Holochain's architecture.](https://developer.holochain.org/concepts/2_application_architecture)
//!
//! Functions of a hApp are organized into reusable components. In Holochain terminology these components are called "zomes".
//! One or multiple zomes are compiled into WebAssembly (WASM) binaries and bundled into a file referred to as a DNA. All of the DNAs of an application are bundled to a hApp.
//! In short, the structure is __hApp -> DNA -> zome -> function__.
//!
//! hApps can be developed using the HDK. See the [Holochain Quick Start Guide](https://developer.holochain.org/quick-start)
//! to get started with hApp development.
//!
//! # Example zomes 
//!
//! There are numerous example/test WASMs on many aspects of hApp development that can be browsed
//! [on Github](https://github.com/holochain/holochain/tree/develop/crates/test_utils/wasm/wasm_workspace).
//!
//! Each example WASM is a minimal demonstration of specific HDK functionality, such as generating random data, creating entries or defining validation callbacks.
//! Some of the examples are very contrived, none are intended as production grade hApp examples, but do highlight key functionality.
//!
//! # Zomes are separated into data model and domain logic
//!
//! hApps are required to produce and validate data deterministically. There's a data model and a domain logic part to each hApp. In Holochain, the
//! data model is defined in integrity zomes and the domain logic is written in coordinator zomes.
//!
//! ## Integrity zomes 
//!
//! Integrity zomes describe a hApp's domain model by defining a set of entry and link types and providing a validation callback
//! function that checks the integrity of any operations that manipulate data of those types.
//! Additionally, a genesis self-check callback can be implemented for basic verification
//! of the data that allows an agent to join a network before they attempt to join it.
//!
//! The wasm workspace contains examples of integrity zomes like this:
//! <https://github.com/holochain/holochain/blob/develop/crates/test_utils/wasm/wasm_workspace/integrity_zome/src/lib.rs>
//!
//! Refer to the [HDI crate](crate::prelude::hdi) for more information on the integrity layer.
//!
//! ## Coordinator zomes 
//!
//! Coordinator zomes are the counterpart of integrity zomes in a DNA. They contain the domain logic of how data is read and written.
//! Whereas data is defined and validated in integrity zomes, functions to manipulate data are implemented in coordinator zomes.
//!
//! An example coordinator zome can be found in the wasm workspace of the Holochain repository:
//! <https://github.com/holochain/holochain/blob/develop/crates/test_utils/wasm/wasm_workspace/coordinator_zome/src/lib.rs>.
//!
//! # HDK structure 
//!
//! HDK implements several key features:
//!
//! - Base HDKT trait for standardisation, mocking, unit testing support: [`hdk`] module
//! - Capabilities and function level access control: [`capability`] module
//! - [Holochain Deterministic Integrity (HDI)]
//! - Application data and entry definitions for the source chain and DHT: [`entry`]
//!   module and [entry_types] callback
//! - Referencing/linking entries on the DHT together into a graph structure: [`link`] module
//! - Defining tree-like structures out of links and entries for discoverability and scalability: [`hash_path`] module
//! - Create, read, update, delete (CRUD) operations on the above
//! - Libsodium compatible symmetric/secret (secretbox) and asymmetric/keypair (box) encryption: [`x_salsa20_poly1305`] module
//! - Ed25519 signing and verification of data: [`ed25519`] module
//! - Exposing information about the current execution context such as zome name: [`info`] module
//! - Other utility functions provided by the host such as generating randomness and timestamps that are impossible in WASM: utility module
//! - Exposing functions to external processes and callbacks to the host: [`hdk_extern!`](macro@crate::prelude::hdk_extern) and [`map_extern!`](macro@crate::prelude::map_extern) macros
//! - Integration with the Rust [tracing](https://docs.rs/tracing/0.1.23/tracing/) crate
//! - Exposing a [`prelude`] of common types and functions for convenience
//!
//! Generally these features are structured logically into modules but there are some affordances to the layering of abstractions.
//!
//!
//! # HDK is based on callbacks 
//!
//! The only way to execute logic inside WASM is by having the conductor (host) call a function that is marked as an `extern` by the zome (guest).
//!
//! > Note: From the perspective of hApp development in WASM, the "guest" is the WASM and the "host" is the running Holochain conductor.
//! > The host is _not_ the "host operating system" in this context.
//!
//! Similarly, the only way for the guest to do anything other than process data and calculations is to call functions the host provides to it at runtime.
//!
//! Host functions are all defined by the Holochain conductor and implemented by HDK for you, but the guest functions need to all be defined by your application.
//!
//! > Any WASM that does _not_ use the HDK will need to define placeholders for and the interface to the host functions.
//!
//! All host functions can be called directly as:
//!
//! ```ignore
//! use crate::prelude::*;
//! let _output: HDK.with(|h| h.borrow().host_fn(input));
//! ```
//!
//! And every host function defined by Holochain has a convenience wrapper in HDK that does the type juggling for you.
//!
//! Low-level communication between the conductor and WASM binaries, like typing and serialization of data, is abstracted by the HDK.
//! Using the HDK, hApp developers can focus on their application's logic. [Learn more about WASM in Holochain.](https://github.com/holochain/holochain/blob/develop/crates/hdk/ON-WASM.md)
//!
//! ## External callbacks = Zome functions
//!
//! To extend a Rust function so that it can be called by the host, add the [`hdk_extern!`](macro@crate::prelude::hdk_extern) attribute.
//!
//! - The function may take _none_ or _one_ argument that, if provided, must implement `serde::Serialize + std::fmt::Debug`.
//! - The function must return an `ExternResult` where the success value implements `serde::Serialize + std::fmt::Debug`
//! - The function must have a unique name across all externs as they share a global namespace in WASM
//! - Everything inside the function is Rust-as-usual including `?` to interact with `ExternResult` that fails as `WasmError`
//! - Use the [`wasm_error!`](crate::prelude::wasm_error) macro along with the
//!   [`WasmErrorInner::Guest`](crate::prelude::WasmErrorInner::Guest) variant for failure conditions that the host or
//!   external processes need to be aware of
//! - Externed functions can be called as normal by other functions inside the same WASM
//!
//! For example:
//!
//! ```ignore
//! use crate::prelude::*;
//!
//! // This function can be called by any external process that can provide and accept messagepack serialized u32 integers.
//! #[hdk_extern]
//! pub fn increment(u: u32) -> ExternResult<u32> {
//!   Ok(u + 1)
//! }
//!
//! // Extern functions can be called as normal by other rust code.
//! assert_eq!(2, increment(1));
//! ```
//!
//! Most externs are simply available to external processes and must be called explicitly e.g. via RPC over websockets.
//! The external process only needs to ensure the input and output data is handled correctly as messagepack.
//!
//! ## Internal callbacks
//!
//! Some externs act as callbacks the host will call at key points in Holochain internal system workflows.
//! These callbacks allow the guest to define how the host proceeds at those decision points. They are defined in zomes like
//! extern callbacks above, but have reserved names listed below.
//!
//! Callbacks are simply called by name and they are "sparse" in that they are matched incrementally from the most specific
//! name to the least specific name. For example, the `validate_{{ create|update|delete }}_{{ agent|entry }}` callbacks will
//! all match and all run during validation. All function components with multiple options are optional, e.g. `validate` will execute and so will `validate_create`.
//!
//! Holochain will merge multiple callback results for the same callback in a context sensitive manner. For example, the host will consider initialization failed if _any_ init callback fails.
//!
//! The callbacks are (see above for examples):
//!
//! - `fn entry_defs() -> ExternResult<EntryDefsCallbackResult>`:
//!   - Typically implemented automatically by macros in the HDK so does NOT
//!     require writing the extern for it manually.
//!   - `EntryDefs` is a vector defining all entries used by this app.
//!   - All zomes in a DNA define all their entries at the same time for the host.
//!   - All entry defs are combined into a single ordered list per zome and exposed to tooling such as DNA generation.
//!   - Entry defs are referenced by `u8` numerical position externally and in DHT actions, and by id/name e.g. "post" in sparse callbacks.
//! - `fn genesis_self_check(_: GenesisSelfCheckData) -> ExternResult<ValidateCallbackResult>`:
//!   - Allows each agent to validate itself before attempting to join the
//!     network.
//!   - Receives `GenesisSelfCheckData` that includes DNA information, the agent
//!     key for the candidate source chain and the membrane proof.
//!   - Runs _before the agent exists on the network_ so has no ability to use
//!     the network and generally only has access to deterministic HDK functions.
//! - `fn init() -> ExternResult<InitCallbackResult>`:
//!   - Allows the guest to pass/fail/retry initialization with [`InitCallbackResult`](crate::prelude::holochain_zome_types::init::InitCallbackResult).
//!   - Lazy execution - only runs when any zome of the DNA is first called.
//!   - All zomes in a DNA init at the same time.
//!   - Any zome failure fails initialization for the DNA, any zome retry (missing dependencies) causes the DNA to retry.
//!   - Failure overrides retry.
//!   - See [`create_cap_grant`](crate::capability::create_cap_grant) for an explanation of how to set up capabilities in `init`.
//! - `fn migrate_agent_{{ open|close }} -> ExternResult<MigrateAgentCallbackResult>`:
//!   - Allows the guest to pass/fail a migration attempt to/from another DNA.
//!   - Open runs when an agent is starting a new source chain from an old one.
//!   - Close runs when an agent is deprecating an old source chain in favour of a new one.
//!   - All zomes in a DNA migrate at the same time.
//!   - Any failure fails the migration.
//! - `fn post_commit(actions: Vec<SignedActionHashed>)`:
//!   - Executes after the WASM call that originated the commits so not bound by the original atomic transaction.
//!   - Input is all the action hashes that were committed.
//!   - The zome that originated the commits is called.
//! - `fn validate(op: Op) -> ExternResult<ValidateCallbackResult>`:
//!   - Allows the guest to pass/fail/retry any operation.
//!   - Only the originating zome is called.
//!   - Failure overrides retry.
//!
//! # HDK has layers 
//!
//! HDK is designed in layers so that there is some kind of 80/20 rule.
//! The code is not strictly organised this way but you'll get a feel for it as you write your own hApps.
//!
//! Roughly speaking, 80% of your apps can be production ready using just 20% of the HDK features and code.
//! These are the 'high level' functions such as [`crate::entry::create_entry`] and macros like [`hdk_extern!`](macro@crate::prelude::hdk_extern).
//! Every Holochain function is available with a typed and documented wrapper and there is a set of macros for exposing functions and defining entries.
//!
//! The 20% of the time that you need to go deeper there is another layer followng its own 80/20 rule.
//! 80% of the time you can fill the gaps from the layer above with `host_call` or by writing your own entry definition logic.
//! For example you may want to implement generic type interfaces or combinations of structs and enums for entries that isn't handled out of the box.
//!
//! If you need to go deeper still, the next layer is the `holochain_wasmer_guest`, `holochain_zome_types` and `holochain_serialization` crates.
//! Here you can customise exactly how your externally facing functions are called and how they serialize data and memory.
//! Ideally you never need to go this far but there are rare situations that may require it.
//! For example, you may need to accept data from an external source that cannot be messagepack serialized (e.g. json), or you may want to customise the tracing tooling and error handling.
//!
//! The lowest layer is the structs and serialization that define how the host and the guest communicate.
//! You cannot change this but you can reimplement it in your language of choice (e.g. Haskell?) by referencing the Rust zome types and extern function signatures.
//!
//!
//! # HDK is atomic on the source chain 
//!
//! [Read up on what the source chain is in Holochain.](https://developer.holochain.org/concepts/3_source_chain)
//!
//! All writes to the source chain are atomic within a single extern/callback call.
//!
//! This means __all data will validate and be written together or nothing will__.
//!
//! There are no such guarantees for other side effects. Notably we cannot control anything over the network or outside the Holochain database.
//!
//! Remote calls will be atomic on the recipients device but could complete successfully while the local agent subsequently errors and rolls back their chain.
//! This means you should not rely on data existing _between_ agents unless you have another source of integrity such as cryptographic countersignatures.
//!
//! Use a post commit hook and signals or remote calls if you need to notify other agents about completed commits.
//!
//!
//! # HDK should be pinned 
//!
//! The basic functionality of the HDK is to communicate with the Holochain conductor using a specific typed interface.
//!
//! If any of the following change relative to the conductor your WASM _will_ have bugs:
//!
//! - Shared types used by the host and guest to communicate
//! - Serialization logic that generates bytes used by cryptographic algorithms
//! - Negotiating shared memory between the host and guest
//! - Functions available to be called by the guest on the host
//! - Callbacks the guest needs to provide to the host
//!
//! For this reason we have dedicated crates for serialization and memory handling that rarely change.
//! HDK references these crates with `=x.y.z` syntax in Cargo.toml to be explicit about this.
//!
//! HDK itself has a slower release cycle than the Holochain conductor by design to make it easier to pin and track changes.
//!
//! You should pin your dependency on HDK using the `=x.y.z` syntax too!
//!
//! You do _not_ need to pin _all_ your Rust dependencies, just those that take part in defining the host/guest interface.
//!
//!
//! # HDK is integrated with rust tracing for better debugging 
//!
//! Every extern defined with the [`hdk_extern!`](macro@crate::prelude::hdk_extern) attribute registers a [tracing subscriber](https://crates.io/crates/tracing-subscriber) that works in WASM.
//!
//! All the basic tracing macros `trace!`, `debug!`, `warn!`, `error!` are implemented.
//!
//! However, tracing spans currently do _not_ work, if you attempt to `#[instrument]`, you will likely panic your WASM.
//!
//! WASM tracing can be filtered at runtime using the `WASM_LOG` environment variable that works exactly as `RUST_LOG` does for the Holochain conductor and other Rust binaries.
//!
//! The most common internal errors, such as invalid deserialization between WASM and external processes, are traced as `error!` by default.
//!
//!
//! # HDK requires explicit error handling between the guest and host 
//!
//! All calls to functions provided by the host can fail to execute cleanly, at the least serialization could always fail.
//!
//! There are many other possibilities for failure, such as a corrupt database or attempting cryptographic operations without a key.
//!
//! When the host encounters a failure `Result`, it will __serialize the error and pass it back to the WASM guest__.
//! The __guest must handle this error__ and either return it back to the host which _then_ rolls back writes (see above), or implement some kind of graceful failure or retry logic.
//!
//! The `Result` from the host in the case of host calls indicates whether the execution _completed_ successfully and is _in addition to_ other Result-like enums.
//! For example, a remote call can be `Ok` from the host's perspective but contain an
//! [`ZomeCallResponse::Unauthorized`](crate::prelude::ZomeCallResponse::Unauthorized) "failure" enum variant from the remote agent.
//! Both need to be handled in context.

pub use hdi::HDI_VERSION;

/// Current HDK rust crate version.
pub const HDK_VERSION: &str = env!("CARGO_PKG_VERSION");

#[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
const ERAND_INTERNAL: u32 = getrandom::Error::CUSTOM_START + 1;

#[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
const ERAND_TOO_LONG: u32 = getrandom::Error::CUSTOM_START + 2;

#[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
fn wasm_getrandom(buf: &mut [u8]) -> Result<(), getrandom::Error> {
    if buf.len() > u32::MAX as usize {
        let code = core::num::NonZeroU32::new(ERAND_TOO_LONG).unwrap();
        return Err(getrandom::Error::from(code));
    }
    let number_of_bytes = buf.len() as u32;
    match crate::hdk::HDK.with(|h| h.borrow().random_bytes(number_of_bytes)) {
        Err(_) => {
            let code = core::num::NonZeroU32::new(ERAND_INTERNAL).unwrap();
            return Err(getrandom::Error::from(code));
        }
        Ok(bytes) => {
            if bytes.len() != buf.len() {
                let code = core::num::NonZeroU32::new(ERAND_INTERNAL).unwrap();
                return Err(getrandom::Error::from(code));
            }
            buf.copy_from_slice(&bytes);
        }
    }
    Ok(())
}

#[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
getrandom::register_custom_getrandom!(wasm_getrandom);

pub mod agent;

/// Capability claims and grants.
///
/// Every exposed function in Holochain uses capability grants/claims to secure
/// access.Capability grants are system entries committed to the source chain
/// that define access. Capability claims are system entries that reference a
/// grant on a source chain.
///
/// # Examples
/// <https://github.com/holochain/holochain/blob/develop/crates/test_utils/wasm/wasm_workspace/capability/src/coordinator.rs>
///
/// 0. When Alice wants Bob to be able to call a function on her running conductor she commits a grant for Bob.
/// 0. Bob commits the grant as a claim on his source chain.
/// 0. When Bob wants to call Alice's function he sends the claim back to Alice along with the function call information.
/// 0. Alice cross references Bob's claim against her grant, e.g. to check it is still valid, before granting access.
///
/// There are four types of capability grant:
///
/// - Author: The author of the local source chain provides their agent key as a claim and has full access to all functions.
/// - Unrestricted: Anyone can call this function without providing a claim.
/// - Unassigned: Anyone with the randomly generated secret associated with the grant can call this function.
/// - Assigned: The specific named agents can call this function if they provide the associated secret.
///
/// Capability grants and claims reference each other by a shared, unique, unpredictable secret.
/// The security properties of a capability secret are roughly the same as an API key for a server.
///
/// - If an attacker knows or guesses the secret they can call Unassigned functions
/// - An attacker cannot call Assigned functions even if they know or guess the secret
/// - If a secret is compromised the grant can be deleted and new claims can be distributed
/// - The secret only grants access to live function calls against a running conductor reachable on the network
/// - Holochain compares capability secrets using constant time equality checks to mitigate timing attacks
/// - Grant secrets are stored in WASM memory so are NOT as secure as a dedicated keystore
///
/// Grant secrets are less sensitive than cryptographic keys but are not intended to be public data.
/// Don't store them to the DHT in plaintext, or commit them to Github repositories, etc!
///
/// For best security, assign grants to specific agents if you can as the assignment check _does_ cryptographically validate the caller.
///
// @todo in the future grant secrets may be moved to lair somehow.
pub mod capability;

/// Signing a single chain entry between multiple participants.
///
/// The basic goal is to enable a kind of atomicity across multiple source chains
/// in an environment where countersigners trust each other in some ways but not
/// entirely. Countersigning provides several trust models, including nominating
/// a single party to gather signatures, M of N signers, majority signing buckets,
/// etc.
///
/// The integrity layer enforces very little other than the structure of a
/// countersigned entry, to define the session parameters and uniqueness and final
/// signature set. Implementations are expected to drive countersigning sessions
/// through coordinator zomes based on understanding both the expected network
/// topologies and trust between peers on the network.
///
/// As various models for driving and finalising systems on the network are
/// defined and implemented they all end up in the countersigning crate.
///
/// This is a network level implementation of countersigning which has pros and
/// cons. There are also cryptographic methods of countersigning such as
/// threshold signatures that produce a single proof between multiple
/// participants, which are NOT included in this crate.
#[cfg(feature = "unstable-countersigning")]
pub mod countersigning;

/// Working with app and system entries.
///
/// Most Holochain applications will define their own app entry types.
///
/// App entries are all entries that are not system entries.
/// Definitions of entry types belong in the integrity zomes of a DNA. In contrast, operations
/// for manipulating entries go into coordinator zomes.
///
/// # Examples
///
/// Refer to the WASM workspace in the Holochain repository for examples.
/// Here's a simple example of an entry definition:
/// <https://github.com/holochain/holochain/blob/develop/crates/test_utils/wasm/wasm_workspace/entry_defs/src/integrity.rs>
///
/// An example of a coordinator zome with functions to manipulate entries:
/// <https://github.com/holochain/holochain/blob/develop/crates/test_utils/wasm/wasm_workspace/coordinator_zome/src/lib.rs>
///
/// # CRUD
///
/// CRUD in Holochain is represented as a graph/tree of Records referencing each other (via Action hashes), representing new states of a shared identity.
/// Because the network is always subject to the possibility of partitions, there is no way to assert an objective truth about the 'current' or 'real' value that all participants will agree on.
/// This is a key difference between Holochain and blockchains.
/// Where blockchains define a consensus algorithm that brings all participants as close as possible to a single value, while Holochain lets each participant discover their own truth.
///
/// The practical implication of this is that agents fetch as much information as they can from the network, then follow an algorithm to 'walk' or 'reduce' the revisions and discover 'current' for themselves.
///
/// In Holochain terms, blockchain consensus is walking all the known 'updates' (blocks) that pass validation, then walking/reducing down them to disover the 'chain with the most work' or similar.
/// For example, to implement a blockchain in Holochain, attach a proof of work to each update and then follow the updates with the most work to the end.
///
/// There are many other ways to discover the correct path through updates, for example a friendly game of chess between two players could involve consensual re-orgs or 'undos' of moves by countersigning a different update higher up the tree, to branch out a new revision history.
///
/// Two agents with the same information may even disagree on the 'correct' path through updates and this may be valid for a particular application.
/// For example, an agent could choose to 'block' another agent and ignore all their updates.
pub mod entry;

pub use hdi;
pub use hdi::entry_types;

pub mod hash;

pub mod hash_path;

/// Maps a Rust function to an extern that WASM can expose to the Holochain host.
///
/// Annotate any compatible function with [`hdk_extern!`] to expose it to Holochain as a WASM extern.
/// The [`map_extern!`](crate::map_extern!) macro is used internally by the [`hdk_extern!`] attribute.
///
/// Compatible functions:
///
/// - Have a globally unique name
/// - Accept `serde::Serialize + std::fmt::Debug` input
/// - Return `Result<O, WasmError>` (`ExternResult`) output where `O: serde::Serialize + std::fmt::Debug`
///
/// This module only defines macros so check the HDK crate root to see more documentation.
///
/// A _new_ extern function is created with the same name as the function with the [`hdk_extern!`] attribute.
/// The new extern is placed in a child module of the current scope.
/// This new extern is hoisted by WASM to share a global namespace with all other externs so names must be globally unique even if the base function is scoped.
///
/// The new extern handles:
///
/// - Extern syntax for Rust
/// - Receiving the serialized bytes from the host at a memory pointer specified by the guest
/// - Setting the HDK WASM tracing subscriber as the global default
/// - Deserializing the input from the host
/// - Calling the function annotated with [`hdk_extern!`]
/// - Serializing the result
/// - Converting the serialized result to a memory pointer for the host
/// - Error handling for all the above
///
/// If you want to do something different to the default you will need to understand and reimplement all the above.
///
/// [`hdk_extern!`]: hdk_derive::hdk_extern
pub mod map_extern;

/// Exports common types and functions according to the Rust prelude pattern.
pub mod prelude;

/// Encryption and decryption using the (secret)box algorithms popularised by Libsodium.
///
/// Libsodium defines and implements two encryption functions `secretbox` and `box`.
/// The former implements shared secret encryption and the latter does the same but with a DH key exchange to generate the shared secret.
/// This has the effect of being able to encrypt data so that only the intended recipient can read it.
/// This is also repudiable so both participants know the data must have been encrypted by the other (because they didn't encrypt it themselves) but cannot prove this to anybody else (because they _could have_ encrypted it themselves).
/// If repudiability is not something you want, you need to use a different approach.
///
/// Note that the secrets are located within the secure lair keystore and never touch WASM memory.
// @todo actually secretbox puts the secret in WASM, but this will be fixed soon
/// The WASM must provide either the public key for box or an opaque _reference_ to the secret key so that lair can encrypt or decrypt as required.
//
// @todo implement a way to export/send an encrypted shared secret for a peer from lair
///
/// Note that even though the elliptic curve is the same as is used by ed25519, the keypairs cannot be shared because the curve is mathematically translated in the signing vs. encryption algorithms.
/// In theory the keypairs could also be translated to move between the two algorithms but Holochain doesn't offer a way to do this (yet?).
/// Create new keypairs for encryption and save the associated public key to your local source chain, and send it to peers you want to interact with.
pub mod x_salsa20_poly1305;

/// Rexporting the paste macro as it is used internally and may help structure downstream code.
pub use paste;

/// Tools to interrogate source chains.
///
/// Interacting with a source chain is very different to the DHT.
///
/// - Source chains have a linear history guaranteed by action hashes
/// - Source chains have a single owner/author signing every chain record
/// - Source chains can be iterated over from most recent back to genesis by following the action hashes as references
/// - Source chains contain interspersed system and application entries
/// - Source chains contain both private (local only) and public (broadcast to DHT) records
///
/// There is a small DSL provided by `query` that allows for inspecting the current agent's local source chain.
/// Typically it will be faster, more direct and efficient to query local data than dial out to the network.
/// It is also possible to query local private entries.
///
/// Agent activity for any other agent on the network can be fetched.
/// The agent activity is _only the actions_ of the remote agent's source chain.
/// Agent activity allows efficient building of the history of an agent.
/// Agent activity is retrieved from a dedicated neighbourhood near the agent.
/// The agent's neighbourhood also maintains a passive security net that guards against attempted chain forks and/or rollbacks.
/// The same query DSL for local chain queries is used to filter remote agent activity actions.
pub mod chain;

/// Create and verify signatures for serializable Rust structures and raw binary data.
///
/// The signatures are always created with the [Ed25519](https://en.wikipedia.org/wiki/EdDSA) algorithm by the secure keystore (lair).
///
/// Agent public keys that identify agents are the public half of a signing keypair.
/// The private half of the signing keypair never leaves the secure keystore and certainly never touches WASM.
///
/// If a signature is requested for a public key that has no corresponding private key in lair, the signing will fail.
///
/// Signatures can always be verified with the public key alone so can be done remotely (by other agents) and offline, etc.
///
/// The elliptic curve used by the signing algorithm is the same as the curve used by the encryption algorithms but is _not_ constant time (because signature verification doesn't need to be).
///
/// In general it is __not a good idea to reuse signing keys for encryption__ even if the curve is the same, without mathematically translating the keypair, and even then it's dubious to do so.
pub mod ed25519;

/// Request contextual information from the Holochain host.
///
/// The Holochain host has additional runtime context that the WASM may find useful and cannot produce for itself including:
///
/// - The calling agent
/// - The current app (bundle of DNAs)
/// - The current DNA
/// - The current Zome
/// - The function call itself
pub mod info;

/// Links in Holochain are analogous to a join table in a traditional SQL schema.
///
/// Links embody navigable graph structures between entires in a more general format than CRUD trees.
///
/// At a high level:
///
/// - Can implement direct or indirect circular references
/// - Reference data by its hash
/// - Have a base and target entry, action or external hash
/// - Can either exist or be deleted (i.e. there is no revision history, deleting removes a link permanently)
/// - Many links can point from/to the same hash
/// - Links reference entry hashes not actions
///
/// Links are retrived from the DHT by performing [ `link::get_links` ] or [ `link::get_link_details` ] against the _base_ of a link.
///
/// Links also support short (about 500 bytes) binary data to encode contextual data on a domain specific basis.
///
/// __Links are not entries__, there is only an action with no associated entry, so links cannot reference other links or maintain or participate in a revision history.
pub mod link;

/// Methods for interacting with peers in the same DHT network.
///
/// Data on the DHT generally propagates at the speed of gossip and must be explicitly polled and retrieved.
///
/// Often we want more responsive and direct interactions between peers.
/// These interactions come in two flavours, RPC style function calls and notification style 'signals'.
///
/// All function calls use capability grants and claims to authenticate and authorize.
/// Signals simply forward information about the introduction of new data on the DHT so that agents can push updates to each other rather than relying purely on polling.
//
// @todo introduce a pubsub mechanism
pub mod p2p;

/// Integrates HDK with the Rust tracing crate.
///
/// The functions and structs in this module do _not_ need to be used directly.
/// The [`hdk_extern!`] attribute on functions exposed externally all set the `WasmSubscriber` as the global default.
///
/// This module defines a [ `trace::WasmSubscriber` ] that forwards all tracing macro calls to another subscriber on the host.
/// The logging level can be changed for the host at runtime using the `WASM_LOG` environment variable that works exactly as `RUST_LOG` for other tracing.
///
/// [`hdk_extern!`]: hdk_derive::hdk_extern
pub mod trace;

/// Everything related to inspecting or responding to time.
///
/// Currently only fetching the host's opinion of the local time is supported.
//
// @todo implement scheduled execution and sleeping
pub mod time;

/// Generate cryptographic strength random data
///
/// The host provides the random bytes because any/all WASM implementations of randomness is flawed and insecure.
pub mod random;

/// The interface between the host and guest is implemented as an `HdkT` trait.
///
/// The `set_hdk` function globally sets a `RefCell` to track the current HDK implementation.
/// When the `mock` feature is set then this will default to an HDK that always errors, else a WASM host is assumed to exist.
/// The `mockall` crate (in prelude with `mock` feature) can be used to generate compatible mocks for unit testing.
/// See mocking examples in the test WASMs crate, such as `agent_info`.
pub mod hdk;

/// Create and manage clone cells in the current app.
///
/// Clone cells are a way to create a new cell that is a copy of an existing cell. They are based on the DNA of an existing cell, and run
/// with the same agent key, but have a unique name or properties that distinguish them from the original cell.
pub mod clone;

/// Tools for working with migrations from one DNA to another.
mod migrate;

/// Look up validation receipts for actions that a local agent has authored.
pub mod validation_receipt;



================================================
File: crates/hdk/src/link.rs
================================================
use crate::prelude::*;

pub mod builder;

pub use builder::*;
pub use hdi::link::*;

/// Create a link from a base hash to a target hash, with an optional tag.
///
/// Links represent the general idea of relationships between data.
///
/// Links are different from the tree of CRUD relationships:
///
/// Links:
///
/// - reference two hashes, base and target, and can be a local entry/action or some external hash
/// - there is only one way to create a link, validation logic depends on only the base+target+tag
/// - can represent circular references because only hashes are needed
/// - support arbitrary bytes of data (i.e. "tag") that can be read or used to filter gets
/// - deletes always point to a _specific_ link creation event, not the link itself
/// - model dynamic sets of or relationships between things
/// - can reference any hash regardless of type (e.g. posts can link to comments)
///
/// Note: There is a hard limit of 1kb of data for the tag.
///
/// CRUD:
///
/// - creates reference a single entry
/// - updates and deletes reference create/update records by both their entry+action
/// - creates, updates and deletes all have different functions, network ops and validation logic
/// - is cryptographically guaranteed to be a DAG (not-circular) because they include actions
/// - model "mutability" for a single thing/identity in an immutable/append-only way
/// - only reference other entries of the same entry type (e.g. comments can _not_ update posts)
///
/// See [ `get_details` ] and get for more information about CRUD
/// See [ `get_links` ] and [ `get_link_details` ] for more information about filtering by tag
///
/// Generally links and CRUDs _do not interact_ beyond the fact that links need hashes to
/// reference for the base and target to already exist due to a prior create or update.
/// The referenced data only needs to exist on the DHT for the link to validate, it doesn't need to be
/// live and can have any combination of valid/invalid crud actions.
/// i.e. if you use link_entries! to create relationships between two entries, then update_entry
/// on the base, the links will still only be visible to get_link(s_details)! against the original
/// base, there is no logic to "bring forward" links to the updated entry because:
///
/// - as per CRUD tree docs there is no "one size fits all" way to walk a tree of CRUDs
/// - links are very generic and could even represent a comment thread against a specific revision
///   such as those found against individual updates in a wiki/CMS tool so they need to stay where
///   they were explicitly placed
/// - it would actually be pretty crazy at the network layer to be gossiping links around to chase
///   the "current revision" even if you could somehow unambiguously define "current revision"
///
/// This can be frustrating if you want "get all the links" for an entry but also be tracking your
/// revision history somehow.
/// A simple pattern to workaround this is to create an immutable (updates and deletes are invalid)
/// "identity" entry that links reference and is referenced as a field on the entry struct of each
/// create/update action.
/// If you have the hash of the identity entry you can get all the links, if you have the entry or
/// action hash for any of the creates or updates you can lookup the identity entry hash out of the
/// body of the create/update entry.
pub fn create_link<T, E>(
    base_address: impl Into<AnyLinkableHash>,
    target_address: impl Into<AnyLinkableHash>,
    link_type: T,
    tag: impl Into<LinkTag>,
) -> ExternResult<ActionHash>
where
    ScopedLinkType: TryFrom<T, Error = E>,
    WasmError: From<E>,
{
    let ScopedLinkType {
        zome_index,
        zome_type: link_type,
    } = link_type.try_into()?;
    HDK.with(|h| {
        h.borrow().create_link(CreateLinkInput::new(
            base_address.into(),
            target_address.into(),
            zome_index,
            link_type,
            tag.into(),
            ChainTopOrdering::default(),
        ))
    })
}

/// Delete a specific link creation record.
///
/// Links are defined by a [OR-Set CRDT](https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type#OR-Set_(Observed-Remove_Set))
/// of "Creates" and "Deletes".
/// The deletes form a "tombstone set", each of which can nullify one of the creates.
/// A link only "exists" if it has one or more "creates" which have not been nullified by a "delete".
///
/// For this reason the delete references the Create Action, not the Entry.
/// Even more than that, both creates and deletes are _only_ actions, there is no separate entry
/// and the delete is not simply a renamed mirror of the create (i.e. with base and target).
///
/// Consider what would happen if the system simply had "create link" and "delete link" pointing at
/// the base and target without pairing:
/// - there would be no way to revert a specific link creation
/// - a delete may be intended for an create you haven't seen yet, so network unpredictability
///   would cause re-ording of any view on create/deletes which means an agent can see more deletes
///   than creates, etc.
/// - there would only be two ways to summarise the state of a relationship between two entries,
///   either "there are N more/less creates than deletes" or "there is at least one delete", the
///   former leads to flakiness as above and the latter means it would be impossible to create a
///   link after any previous delete of any link.
///
/// All of this is bad so link creates point to entries (See [ `create_link` ]) and deletes point to
/// creates.
pub fn delete_link(address: ActionHash) -> ExternResult<ActionHash> {
    HDK.with(|h| {
        h.borrow()
            .delete_link(DeleteLinkInput::new(address, ChainTopOrdering::default()))
    })
}

/// Returns all links that reference a base hash, filtered by link type and other criteria.
/// Use a [ `GetLinksInputBuilder` ] to create the [ `GetLinksInput` ] and optionally filter links further.
///
/// _Note this will only get links that are defined in dependent integrity zomes._
///
/// Tag filtering is a simple bytes prefix.
///
/// e.g. if you had these links:
///   - a: `[ 1, 2, 3]`
///   - b: `[ 1, 2, 4]`
///   - c: `[ 1, 3, 5]`
///
/// Then tag filters:
///   - `[ 1 ]` returns `[ a, b, c]`
///   - `[ 1, 2 ]` returns `[ a, b ]`
///   - `[ 1, 2, 3 ]` returns `[ a ]`
///   - `[ 5 ]` returns `[ ]` (does _not_ return c because the filter is by "prefix", not "contains")
///
/// This is mostly identical to [ `get_link_details` ] but returns only creates that have not been
/// deleted, whereas `get_link_details` returns all the creates and all the deletes together.
/// Also note that, unlike when [ `get` ] is used to retrieve an entry, links that
/// only differ by author and creation time are not deduplicated; hence, you may receive multiple
/// links with the same base, tag, and target.
///
/// See [ `get_link_details` ].
pub fn get_links(input: GetLinksInput) -> ExternResult<Vec<Link>> {
    Ok(HDK
        .with(|h| h.borrow().get_links(vec![input]))?
        .into_iter()
        .flatten()
        .collect())
}

/// Get all link creates and deletes that reference a base hash, optionally filtered by type or tag.
///
/// Type can be filtered by providing a variant of the link types, or a range of them. To get links of
/// all types, the full range operator can be used: `get_links(base, .., None)`. Furthermore, vectors of
/// link types can be passed in to specify multiple types. Refer to the `get_links` function in
/// [this coordinator zome](https://github.com/holochain/holochain/blob/develop/crates/test_utils/wasm/wasm_workspace/link/src/coordinator.rs)
/// for several examples.
///
/// Tag filtering is a simple bytes prefix.
///
/// e.g. if you had these links:
///   - a: `[ 1, 2, 3]`
///   - b: `[ 1, 2, 4]`
///   - c: `[ 1, 3, 5]`
///
/// then tag filters:
///   - `[ 1 ]` returns `[ a, b, c]`
///   - `[ 1, 2 ]` returns `[ a, b ]`
///   - `[ 1, 2, 3 ]` returns `[ a ]`
///   - `[ 5 ]` returns `[ ]` (does _not_ return c because the filter is by "prefix", not "contains")
///
/// This is mostly identical to get_links but it returns all the creates and all the deletes.
/// c.f. get_links that returns only the creates that have not been deleted.
///
/// See [ `get_links` ].
pub fn get_link_details(
    base: impl Into<AnyLinkableHash>,
    link_type: impl LinkTypeFilterExt,
    link_tag: Option<LinkTag>,
    get_options: GetOptions,
) -> ExternResult<LinkDetails> {
    Ok(HDK
        .with(|h| {
            let mut input = GetLinksInputBuilder::try_new(base.into(), link_type)?;
            if let Some(link_tag) = link_tag {
                input = input.tag_prefix(link_tag);
            }
            input = input.get_options(get_options.strategy);
            h.borrow().get_link_details(vec![input.build()])
        })?
        .into_iter()
        .next()
        .unwrap())
}

pub fn count_links(query: LinkQuery) -> ExternResult<usize> {
    HDK.with(|h| h.borrow().count_links(query))
}



================================================
File: crates/hdk/src/map_extern.rs
================================================
pub use hdi::map_extern::*;

/// Hides away the gross bit where we hook up integer pointers to length-prefixed guest memory
/// to serialization and deserialization, and returning things to the host, and memory allocation
/// and deallocation.
///
/// A lot of that is handled by the holochain_wasmer crates but this handles the boilerplate of
/// writing an extern function as they have awkward input and output signatures:
///
/// - requires remembering `#[no_mangle]`
/// - requires remembering pub extern "C"
/// - requires juggling GuestPtr on the input and output with the memory/serialization
/// - doesn't support Result returns at all, so breaks things as simple as `?`
///
/// This can be used directly as `map_extern!(external_facing_fn_name, internal_fn_name)` but it is
/// more idiomatic to use the `#[hdk_extern]` attribute
///
/// ```ignore
/// #[hdk_extern]
/// pub fn foo(foo_input: FooInput) -> ExternResult<FooOutput> {
///  // ... do stuff to respond to incoming calls from the host to "foo"
/// }
/// ```
#[macro_export]
macro_rules! map_extern {
    ( $name:tt, $f:ident, $input:ty, $output:ty ) => {
        $crate::prelude::hdi::map_extern!($name, $f, $input, $output);
    };
}

#[macro_export]
macro_rules! map_extern_infallible {
    ( $name:tt, $f:ident, $input:ty, $output:ty ) => {
        $crate::prelude::hdi::map_extern_infallible!($name, $f, $input, $output);
    };
}



================================================
File: crates/hdk/src/migrate.rs
================================================
use crate::hdk::HDK;
use crate::prelude::CloseChainInput;
use hdi::prelude::{ExternResult, MigrationTarget, OpenChainInput};
use holo_hash::ActionHash;

/// Close your current source chain to indicate that you are planning to migrate to a new DNA.
///
/// This must be the last entry you try to make in your source chain. Holochain's sytem validation
/// will reject any actions that come after this one.
pub fn close_chain(new_target: Option<MigrationTarget>) -> ExternResult<ActionHash> {
    HDK.with(|h| h.borrow().close_chain(CloseChainInput { new_target }))
}

/// Indicate the DNA that you have migrated from. This should be committed to the new DNA's source
/// chain.
///
/// Holochain does not enforce an order for this action, or even that you must use it at all. It is
/// the only way that your app validation rules can know which DNA you have migrated from. So if
/// your app needs to know this to validate imported data then you will need to call this function.
pub fn open_chain(
    prev_target: MigrationTarget,
    close_hash: ActionHash,
) -> ExternResult<ActionHash> {
    HDK.with(|h| {
        h.borrow().open_chain(OpenChainInput {
            prev_target,
            close_hash,
        })
    })
}



================================================
File: crates/hdk/src/p2p.rs
================================================
use crate::prelude::*;

/// # Call
/// Make a Zome call in another Zome.
/// The Zome can be in another Cell or the
/// same Cell but must be installed on the same conductor.
///
/// ## Parameters
/// - to_cell: The cell you want to call (If None will call the current cell).
/// - zome_name: The name of the zome you want to call.
/// - fn_name: The name of the function in the zome you are calling.
/// - cap_secret: The capability secret if required.
/// - payload: The arguments to the function you are calling.
pub fn call<I, Z>(
    to_cell: CallTargetCell,
    zome_name: Z,
    fn_name: FunctionName,
    cap_secret: Option<CapSecret>,
    payload: I,
) -> ExternResult<ZomeCallResponse>
where
    I: serde::Serialize + std::fmt::Debug,
    Z: Into<ZomeName>,
{
    Ok(HDK
        .with(|h| {
            h.borrow().call(vec![Call::new(
                CallTarget::ConductorCell(to_cell),
                zome_name.into(),
                fn_name,
                cap_secret,
                ExternIO::encode(payload).map_err(|e| wasm_error!(e))?,
            )])
        })?
        .into_iter()
        .next()
        .unwrap())
}

/// Wrapper for __call_remote host function.
///
/// Remote calls differ from local calls because they run on a different agent on
/// the same DNA. Remote calls are synchronous and require an active network
/// connection between local and the remote peer. The remote peer may reject the
/// incoming call and manage capability grants to determine who to selectively
/// grant access to. The call on the remote will run exactly as a local call, all
/// commits will be to the _remote_ source chain NOT the local chain. The only
/// difference between the remote calling itself vs. accepting an incoming remote
/// call will be the provenance of the call visible on the call info.
///
/// There are several positional arguments:
///
/// - agent: The address of the agent to call the RPC style remote function on.
/// - zome: The zome to call the remote function in. Use zome_info() to get the current zome info.
/// - fn_name: The name of the function in the zome to call.
/// - cap_secret: Optional cap claim secret to allow access to the remote call.
/// - payload: The payload to send to the remote function; receiver needs to deserialize cleanly.
///
/// Response is [ `ExternResult` ] which returns [ `ZomeCallResponse` ] of the function call.
/// [ `ZomeCallResponse::NetworkError` ] if there was a network error.
/// [ `ZomeCallResponse::Unauthorized` ] if the provided cap grant is invalid.
/// The unauthorized case should always be handled gracefully because gap grants can be revoked at
/// any time and the claim holder has no way of knowing until they provide a secret for a call.
///
/// An Ok response already includes an [ `ExternIO` ] to be deserialized with `extern_io.decode()?`.
///
/// ```ignore
/// ...
/// let foo: Foo = call_remote(bob, "foo_zome", "do_it", secret, serializable_payload)?;
/// ...
/// ```
pub fn call_remote<I, Z>(
    agent: AgentPubKey,
    zome: Z,
    fn_name: FunctionName,
    cap_secret: Option<CapSecret>,
    payload: I,
) -> ExternResult<ZomeCallResponse>
where
    I: serde::Serialize + std::fmt::Debug,
    Z: Into<ZomeName>,
{
    Ok(HDK
        .with(|h| {
            h.borrow().call(vec![Call::new(
                CallTarget::NetworkAgent(agent),
                zome.into(),
                fn_name,
                cap_secret,
                ExternIO::encode(payload).map_err(|e| wasm_error!(e))?,
            )])
        })?
        .into_iter()
        .next()
        .unwrap())
}

/// Emit an app-defined Signal.
///
/// Only clients who have subscribed to signals from this Cell with the proper
/// filters will receive it.
///
/// # Examples
/// <https://github.com/holochain/holochain/blob/develop/crates/test_utils/wasm/wasm_workspace/emit_signal/src/lib.rs>
//
// TODO: we could consider adding a (optional?) "type" parameter, so that
// statically typed languages can more easily get a hint of what type to
// deserialize to. This of course requires a corresponding change to the
// Signal type.
pub fn emit_signal<I>(input: I) -> ExternResult<()>
where
    I: serde::Serialize + std::fmt::Debug,
{
    HDK.with(|h| {
        h.borrow().emit_signal(AppSignal::new(
            ExternIO::encode(input).map_err(|e| wasm_error!(e))?,
        ))
    })
}

/// ## Remote Signal
/// Send a signal to a list of other agents.
/// This will send the data as an [ `AppSignal` ] to
/// this zome for all the agents supplied.
///
/// ### Non-blocking
/// This is a non-blocking call and will not return an
/// error if the calls fail. This is designed to be used
/// as a send and forget operation.
/// A log will be produced at `[send_remote_signal]=info` if the calls
/// fail though (this may be removed in the future).
///
/// ### Usage
/// Currently this requires the function `recv_remote_signal` be
/// exposed by this zome with a signature like:
/// ```ignore
/// #[hdk_extern]
/// fn recv_remote_signal(signal: SerializedBytes) -> ExternResult<()> {
///     emit_signal(&signal)?;
///     Ok(())
/// }
/// ```
/// This function will also need to be added to your init as a
/// unrestricted cap grant so it can be called remotely.
///
/// This requirements will likely be removed in the future as
/// we design a better way to grant the capability to remote signal.
pub fn send_remote_signal<I>(input: I, agents: Vec<AgentPubKey>) -> ExternResult<()>
where
    I: serde::Serialize + std::fmt::Debug,
{
    HDK.with(|h| {
        h.borrow().send_remote_signal(RemoteSignal {
            signal: ExternIO::encode(input).map_err(|e| wasm_error!(e))?,
            agents,
        })
    })
}



================================================
File: crates/hdk/src/prelude.rs
================================================
pub use crate::capability::create_cap_claim;
pub use crate::capability::create_cap_grant;
pub use crate::capability::delete_cap_grant;
pub use crate::capability::generate_cap_secret;
pub use crate::capability::update_cap_grant;
pub use crate::chain::get_agent_activity;
pub use crate::chain::must_get_agent_activity;
pub use crate::chain::query;
pub use crate::clone::*;
#[cfg(feature = "unstable-countersigning")]
pub use crate::countersigning::session_times_from_millis;
pub use crate::ed25519::sign;
pub use crate::ed25519::sign_ephemeral;
pub use crate::ed25519::sign_ephemeral_raw;
pub use crate::ed25519::sign_raw;
pub use crate::ed25519::verify_signature;
pub use crate::ed25519::verify_signature_raw;
pub use crate::entry::create;
pub use crate::entry::create_entry;
pub use crate::entry::delete;
pub use crate::entry::delete_entry;
pub use crate::entry::get;
pub use crate::entry::get_details;
pub use crate::entry::must_get_action;
pub use crate::entry::must_get_entry;
pub use crate::entry::must_get_valid_record;
pub use crate::entry::update;
pub use crate::entry::update_entry;
pub use crate::entry_type;
pub use crate::entry_types;
pub use crate::hash::*;
pub use crate::hash_path::anchor::anchor;
pub use crate::hash_path::anchor::list_anchor_addresses;
pub use crate::hash_path::anchor::list_anchor_tags;
pub use crate::hash_path::anchor::list_anchor_type_addresses;
pub use crate::hash_path::anchor::TryFromPath;
pub use crate::hash_path::path::HdkPathExt;
pub use crate::hdk::*;
pub use crate::info::agent_info;
pub use crate::info::call_info;
pub use crate::info::dna_info;
pub use crate::info::zome_info;
pub use crate::link::count_links;
pub use crate::link::create_link;
pub use crate::link::delete_link;
pub use crate::link::get_link_details;
pub use crate::link::get_links;
pub use crate::link::GetLinksInputBuilder;
pub use crate::link::LinkTypeFilterExt;
pub use crate::map_extern;
pub use crate::map_extern::ExternResult;
pub use crate::migrate::*;
pub use crate::p2p::call;
pub use crate::p2p::call_remote;
pub use crate::p2p::emit_signal;
pub use crate::p2p::send_remote_signal;
pub use crate::random::*;
pub use crate::time::sys_time;
pub use crate::validation_receipt::get_validation_receipts;
pub use crate::x_salsa20_poly1305::create_x25519_keypair;
pub use crate::x_salsa20_poly1305::ed_25519_x_salsa20_poly1305_decrypt;
pub use crate::x_salsa20_poly1305::ed_25519_x_salsa20_poly1305_encrypt;
pub use crate::x_salsa20_poly1305::x_25519_x_salsa20_poly1305_decrypt;
pub use crate::x_salsa20_poly1305::x_25519_x_salsa20_poly1305_encrypt;
pub use crate::x_salsa20_poly1305::x_salsa20_poly1305_decrypt;
pub use crate::x_salsa20_poly1305::x_salsa20_poly1305_encrypt;
pub use crate::x_salsa20_poly1305::x_salsa20_poly1305_shared_secret_create_random;
pub use crate::x_salsa20_poly1305::x_salsa20_poly1305_shared_secret_export;
pub use crate::x_salsa20_poly1305::x_salsa20_poly1305_shared_secret_ingest;
pub use hdi;
pub use hdi::map_extern_infallible;
pub use hdi::op::OpHelper;
pub use hdi::prelude::app_entry;
pub use hdi::prelude::Anchor;
pub use hdi::prelude::Component;
pub use hdi::prelude::Path;
pub use hdi::prelude::ShardStrategy;
pub use hdi::prelude::TypedPath;
pub use hdk_derive;
pub use hdk_derive::dna_properties;
pub use hdk_derive::hdk_dependent_entry_types;
pub use hdk_derive::hdk_dependent_link_types;
pub use hdk_derive::hdk_entry_helper;
pub use hdk_derive::hdk_entry_types;
pub use hdk_derive::hdk_entry_types_conversions;
pub use hdk_derive::hdk_extern;
pub use hdk_derive::hdk_link_types;
pub use hdk_derive::hdk_to_coordinates;
pub use hdk_derive::EntryDefRegistration;
pub use hdk_derive::UnitEnum;
pub use holo_hash;
pub use holo_hash::ActionHash;
pub use holo_hash::AgentPubKey;
pub use holo_hash::AnyDhtHash;
pub use holo_hash::AnyLinkableHash;
pub use holo_hash::EntryHash;
pub use holo_hash::EntryHashes;
pub use holo_hash::ExternalHash;
pub use holo_hash::HasHash;
pub use holo_hash::HoloHash;
pub use holo_hash::HoloHashed;
pub use holochain_wasmer_guest::*;
pub use holochain_zome_types;
pub use holochain_zome_types::prelude::*;
pub use std::collections::BTreeSet;
pub use std::collections::HashSet;
pub use std::convert::TryFrom;
pub use tracing;
pub use tracing::{debug, error, info, instrument, trace, warn};

#[cfg(feature = "unstable-countersigning")]
pub use crate::countersigning::accept_countersigning_preflight_request;

#[cfg(feature = "unstable-functions")]
pub use crate::time::schedule;

#[cfg(feature = "mock")]
pub use mockall;

#[cfg(feature = "mock")]
pub use crate::hdk::MockHdkT;

// This needs to be called at least once _somewhere_ and is idempotent.
#[macro_export]
macro_rules! holochain_externs {
    () => {
        holochain_wasmer_guest::host_externs!(
            trace:1,
            hash:1,
            unreachable:1,
            verify_signature:1,
            sign:1,
            sign_ephemeral:1,
            zome_info:1,
            call_info:1,
            dna_info:1,
            random_bytes:1,
            sys_time:1,
            agent_info:1,
            capability_claims:1,
            capability_grants:1,
            capability_info:1,
            get:1,
            get_details:1,
            get_links:1,
            get_link_details:1,
            count_links:1,
            get_agent_activity:1,
            must_get_entry:1,
            must_get_valid_record:1,
            must_get_action:1,
            query:1,
            call_remote:1,
            call:1,
            create:1,
            emit_signal:1,
            send_remote_signal:1,
            create_link:1,
            delete_link:1,
            update:1,
            delete:1,
            x_salsa20_poly1305_shared_secret_create_random:1,
            x_salsa20_poly1305_shared_secret_export:1,
            x_salsa20_poly1305_shared_secret_ingest:1,
            x_salsa20_poly1305_encrypt:1,
            x_salsa20_poly1305_decrypt:1,
            x_25519_x_salsa20_poly1305_encrypt:1,
            x_25519_x_salsa20_poly1305_decrypt:1,
            ed_25519_x_salsa20_poly1305_encrypt:1,
            ed_25519_x_salsa20_poly1305_decrypt:1,
            create_x25519_keypair:1,
            create_clone_cell:1,
            disable_clone_cell:1,
            enable_clone_cell:1,
            delete_clone_cell:1,
            close_chain:1,
            open_chain:1,
            get_validation_receipts:1
        );

        #[cfg(feature = "unstable-countersigning")]
        holochain_wasmer_guest::host_externs!(
            accept_countersigning_preflight_request:1
        );

        #[cfg(feature = "unstable-functions")]
        holochain_wasmer_guest::host_externs!(
            get_agent_key_lineage:1,
            block_agent:1,
            unblock_agent:1,
            schedule:1
        );
    };
}

#[cfg(not(feature = "mock"))]
holochain_externs!();



================================================
File: crates/hdk/src/random.rs
================================================
use crate::prelude::*;

/// Get N cryptographically strong random bytes.
///
/// ```ignore
/// let five_bytes = random_bytes(5)?;
/// ```
///
/// It's not possible to generate random bytes from inside the wasm guest so the data is provided
/// by the wasm host which implies operating system specific details re: randomness.
///
/// The bytes are cryptographically random in that they are unpredictable, to the quality of what
/// host environment offers and the crypto implementation within holochain.
///
/// The bytes are not "secure" though:
///
/// - there's no way to prove that a specific value was the result of random generation or not
/// - the bytes are open in memory and even (de)serialized several times between the host and guest
///
/// The bytes are not a performant or testable way to do statistical analysis (e.g. monte carlo).
/// Rust provides several seedable PRNG implementations that are fast, repeatable and statistically
/// high quality even if not suitable for crypto applications. If you need to do anything with
/// statistics it is usually recommended to generate or provide a seed and then use an appropriate
/// PRNG from there.
///
/// See the rand rust crate
pub fn random_bytes(number_of_bytes: u32) -> ExternResult<Bytes> {
    HDK.with(|h| h.borrow().random_bytes(number_of_bytes))
}

pub trait TryFromRandom {
    fn try_from_random() -> ExternResult<Self>
    where
        Self: Sized;
}

/// Ideally we wouldn't need to do this with a macro.
/// All we want is to implement this trait with whatever length our random-bytes-new-types need to
/// be, but if we use a const on the trait directly we get 'constant expression depends on a
/// generic parameter'
macro_rules! impl_try_from_random {
    ( $t:ty, $bytes:expr ) => {
        impl TryFromRandom for $t {
            fn try_from_random() -> $crate::prelude::ExternResult<Self> {
                $crate::prelude::random_bytes($bytes as u32).map(|bytes| {
                    // Always a fatal error if our own bytes generation has the wrong length.
                    assert_eq!($bytes, bytes.len());
                    let mut inner = [0; $bytes];
                    inner.copy_from_slice(bytes.as_ref());
                    Self::from(inner)
                })
            }
        }
    };
}

impl_try_from_random!(
    CapSecret,
    holochain_zome_types::capability::CAP_SECRET_BYTES
);



================================================
File: crates/hdk/src/time.rs
================================================
use crate::prelude::*;

/// Current system time from the host.
///
/// System time doesn't accept any arguments so usage is as simple as:
///
/// ```ignore
/// let now = sys_time()?;
/// ```
///
/// Note: sys_time returns a result like all host fns so `?` or `.ok()` is needed.
///
/// System times can be considered "secure" or "insecure" situationally, some things to consider:
///
/// - the host signing times into chain actions is using the same clock in the host_fn call so the
///   the sys_time returned by a function for inclusion in an entry will always be less than or
///   equal to the time in the action of that entry unless:
///     - the user manually changed the system time backwards between this host_fn being called and
///       an entry using it being committed (NTP avoids making time go backward by stretching it)
///     - the sys_time call ran on a different machine, e.g. via a call_remote, to the machine that
///       commits it into an entry so your app can decide to implement validation logic that fails
///       any sys time that comes after the time signed in the action if that makes sense.
/// - the times in the actions of the local source chain must increase monotonically and all
///   actions are pushed to the neighbourhood of the agent publishing them, so the agent activity
///   authorities will immediately warrant any actions running chronologically backwards
/// - the times within a single record may be relatively secure but are easy to manipulate in an
///   absolute sense, the user can simply change their system clock before attempting a commit to
///   any time that is equal to or later than their current chain head
///
/// This is an improvement on pushing time collection back onto the "client" which can't
/// guarantee that it is seeing the same time as the rust host, so this enables stricter validation
/// logic.
///
// @todo
// Sys times aren't the final word on secure times, for another option it may be best to use the
// roughtime protocol which redundantly fetches cryptographically signed times from multiple
// different servers and cross-references them.
// There is a POC for this but it's not in core yet (requires at least UDP calls from the host).
// Note that the **redundant fetching** and **cross-referencing** parts are critical, even though
// they add a lot of complexity to the protocol. Failure to do this brought down the ETH2.0
// Medalla testnet due to a single roughtime server from cloudflare being 24 hours off.
// Note also that roughtime, or any other "secure timestamping" option requires the agent to be
// online at the time of generating times, which runs counter to the requirement that holochain
// support "agent centric, offline first" behaviour, but may be acceptable or even a neccessary
// evil for specific application logic.
// The other challenge with roughtime is list management to track the list of valid servers over
// time, which might rely on agents providing snapshots of links to public keys (i.e. representing
// the roughtime ecosystem itself in a happ).
//
// See <https://blog.cloudflare.com/roughtime/>
//
// @todo
// Another option is to use proof of work style constructions to roughly throttle the speed that
// things can be done without relying on absolute times, or even that users experience the same
// throttling due to differences in CPU/GPU performance on the POW algorithm.
// See <https://zkga.me/> uses this as a game mechanic
//
// @todo
// Other p2p type time syncing algorithms that allow peers to adjust their clock offsets to agree
// on the current time within relatively tight accuracy/precision up-front in a relatively trusted
// environment e.g. a chess game between friends with time moves that balances security/trust and
// flaky networking, etc.
pub fn sys_time() -> ExternResult<Timestamp> {
    HDK.with(|h| h.borrow().sys_time(()))
}

/// Adds a function from the current zome to the scheduler.
///
/// Any schedulable function from the current zome can be added to the scheduler
/// by calling this function. Schedulable functions are infallable and MUST return
/// their next trigger time. Trigger times are expressed as either "ephemeral"
/// which means they will run as "best effort" after some duration, or "persisted"
/// which uses crontab like syntax to trigger the scheduled function many times.
/// Ephemeral scheduled functions do not outlive the running conductor but
/// persisted scheduled functions will continue to function after a reboot.
/// Persisted functions MUST continue to return the same persisted crontab every
/// time they are triggered if they wish to maintain their schedule. They MAY change
/// their schedule by returning a different crontab or even returning an ephemeral
/// trigger or `None` for no further triggers. If this is the initial trigger of
/// a scheduled function the input schedule will be `None`, otherwise it will be
/// whatever was returned by the previous invocation that triggered the current
/// invocation.
///
/// Scheduling a function will trigger it once unconditionally on the next iteration
/// of the conductor's internal scheduler loop. The frequency of the loop is subject
/// to change between conductor versions and MAY be configurable in the future, so
/// happ devs are advised NOT to assume or rely on any specific granularity. For
/// example the loop has historically ranged from once every 100ms to every 10s.
///
/// As `schedule` is callable in any coordination context it could even be called
/// as the result of inbound remote calls or many times concurrently by some client.
/// Both floods of inbound scheduling requests and "confused deputy" situations
/// must be handled by the conductor.
///
/// - Scheduling a function is idempotent. If it is already scheduled the existing
///   schedule will be respected and the `schedule` call is a noop. If the function
///   is not currently scheduled, even if it recently returned `None` from a previous
///   schedule, it will immediately be added for inclusion in the next scheduler
///   loop iteration.
/// - Scheduled functions ALWAYS run as the author of the chain they run for. Any
///   appropriate cap grants must be implemented in front of the `schedule` call
///   as the provenance of the scheduling agent is lost as soon as the original
///   zome call returns. This resolves the natural tension between disambiguating
///   and handling potentially hundreds of scheduled calls under different
///   provenances, while also wanting a single lightweight and idempotent scheduler.
/// - Scheduled functions are infallible and their only input and output is their
///   current and next schedule trigger. The `#[hdk_extern(infallible)]` attribute
///   facilitates this pattern separate to other zome externs that are both fallible
///   and support arbitrary inputs and outputs. Any errors on the host side will
///   simply be logged and otherwise ignored.
///   ```ignore
///   #[hdk_extern(infallible)]
///   fn scheduled_fn(_: Option<Schedule>) -> Option<Schedule> {}
///   ```
///   This is because the scheduler runs in a background loop and unlike regular
///   zome calls there is no client or workflow attached to report back to or
///   handle errors. There are no inputs and outputs to scheduleable functions as
///   we don't want to provide the opportunity to smuggle in data that will be run
///   by the author as themselves if the input originated from some caller who
///   merely held a cap grant to trigger the schedule.
/// - Happ devs MUST assume that malicious agents are able to trigger scheduled
///   functions at the "wrong time" and write their scheduled functions defensively
///   to noop then delay or terminate themselves if triggered during the incorrect
///   time window.
///
/// It is worth noting that at the time of writing, `init` callbacks are lazy in
/// that they do not execute until/unless some other zome call runs for the first
/// time after installation. It is possible to schedule functions during `init`
/// but happ devs should be mindful that this may not happen immediately or ever
/// after happ installation.
///
/// The only argument to `schedule` is the name of the schedulable function in the
/// current zome to be scheduled.
#[cfg(feature = "unstable-functions")]
pub fn schedule(scheduled_fn: &str) -> ExternResult<()> {
    HDK.with(|h| h.borrow().schedule(String::from(scheduled_fn)))
}



================================================
File: crates/hdk/src/trace.rs
================================================
use crate::prelude::*;
use std::fmt::Write;
use std::sync::atomic::AtomicUsize;
use std::sync::atomic::Ordering;

#[derive(Default)]
pub struct WasmSubscriber {
    pub ids: AtomicUsize,
}

/// Very basic struct to hold strings that can be written to by the tracing crate and sent to the host when complete.
struct StringVisitor<'a> {
    fields: &'a mut String,
    message: &'a mut String,
}

impl tracing_core::field::Visit for StringVisitor<'_> {
    fn record_debug(&mut self, field: &tracing_core::Field, value: &dyn std::fmt::Debug) {
        // Special case the message field so that it doesn't appear in the key/value format.
        if field.name() == "message" {
            let did_write = write!(self.message, "{:?}", value);
            if did_write.is_err() {
                let _ = write!(self.message, "**failed to write message**");
            }
        // Everything else is a simple key/value debug output.
        } else {
            let did_write = write!(self.fields, "{} = {:?}; ", field.name(), value);
            if did_write.is_err() {
                let _ = write!(self.fields, "**failed to write {}**", field.name());
            }
        }
    }
}

/// By implementing WasmSubscriber we integrate the rust tracing crate with the __trace host_fn without inventing some DIY DSL
///
/// Currently supports all the event macros for tracing such as `trace!`, `info!`, `debug!`, `warn!`, `error!`.
///
/// Does NOT support spans, so attempting to `#[instrument]` a function or similar will panic the wasm.
impl tracing_core::Subscriber for WasmSubscriber {
    fn enabled(&self, _metadata: &tracing::Metadata<'_>) -> bool {
        true
    }
    /// Not really implemented yet.
    /// Placeholder logic only.
    fn new_span(&self, _attributes: &tracing_core::span::Attributes<'_>) -> tracing::Id {
        let next = self.ids.fetch_add(1, Ordering::SeqCst) as u64;
        tracing::Id::from_u64(next)
    }
    fn record(&self, _span: &tracing::Id, _values: &tracing::span::Record<'_>) {
        // unimplemented
    }
    fn record_follows_from(&self, _span: &tracing::Id, _follows: &tracing::Id) {
        // unimplemented
    }
    fn event(&self, event: &tracing::Event<'_>) {
        // New strings for every event.
        let mut visitor = StringVisitor {
            message: &mut String::new(),
            fields: &mut String::new(),
        };

        // This is handled by the Visit implementation above.
        event.record(&mut visitor);

        // The event is pushed to the host to be picked up by the subscriber on that side.
        // The visitor is dropped.
        hdi::hdi::HDI.with(|h| {
            h.borrow()
                .trace(TraceMsg {
                    level: event.metadata().level().into(),
                    msg: format!(
                        "{}:{}:{} {}{}",
                        event.metadata().module_path().unwrap_or(""),
                        event.metadata().file().unwrap_or(""),
                        event.metadata().line().unwrap_or(0),
                        visitor.fields,
                        visitor.message
                    ),
                })
                .ok()
        });
    }
    fn enter(&self, _span: &tracing::Id) {
        // unimplemented
    }
    fn exit(&self, _span: &tracing::Id) {
        // unimplemented
    }
}



================================================
File: crates/hdk/src/validation_receipt.rs
================================================
use crate::hdk::HDK;
use hdi::map_extern::ExternResult;
use holochain_zome_types::prelude::{GetValidationReceiptsInput, ValidationReceiptSet};

/// Get validation receipts associated with an action.
///
/// When an action is created, it is represented as multiple DHT ops to be published on the network.
/// Each op will be validated by other agents on the network and a receipt will be sent back to the
/// author. The return value of this function is organized by DHT op hash. Each [ValidationReceiptSet]
/// contains all the validation receipts that have been received for that DHT op.
///
/// Note: This function will permit you to look for validation receipts for any action hash, but you
/// will only have receipts if the action was authored on the same conductor. Not necessarily the
/// same agent, but it must be the same conductor.
///
/// ### Example
/// ```rust,no_run
/// use hdk::prelude::*;
///
/// #[derive(Serialize, Deserialize)]
/// #[serde(tag = "type")]
/// #[hdk_entry_types]
/// #[unit_enum(UnitEntryTypes)]
/// pub enum EntryTypes {
///     MyType(MyType),
/// }
///
/// #[hdk_entry_helper]
/// pub struct MyType {
///     value: String,
/// }
///
/// #[hdk_extern]
/// fn create_and_list() -> ExternResult<()> {
///     let action_hash = create_entry(EntryTypes::MyType(MyType {
///         value: "foo".into(),
///     }))?;
///
///     // Later on
///     let receipts = get_validation_receipts(GetValidationReceiptsInput::new(action_hash))?;
///     let count = receipts
///         .into_iter()
///         .filter(|receipt_set| receipt_set.op_type == "RegisterAgentActivity")
///         .flat_map(|receipt_set| receipt_set.receipts)
///         .count();
///     info!("Found {} receipts from agent activity authorities", count);
///     Ok(())
/// }
/// ```
pub fn get_validation_receipts(
    input: GetValidationReceiptsInput,
) -> ExternResult<Vec<ValidationReceiptSet>> {
    HDK.with(|h| h.borrow().get_validation_receipts(input))
}



================================================
File: crates/hdk/src/x_salsa20_poly1305.rs
================================================
use crate::prelude::*;
pub use hdi::x_salsa20_poly1305::*;

// -- secretbox encryption -- //

/// Generate a new secure random shared secret suitable for encrypting and
/// decrypting using x_salsa20_poly1305_{en,de}crypt.
/// If key_ref is `None` an opaque reference will be auto-generated.
/// If key_ref is `Some` and that key already exists in the store,
/// this function will return an error.
/// If `Ok`, this function will return the KeyRef by which the shared
/// secret may be accessed.
pub fn x_salsa20_poly1305_shared_secret_create_random(
    key_ref: Option<XSalsa20Poly1305KeyRef>,
) -> ExternResult<XSalsa20Poly1305KeyRef> {
    HDK.with(|h| {
        h.borrow()
            .x_salsa20_poly1305_shared_secret_create_random(key_ref)
    })
}

/// Using the Libsodium box algorithm, encrypt a shared secret so that it
/// may be forwarded to another specific peer.
pub fn x_salsa20_poly1305_shared_secret_export(
    sender: X25519PubKey,
    recipient: X25519PubKey,
    key_ref: XSalsa20Poly1305KeyRef,
) -> ExternResult<XSalsa20Poly1305EncryptedData> {
    HDK.with(|h| {
        h.borrow()
            .x_salsa20_poly1305_shared_secret_export(XSalsa20Poly1305SharedSecretExport::new(
                sender, recipient, key_ref,
            ))
    })
}

/// Using the Libsodium box algorithm, decrypt a shared secret, storing it
/// in the keystore so that it may be used in `x_salsa20_poly1305_decrypt`.
/// This method may be co-opted to ingest shared secrets generated by other
/// custom means. Just be careful, as WASM memory is not a very secure
/// environment for cryptographic secrets.
/// If key_ref is `None` an opaque reference string will be auto-generated.
/// If key_ref is `Some` and that key already exists in the store,
/// this function will return an error.
/// If `Ok`, this function will return the KeyRef by which the shared
/// secret may be accessed.
pub fn x_salsa20_poly1305_shared_secret_ingest(
    recipient: X25519PubKey,
    sender: X25519PubKey,
    encrypted_data: XSalsa20Poly1305EncryptedData,
    key_ref: Option<XSalsa20Poly1305KeyRef>,
) -> ExternResult<XSalsa20Poly1305KeyRef> {
    HDK.with(|h| {
        h.borrow()
            .x_salsa20_poly1305_shared_secret_ingest(XSalsa20Poly1305SharedSecretIngest::new(
                recipient,
                sender,
                encrypted_data,
                key_ref,
            ))
    })
}

/// Libsodium secret-key authenticated encryption: secretbox.
///
/// Libsodium symmetric encryption (a shared key to encrypt/decrypt) is called secretbox.
/// Secretbox can be used directly to hide data and is part of cryptographic systems such as
/// [saltpack](https://saltpack.org/).
///
/// Important information about secretbox:
///  - Wasm memory is NOT secure, a compromised host can steal the key.
///  - The key is SECRET, anyone with the key and nonce can read the encrypted message.
///  - The nonce is PUBLIC and UNIQUE, it must NEVER be re-used (so we don't allow it to be set).
///  - Secretbox is designed for 'small' data, break large data into chunks with unique nonces.
///  - Secretbox is NOT quantum resistant.
///
// @todo shift all the secret handling into lair so that we only work with opaque key references.
///
/// If you want to hide data:
///  - Consider using capability tokens and/or dedicated DHT networks to control access.
///  - Consider how the shared key is being distributed, e.g. maybe use a key exchange protocol.
///  - Consider that a hybrid approach between network access + encryption might be best.
///  - Consider that encrypted data cannot be validated effectively by the public DHT.
///
/// The main use-case is to control access to data that may be broadcast across a semi-trusted or
/// untrusted context, where the intended recipients have all negotiated or shared a key outside
/// that context.
///
/// If you want to encrypt content so that a _specific_ recipient (i.e. public key) can decrypt it
/// then see the libsodium `box` algorithm or similar.
///
/// See <https://doc.libsodium.org/secret-key_cryptography/secretbox>
/// See <https://nacl.cr.yp.to/secretbox.html>
pub fn x_salsa20_poly1305_encrypt(
    key_ref: XSalsa20Poly1305KeyRef,
    data: XSalsa20Poly1305Data,
) -> ExternResult<XSalsa20Poly1305EncryptedData> {
    HDK.with(|h| {
        h.borrow()
            .x_salsa20_poly1305_encrypt(XSalsa20Poly1305Encrypt::new(key_ref, data))
    })
}

// -- curve25519 box encryption -- //

/// Generate a new x25519 keypair in lair from entropy.
/// Only the pubkey is returned from lair because the secret key never leaves lair.
pub fn create_x25519_keypair() -> ExternResult<X25519PubKey> {
    HDK.with(|h| h.borrow().create_x25519_keypair(()))
}

/// Libsodium keypair based authenticated encryption: box.
///
/// Libsodium asymmetric encryption (two keypairs to encrypt/decrypt) is called box.
/// Box can be used directly to hide data and is part of cryptographic systems such as
/// [saltpack](https://saltpack.org/).
///
/// Important information about box:
///  - The secret half of the keypair is generated in and remains in lair.
///  - The nonce is randomly generated in lair for every call to encrypt.
///  - The nonce is PUBLIC and UNIQUE, it must NEVER be re-used (currently can't be set directly).
///  - Box is the same encryption as secretbox using ECDH off the keypairs for the shared key.
///  - Box is repudible. Either keypair can create any message to be read by the other party. Each
///    party knows they did not create a certain message so they know it came from the counterpary
///    but neither can prove to a third party that any message wasn't forged. Note that if you want
///    the opposite it is not enough to simply layer signatures and encryption.
///    See <https://theworld.com/~dtd/sign_encrypt/sign_encrypt7.html>
///  - To encrypt something potentially large for potentially many recipients efficiently it may be
///    worth chunking the large data, secret boxing it with a unique key for each chunk, then
///    boxing the _keys_ for each recipient alongside the chunks, to avoid encrypting the large
///    data repeatedly for every recipient.
///  - Box is NOT quantum resistant.
///
/// If you want to hide data:
///  - Consider using capability tokens and/or dedicated DHT networks to control access.
///  - Consider how the keypairs are being generated and pubkeys distributed.
///  - Consider that a hybrid approach between network access + encryption might be best.
///  - Consider that encrypted data cannot be validated effectively by the public DHT.
///
/// The main use-case is to control access to data that may be broadcast across a semi-trusted or
/// untrusted context, where the intended recipients have all negotiated or shared a key outside
/// that context.
///
/// If you want to encrypt content so that _any_ recipient with a shared secret can decrypt it
/// then see the libsodium `secretbox` algorithm or similar.
///
/// See <https://doc.libsodium.org/public-key_cryptography/authenticated_encryption>
/// See <https://nacl.cr.yp.to/box.html>
pub fn x_25519_x_salsa20_poly1305_encrypt(
    sender: X25519PubKey,
    recipient: X25519PubKey,
    data: XSalsa20Poly1305Data,
) -> ExternResult<XSalsa20Poly1305EncryptedData> {
    HDK.with(|h| {
        h.borrow()
            .x_25519_x_salsa20_poly1305_encrypt(X25519XSalsa20Poly1305Encrypt::new(
                sender, recipient, data,
            ))
    })
}

/// Libsodium crypto_box encryption, but converts ed25519 *signing*
/// keys into x25519 encryption keys.
/// WARNING: Please first understand the downsides of using this function:
/// <https://doc.libsodium.org/advanced/ed25519-curve25519>
pub fn ed_25519_x_salsa20_poly1305_encrypt(
    sender: AgentPubKey,
    recipient: AgentPubKey,
    data: XSalsa20Poly1305Data,
) -> ExternResult<XSalsa20Poly1305EncryptedData> {
    HDK.with(|h| {
        h.borrow()
            .ed_25519_x_salsa20_poly1305_encrypt(Ed25519XSalsa20Poly1305Encrypt::new(
                sender, recipient, data,
            ))
    })
}



================================================
File: crates/hdk/src/hash_path/anchor.rs
================================================
use super::path::HdkPathExt;
use crate::prelude::*;
use hdi::hash_path::{
    anchor::{Anchor, ROOT},
    path::{Component, Path},
};

pub trait TryFromPath {
    fn try_from_path(path: &Path) -> Result<Anchor, WasmError>;
}

/// Paths are more general than anchors so a path could be represented that is not a valid anchor.
/// The obvious example would be a path of binary data that is not valid utf-8 strings or a path
/// that is more than 2 levels deep.
impl TryFromPath for Anchor {
    fn try_from_path(path: &Path) -> Result<Self, WasmError> {
        let components: Vec<Component> = path.as_ref().to_owned();
        if components.len() == 2 || components.len() == 3 {
            if components[0] == Component::new(ROOT.to_vec()) {
                Ok(Anchor {
                    anchor_type: std::str::from_utf8(components[1].as_ref())
                        .map_err(|e| wasm_error!(SerializedBytesError::Deserialize(e.to_string())))?
                        .to_string(),
                    anchor_text: {
                        match components.get(2) {
                            Some(component) => Some(
                                std::str::from_utf8(component.as_ref())
                                    .map_err(|e| {
                                        wasm_error!(SerializedBytesError::Deserialize(
                                            e.to_string()
                                        ))
                                    })?
                                    .to_string(),
                            ),
                            None => None,
                        }
                    },
                })
            } else {
                Err(wasm_error!(WasmErrorInner::Serialize(
                    SerializedBytesError::Deserialize(format!(
                        "Bad anchor path root {:0?} should be {:1?}",
                        components[0].as_ref(),
                        ROOT,
                    ),)
                )))
            }
        } else {
            Err(wasm_error!(WasmErrorInner::Serialize(
                SerializedBytesError::Deserialize(format!(
                    "Bad anchor path length {}",
                    components.len()
                ),)
            )))
        }
    }
}

/// Simple string interface to simple string based paths.
/// a.k.a "the anchor pattern" that predates paths by a few years.
pub fn anchor<T, E>(
    link_type: T,
    anchor_type: String,
    anchor_text: String,
) -> ExternResult<holo_hash::EntryHash>
where
    ScopedLinkType: TryFrom<T, Error = E>,
    WasmError: From<E>,
{
    let path: Path = (&Anchor {
        anchor_type,
        anchor_text: Some(anchor_text),
    })
        .into();
    let path = path.typed(link_type)?;
    path.ensure()?;
    path.path_entry_hash()
}

/// Returns every hash in a vector from the root of an anchor.
/// Hashes are sorted in the same way that paths sort children.
pub fn list_anchor_type_addresses<T, E>(link_type: T) -> ExternResult<Vec<AnyLinkableHash>>
where
    ScopedLinkType: TryFrom<T, Error = E>,
    WasmError: From<E>,
{
    let links = Path::from(vec![Component::new(ROOT.to_vec())])
        .typed(link_type)?
        .children()?
        .into_iter()
        .map(|link| link.target)
        .collect();
    Ok(links)
}

/// Returns every hash in a vector from the second level of an anchor.
/// Uses the string argument to build the path from the root.
/// Hashes are sorted in the same way that paths sort children.
pub fn list_anchor_addresses<T, E>(
    link_type: T,
    anchor_type: String,
) -> ExternResult<Vec<AnyLinkableHash>>
where
    ScopedLinkType: TryFrom<T, Error = E>,
    WasmError: From<E>,
{
    let path: Path = (&Anchor {
        anchor_type,
        anchor_text: None,
    })
        .into();
    let links = path
        .typed(link_type)?
        .children()?
        .into_iter()
        .map(|link| link.target)
        .collect();
    Ok(links)
}

/// Old version of holochain that anchors was designed for had two part link tags but now link
/// tags are a single array of bytes, so to get an external interface that is somewhat backwards
/// compatible we need to rebuild the anchors from the paths serialized into the links and then
/// return them.
pub fn list_anchor_tags<T, E>(link_type: T, anchor_type: String) -> ExternResult<Vec<String>>
where
    ScopedLinkType: TryFrom<T, Error = E>,
    WasmError: From<E>,
{
    let path: Path = (&Anchor {
        anchor_type,
        anchor_text: None,
    })
        .into();
    let path = path.typed(link_type)?;
    path.ensure()?;
    let hopefully_anchor_tags: Result<Vec<String>, WasmError> = path
        .children_paths()?
        .into_iter()
        .map(|path| match Anchor::try_from_path(&path.path) {
            Ok(anchor) => match anchor.anchor_text {
                Some(text) => Ok(text),
                None => Err(wasm_error!(WasmErrorInner::Serialize(
                    SerializedBytesError::Deserialize("missing anchor text".into(),)
                ))),
            },
            Err(e) => Err(e),
        })
        .collect();
    let mut anchor_tags = hopefully_anchor_tags?;
    anchor_tags.sort();
    anchor_tags.dedup();
    Ok(anchor_tags)
}

#[cfg(test)]
#[test]
fn hash_path_anchor_from_path() {
    let path = Path::from(vec![
        Component::from(vec![0, 0]),
        Component::from(vec![102, 111, 111]),
        Component::from(vec![98, 97, 114]),
    ]);

    assert_eq!(
        Anchor::try_from_path(&path).unwrap(),
        Anchor {
            anchor_type: "foo".into(),
            anchor_text: Some("bar".into()),
        },
    );
}



================================================
File: crates/hdk/src/hash_path/path.rs
================================================
use crate::prelude::*;
use hdi::hash_path::path::{root_hash, Component, TypedPath};

pub trait HdkPathExt {
    fn children(&self) -> ExternResult<Vec<holochain_zome_types::link::Link>>;
    fn children_paths(&self) -> ExternResult<Vec<TypedPath>>;
    fn children_details(&self) -> ExternResult<holochain_zome_types::link::LinkDetails>;
    fn ensure(&self) -> ExternResult<()>;
    fn exists(&self) -> ExternResult<bool>;
}

impl HdkPathExt for TypedPath {
    /// Touch and list all the links from this path to paths below it.
    /// Only returns links between paths, not to other entries that might have their own links.
    fn children(&self) -> ExternResult<Vec<holochain_zome_types::link::Link>> {
        Self::ensure(self)?;
        let mut unwrapped = get_links(
            GetLinksInputBuilder::try_new(
                self.path_entry_hash()?,
                LinkTypeFilter::single_type(self.link_type.zome_index, self.link_type.zome_type),
            )?
            .build(),
        )?;
        // Only need one of each hash to build the tree.
        unwrapped.sort_unstable_by(|a, b| a.tag.cmp(&b.tag));
        unwrapped.dedup_by(|a, b| a.tag.eq(&b.tag));
        Ok(unwrapped)
    }

    /// Touch and list all the links from this path to paths below it.
    /// Same as `Path::children` but returns `Vec<Path>` rather than `Vec<Link>`.
    /// This is more than just a convenience. In general it's not possible to
    /// construct a full `Path` from a child `Link` alone as only a single
    /// `Component` is encoded into the link tag. To build a full child path
    /// the parent path + child link must be combined, which this function does
    /// to produce each child, by using `&self` as that parent.
    fn children_paths(&self) -> ExternResult<Vec<TypedPath>> {
        let children = self.children()?;
        let components: ExternResult<Vec<Option<Component>>> = children
            .into_iter()
            .map(|link| {
                let component_bytes = &link.tag.0[..];
                if component_bytes.is_empty() {
                    Ok(None)
                } else {
                    Ok(Some(
                        SerializedBytes::from(UnsafeBytes::from(component_bytes.to_vec()))
                            .try_into()
                            .map_err(|e: SerializedBytesError| wasm_error!(e))?,
                    ))
                }
            })
            .collect();
        Ok(components?
            .into_iter()
            .map(|maybe_component| {
                let mut new_path = self.path.clone();
                if let Some(component) = maybe_component {
                    new_path.append_component(component);
                }
                new_path.into_typed(self.link_type)
            })
            .collect())
    }

    fn children_details(&self) -> ExternResult<holochain_zome_types::link::LinkDetails> {
        Self::ensure(self)?;
        get_link_details(
            self.path_entry_hash()?,
            LinkTypeFilter::single_type(self.link_type.zome_index, self.link_type.zome_type),
            Some(holochain_zome_types::link::LinkTag::new([])),
            GetOptions::default(),
        )
    }

    /// Recursively touch this and every parent that doesn't exist yet.
    fn ensure(&self) -> ExternResult<()> {
        if !self.exists()? {
            if self.is_root() {
                create_link(
                    root_hash()?,
                    self.path_entry_hash()?,
                    self.link_type,
                    self.make_tag()?,
                )?;
            } else if let Some(parent) = self.parent() {
                parent.ensure()?;
                create_link(
                    parent.path_entry_hash()?,
                    self.path_entry_hash()?,
                    self.link_type,
                    self.make_tag()?,
                )?;
            }
        }
        Ok(())
    }

    /// Does data exist at the hash we expect?
    fn exists(&self) -> ExternResult<bool> {
        if self.0.is_empty() {
            Ok(false)
        } else if self.is_root() {
            let this_paths_hash: AnyLinkableHash = self.path_entry_hash()?.into();
            let exists = get_links(
                GetLinksInputBuilder::try_new(
                    root_hash()?,
                    LinkTypeFilter::single_type(
                        self.link_type.zome_index,
                        self.link_type.zome_type,
                    ),
                )?
                .tag_prefix(self.make_tag()?)
                .build(),
            )?
            .iter()
            .any(|Link { target, .. }| *target == this_paths_hash);
            Ok(exists)
        } else {
            let parent = self
                .parent()
                .expect("Must have parent if not empty or root");
            let this_paths_hash: AnyLinkableHash = self.path_entry_hash()?.into();
            let exists = get_links(
                GetLinksInputBuilder::try_new(
                    parent.path_entry_hash()?,
                    LinkTypeFilter::single_type(
                        self.link_type.zome_index,
                        self.link_type.zome_type,
                    ),
                )?
                .tag_prefix(self.make_tag()?)
                .build(),
            )?
            .iter()
            .any(|Link { target, .. }| *target == this_paths_hash);
            Ok(exists)
        }
    }
}



================================================
File: crates/hdk/src/link/builder.rs
================================================
use hdi::prelude::LinkTypeFilterExt;
use holo_hash::{AgentPubKey, AnyLinkableHash};
use holochain_wasmer_guest::WasmError;
use holochain_zome_types::prelude::*;

/// A builder to streamline creating a `GetLinksInput`.
///
/// Example: Get links of any time from a given base address.
/// ```rust,no_run
/// use hdk::prelude::*;
///
/// # fn main() -> ExternResult<()> {
///     let my_base = ActionHash::from_raw_36(vec![0; 36]); // Some base address, this is a dummy address created for the example!
///     let links = get_links(GetLinksInputBuilder::try_new(my_base, ..)?.build())?;
/// #   Ok(())
/// # }
/// ```
///
/// Example: Get links of a specific type from a given base address.
/// ```rust,no_run
/// use hdk::prelude::*;
///
/// #[hdk_link_types]
/// pub enum LinkTypes {
///     Example,
/// }
///
/// # fn main() -> ExternResult<()> {
///     let my_base = ActionHash::from_raw_36(vec![0; 36]); // Some base address, this is a dummy address created for the example!
///     let links = get_links(GetLinksInputBuilder::try_new(my_base, LinkTypes::Example)?.build())?;
/// #   Ok(())
/// # }
/// ```
///
/// You can add additional filters using the functions defined on the builder.
/// For example, to only fetch links that are available locally, without going to the network:
/// ```rust,no_run
/// use hdk::prelude::*;
///
/// # fn main() -> ExternResult<()> {
///     let my_base = ActionHash::from_raw_36(vec![0; 36]); // Some base address, this is a dummy address created for the example!
///     let links = get_links(GetLinksInputBuilder::try_new(my_base, ..)?.get_options(GetStrategy::Local).build())?;
/// #   Ok(())
/// # }
/// ```
#[derive(PartialEq, Clone, Debug)]
pub struct GetLinksInputBuilder(GetLinksInput);

impl GetLinksInputBuilder {
    /// Create a new `GetLinksInputBuilder` from the required fields for a `GetLinksInput`.
    pub fn try_new(
        base_address: impl Into<AnyLinkableHash>,
        link_type: impl LinkTypeFilterExt,
    ) -> Result<Self, WasmError> {
        Ok(GetLinksInputBuilder(GetLinksInput {
            base_address: base_address.into(),
            link_type: link_type.try_into_filter()?,
            get_options: GetOptions::default(),
            tag_prefix: None,
            before: None,
            after: None,
            author: None,
        }))
    }

    /// Fetch links from network or local only.
    pub fn get_options(mut self, get_strategy: GetStrategy) -> Self {
        self.0.get_options.strategy = get_strategy;
        self
    }

    /// Filter for links with the given tag prefix.
    pub fn tag_prefix(mut self, tag_prefix: LinkTag) -> Self {
        self.0.tag_prefix = Some(tag_prefix);
        self
    }

    /// Filter for links created before `before`.
    pub fn before(mut self, before: Timestamp) -> Self {
        self.0.before = Some(before);
        self
    }

    /// Filter for links create after `after`.
    pub fn after(mut self, after: Timestamp) -> Self {
        self.0.after = Some(after);
        self
    }

    /// Filter for links created by this author.
    pub fn author(mut self, author: AgentPubKey) -> Self {
        self.0.author = Some(author);
        self
    }

    /// Construct the result of the builder.
    pub fn build(self) -> GetLinksInput {
        self.0
    }
}



================================================
File: crates/hdk/tests/integration.rs
================================================
mod tests;



================================================
File: crates/hdk/tests/tests/mod.rs
================================================
mod samples;



================================================
File: crates/hdk/tests/tests/samples.rs
================================================
#[test]
#[cfg_attr(feature = "fixturators", ignore)] // Turns on `full-dna-def` in holochain_zome_types which turns on `kitsune_p2p_timestamp/now`.
fn samples() {
    let t = trybuild::TestCases::new();
    t.compile_fail("tests/samples/*.rs");
}



================================================
File: crates/hdk/tests/tests/samples/no_timestamp_now.rs
================================================
use hdk::prelude::*;

// Intended to be a regression test for https://github.com/holochain/holochain/issues/3003
fn main() {
    // Should not be available, will crash in a wasm call
    Timestamp::now();
}



================================================
File: crates/hdk/tests/tests/samples/no_timestamp_now.stderr
================================================
error[E0599]: no function or associated item named `now` found for struct `hdk::prelude::Timestamp` in the current scope
 --> tests/samples/no_timestamp_now.rs:6:16
  |
6 |     Timestamp::now();
  |                ^^^ function or associated item not found in `Timestamp`



================================================
File: crates/hdk_derive/README.md
================================================
# hdk_derive

Derive macros for the holochain hdk.



================================================
File: crates/hdk_derive/Cargo.toml
================================================
[package]
name = "hdk_derive"
version = "0.5.0-dev.14"
description = "derive macros for the holochain hdk"
license = "Apache-2.0"
homepage = "https://github.com/holochain/holochain"
documentation = "https://docs.rs/hdk_derive"
authors = ["Holochain Core Dev Team <devcore@holochain.org>"]
keywords = ["holochain", "holo", "hdk"]
categories = ["cryptography"]
edition = "2021"

[lib]
proc-macro = true

# reminder - do not use workspace deps
[dependencies]
syn = { version = "1", features = ["full", "extra-traits"] }
quote = "1"
proc-macro2 = "1"
paste = "1.0"
darling = "0.14.1"
heck = "0.5"
# it's important that we depend on holochain_zome_types with no default
# features, both here AND in hdi, to reduce code bloat
holochain_integrity_types = { version = "^0.5.0-dev.12", path = "../holochain_integrity_types", default-features = false }
proc-macro-error = "1.0.4"

[dev-dependencies]
trybuild = "1.0"

[lints]
workspace = true

[features]
default = []
mock = []



================================================
File: crates/hdk_derive/CHANGELOG.md
================================================
---
default_semver_increment_mode: !pre_minor dev
---
# Changelog

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/). This project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## \[Unreleased\]

## 0.5.0-dev.14

- `#[hdk_extern]` validates the annotated functions return type

## 0.5.0-dev.13

## 0.5.0-dev.12

## 0.5.0-dev.11

## 0.5.0-dev.10

## 0.5.0-dev.9

## 0.5.0-dev.8

## 0.5.0-dev.7

## 0.5.0-dev.6

## 0.5.0-dev.5

## 0.5.0-dev.4

## 0.5.0-dev.3

## 0.5.0-dev.2

## 0.5.0-dev.1

## 0.5.0-dev.0

## 0.4.0

## 0.4.0-dev.15

## 0.4.0-dev.14

## 0.4.0-dev.13

## 0.4.0-dev.12

## 0.4.0-dev.11

## 0.4.0-dev.10

## 0.4.0-dev.9

## 0.4.0-dev.8

## 0.4.0-dev.7

## 0.4.0-dev.6

## 0.4.0-dev.5

## 0.4.0-dev.4

## 0.4.0-dev.3

## 0.4.0-dev.2

## 0.4.0-dev.1

## 0.4.0-dev.0

## 0.3.0

## 0.3.0-beta-dev.34

## 0.3.0-beta-dev.33

## 0.3.0-beta-dev.32

## 0.3.0-beta-dev.31

## 0.3.0-beta-dev.30

## 0.3.0-beta-dev.29

- Added support for `#[hdk_extern]` usage with parameterless functions

## 0.3.0-beta-dev.28

## 0.3.0-beta-dev.27

## 0.3.0-beta-dev.26

## 0.3.0-beta-dev.25

## 0.3.0-beta-dev.24

## 0.3.0-beta-dev.23

- **BREAKING CHANGE**: Renamed macros `hdk_entry_defs` to `hdk_entry_types` and `entry_def` to `entry_type` for naming consistency with `hdk_link_types` [\#2979](https://github.com/holochain/holochain/pull/2979)

## 0.3.0-beta-dev.22

## 0.3.0-beta-dev.21

## 0.3.0-beta-dev.20

## 0.3.0-beta-dev.19

## 0.3.0-beta-dev.18

## 0.3.0-beta-dev.17

- Added a macro `#![dna_properties]` which when applied to a struct, exposes a function `try_from_dna_properties()` on that struct

## 0.3.0-beta-dev.16

## 0.3.0-beta-dev.15

## 0.3.0-beta-dev.14

## 0.3.0-beta-dev.13

## 0.3.0-beta-dev.12

## 0.3.0-beta-dev.11

## 0.3.0-beta-dev.10

## 0.3.0-beta-dev.9

## 0.3.0-beta-dev.8

## 0.3.0-beta-dev.7

## 0.3.0-beta-dev.6

## 0.3.0-beta-dev.5

## 0.3.0-beta-dev.4

## 0.3.0-beta-dev.3

## 0.3.0-beta-dev.2

## 0.3.0-beta-dev.1

## 0.3.0-beta-dev.0

## 0.2.0

## 0.2.0-beta-rc.5

## 0.2.0-beta-rc.4

## 0.2.0-beta-rc.3

## 0.2.0-beta-rc.2

## 0.2.0-beta-rc.1

## 0.2.0-beta-rc.0

## 0.1.0

## 0.1.0-beta-rc.3

## 0.1.0-beta-rc.2

## 0.1.0-beta-rc.1

## 0.1.0-beta-rc.0

## 0.0.56

## 0.0.55

## 0.0.54

## 0.0.53

## 0.0.52

## 0.0.51

## 0.0.50

## 0.0.49

## 0.0.48

## 0.0.47

## 0.0.46

## 0.0.45

## 0.0.44

## 0.0.43

## 0.0.42

## 0.0.41

## 0.0.40

## 0.0.39

## 0.0.38

- `hdk_to_global_types` is removed.
- `hdk_to_local_types` becomes `hdk_to_coordinates`.

## 0.0.37

## 0.0.36

## 0.0.35

## 0.0.34

## 0.0.33

## 0.0.32

## 0.0.31

## 0.0.30

## 0.0.29

## 0.0.28

## 0.0.27

## 0.0.26

## 0.0.25

## 0.0.24

## 0.0.23

## 0.0.22

## 0.0.21

## 0.0.20

## 0.0.19

## 0.0.18

## 0.0.17

## 0.0.16

## 0.0.15

- `#[hdk_extern(infallible)]` now supports leaving off the return type of a fn [PR1049](https://github.com/holochain/holochain/pull/1049)

## 0.0.14

## 0.0.13

## 0.0.12

## 0.0.11

## 0.0.10

### Added

- Added support for `#[hdk_extern(infallible)]`

## 0.0.9

## 0.0.8

## 0.0.7

## 0.0.6

## 0.0.5

## 0.0.4

## 0.0.3



================================================
File: crates/hdk_derive/LICENSE_CAL-1.0
================================================
# Cryptographic Autonomy License version 1.0

*This Cryptographic Autonomy License (the License) applies to any Work whose owner has marked it with any of the following notices:*

*Licensed under the Cryptographic Autonomy License version 1.0, or*

*SPDX-License-Identifier: CAL-1.0, or*

*Licensed under the Cryptographic Autonomy License version 1.0, with Combined Work Exception, or*

*SPDX-License-Identifier: CAL-1.0 with Combined-Work-Exception.*

------

## 1. Purpose

This License gives You unlimited permission to use and modify the software to which it applies (the Work), either as-is or in modified form, for Your private purposes, while protecting the owners and contributors to the software from liability. 

This License also strives to protect the freedom and autonomy of third parties who receive the Work from you.  If any non-affiliated third party receives any part, aspect, or element of the Work from You, this License requires that You provide that third party all the permissions and materials needed to independently use and modify the Work without that third party having a loss of data or capability due to your actions.

The full permissions, conditions, and other terms are laid out below.

## 2. Receiving a License

In order to receive this License, You must agree to its rules. The rules of this License are both obligations of Your agreement with the Licensor and conditions to your License. You must not do anything with the Work that triggers a rule You cannot or will not follow. 

### 2.1. Application

The terms of this License apply to the Work as you receive it from Licensor, as well as to any modifications, elaborations, or implementations created by You that contain any licenseable portion of the Work (a Modified Work). Unless specified, any reference to the Work also applies to a Modified Work.

### 2.2. Offer and Acceptance

This License is automatically offered to every person and organization. You show that you accept this License and agree to its conditions by taking any action with the Work that, absent this License, would infringe any intellectual property right held by Licensor. 

### 2.3. Compliance and Remedies

Any failure to act according to the terms and conditions of this License places Your use of the Work outside the scope of the License and infringes the intellectual property rights of the Licensor. In the event of infringement, the terms and conditions of this License may be enforced by Licensor under the intellectual property laws of any jurisdiction to which You are subject. You also agree that either the Licensor or a Recipient (as an intended third-party beneficiary) may enforce the terms and conditions of this License against You via specific performance.

## 3. Permissions and Conditions

### 3.1. Permissions Granted

Conditioned on compliance with section 4, and subject to the limitations of section 3.2, Licensor grants You the world-wide, royalty-free, non-exclusive permission to: 

> a) Take any action with the Work that would infringe the non-patent intellectual property laws of any jurisdiction to which You are subject; and
>
> b) Take any action with the Work that would infringe any patent claims that Licensor can license or becomes able to license, to the extent that those claims are embodied in the Work as distributed by Licensor.

### 3.2. Limitations on Permissions Granted

The following limitations apply to the permissions granted in section 3.1:

> a) Licensor does not grant any patent license for claims that are only infringed due to modification of the Work as provided by Licensor, or the combination of the Work as provided by Licensor, directly or indirectly, with any other component, including other software or hardware.
>
> b) Licensor does not grant any license to the trademarks, service marks, or logos of Licensor, except to the extent necessary to comply with the attribution conditions in section 4.1 of this License.

## 4. Conditions

If You exercise any permission granted by this License, such that the Work, or any part, aspect, or element of the Work, is distributed, communicated, made available, or made perceptible to a non-Affiliate third party (a Recipient), either via physical delivery or via a network connection to the Recipient, You must comply with the following conditions: 

### 4.1. Provide Access to Source Code

Subject to the exception in section 4.4, You must provide to each Recipient a copy of, or no-charge unrestricted network access to, the Source Code corresponding to the Work.

The Source Code of the Work means the form of the Work preferred for making modifications, including any comments, configuration information, documentation, help materials, installation instructions, cryptographic seeds or keys, and any information reasonably necessary for the Recipient to independently compile and use the Source Code and to have full access to the functionality contained in the Work.

#### 4.1.1. Providing Network Access to the Source Code

Network access to the Notices and Source Code may be provided by You or by a third party, such as a public software repository, and must persist during the same period in which You exercise any of the permissions granted to You under this License and for at least one year thereafter.

#### 4.1.2. Source Code for a Modified Work

Subject to the exception in section 4.5, You must provide to each Recipient of a Modified Work Access to Source Code corresponding to those portions of the Work remaining in the Modified Work as well as the modifications used by You to create the Modified Work. The Source Code corresponding to the modifications in the Modified Work must be provided to the Recipient either a) under this License, or b) under a Compatible Open Source License.

A Compatible Open Source License means a license accepted by the Open Source Initiative that allows object code created using both Source Code provided under this License and Source Code provided under the other open source license to be distributed together as a single work.

#### 4.1.3. Coordinated Disclosure of Security Vulnerabilities

You may delay providing the Source Code corresponding to a particular modification of the Work for up to ninety (90) days (the Embargo Period) if: a) the modification is intended to address a newly-identified vulnerability or a security flaw in the Work, b) disclosure of the vulnerability or security flaw before the end of the Embargo Period would put the data, identity, or autonomy of one or more Recipients of the Work at significant risk, c) You are participating in a coordinated disclosure of the vulnerability or security flaw with one or more additional Licensees, and d) Access to the Source Code pertaining to the modification is provided to all Recipients at the end of the Embargo Period.

### 4.2. Maintain User Autonomy

In addition to providing each Recipient the opportunity to have Access to the Source Code, You cannot use the permissions given under this License to interfere with a Recipients ability to fully use an independent copy of the Work generated from the Source Code You provide with the Recipients own User Data.

User Data means any data that is an input to or an output from the Work, where the presence of the data is necessary for substantially identical use of the Work in an equivalent context chosen by the Recipient, and where the Recipient has an existing ownership interest, an existing right to possess, or where the data has been generated by, for, or has been assigned to the Recipient.

#### 4.2.1. No Withholding User Data

Throughout any period in which You exercise any of the permissions granted to You under this License, You must also provide to any Recipient to whom you provide services via the Work, a no-charge copy, provided in a commonly used electronic form, of the Recipients User Data in your possession, to the extent that such User Data is available to You for use in conjunction with the Work. 

#### 4.2.2. No Technical Measures that Limit Access

You may not, by the use of cryptographic methods applied to anything provided to the Recipient, by possession or control of cryptographic keys, seeds, or hashes, by other technological protection measures, or by any other method, limit a Recipient's ability to access any functionality present in the Recipient's independent copy of the Work, or deny a Recipient full control of the Recipient's User Data.

#### 4.2.3. No Legal or Contractual Measures that Limit Access

You may not contractually restrict a Recipient's ability to independently exercise the permissions granted under this License. You waive any legal power to forbid circumvention of technical protection measures that include use of the Work, and You waive any claim that the capabilities of the Work were limited or modified as a means of enforcing the legal rights of third parties against Recipients.

### 4.3. Provide Notices and Attribution

You must retain all licensing, authorship, or attribution notices contained in the Source Code (the Notices), and provide all such Notices to each Recipient, together with a statement acknowledging the use of the Work. Notices may be provided directly to a Recipient or via an easy-to-find hyperlink to an Internet location also providing Access to Source Code.

### 4.4. Scope of Conditions in this License

You are required to uphold the conditions of this License only relative to those who are Recipients of the Work from You.  Other than providing Recipients with the applicable Notices, Access to Source Code, and a copy of and full control of their User Data, nothing in this License requires You to provide processing services to or engage in network interactions with anyone. 

### 4.5. Combined Work Exception

As an exception to condition that You provide Recipients Access to Source Code, any Source Code files marked by the Licensor as having the Combined Work Exception, or any object code exclusively resulting from Source Code files so marked, may be combined with other Software into a Larger Work. So long as you comply with the requirements to provide Recipients the applicable Notices and Access to the Source Code provided to You by Licensor, and you provide Recipients access to their User Data and do not limit Recipients ability to independently work with their User Data, any other Software in the Larger Work as well as the Larger Work as a whole may be licensed under the terms of your choice.

## 5. Term and Termination

The term of this License begins when You receive the Work, and continues until terminated for any of the reasons described herein, or until all Licensors intellectual property rights in the Software expire, whichever comes first (Term). This License cannot be revoked, only terminated for the reasons listed below. 

### 5.1. Effect of Termination

If this License is terminated for any reason, all permissions granted to You under Section 3 by any Licensor automatically terminate. You will immediately cease exercising any permissions granted in this License relative to the Work, including as part of any Modified Work.

### 5.2. Termination for Non-Compliance; Reinstatement

This License terminates automatically if You fail to comply with any of the conditions in section 4. As a special exception to termination for non-compliance, Your permissions for the Work under this License will automatically be reinstated if You come into compliance with all the conditions in section 2 within sixty (60) days of being notified by Licensor or an intended third party beneficiary of Your noncompliance. You are eligible for reinstatement of permissions for the Work one time only, and only for the sixty days immediately after becoming aware of noncompliance. Loss of permissions granted for the Work under this License due to either a) sustained noncompliance lasting more than sixty days or b) subsequent termination for noncompliance after reinstatement, is permanent, unless rights are specifically restored by Licensor in writing. 

### 5.3 Termination Due to Litigation

If You initiate litigation against Licensor, or any Recipient of the Work, either direct or indirect, asserting that the Work directly or indirectly infringes any patent, then all permissions granted to You by this License shall terminate. In the event of termination due to litigation, all permissions validly granted by You under this License, directly or indirectly, shall survive termination. Administrative review procedures, declaratory judgment actions, counterclaims in response to patent litigation, and enforcement actions against former Licensees terminated under this section do not cause termination due to litigation.

## 6. Disclaimer of Warranty and Limit on Liability

As far as the law allows, the Work comes AS-IS, without any warranty of any kind, and no Licensor or contributor will be liable to anyone for any damages related to this software or this license, under any kind of legal claim, or for any type of damages, including indirect, special, incidental, or consequential damages of any type arising as a result of this License or the use of the Work including, without limitation, damages for loss of goodwill, work stoppage, computer failure or malfunction, loss of profits, revenue, or any and all other commercial damages or losses. 

## 7. Other Provisions

### 7.1. Affiliates

An Affiliate means any other entity that, directly or indirectly through one or more intermediaries, controls, is controlled by, or is under common control with, the Licensee. Employees of a Licensee and natural persons acting as contractors exclusively providing services to Licensee are also Affiliates.

### 7.2. Choice of Jurisdiction and Governing Law

A Licensor may require that any action or suit by a Licensee relating to a Work provided by Licensor under this License may be brought only in the courts of a particular jurisdiction and under the laws of a particular jurisdiction (excluding its conflict-of-law provisions), if Licensor provides conspicuous notice of the particular jurisdiction to all Licensees.

### 7.3. No Sublicensing

This License is not sublicensable. Each time You provide the Work or a Modified Work to a Recipient, the Recipient automatically receives a license under the terms described in this License. You may not impose any further reservations, conditions, or other provisions on any Recipients exercise of the permissions granted herein. 

### 7.4. Attorneys' Fees

In any action to enforce the terms of this License, or seeking damages relating thereto, including by an intended third party beneficiary, the prevailing party shall be entitled to recover its costs and expenses, including, without limitation, reasonable attorneys' fees and costs incurred in connection with such action, including any appeal of such action. A prevailing party is the party that achieves, or avoids, compliance with this License, including through settlement. This section shall survive the termination of this License.

### 7.5. No Waiver

Any failure by Licensor to enforce any provision of this License will not constitute a present or future waiver of such provision nor limit Licensors ability to enforce such provision at a later time.

### 7.6. Severability

If any provision of this License is held to be unenforceable, such provision shall be reformed only to the extent necessary to make it enforceable. Any invalid or unenforceable portion will be interpreted to the effect and intent of the original portion. If such a construction is not possible, the invalid or unenforceable portion will be severed from this License but the rest of this License will remain in full force and effect.

### 7.7. License for the Text of this License

The text of this license is released under the Creative Commons Attribution-ShareAlike 4.0 International License, with the caveat that any modifications of this license may not use the name Cryptographic Autonomy License or any name confusingly similar thereto to describe any derived work of this License.




================================================
File: crates/hdk_derive/src/dna_properties.rs
================================================
use proc_macro::TokenStream;
use proc_macro_error::abort;
use syn::parse_macro_input;
use syn::Item;
use syn::ItemStruct;

pub fn build(_attrs: TokenStream, input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as Item);
    let ident = match &input {
        Item::Struct(ItemStruct { ident, .. }) => ident,
        _ => abort!(input, "dna_properties macro can only be used on Structs"),
    };

    let output = quote::quote! {
        #[derive(Serialize, Deserialize, SerializedBytes, Debug)]
        #input

        impl TryFromDnaProperties for #ident {
            type Error = WasmError;

            fn try_from_dna_properties() -> Result<#ident, WasmError> {
                #ident::try_from(dna_info()?.modifiers.properties)
                    .map_err(|_| wasm_error!(WasmErrorInner::Guest(format!("Failed to deserialize DNA properties into {}", std::any::type_name::<#ident>()))))
            }
        }
    };
    output.into()
}



================================================
File: crates/hdk_derive/src/entry_helper.rs
================================================
use proc_macro::TokenStream;
use proc_macro_error::abort;
use syn::parse_macro_input;
use syn::Item;
use syn::ItemEnum;
use syn::ItemStruct;

pub fn build(_attrs: TokenStream, input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as Item);

    let ident = match &input {
        Item::Enum(ItemEnum { ident, .. }) | Item::Struct(ItemStruct { ident, .. }) => ident,
        _ => abort!(
            input,
            "hdk_entry_helper can only be used on Enums or Structs"
        ),
    };

    let output = quote::quote! {
        #[derive(Serialize, Deserialize, SerializedBytes, Debug)]
        #input

        hdi::app_entry!(#ident);
    };
    output.into()
}



================================================
File: crates/hdk_derive/src/entry_type_registration.rs
================================================
use holochain_integrity_types::EntryVisibility;
use holochain_integrity_types::RequiredValidations;
use proc_macro::TokenStream;

use darling::FromDeriveInput;
use darling::FromVariant;
use proc_macro_error::abort;
use syn::parse_macro_input;

#[derive(FromVariant)]
#[darling(attributes(entry_type, entry_name))]
struct VarOpts {
    ident: syn::Ident,
    #[darling(default)]
    name: Option<String>,
    #[darling(default)]
    visibility: Option<String>,
    #[darling(default)]
    required_validations: Option<u8>,
    #[darling(default)]
    cache_at_agent_activity: Option<bool>,
}

#[derive(FromDeriveInput)]
struct Opts {
    ident: syn::Ident,
    data: darling::ast::Data<VarOpts, darling::util::Ignored>,
}

pub fn derive(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input);
    let opts = match Opts::from_derive_input(&input) {
        Ok(o) => o,
        Err(e) => abort!(e.span(), e),
    };
    let Opts { ident, data } = opts;

    let inner: proc_macro2::TokenStream = match data {
        darling::ast::Data::Enum(variants) => variants
            .into_iter()
            .flat_map(
                |VarOpts {
                     ident: v_ident,
                     name,
                     visibility,
                     required_validations,
                     cache_at_agent_activity,
                     ..
                 }| {
                    let id = crate::util::to_snake_case(name, &v_ident);
                    let visibility = parse_visibility(&v_ident, visibility);
                    let required_validations =
                        required_validations.unwrap_or_else(|| RequiredValidations::default().0);
                    let cache_at_agent_activity = cache_at_agent_activity.unwrap_or(false);
                    quote::quote! {
                        EntryDef {
                            id: EntryDefId::App(AppEntryName::from_str(#id)),
                            visibility: #visibility,
                            required_validations: RequiredValidations(#required_validations),
                            cache_at_agent_activity: #cache_at_agent_activity,
                        },
                    }
                },
            )
            .collect(),
        _ => abort!(ident, "EntryDefRegistration can only be derived on Enums"),
    };

    let output = quote::quote! {
        impl EntryDefRegistration for #ident {
            const ENTRY_DEFS: &'static [EntryDef] = &[#inner];
        }
        impl EntryDefRegistration for &#ident {
            const ENTRY_DEFS: &'static [EntryDef] = &#ident::ENTRY_DEFS;
        }
    };
    output.into()
}

fn parse_visibility(ident: &syn::Ident, variant: Option<String>) -> proc_macro2::TokenStream {
    let variant = match variant {
        Some(v) => v,
        None => return default_visibility(),
    };
    match variant.as_str() {
        "public" => quote::quote! {EntryVisibility::Public},
        "private" => quote::quote! {EntryVisibility::Private},
        _ => abort!(ident, "EntryVisibility can only be `public` or `private`"),
    }
}

fn default_visibility() -> proc_macro2::TokenStream {
    match EntryVisibility::default() {
        EntryVisibility::Public => quote::quote! {EntryVisibility::Public},
        EntryVisibility::Private => quote::quote! {EntryVisibility::Private},
    }
}



================================================
File: crates/hdk_derive/src/entry_types.rs
================================================
use proc_macro::TokenStream;
use syn::parse_macro_input;
use syn::Item;

pub fn build(attrs: TokenStream, input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as Item);
    let attr_args: proc_macro2::TokenStream = attrs.into();

    let output = quote::quote! {
        #[hdk_derive::hdk_entry_types_name_registration(#attr_args)]
        #[hdk_derive::hdk_entry_types_conversions]
        #[derive(Debug)]
        #input
    };
    output.into()
}



================================================
File: crates/hdk_derive/src/entry_types_conversions.rs
================================================
use proc_macro::TokenStream;
use proc_macro_error::abort;
use syn::parse_macro_input;
use syn::Item;
use syn::ItemEnum;

use crate::util::get_single_tuple_variant;

pub fn build(_attrs: TokenStream, input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as Item);
    let (ident, variants) = match &input {
        Item::Enum(ItemEnum {
            ident, variants, ..
        }) => (ident, variants),
        _ => abort!(input, "hdk_entry_def_conversions can only be used on Enums"),
    };

    let inner: proc_macro2::TokenStream = variants
        .into_iter()
        .map(
            |syn::Variant {
                 ident: v_ident,
                 fields,
                 ..
             }| {
                get_single_tuple_variant(v_ident, fields);
                quote::quote! {#ident::#v_ident (v) => SerializedBytes::try_from(v),}
            },
        )
        .collect();
    let try_from_sb: proc_macro2::TokenStream = quote::quote! {
        let result = match t {
            #inner
        };
    };

    let output = quote::quote! {
        #input

        impl TryFrom<&#ident> for AppEntryBytes {
            type Error = WasmError;
            fn try_from(t: &#ident) -> Result<Self, Self::Error> {
                #try_from_sb
                AppEntryBytes::try_from(result.map_err(|e| wasm_error!(e))?).map_err(|entry_error| match entry_error {
                    EntryError::SerializedBytes(serialized_bytes_error) => {
                        wasm_error!(WasmErrorInner::Serialize(serialized_bytes_error))
                    }
                    EntryError::EntryTooLarge(_) => {
                        wasm_error!(WasmErrorInner::Guest(entry_error.to_string()))
                    }
                })
            }
        }
        impl TryFrom<#ident> for AppEntryBytes {
            type Error = WasmError;
            fn try_from(t: #ident) -> Result<Self, Self::Error> {
                Self::try_from(&t)
            }
        }

        impl TryFrom<&#ident> for Entry {
            type Error = WasmError;
            fn try_from(t: &#ident) -> Result<Self, Self::Error> {
                Ok(Self::App(AppEntryBytes::try_from(t)?))
            }
        }

        impl TryFrom<#ident> for Entry {
            type Error = WasmError;
            fn try_from(t: #ident) -> Result<Self, Self::Error> {
                Self::try_from(&t)
            }
        }

    };
    output.into()
}



================================================
File: crates/hdk_derive/src/entry_types_name_registration.rs
================================================
use darling::FromMeta;
use proc_macro::TokenStream;
use proc_macro_error::abort;
use syn::parse_macro_input;
use syn::AttributeArgs;
use syn::Item;
use syn::ItemEnum;

use crate::util::get_unit_ident;

#[derive(Debug, FromMeta)]
pub struct MacroArgs {
    #[darling(default)]
    skip_hdk_extern: bool,
}

pub fn build(attrs: TokenStream, input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as Item);
    let attr_args = parse_macro_input!(attrs as AttributeArgs);

    let (ident, variants, attrs) = match &input {
        Item::Enum(ItemEnum {
            ident,
            variants,
            attrs,
            ..
        }) => (ident, variants, attrs),
        _ => abort!(
            input,
            "hdk_entry_types_name_registration can only be used on Enums"
        ),
    };

    let unit_ident = get_unit_ident(attrs);

    let units_to_full: proc_macro2::TokenStream = variants
        .iter()
        .map(|syn::Variant { ident: v_ident, .. }| {
            quote::quote! {
                #unit_ident::#v_ident => Ok(Self::#v_ident(entry.try_into()?)),
            }
        })
        .collect();

    let skip_hdk_extern = match MacroArgs::from_list(&attr_args) {
        Ok(a) => a.skip_hdk_extern,
