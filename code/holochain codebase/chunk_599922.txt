## [holochain\_p2p-0.0.27](crates/holochain_p2p/CHANGELOG.md#0.0.27)

## [holochain\_cli\_bundle-0.0.23](crates/holochain_cli_bundle/CHANGELOG.md#0.0.23)

- The DNA manifest now requires an `origin_time` Timestamp field, which will be used in the forthcoming gossip optimization.
  - There is a new system validation rule that all Header timestamps (including the initial Dna header) must come after the DNA’s `origin_time` field.
  - `hc dna init` injects the current system time as *microseconds* for the `origin_time` field of the DNA manifest
  - Since this field is not actually hooked up to anything at the moment, if the field is not present in a DNA manifest, a default `origin_time` of `January 1, 2022 12:00:00 AM` will be used instead. Once the new gossip algorithm lands, this default will be removed, and this will become a breaking change for DNA manifests which have not yet added an `origin_time`.

## [holochain\_types-0.0.27](crates/holochain_types/CHANGELOG.md#0.0.27)

## [holochain\_keystore-0.0.27](crates/holochain_keystore/CHANGELOG.md#0.0.27)

## [holochain\_sqlite-0.0.27](crates/holochain_sqlite/CHANGELOG.md#0.0.27)

## [kitsune\_p2p-0.0.24](crates/kitsune_p2p/CHANGELOG.md#0.0.24)

## [kitsune\_p2p\_proxy-0.0.18](crates/kitsune_p2p_proxy/CHANGELOG.md#0.0.18)

## [kitsune\_p2p\_transport\_quic-0.0.18](crates/kitsune_p2p_transport_quic/CHANGELOG.md#0.0.18)

## [kitsune\_p2p\_types-0.0.18](crates/kitsune_p2p_types/CHANGELOG.md#0.0.18)

- Sharded DHT arcs is on by default. This means that once the network reaches a certain size, it will split into multiple shards.

## [hdk-0.0.123](crates/hdk/CHANGELOG.md#0.0.123)

## [hdk\_derive-0.0.25](crates/hdk_derive/CHANGELOG.md#0.0.25)

## [holochain\_zome\_types-0.0.25](crates/holochain_zome_types/CHANGELOG.md#0.0.25)

- Adds the `Op` type which is used in the validation callback. [\#1212](https://github.com/holochain/holochain/pull/1212)
- Adds the `SignedHashed<T>` type for any data that can be signed and hashed.
- BREAKING CHANGE: Many hashing algorithms can now be specified although only the `Entry` hash type does anything yet [\#1222](https://github.com/holochain/holochain/pull/1222)

## [kitsune\_p2p\_timestamp-0.0.6](crates/kitsune_p2p_timestamp/CHANGELOG.md#0.0.6)

## [holo\_hash-0.0.20](crates/holo_hash/CHANGELOG.md#0.0.20)

# 20220211.091841

- Bump `holochain_wasmer_*` crates to v0.0.77 which relaxes the version requirements on `serde`. [\#1204](https://github.com/holochain/holochain/pull/1204)

## [holochain-0.0.126](crates/holochain/CHANGELOG.md#0.0.126)

## [kitsune\_p2p\_bootstrap-0.0.2](crates/kitsune_p2p_bootstrap/CHANGELOG.md#0.0.2)

## [holochain\_test\_wasm\_common-0.0.22](crates/holochain_test_wasm_common/CHANGELOG.md#0.0.22)

## [holochain\_cascade-0.0.26](crates/holochain_cascade/CHANGELOG.md#0.0.26)

## [holochain\_cli-0.0.27](crates/holochain_cli/CHANGELOG.md#0.0.27)

## [holochain\_cli\_sandbox-0.0.23](crates/holochain_cli_sandbox/CHANGELOG.md#0.0.23)

## [holochain\_websocket-0.0.26](crates/holochain_websocket/CHANGELOG.md#0.0.26)

## [holochain\_conductor\_api-0.0.26](crates/holochain_conductor_api/CHANGELOG.md#0.0.26)

## [holochain\_state-0.0.26](crates/holochain_state/CHANGELOG.md#0.0.26)

## [holochain\_wasm\_test\_utils-0.0.26](crates/holochain_wasm_test_utils/CHANGELOG.md#0.0.26)

## [holochain\_p2p-0.0.26](crates/holochain_p2p/CHANGELOG.md#0.0.26)

## [holochain\_cli\_bundle-0.0.22](crates/holochain_cli_bundle/CHANGELOG.md#0.0.22)

## [holochain\_types-0.0.26](crates/holochain_types/CHANGELOG.md#0.0.26)

## [holochain\_keystore-0.0.26](crates/holochain_keystore/CHANGELOG.md#0.0.26)

## [holochain\_sqlite-0.0.26](crates/holochain_sqlite/CHANGELOG.md#0.0.26)

## [kitsune\_p2p-0.0.23](crates/kitsune_p2p/CHANGELOG.md#0.0.23)

- Fixes D-01415 holochain panic on startup [\#1206](https://github.com/holochain/holochain/pull/1206)

## [kitsune\_p2p\_proxy-0.0.17](crates/kitsune_p2p_proxy/CHANGELOG.md#0.0.17)

## [kitsune\_p2p\_transport\_quic-0.0.17](crates/kitsune_p2p_transport_quic/CHANGELOG.md#0.0.17)

## [kitsune\_p2p\_types-0.0.17](crates/kitsune_p2p_types/CHANGELOG.md#0.0.17)

## [mr\_bundle-0.0.7](crates/mr_bundle/CHANGELOG.md#0.0.7)

## [holochain\_util-0.0.7](crates/holochain_util/CHANGELOG.md#0.0.7)

## [hdk-0.0.122](crates/hdk/CHANGELOG.md#0.0.122)

- hdk: `delete`, `delete_entry`, and `delete_cap_grant` can all now take a `DeleteInput` as an argument to be able specify `ChainTopOrdering`, congruent with `create` and `update`. This change is backward compatible: a plain `HeaderHash` can still be used as input to `delete`.

## [hdk\_derive-0.0.24](crates/hdk_derive/CHANGELOG.md#0.0.24)

## [holochain\_zome\_types-0.0.24](crates/holochain_zome_types/CHANGELOG.md#0.0.24)

## [holo\_hash-0.0.19](crates/holo_hash/CHANGELOG.md#0.0.19)

## [kitsune\_p2p\_dht\_arc-0.0.9](crates/kitsune_p2p_dht_arc/CHANGELOG.md#0.0.9)

# 20220202.112225

## [holochain-0.0.125](crates/holochain/CHANGELOG.md#0.0.125)

## [kitsune\_p2p\_bootstrap-0.0.1](crates/kitsune_p2p_bootstrap/CHANGELOG.md#0.0.1)

## [holochain\_test\_wasm\_common-0.0.21](crates/holochain_test_wasm_common/CHANGELOG.md#0.0.21)

## [holochain\_cascade-0.0.25](crates/holochain_cascade/CHANGELOG.md#0.0.25)

## [holochain\_cli-0.0.26](crates/holochain_cli/CHANGELOG.md#0.0.26)

## [holochain\_cli\_sandbox-0.0.22](crates/holochain_cli_sandbox/CHANGELOG.md#0.0.22)

## [holochain\_websocket-0.0.25](crates/holochain_websocket/CHANGELOG.md#0.0.25)

## [holochain\_conductor\_api-0.0.25](crates/holochain_conductor_api/CHANGELOG.md#0.0.25)

## [holochain\_state-0.0.25](crates/holochain_state/CHANGELOG.md#0.0.25)

## [holochain\_wasm\_test\_utils-0.0.25](crates/holochain_wasm_test_utils/CHANGELOG.md#0.0.25)

## [holochain\_p2p-0.0.25](crates/holochain_p2p/CHANGELOG.md#0.0.25)

## [holochain\_cli\_bundle-0.0.21](crates/holochain_cli_bundle/CHANGELOG.md#0.0.21)

## [holochain\_types-0.0.25](crates/holochain_types/CHANGELOG.md#0.0.25)

## [holochain\_keystore-0.0.25](crates/holochain_keystore/CHANGELOG.md#0.0.25)

## [holochain\_sqlite-0.0.25](crates/holochain_sqlite/CHANGELOG.md#0.0.25)

## [kitsune\_p2p-0.0.22](crates/kitsune_p2p/CHANGELOG.md#0.0.22)

## [kitsune\_p2p\_proxy-0.0.16](crates/kitsune_p2p_proxy/CHANGELOG.md#0.0.16)

## [kitsune\_p2p\_transport\_quic-0.0.16](crates/kitsune_p2p_transport_quic/CHANGELOG.md#0.0.16)

## [kitsune\_p2p\_types-0.0.16](crates/kitsune_p2p_types/CHANGELOG.md#0.0.16)

## [hdk-0.0.121](crates/hdk/CHANGELOG.md#0.0.121)

## [hdk\_derive-0.0.23](crates/hdk_derive/CHANGELOG.md#0.0.23)

## [holochain\_zome\_types-0.0.23](crates/holochain_zome_types/CHANGELOG.md#0.0.23)

## [holo\_hash-0.0.18](crates/holo_hash/CHANGELOG.md#0.0.18)

## [kitsune\_p2p\_dht\_arc-0.0.8](crates/kitsune_p2p_dht_arc/CHANGELOG.md#0.0.8)

- New arc resizing algorithm based on `PeerViewBeta`
- In both arc resizing algorithms, instead of aiming for the ideal target arc size, aim for an ideal range. This slack in the system allows all agents to converge on their target more stably, with less oscillation.

# 20220126.200716

- Bump holochain-wasmer to fix a compilation issue. [\#1194](https://github.com/holochain/holochain/pull/1194)

## [holochain-0.0.124](crates/holochain/CHANGELOG.md#0.0.124)

## [holochain\_test\_wasm\_common-0.0.20](crates/holochain_test_wasm_common/CHANGELOG.md#0.0.20)

## [holochain\_cascade-0.0.24](crates/holochain_cascade/CHANGELOG.md#0.0.24)

## [holochain\_cli-0.0.25](crates/holochain_cli/CHANGELOG.md#0.0.25)

## [holochain\_cli\_sandbox-0.0.21](crates/holochain_cli_sandbox/CHANGELOG.md#0.0.21)

## [holochain\_websocket-0.0.24](crates/holochain_websocket/CHANGELOG.md#0.0.24)

## [holochain\_conductor\_api-0.0.24](crates/holochain_conductor_api/CHANGELOG.md#0.0.24)

## [holochain\_state-0.0.24](crates/holochain_state/CHANGELOG.md#0.0.24)

## [holochain\_wasm\_test\_utils-0.0.24](crates/holochain_wasm_test_utils/CHANGELOG.md#0.0.24)

## [holochain\_p2p-0.0.24](crates/holochain_p2p/CHANGELOG.md#0.0.24)

## [holochain\_cli\_bundle-0.0.20](crates/holochain_cli_bundle/CHANGELOG.md#0.0.20)

## [holochain\_types-0.0.24](crates/holochain_types/CHANGELOG.md#0.0.24)

## [holochain\_keystore-0.0.24](crates/holochain_keystore/CHANGELOG.md#0.0.24)

## [holochain\_sqlite-0.0.24](crates/holochain_sqlite/CHANGELOG.md#0.0.24)

## [kitsune\_p2p-0.0.21](crates/kitsune_p2p/CHANGELOG.md#0.0.21)

## [hdk-0.0.120](crates/hdk/CHANGELOG.md#0.0.120)

- docs: Add introduction to front-page and move example section up [1172](https://github.com/holochain/holochain/pull/1172)

## [hdk\_derive-0.0.22](crates/hdk_derive/CHANGELOG.md#0.0.22)

## [holochain\_zome\_types-0.0.22](crates/holochain_zome_types/CHANGELOG.md#0.0.22)

## [holo\_hash-0.0.17](crates/holo_hash/CHANGELOG.md#0.0.17)

# 20220120.093525

## [holochain-0.0.123](crates/holochain/CHANGELOG.md#0.0.123)

- Fixes issue where holochain could get stuck in infinite loop when trying to send validation receipts. [\#1181](https://github.com/holochain/holochain/pull/1181).
- Additional networking metric collection and associated admin api `DumpNetworkMetrics { dna_hash: Option<DnaHash> }` for inspection of metrics [\#1160](https://github.com/holochain/holochain/pull/1160)
- **BREAKING CHANGE** - Schema change for metrics database. Holochain will persist historical metrics once per hour, if you do not clear the metrics database it will crash at that point. [\#1183](https://github.com/holochain/holochain/pull/1183)

## [holochain\_test\_wasm\_common-0.0.19](crates/holochain_test_wasm_common/CHANGELOG.md#0.0.19)

## [holochain\_cascade-0.0.23](crates/holochain_cascade/CHANGELOG.md#0.0.23)

## [holochain\_cli-0.0.24](crates/holochain_cli/CHANGELOG.md#0.0.24)

## [holochain\_cli\_sandbox-0.0.20](crates/holochain_cli_sandbox/CHANGELOG.md#0.0.20)

## [holochain\_websocket-0.0.23](crates/holochain_websocket/CHANGELOG.md#0.0.23)

## [holochain\_conductor\_api-0.0.23](crates/holochain_conductor_api/CHANGELOG.md#0.0.23)

## [holochain\_state-0.0.23](crates/holochain_state/CHANGELOG.md#0.0.23)

## [holochain\_wasm\_test\_utils-0.0.23](crates/holochain_wasm_test_utils/CHANGELOG.md#0.0.23)

## [holochain\_p2p-0.0.23](crates/holochain_p2p/CHANGELOG.md#0.0.23)

## [holochain\_cli\_bundle-0.0.19](crates/holochain_cli_bundle/CHANGELOG.md#0.0.19)

## [holochain\_types-0.0.23](crates/holochain_types/CHANGELOG.md#0.0.23)

## [holochain\_keystore-0.0.23](crates/holochain_keystore/CHANGELOG.md#0.0.23)

## [holochain\_sqlite-0.0.23](crates/holochain_sqlite/CHANGELOG.md#0.0.23)

## [kitsune\_p2p-0.0.20](crates/kitsune_p2p/CHANGELOG.md#0.0.20)

## [hdk-0.0.119](crates/hdk/CHANGELOG.md#0.0.119)

## [hdk\_derive-0.0.21](crates/hdk_derive/CHANGELOG.md#0.0.21)

## [holochain\_zome\_types-0.0.21](crates/holochain_zome_types/CHANGELOG.md#0.0.21)

## [holo\_hash-0.0.16](crates/holo_hash/CHANGELOG.md#0.0.16)

# 20220106.093622

## [holochain-0.0.122](crates/holochain/CHANGELOG.md#0.0.122)

- Adds better batching to validation workflows for much faster validation. [\#1167](https://github.com/holochain/holochain/pull/1167).

## [holochain\_test\_wasm\_common-0.0.18](crates/holochain_test_wasm_common/CHANGELOG.md#0.0.18)

## [holochain\_cascade-0.0.22](crates/holochain_cascade/CHANGELOG.md#0.0.22)

## [holochain\_cli-0.0.23](crates/holochain_cli/CHANGELOG.md#0.0.23)

## [holochain\_cli\_sandbox-0.0.19](crates/holochain_cli_sandbox/CHANGELOG.md#0.0.19)

## [holochain\_websocket-0.0.22](crates/holochain_websocket/CHANGELOG.md#0.0.22)

## [holochain\_conductor\_api-0.0.22](crates/holochain_conductor_api/CHANGELOG.md#0.0.22)

- Adds the ability to manually insert elements into a source chain using the `AdminRequest::AddElements` command. Please check the docs and PR for more details / warnings on proper usage. [\#1166](https://github.com/holochain/holochain/pull/1166)

## [holochain\_state-0.0.22](crates/holochain_state/CHANGELOG.md#0.0.22)

## [holochain\_wasm\_test\_utils-0.0.22](crates/holochain_wasm_test_utils/CHANGELOG.md#0.0.22)

## [holochain\_p2p-0.0.22](crates/holochain_p2p/CHANGELOG.md#0.0.22)

## [holochain\_cli\_bundle-0.0.18](crates/holochain_cli_bundle/CHANGELOG.md#0.0.18)

## [holochain\_types-0.0.22](crates/holochain_types/CHANGELOG.md#0.0.22)

## [holochain\_keystore-0.0.22](crates/holochain_keystore/CHANGELOG.md#0.0.22)

## [holochain\_sqlite-0.0.22](crates/holochain_sqlite/CHANGELOG.md#0.0.22)

## [kitsune\_p2p-0.0.19](crates/kitsune_p2p/CHANGELOG.md#0.0.19)

## [hdk-0.0.118](crates/hdk/CHANGELOG.md#0.0.118)

- hdk: `Path` now split into `Path` and `PathEntry` [1156](https://github.com/holochain/holochain/pull/1156)
- hdk: Minor changes and additions to `Path` methods [1156](https://github.com/holochain/holochain/pull/1156)

## [hdk\_derive-0.0.20](crates/hdk_derive/CHANGELOG.md#0.0.20)

## [holochain\_zome\_types-0.0.20](crates/holochain_zome_types/CHANGELOG.md#0.0.20)

- BREAKING CHANGE: Range filters on chain queries are now INCLUSIVE and support hash bounds [\#1142](https://github.com/holochain/holochain/pull/1142)
- BREAKING CHANGE: Chain queries now support restricting results to a list of entry hashes [\#1142](https://github.com/holochain/holochain/pull/1142)

## [holo\_hash-0.0.15](crates/holo_hash/CHANGELOG.md#0.0.15)

# 20211222.094252

## [holochain-0.0.121](crates/holochain/CHANGELOG.md#0.0.121)

- **BREAKING CHANGE** Removed `app_info` from HDK [1108](https://github.com/holochain/holochain/pull/1108)
- Permissions on host functions now return an error instead of panicking [1141](https://github.com/holochain/holochain/pull/1141)
- Add `--build-info` CLI flag for displaying various information in JSON format. [\#1163](https://github.com/holochain/holochain/pull/1163)

## [holochain\_test\_wasm\_common-0.0.17](crates/holochain_test_wasm_common/CHANGELOG.md#0.0.17)

## [holochain\_cascade-0.0.21](crates/holochain_cascade/CHANGELOG.md#0.0.21)

- Gets won’t return private entries unless you are have committed a header for that entry. [\#1157](https://github.com/holochain/holochain/pull/1157)

## [holochain\_cli-0.0.22](crates/holochain_cli/CHANGELOG.md#0.0.22)

## [holochain\_websocket-0.0.21](crates/holochain_websocket/CHANGELOG.md#0.0.21)

## [holochain\_conductor\_api-0.0.21](crates/holochain_conductor_api/CHANGELOG.md#0.0.21)

## [holochain\_state-0.0.21](crates/holochain_state/CHANGELOG.md#0.0.21)

## [holochain\_wasm\_test\_utils-0.0.21](crates/holochain_wasm_test_utils/CHANGELOG.md#0.0.21)

## [holochain\_p2p-0.0.21](crates/holochain_p2p/CHANGELOG.md#0.0.21)

## [holochain\_types-0.0.21](crates/holochain_types/CHANGELOG.md#0.0.21)

## [holochain\_keystore-0.0.21](crates/holochain_keystore/CHANGELOG.md#0.0.21)

## [holochain\_sqlite-0.0.21](crates/holochain_sqlite/CHANGELOG.md#0.0.21)

## [hdk-0.0.117](crates/hdk/CHANGELOG.md#0.0.117)

## [hdk\_derive-0.0.19](crates/hdk_derive/CHANGELOG.md#0.0.19)

## [holochain\_zome\_types-0.0.19](crates/holochain_zome_types/CHANGELOG.md#0.0.19)

## [holo\_hash-0.0.14](crates/holo_hash/CHANGELOG.md#0.0.14)

# 20211215.130843

## [holochain-0.0.120](crates/holochain/CHANGELOG.md#0.0.120)

## [holochain\_cascade-0.0.20](crates/holochain_cascade/CHANGELOG.md#0.0.20)

## [holochain\_cli-0.0.21](crates/holochain_cli/CHANGELOG.md#0.0.21)

## [holochain\_cli\_sandbox-0.0.18](crates/holochain_cli_sandbox/CHANGELOG.md#0.0.18)

## [holochain\_websocket-0.0.20](crates/holochain_websocket/CHANGELOG.md#0.0.20)

## [holochain\_conductor\_api-0.0.20](crates/holochain_conductor_api/CHANGELOG.md#0.0.20)

## [holochain\_state-0.0.20](crates/holochain_state/CHANGELOG.md#0.0.20)

## [holochain\_wasm\_test\_utils-0.0.20](crates/holochain_wasm_test_utils/CHANGELOG.md#0.0.20)

## [holochain\_p2p-0.0.20](crates/holochain_p2p/CHANGELOG.md#0.0.20)

## [holochain\_cli\_bundle-0.0.17](crates/holochain_cli_bundle/CHANGELOG.md#0.0.17)

## [holochain\_types-0.0.20](crates/holochain_types/CHANGELOG.md#0.0.20)

## [holochain\_keystore-0.0.20](crates/holochain_keystore/CHANGELOG.md#0.0.20)

## [holochain\_sqlite-0.0.20](crates/holochain_sqlite/CHANGELOG.md#0.0.20)

## [kitsune\_p2p-0.0.18](crates/kitsune_p2p/CHANGELOG.md#0.0.18)

# 20211208.091009

## [holochain-0.0.119](crates/holochain/CHANGELOG.md#0.0.119)

## [holochain\_test\_wasm\_common-0.0.16](crates/holochain_test_wasm_common/CHANGELOG.md#0.0.16)

## [holochain\_cascade-0.0.19](crates/holochain_cascade/CHANGELOG.md#0.0.19)

- Fixes database queries that were running on the runtime thread instead of the background thread. Makes the connections wait for a permit before taking a database connection from the pool. [\#1145](https://github.com/holochain/holochain/pull/1145)

## [holochain\_cli-0.0.20](crates/holochain_cli/CHANGELOG.md#0.0.20)

## [holochain\_cli\_sandbox-0.0.17](crates/holochain_cli_sandbox/CHANGELOG.md#0.0.17)

## [holochain\_websocket-0.0.19](crates/holochain_websocket/CHANGELOG.md#0.0.19)

## [holochain\_conductor\_api-0.0.19](crates/holochain_conductor_api/CHANGELOG.md#0.0.19)

## [holochain\_state-0.0.19](crates/holochain_state/CHANGELOG.md#0.0.19)

## [holochain\_wasm\_test\_utils-0.0.19](crates/holochain_wasm_test_utils/CHANGELOG.md#0.0.19)

## [holochain\_p2p-0.0.19](crates/holochain_p2p/CHANGELOG.md#0.0.19)

## [holochain\_cli\_bundle-0.0.16](crates/holochain_cli_bundle/CHANGELOG.md#0.0.16)

## [holochain\_types-0.0.19](crates/holochain_types/CHANGELOG.md#0.0.19)

## [holochain\_keystore-0.0.19](crates/holochain_keystore/CHANGELOG.md#0.0.19)

## [holochain\_sqlite-0.0.19](crates/holochain_sqlite/CHANGELOG.md#0.0.19)

- Adds `basis_hash` index to `DhtOp` table. This makes get queries faster. [\#1143](https://github.com/holochain/holochain/pull/1143)

## [kitsune\_p2p-0.0.17](crates/kitsune_p2p/CHANGELOG.md#0.0.17)

- Agent info is now published as well as gossiped. [\#1115](https://github.com/holochain/holochain/pull/1115)
- BREAKING: Network wire message has changed format so will not be compatible with older versions. [1143](https://github.com/holochain/holochain/pull/1143).
- Fixes to gossip that allows batching of large amounts of data. [1143](https://github.com/holochain/holochain/pull/1143).

## [kitsune\_p2p\_proxy-0.0.15](crates/kitsune_p2p_proxy/CHANGELOG.md#0.0.15)

## [kitsune\_p2p\_transport\_quic-0.0.15](crates/kitsune_p2p_transport_quic/CHANGELOG.md#0.0.15)

## [kitsune\_p2p\_types-0.0.15](crates/kitsune_p2p_types/CHANGELOG.md#0.0.15)

## [hdk-0.0.116](crates/hdk/CHANGELOG.md#0.0.116)

## [hdk\_derive-0.0.18](crates/hdk_derive/CHANGELOG.md#0.0.18)

## [holochain\_zome\_types-0.0.18](crates/holochain_zome_types/CHANGELOG.md#0.0.18)

## [holo\_hash-0.0.13](crates/holo_hash/CHANGELOG.md#0.0.13)

## [fixt-0.0.8](crates/fixt/CHANGELOG.md#0.0.8)

# 20211201.111024

## [holochain-0.0.118](crates/holochain/CHANGELOG.md#0.0.118)

- **BREAKING CHANGE** - Gossip now exchanges local peer info with `initiate` and `accept` request types. [\#1114](https://github.com/holochain/holochain/pull/1114).

## [holochain\_cascade-0.0.18](crates/holochain_cascade/CHANGELOG.md#0.0.18)

## [holochain\_cli-0.0.19](crates/holochain_cli/CHANGELOG.md#0.0.19)

## [holochain\_cli\_sandbox-0.0.16](crates/holochain_cli_sandbox/CHANGELOG.md#0.0.16)

## [holochain\_websocket-0.0.18](crates/holochain_websocket/CHANGELOG.md#0.0.18)

## [holochain\_conductor\_api-0.0.18](crates/holochain_conductor_api/CHANGELOG.md#0.0.18)

## [holochain\_state-0.0.18](crates/holochain_state/CHANGELOG.md#0.0.18)

## [holochain\_wasm\_test\_utils-0.0.18](crates/holochain_wasm_test_utils/CHANGELOG.md#0.0.18)

## [holochain\_p2p-0.0.18](crates/holochain_p2p/CHANGELOG.md#0.0.18)

## [holochain\_cli\_bundle-0.0.15](crates/holochain_cli_bundle/CHANGELOG.md#0.0.15)

## [holochain\_types-0.0.18](crates/holochain_types/CHANGELOG.md#0.0.18)

## [holochain\_keystore-0.0.18](crates/holochain_keystore/CHANGELOG.md#0.0.18)

## [holochain\_sqlite-0.0.18](crates/holochain_sqlite/CHANGELOG.md#0.0.18)

## [kitsune\_p2p-0.0.16](crates/kitsune_p2p/CHANGELOG.md#0.0.16)

# 20211124.093220

## [holochain-0.0.117](crates/holochain/CHANGELOG.md#0.0.117)

## [holochain\_cascade-0.0.17](crates/holochain_cascade/CHANGELOG.md#0.0.17)

## [holochain\_cli-0.0.18](crates/holochain_cli/CHANGELOG.md#0.0.18)

## [holochain\_cli\_sandbox-0.0.15](crates/holochain_cli_sandbox/CHANGELOG.md#0.0.15)

## [holochain\_websocket-0.0.17](crates/holochain_websocket/CHANGELOG.md#0.0.17)

## [holochain\_conductor\_api-0.0.17](crates/holochain_conductor_api/CHANGELOG.md#0.0.17)

- **BREAKING CHANGES**: db\_sync\_level changes to db\_sync\_strategy. Options are now `Fast` and `Resilient`. Default is `Fast` and should be the standard choice for most use cases. [\#1130](https://github.com/holochain/holochain/pull/1130)

## [holochain\_state-0.0.17](crates/holochain_state/CHANGELOG.md#0.0.17)

- Some databases can handle corruption by wiping the db file and starting again. [\#1039](https://github.com/holochain/holochain/pull/1039).

## [holochain\_wasm\_test\_utils-0.0.17](crates/holochain_wasm_test_utils/CHANGELOG.md#0.0.17)

## [holochain\_p2p-0.0.17](crates/holochain_p2p/CHANGELOG.md#0.0.17)

- BREAKING: Wire message `CallRemote` Takes `from_agent`. [\#1091](https://github.com/holochain/holochain/pull/1091)

## [holochain\_cli\_bundle-0.0.14](crates/holochain_cli_bundle/CHANGELOG.md#0.0.14)

## [holochain\_types-0.0.17](crates/holochain_types/CHANGELOG.md#0.0.17)

## [holochain\_keystore-0.0.17](crates/holochain_keystore/CHANGELOG.md#0.0.17)

## [holochain\_sqlite-0.0.17](crates/holochain_sqlite/CHANGELOG.md#0.0.17)

- **BREAKING CHANGES**: All DHT data for the same DNA space is now shared in the same database. All authored data for the same DNA space is also now shared in another database. This requires no changes however data must be manually migrated from the old databases to the new databases. [\#1130](https://github.com/holochain/holochain/pull/1130)

## [kitsune\_p2p-0.0.15](crates/kitsune_p2p/CHANGELOG.md#0.0.15)

- BREAKING: Wire message `Call` no longer takes `from_agent`. [\#1091](https://github.com/holochain/holochain/pull/1091)

## [kitsune\_p2p\_proxy-0.0.14](crates/kitsune_p2p_proxy/CHANGELOG.md#0.0.14)

## [kitsune\_p2p\_transport\_quic-0.0.14](crates/kitsune_p2p_transport_quic/CHANGELOG.md#0.0.14)

## [kitsune\_p2p\_types-0.0.14](crates/kitsune_p2p_types/CHANGELOG.md#0.0.14)

## [mr\_bundle-0.0.6](crates/mr_bundle/CHANGELOG.md#0.0.6)

## [holochain\_util-0.0.6](crates/holochain_util/CHANGELOG.md#0.0.6)

# 20211117.094411

## [holochain-0.0.116](crates/holochain/CHANGELOG.md#0.0.116)

## [holochain\_cascade-0.0.16](crates/holochain_cascade/CHANGELOG.md#0.0.16)

## [holochain\_cli-0.0.17](crates/holochain_cli/CHANGELOG.md#0.0.17)

## [holochain\_websocket-0.0.16](crates/holochain_websocket/CHANGELOG.md#0.0.16)

## [holochain\_conductor\_api-0.0.16](crates/holochain_conductor_api/CHANGELOG.md#0.0.16)

## [holochain\_state-0.0.16](crates/holochain_state/CHANGELOG.md#0.0.16)

## [holochain\_wasm\_test\_utils-0.0.16](crates/holochain_wasm_test_utils/CHANGELOG.md#0.0.16)

## [holochain\_p2p-0.0.16](crates/holochain_p2p/CHANGELOG.md#0.0.16)

## [holochain\_types-0.0.16](crates/holochain_types/CHANGELOG.md#0.0.16)

## [holochain\_keystore-0.0.16](crates/holochain_keystore/CHANGELOG.md#0.0.16)

## [holochain\_sqlite-0.0.16](crates/holochain_sqlite/CHANGELOG.md#0.0.16)

## [kitsune\_p2p-0.0.14](crates/kitsune_p2p/CHANGELOG.md#0.0.14)

## [kitsune\_p2p\_proxy-0.0.13](crates/kitsune_p2p_proxy/CHANGELOG.md#0.0.13)

## [kitsune\_p2p\_transport\_quic-0.0.13](crates/kitsune_p2p_transport_quic/CHANGELOG.md#0.0.13)

## [kitsune\_p2p\_types-0.0.13](crates/kitsune_p2p_types/CHANGELOG.md#0.0.13)

## [mr\_bundle-0.0.5](crates/mr_bundle/CHANGELOG.md#0.0.5)

## [holochain\_util-0.0.5](crates/holochain_util/CHANGELOG.md#0.0.5)

# 20211110.083530

## [holochain-0.0.115](crates/holochain/CHANGELOG.md#0.0.115)

- Fix [issue](https://github.com/holochain/holochain/issues/1100) where private dht ops were being leaked through the incoming ops sender. [1104](https://github.com/holochain/holochain/pull/1104).
- Kitsune now attempts to rebind the network interface in the event of endpoint shutdown. Note, it’s still recommended to bind to `0.0.0.0` as the OS provides additional resiliency for interfaces coming and going. [\#1083](https://github.com/holochain/holochain/pull/1083)
- **BREAKING CHANGE** current chain head including recent writes available in agent info [\#1079](https://github.com/holochain/holochain/pull/1079)
- **BREAKING (If using new lair)** If you are using the new (non-legacy) `lair_server` keystore, you will need to rebuild your keystore, we now pre-hash the passphrase used to access it to mitigate some information leakage. [\#1094](https://github.com/holochain/holochain/pull/1094)
- Better lair signature fallback child process management. The child process will now be properly restarted if it exits. (Note this can take a few millis on Windows, and may result in some signature errors.) [\#1094](https://github.com/holochain/holochain/pull/1094)

## [holochain\_test\_wasm\_common-0.0.15](crates/holochain_test_wasm_common/CHANGELOG.md#0.0.15)

## [holochain\_cascade-0.0.15](crates/holochain_cascade/CHANGELOG.md#0.0.15)

## [holochain\_cli-0.0.16](crates/holochain_cli/CHANGELOG.md#0.0.16)

## [holochain\_cli\_sandbox-0.0.14](crates/holochain_cli_sandbox/CHANGELOG.md#0.0.14)

## [holochain\_websocket-0.0.15](crates/holochain_websocket/CHANGELOG.md#0.0.15)

## [holochain\_conductor\_api-0.0.15](crates/holochain_conductor_api/CHANGELOG.md#0.0.15)

## [holochain\_state-0.0.15](crates/holochain_state/CHANGELOG.md#0.0.15)

## [holochain\_wasm\_test\_utils-0.0.15](crates/holochain_wasm_test_utils/CHANGELOG.md#0.0.15)

## [holochain\_p2p-0.0.15](crates/holochain_p2p/CHANGELOG.md#0.0.15)

## [holochain\_cli\_bundle-0.0.13](crates/holochain_cli_bundle/CHANGELOG.md#0.0.13)

## [holochain\_types-0.0.15](crates/holochain_types/CHANGELOG.md#0.0.15)

- FIX: [Bug](https://github.com/holochain/holochain/issues/1101) that was allowing `HeaderWithoutEntry` to shutdown apps. [\#1105](https://github.com/holochain/holochain/pull/1105)

## [holochain\_keystore-0.0.15](crates/holochain_keystore/CHANGELOG.md#0.0.15)

## [holochain\_sqlite-0.0.15](crates/holochain_sqlite/CHANGELOG.md#0.0.15)

- Fixes: Bug where database connections would timeout and return `DatabaseError(DbConnectionPoolError(Error(None)))`. [\#1097](https://github.com/holochain/holochain/pull/1097).

## [kitsune\_p2p-0.0.13](crates/kitsune_p2p/CHANGELOG.md#0.0.13)

## [kitsune\_p2p\_proxy-0.0.12](crates/kitsune_p2p_proxy/CHANGELOG.md#0.0.12)

## [kitsune\_p2p\_transport\_quic-0.0.12](crates/kitsune_p2p_transport_quic/CHANGELOG.md#0.0.12)

## [kitsune\_p2p\_types-0.0.12](crates/kitsune_p2p_types/CHANGELOG.md#0.0.12)

## [hdk-0.0.115](crates/hdk/CHANGELOG.md#0.0.115)

## [hdk\_derive-0.0.17](crates/hdk_derive/CHANGELOG.md#0.0.17)

## [holochain\_zome\_types-0.0.17](crates/holochain_zome_types/CHANGELOG.md#0.0.17)

- BREAKING CHANGE: Add all function names in a wasm to the zome info [\#1081](https://github.com/holochain/holochain/pull/1081)
- BREAKING CHANGE: Added a placeholder for zome properties on zome info [\#1080](https://github.com/holochain/holochain/pull/1080)

# 20211103.094627

## [holochain-0.0.114](crates/holochain/CHANGELOG.md#0.0.114)

- `remote_signal` has always been a fire-and-forget operation. Now it also uses the more efficient fire-and-forget “notify” low-level networking plumbing. [\#1075](https://github.com/holochain/holochain/pull/1075)

- **BREAKING CHANGE** `entry_defs` added to `zome_info` and referenced by macros [PR1055](https://github.com/holochain/holochain/pull/1055)

- **BREAKING CHANGE**: The notion of “cell nicknames” (“nicks”) and “app slots” has been unified into the notion of “app roles”. This introduces several breaking changes. In general, you will need to rebuild any app bundles you are using, and potentially update some usages of the admin interface. In particular:
  
  - The `slots` field in App manifests is now called `roles`
  - The `InstallApp` admin method now takes a `role_id` field instead of a `nick` field
  - In the return value for any admin method which lists installed apps, e.g. `ListEnabledApps`, any reference to `"slots"` is now named `"roles"`
  - See [\#1045](https://github.com/holochain/holochain/pull/1045)

- Adds test utils for creating simulated networks. [\#1037](https://github.com/holochain/holochain/pull/1037).

- Conductor can take a mocked network for testing simulated networks. [\#1036](https://github.com/holochain/holochain/pull/1036)

- Added `DumpFullState` to the admin interface, as a more complete form of `DumpState` which returns full `Vec<DhtOp>` instead of just their count, enabling more introspection of the state of the cell [\#1065](https://github.com/holochain/holochain/pull/1065).

- **BREAKING CHANGE** Added function name to call info in HDK. [\#1078](https://github.com/holochain/holochain/pull/1078).

## [holochain\_test\_wasm\_common-0.0.14](crates/holochain_test_wasm_common/CHANGELOG.md#0.0.14)

## [holochain\_cascade-0.0.14](crates/holochain_cascade/CHANGELOG.md#0.0.14)

## [holochain\_cli-0.0.15](crates/holochain_cli/CHANGELOG.md#0.0.15)

## [holochain\_cli\_sandbox-0.0.13](crates/holochain_cli_sandbox/CHANGELOG.md#0.0.13)

## [holochain\_websocket-0.0.14](crates/holochain_websocket/CHANGELOG.md#0.0.14)

## [holochain\_conductor\_api-0.0.14](crates/holochain_conductor_api/CHANGELOG.md#0.0.14)

## [holochain\_state-0.0.14](crates/holochain_state/CHANGELOG.md#0.0.14)

- BREAKING CHANGE. Source chain `query` will now return results in header sequence order ascending.

## [holochain\_wasm\_test\_utils-0.0.14](crates/holochain_wasm_test_utils/CHANGELOG.md#0.0.14)

## [holochain\_p2p-0.0.14](crates/holochain_p2p/CHANGELOG.md#0.0.14)

## [holochain\_cli\_bundle-0.0.12](crates/holochain_cli_bundle/CHANGELOG.md#0.0.12)

## [holochain\_types-0.0.14](crates/holochain_types/CHANGELOG.md#0.0.14)

## [holochain\_keystore-0.0.14](crates/holochain_keystore/CHANGELOG.md#0.0.14)

## [holochain\_sqlite-0.0.14](crates/holochain_sqlite/CHANGELOG.md#0.0.14)

## [kitsune\_p2p-0.0.12](crates/kitsune_p2p/CHANGELOG.md#0.0.12)

- BREAKING: Return `ShardedGossipWire::Busy` if we are overloaded with incoming gossip. [\#1076](https://github.com/holochain/holochain/pull/1076)
  - This breaks the current network protocol and will not be compatible with other older versions of holochain (no manual action required).

## [kitsune\_p2p\_proxy-0.0.11](crates/kitsune_p2p_proxy/CHANGELOG.md#0.0.11)

## [kitsune\_p2p\_transport\_quic-0.0.11](crates/kitsune_p2p_transport_quic/CHANGELOG.md#0.0.11)

## [kitsune\_p2p\_types-0.0.11](crates/kitsune_p2p_types/CHANGELOG.md#0.0.11)

## [hdk-0.0.114](crates/hdk/CHANGELOG.md#0.0.114)

## [hdk\_derive-0.0.16](crates/hdk_derive/CHANGELOG.md#0.0.16)

## [holochain\_zome\_types-0.0.16](crates/holochain_zome_types/CHANGELOG.md#0.0.16)

## [holo\_hash-0.0.12](crates/holo_hash/CHANGELOG.md#0.0.12)

## [kitsune\_p2p\_dht\_arc-0.0.7](crates/kitsune_p2p_dht_arc/CHANGELOG.md#0.0.7)

# 20211027.100746

## [holochain-0.0.113](crates/holochain/CHANGELOG.md#0.0.113)

- Post commit is now infallible and expects no return value [PR1049](https://github.com/holochain/holochain/pull/1049)
- Always depend on `itertools` to make `cargo build --no-default-features` work [\#1060](https://github.com/holochain/holochain/pull/1060)

## [holochain\_test\_wasm\_common-0.0.13](crates/holochain_test_wasm_common/CHANGELOG.md#0.0.13)

## [holochain\_cascade-0.0.13](crates/holochain_cascade/CHANGELOG.md#0.0.13)

## [holochain\_cli-0.0.14](crates/holochain_cli/CHANGELOG.md#0.0.14)

## [holochain\_cli\_sandbox-0.0.12](crates/holochain_cli_sandbox/CHANGELOG.md#0.0.12)

## [holochain\_websocket-0.0.13](crates/holochain_websocket/CHANGELOG.md#0.0.13)

## [holochain\_conductor\_api-0.0.13](crates/holochain_conductor_api/CHANGELOG.md#0.0.13)

## [holochain\_state-0.0.13](crates/holochain_state/CHANGELOG.md#0.0.13)

## [holochain\_wasm\_test\_utils-0.0.13](crates/holochain_wasm_test_utils/CHANGELOG.md#0.0.13)

## [holochain\_p2p-0.0.13](crates/holochain_p2p/CHANGELOG.md#0.0.13)

## [holochain\_cli\_bundle-0.0.11](crates/holochain_cli_bundle/CHANGELOG.md#0.0.11)

## [holochain\_types-0.0.13](crates/holochain_types/CHANGELOG.md#0.0.13)

## [holochain\_keystore-0.0.13](crates/holochain_keystore/CHANGELOG.md#0.0.13)

## [holochain\_sqlite-0.0.13](crates/holochain_sqlite/CHANGELOG.md#0.0.13)

## [hdk-0.0.113](crates/hdk/CHANGELOG.md#0.0.113)

## [hdk\_derive-0.0.15](crates/hdk_derive/CHANGELOG.md#0.0.15)

- `#[hdk_extern(infallible)]` now supports leaving off the return type of a fn [PR1049](https://github.com/holochain/holochain/pull/1049)

## [holochain\_zome\_types-0.0.15](crates/holochain_zome_types/CHANGELOG.md#0.0.15)

- `HeaderHashes` no longer exists [PR1049](https://github.com/holochain/holochain/pull/1049)
- `HeaderHashedVec` no longer exists [PR1049](https://github.com/holochain/holochain/pull/1049)

## [holo\_hash-0.0.11](crates/holo_hash/CHANGELOG.md#0.0.11)

# 20211021.140006

## [holochain-0.0.112](crates/holochain/CHANGELOG.md#0.0.112)

- Always depend on `itertools` to make `cargo build --no-default-features` work [\#1060](https://github.com/holochain/holochain/pull/1060)

## [holochain\_test\_wasm\_common-0.0.12](crates/holochain_test_wasm_common/CHANGELOG.md#0.0.12)

## [holochain\_cascade-0.0.12](crates/holochain_cascade/CHANGELOG.md#0.0.12)

## [holochain\_cli-0.0.13](crates/holochain_cli/CHANGELOG.md#0.0.13)

## [holochain\_cli\_sandbox-0.0.11](crates/holochain_cli_sandbox/CHANGELOG.md#0.0.11)

## [holochain\_websocket-0.0.12](crates/holochain_websocket/CHANGELOG.md#0.0.12)

## [holochain\_conductor\_api-0.0.12](crates/holochain_conductor_api/CHANGELOG.md#0.0.12)

## [holochain\_state-0.0.12](crates/holochain_state/CHANGELOG.md#0.0.12)

## [holochain\_wasm\_test\_utils-0.0.12](crates/holochain_wasm_test_utils/CHANGELOG.md#0.0.12)

## [holochain\_p2p-0.0.12](crates/holochain_p2p/CHANGELOG.md#0.0.12)

## [holochain\_cli\_bundle-0.0.10](crates/holochain_cli_bundle/CHANGELOG.md#0.0.10)

## [holochain\_types-0.0.12](crates/holochain_types/CHANGELOG.md#0.0.12)

## [holochain\_keystore-0.0.12](crates/holochain_keystore/CHANGELOG.md#0.0.12)

## [holochain\_sqlite-0.0.12](crates/holochain_sqlite/CHANGELOG.md#0.0.12)

## [hdk-0.0.112](crates/hdk/CHANGELOG.md#0.0.112)

## [hdk\_derive-0.0.14](crates/hdk_derive/CHANGELOG.md#0.0.14)

## [holochain\_zome\_types-0.0.14](crates/holochain_zome_types/CHANGELOG.md#0.0.14)

# 20211020.171211

## [holochain-0.0.111](crates/holochain/CHANGELOG.md#0.0.111)

- `call_info` is now implemented [1047](https://github.com/holochain/holochain/pull/1047)

- `dna_info` now returns `DnaInfo` correctly [\#1044](https://github.com/holochain/holochain/pull/1044)
  
  - `ZomeInfo` no longer includes what is now on `DnaInfo`
  - `ZomeInfo` renames `zome_name` and `zome_id` to `name` and `id`
  - `DnaInfo` includes `name`, `hash`, `properties`

- `post_commit` hook is implemented now [PR 1000](https://github.com/holochain/holochain/pull/1000)

- Bump legacy lair version to 0.0.8 fixing a crash when error message was too long [\#1046](https://github.com/holochain/holochain/pull/1046)

- Options to use new lair keystore [\#1040](https://github.com/holochain/holochain/pull/1040)

<!-- end list -->

``` yaml
keystore:
  type: danger_test_keystore
```

or

``` yaml
keystore:
  type: lair_server
  connection_url: "unix:///my/path/socket?k=Foo"
```

## [holochain\_test\_wasm\_common-0.0.11](crates/holochain_test_wasm_common/CHANGELOG.md#0.0.11)

## [holochain\_cascade-0.0.11](crates/holochain_cascade/CHANGELOG.md#0.0.11)

## [holochain\_cli-0.0.12](crates/holochain_cli/CHANGELOG.md#0.0.12)

## [holochain\_cli\_sandbox-0.0.10](crates/holochain_cli_sandbox/CHANGELOG.md#0.0.10)

## [holochain\_websocket-0.0.11](crates/holochain_websocket/CHANGELOG.md#0.0.11)

## [holochain\_conductor\_api-0.0.11](crates/holochain_conductor_api/CHANGELOG.md#0.0.11)

## [holochain\_state-0.0.11](crates/holochain_state/CHANGELOG.md#0.0.11)

## [holochain\_wasm\_test\_utils-0.0.11](crates/holochain_wasm_test_utils/CHANGELOG.md#0.0.11)

## [holochain\_p2p-0.0.11](crates/holochain_p2p/CHANGELOG.md#0.0.11)

## [holochain\_cli\_bundle-0.0.9](crates/holochain_cli_bundle/CHANGELOG.md#0.0.9)

## [holochain\_types-0.0.11](crates/holochain_types/CHANGELOG.md#0.0.11)

## [holochain\_keystore-0.0.11](crates/holochain_keystore/CHANGELOG.md#0.0.11)

## [holochain\_sqlite-0.0.11](crates/holochain_sqlite/CHANGELOG.md#0.0.11)

## [kitsune\_p2p-0.0.11](crates/kitsune_p2p/CHANGELOG.md#0.0.11)

## [kitsune\_p2p\_proxy-0.0.10](crates/kitsune_p2p_proxy/CHANGELOG.md#0.0.10)

## [kitsune\_p2p\_transport\_quic-0.0.10](crates/kitsune_p2p_transport_quic/CHANGELOG.md#0.0.10)

## [kitsune\_p2p\_types-0.0.10](crates/kitsune_p2p_types/CHANGELOG.md#0.0.10)

## [hdk-0.0.111](crates/hdk/CHANGELOG.md#0.0.111)

## [hdk\_derive-0.0.13](crates/hdk_derive/CHANGELOG.md#0.0.13)

## [holochain\_zome\_types-0.0.13](crates/holochain_zome_types/CHANGELOG.md#0.0.13)

- `CallInfo` now has `as_at` on it [PR 1047](https://github.com/holochain/holochain/pull/1047)
- Removed `Links` in favour of `Vec<Link>` [PR 1012](https://github.com/holochain/holochain/pull/1012)

## [holo\_hash-0.0.10](crates/holo_hash/CHANGELOG.md#0.0.10)

# 20211013.091723

## [holochain-0.0.110](crates/holochain/CHANGELOG.md#0.0.110)

- Publish now runs on a loop if there are ops still needing receipts. [\#1024](https://github.com/holochain/holochain/pull/1024)
- Batch peer store write so we use less transactions. [\#1007](https://github.com/holochain/holochain/pull/1007/).
- Preparation for new lair api [\#1017](https://github.com/holochain/holochain/pull/1017)
  - there should be no functional changes with this update.
  - adds new lair as an additional dependency and begins preparation for a config-time switch allowing use of new api lair keystore.
- Add method `SweetDnaFile::from_bundle_with_overrides` [\#1030](https://github.com/holochain/holochain/pull/1030)
- Some `SweetConductor::setup_app_*` methods now take anything iterable, instead of array slices, for specifying lists of agents and DNAs [\#1030](https://github.com/holochain/holochain/pull/1030)
- BREAKING conductor config changes [\#1031](https://github.com/holochain/holochain/pull/1031)

Where previously, you might have had:

``` yaml
use_dangerous_test_keystore: false
keystore_path: /my/path
passphrase_service:
  type: danger_insecure_from_config
  passphrase: "test-passphrase"
```

now you will use:

``` yaml
keystore:
  type: lair_server_legacy_deprecated
  keystore_path: /my/path
  danger_passphrase_insecure_from_config: "test-passphrase"
```

or:

``` yaml
keystore:
  type: danger_test_keystore_legacy_deprecated
```

## [holochain\_test\_wasm\_common-0.0.10](crates/holochain_test_wasm_common/CHANGELOG.md#0.0.10)

## [holochain\_cascade-0.0.10](crates/holochain_cascade/CHANGELOG.md#0.0.10)

- Fix authority side get\_links query [\#1027](https://github.com/holochain/holochain/pull/1027).

## [holochain\_cli-0.0.11](crates/holochain_cli/CHANGELOG.md#0.0.11)

## [holochain\_cli\_sandbox-0.0.9](crates/holochain_cli_sandbox/CHANGELOG.md#0.0.9)

## [holochain\_websocket-0.0.10](crates/holochain_websocket/CHANGELOG.md#0.0.10)

## [holochain\_conductor\_api-0.0.10](crates/holochain_conductor_api/CHANGELOG.md#0.0.10)

## [holochain\_state-0.0.10](crates/holochain_state/CHANGELOG.md#0.0.10)

## [holochain\_wasm\_test\_utils-0.0.10](crates/holochain_wasm_test_utils/CHANGELOG.md#0.0.10)

## [holochain\_p2p-0.0.10](crates/holochain_p2p/CHANGELOG.md#0.0.10)

## [holochain\_cli\_bundle-0.0.8](crates/holochain_cli_bundle/CHANGELOG.md#0.0.8)

## [holochain\_types-0.0.10](crates/holochain_types/CHANGELOG.md#0.0.10)

## [holochain\_keystore-0.0.10](crates/holochain_keystore/CHANGELOG.md#0.0.10)

## [holochain\_sqlite-0.0.10](crates/holochain_sqlite/CHANGELOG.md#0.0.10)

## [kitsune\_p2p-0.0.10](crates/kitsune_p2p/CHANGELOG.md#0.0.10)

- Check local agents for basis when doing a RPCMulti call. [\#1009](https://github.com/holochain/holochain/pull/1009).

## [kitsune\_p2p\_proxy-0.0.9](crates/kitsune_p2p_proxy/CHANGELOG.md#0.0.9)

## [kitsune\_p2p\_transport\_quic-0.0.9](crates/kitsune_p2p_transport_quic/CHANGELOG.md#0.0.9)

## [kitsune\_p2p\_types-0.0.9](crates/kitsune_p2p_types/CHANGELOG.md#0.0.9)

## [hdk-0.0.110](crates/hdk/CHANGELOG.md#0.0.110)

## [hdk\_derive-0.0.12](crates/hdk_derive/CHANGELOG.md#0.0.12)

## [holochain\_zome\_types-0.0.12](crates/holochain_zome_types/CHANGELOG.md#0.0.12)

## [holo\_hash-0.0.9](crates/holo_hash/CHANGELOG.md#0.0.9)

## [kitsune\_p2p\_dht\_arc-0.0.6](crates/kitsune_p2p_dht_arc/CHANGELOG.md#0.0.6)

## [fixt-0.0.7](crates/fixt/CHANGELOG.md#0.0.7)

# 20211006.105406

## [holochain-0.0.109](crates/holochain/CHANGELOG.md#0.0.109)

- Make validation run concurrently up to 50 DhtOps. This allows us to make progress on other ops when waiting for the network. [\#1005](https://github.com/holochain/holochain/pull/1005)
- FIX: Prevent the conductor from trying to join cells to the network that are already in the process of joining. [\#1006](https://github.com/holochain/holochain/pull/1006)

## [holochain\_test\_wasm\_common-0.0.9](crates/holochain_test_wasm_common/CHANGELOG.md#0.0.9)

## [holochain\_cascade-0.0.9](crates/holochain_cascade/CHANGELOG.md#0.0.9)

## [holochain\_cli-0.0.10](crates/holochain_cli/CHANGELOG.md#0.0.10)

## [holochain\_cli\_sandbox-0.0.8](crates/holochain_cli_sandbox/CHANGELOG.md#0.0.8)

## [holochain\_websocket-0.0.9](crates/holochain_websocket/CHANGELOG.md#0.0.9)

## [holochain\_conductor\_api-0.0.9](crates/holochain_conductor_api/CHANGELOG.md#0.0.9)

## [holochain\_state-0.0.9](crates/holochain_state/CHANGELOG.md#0.0.9)

- Fixed a bug when creating an entry with `ChainTopOrdering::Relaxed`, in which the header was created and stored in the Source Chain, but the actual entry was not.
- Geneis ops will no longer run validation for the authored node and only genesis self check will run. [\#995](https://github.com/holochain/holochain/pull/995)

## [holochain\_wasm\_test\_utils-0.0.9](crates/holochain_wasm_test_utils/CHANGELOG.md#0.0.9)

## [holochain\_p2p-0.0.9](crates/holochain_p2p/CHANGELOG.md#0.0.9)

## [holochain\_cli\_bundle-0.0.7](crates/holochain_cli_bundle/CHANGELOG.md#0.0.7)

## [holochain\_types-0.0.9](crates/holochain_types/CHANGELOG.md#0.0.9)

## [holochain\_keystore-0.0.9](crates/holochain_keystore/CHANGELOG.md#0.0.9)

- Update to lair 0.0.7 which updates to rusqlite 0.26.0 [\#1023](https://github.com/holochain/holochain/pull/1023)
  - provides `bundled-sqlcipher-vendored-openssl` to ease build process on non-windows systems (windows is still using `bundled` which doesn’t provide at-rest encryption).

## [holochain\_sqlite-0.0.9](crates/holochain_sqlite/CHANGELOG.md#0.0.9)

- Update to rusqlite 0.26.0 [\#1023](https://github.com/holochain/holochain/pull/1023)
  - provides `bundled-sqlcipher-vendored-openssl` to ease build process on non-windows systems (windows is still using `bundled` which doesn’t provide at-rest encryption).

## [kitsune\_p2p-0.0.9](crates/kitsune_p2p/CHANGELOG.md#0.0.9)

- Fix rpc\_multi bug that caused all request to wait 3 seconds. [\#1009](https://github.com/holochain/holochain/pull/1009/)
- Fix to gossip’s round initiate. We were not timing out a round if there was no response to an initiate message. [\#1014](https://github.com/holochain/holochain/pull/1014).
- Make gossip only initiate with agents that have info that is not expired. [\#1014](https://github.com/holochain/holochain/pull/1014).

## [kitsune\_p2p\_proxy-0.0.8](crates/kitsune_p2p_proxy/CHANGELOG.md#0.0.8)

## [kitsune\_p2p\_transport\_quic-0.0.8](crates/kitsune_p2p_transport_quic/CHANGELOG.md#0.0.8)

## [kitsune\_p2p\_types-0.0.8](crates/kitsune_p2p_types/CHANGELOG.md#0.0.8)

## [kitsune\_p2p\_dht\_arc-0.0.5](crates/kitsune_p2p_dht_arc/CHANGELOG.md#0.0.5)

## [hdk-0.0.109](crates/hdk/CHANGELOG.md#0.0.109)

## [hdk\_derive-0.0.11](crates/hdk_derive/CHANGELOG.md#0.0.11)

## [holochain\_zome\_types-0.0.11](crates/holochain_zome_types/CHANGELOG.md#0.0.11)

## [kitsune\_p2p\_timestamp-0.0.5](crates/kitsune_p2p_timestamp/CHANGELOG.md#0.0.5)

## [holo\_hash-0.0.8](crates/holo_hash/CHANGELOG.md#0.0.8)

# 20210929.090317

## [holochain-0.0.108](crates/holochain/CHANGELOG.md#0.0.108)

- Refactor conductor to use parking lot rw lock instead of tokio rw lock. (Faster and prevents deadlocks.). [\#979](https://github.com/holochain/holochain/pull/979).

### Changed

- The scheduler should work now

## [holochain\_test\_wasm\_common-0.0.8](crates/holochain_test_wasm_common/CHANGELOG.md#0.0.8)

## [holochain\_cascade-0.0.8](crates/holochain_cascade/CHANGELOG.md#0.0.8)

## [holochain\_cli-0.0.9](crates/holochain_cli/CHANGELOG.md#0.0.9)

## [holochain\_websocket-0.0.8](crates/holochain_websocket/CHANGELOG.md#0.0.8)

## [holochain\_conductor\_api-0.0.8](crates/holochain_conductor_api/CHANGELOG.md#0.0.8)

## [holochain\_state-0.0.8](crates/holochain_state/CHANGELOG.md#0.0.8)

## [holochain\_wasm\_test\_utils-0.0.8](crates/holochain_wasm_test_utils/CHANGELOG.md#0.0.8)

## [holochain\_p2p-0.0.8](crates/holochain_p2p/CHANGELOG.md#0.0.8)

## [holochain\_types-0.0.8](crates/holochain_types/CHANGELOG.md#0.0.8)

## [holochain\_keystore-0.0.8](crates/holochain_keystore/CHANGELOG.md#0.0.8)

## [holochain\_sqlite-0.0.8](crates/holochain_sqlite/CHANGELOG.md#0.0.8)

## [kitsune\_p2p-0.0.8](crates/kitsune_p2p/CHANGELOG.md#0.0.8)

### Changed

- `query_gossip_agents`, `query_agent_info_signed`, and `query_agent_info_signed_near_basis` are now unified into a single `query_agents` call in `KitsuneP2pEvent`

## [kitsune\_p2p\_proxy-0.0.7](crates/kitsune_p2p_proxy/CHANGELOG.md#0.0.7)

## [kitsune\_p2p\_transport\_quic-0.0.7](crates/kitsune_p2p_transport_quic/CHANGELOG.md#0.0.7)

## [kitsune\_p2p\_types-0.0.7](crates/kitsune_p2p_types/CHANGELOG.md#0.0.7)

- Adds a prototype protocol for checking consistency in a sharded network.

## [kitsune\_p2p\_dht\_arc-0.0.4](crates/kitsune_p2p_dht_arc/CHANGELOG.md#0.0.4)

## [hdk-0.0.108](crates/hdk/CHANGELOG.md#0.0.108)

## [hdk\_derive-0.0.10](crates/hdk_derive/CHANGELOG.md#0.0.10)

### Added

- Added support for `#[hdk_extern(infallible)]`

## [holochain\_zome\_types-0.0.10](crates/holochain_zome_types/CHANGELOG.md#0.0.10)

## [kitsune\_p2p\_timestamp-0.0.4](crates/kitsune_p2p_timestamp/CHANGELOG.md#0.0.4)

# 20210922.083906

- Adds experimental feature for one storage agent per space to kitsune tuning params. `gossip_single_storage_arc_per_space`.
- Adds the ability to lower the synchronous level for the sqlite backend to the conductor config. `db_sync_level`. See [sqlite documentation](https://www.sqlite.org/pragma.html#pragma_synchronous). This allows running on slower HDD but can result in corrupted databases and is not recommended for production or SSDs.
- Fixes bug where WAL mode was set on every opening connection.

## [holochain-0.0.107](crates/holochain/CHANGELOG.md#0.0.107)

## [holochain\_test\_wasm\_common-0.0.7](crates/holochain_test_wasm_common/CHANGELOG.md#0.0.7)

## [holochain\_cascade-0.0.7](crates/holochain_cascade/CHANGELOG.md#0.0.7)

## [holochain\_cli-0.0.8](crates/holochain_cli/CHANGELOG.md#0.0.8)

## [holochain\_cli\_sandbox-0.0.7](crates/holochain_cli_sandbox/CHANGELOG.md#0.0.7)

## [holochain\_websocket-0.0.7](crates/holochain_websocket/CHANGELOG.md#0.0.7)

## [holochain\_conductor\_api-0.0.7](crates/holochain_conductor_api/CHANGELOG.md#0.0.7)

## [holochain\_state-0.0.7](crates/holochain_state/CHANGELOG.md#0.0.7)

## [holochain\_wasm\_test\_utils-0.0.7](crates/holochain_wasm_test_utils/CHANGELOG.md#0.0.7)

## [holochain\_p2p-0.0.7](crates/holochain_p2p/CHANGELOG.md#0.0.7)

## [holochain\_cli\_bundle-0.0.6](crates/holochain_cli_bundle/CHANGELOG.md#0.0.6)

## [holochain\_types-0.0.7](crates/holochain_types/CHANGELOG.md#0.0.7)

- Added helper functions to `WebAppBundle` and `AppManifest` to be able to handle these types better in consuming applications.

## [holochain\_keystore-0.0.7](crates/holochain_keystore/CHANGELOG.md#0.0.7)

## [holochain\_sqlite-0.0.7](crates/holochain_sqlite/CHANGELOG.md#0.0.7)

## [kitsune\_p2p-0.0.7](crates/kitsune_p2p/CHANGELOG.md#0.0.7)

## [kitsune\_p2p\_proxy-0.0.6](crates/kitsune_p2p_proxy/CHANGELOG.md#0.0.6)

## [kitsune\_p2p\_transport\_quic-0.0.6](crates/kitsune_p2p_transport_quic/CHANGELOG.md#0.0.6)

## [kitsune\_p2p\_types-0.0.6](crates/kitsune_p2p_types/CHANGELOG.md#0.0.6)

## [kitsune\_p2p\_dht\_arc-0.0.3](crates/kitsune_p2p_dht_arc/CHANGELOG.md#0.0.3)

## [kitsune\_p2p\_mdns-0.0.2](crates/kitsune_p2p_mdns/CHANGELOG.md#0.0.2)

## [mr\_bundle-0.0.4](crates/mr_bundle/CHANGELOG.md#0.0.4)

## [holochain\_util-0.0.4](crates/holochain_util/CHANGELOG.md#0.0.4)

## [hdk-0.0.107](crates/hdk/CHANGELOG.md#0.0.107)

### Changed

- hdk: `schedule` function now takes a String giving a function name to schedule, rather than a Duration

## [hdk\_derive-0.0.9](crates/hdk_derive/CHANGELOG.md#0.0.9)

## [holochain\_zome\_types-0.0.9](crates/holochain_zome_types/CHANGELOG.md#0.0.9)

### Added

- Added `Schedule` enum to define schedules

## [kitsune\_p2p\_timestamp-0.0.3](crates/kitsune_p2p_timestamp/CHANGELOG.md#0.0.3)

## [holo\_hash-0.0.7](crates/holo_hash/CHANGELOG.md#0.0.7)

## [fixt-0.0.6](crates/fixt/CHANGELOG.md#0.0.6)

# 20210916.085414

## [holochain-0.0.106](crates/holochain/CHANGELOG.md#0.0.106)

### Changed

- HDK `sys_time` now returns a `holochain_zome_types::prelude::Timestamp` instead of a `core::time::Duration`.
- Exposes `UninstallApp` in the conductor admin API.

## [holochain\_test\_wasm\_common-0.0.6](crates/holochain_test_wasm_common/CHANGELOG.md#0.0.6)

## [holochain\_cascade-0.0.6](crates/holochain_cascade/CHANGELOG.md#0.0.6)

## [holochain\_cli-0.0.7](crates/holochain_cli/CHANGELOG.md#0.0.7)

- Added the `hc web-app` sub-command for bundling up a UI with a previously created hApp bundle.  It uses the same same behavior as `hc dna` and `hc app` to specify the .yaml manifest file.

## [holochain\_cli\_sandbox-0.0.6](crates/holochain_cli_sandbox/CHANGELOG.md#0.0.6)

- Added `UninstallApp` command.

## [holochain\_websocket-0.0.6](crates/holochain_websocket/CHANGELOG.md#0.0.6)

## [holochain\_conductor\_api-0.0.6](crates/holochain_conductor_api/CHANGELOG.md#0.0.6)

## [holochain\_state-0.0.6](crates/holochain_state/CHANGELOG.md#0.0.6)

## [holochain\_wasm\_test\_utils-0.0.6](crates/holochain_wasm_test_utils/CHANGELOG.md#0.0.6)

## [holochain\_p2p-0.0.6](crates/holochain_p2p/CHANGELOG.md#0.0.6)

## [holochain\_cli\_bundle-0.0.5](crates/holochain_cli_bundle/CHANGELOG.md#0.0.5)

- Added the `hc web-app` subcommand, with the exact same behaviour and functionality as `hc dna` and `hc app`.

## [holochain\_types-0.0.6](crates/holochain_types/CHANGELOG.md#0.0.6)

- Added `WebAppManifest` to support `.webhapp` bundles. This is necessary to package hApps together with web UIs, to export to the Launcher and Holo.

## [holochain\_keystore-0.0.6](crates/holochain_keystore/CHANGELOG.md#0.0.6)

## [holochain\_sqlite-0.0.6](crates/holochain_sqlite/CHANGELOG.md#0.0.6)

## [kitsune\_p2p-0.0.6](crates/kitsune_p2p/CHANGELOG.md#0.0.6)

## [kitsune\_p2p\_proxy-0.0.5](crates/kitsune_p2p_proxy/CHANGELOG.md#0.0.5)

## [kitsune\_p2p\_transport\_quic-0.0.5](crates/kitsune_p2p_transport_quic/CHANGELOG.md#0.0.5)

## [kitsune\_p2p\_types-0.0.5](crates/kitsune_p2p_types/CHANGELOG.md#0.0.5)

## [hdk-0.0.106](crates/hdk/CHANGELOG.md#0.0.106)

## [hdk\_derive-0.0.8](crates/hdk_derive/CHANGELOG.md#0.0.8)

## [holochain\_zome\_types-0.0.8](crates/holochain_zome_types/CHANGELOG.md#0.0.8)

## [kitsune\_p2p\_timestamp-0.0.2](crates/kitsune_p2p_timestamp/CHANGELOG.md#0.0.2)

## [holo\_hash-0.0.6](crates/holo_hash/CHANGELOG.md#0.0.6)

### Fixed

- Crate now builds with `--no-default-features`

# 20210901.105419

***Note***: The following crates could not be published to crates.io due to build errors:

- hdk\_derive-0.0.7
- hdk-0.0.105
- holochain\_state-0.0.5
- holochain\_conductor\_api-0.0.5
- holochain\_cascade-0.0.5”,
- holochain\_test\_wasm\_common-0.0.5
- holochain-0.0.105

## [holochain-0.0.105](crates/holochain/CHANGELOG.md#0.0.105)

## [holochain\_test\_wasm\_common-0.0.5](crates/holochain_test_wasm_common/CHANGELOG.md#0.0.5)

## [holochain\_cascade-0.0.5](crates/holochain_cascade/CHANGELOG.md#0.0.5)

## [holochain\_cli-0.0.6](crates/holochain_cli/CHANGELOG.md#0.0.6)

## [holochain\_websocket-0.0.5](crates/holochain_websocket/CHANGELOG.md#0.0.5)

## [holochain\_conductor\_api-0.0.5](crates/holochain_conductor_api/CHANGELOG.md#0.0.5)

## [holochain\_state-0.0.5](crates/holochain_state/CHANGELOG.md#0.0.5)

## [holochain\_wasm\_test\_utils-0.0.5](crates/holochain_wasm_test_utils/CHANGELOG.md#0.0.5)

## [holochain\_p2p-0.0.5](crates/holochain_p2p/CHANGELOG.md#0.0.5)

## [holochain\_types-0.0.5](crates/holochain_types/CHANGELOG.md#0.0.5)

## [holochain\_keystore-0.0.5](crates/holochain_keystore/CHANGELOG.md#0.0.5)

## [holochain\_sqlite-0.0.5](crates/holochain_sqlite/CHANGELOG.md#0.0.5)

## [kitsune\_p2p-0.0.5](crates/kitsune_p2p/CHANGELOG.md#0.0.5)

## [hdk-0.0.105](crates/hdk/CHANGELOG.md#0.0.105)

## [hdk\_derive-0.0.7](crates/hdk_derive/CHANGELOG.md#0.0.7)

## [holochain\_zome\_types-0.0.7](crates/holochain_zome_types/CHANGELOG.md#0.0.7)

# 20210825.101130

## [holochain-0.0.104](crates/holochain/CHANGELOG.md#0.0.104)

- Updates lair to 0.0.4 which pins rcgen to 0.8.11 to work around [https://github.com/est31/rcgen/issues/63](https://github.com/est31/rcgen/issues/63)

## [holochain\_test\_wasm\_common-0.0.4](crates/holochain_test_wasm_common/CHANGELOG.md#0.0.4)

## [holochain\_cascade-0.0.4](crates/holochain_cascade/CHANGELOG.md#0.0.4)

## [holochain\_cli-0.0.5](crates/holochain_cli/CHANGELOG.md#0.0.5)

## [holochain\_cli\_sandbox-0.0.5](crates/holochain_cli_sandbox/CHANGELOG.md#0.0.5)

## [holochain\_websocket-0.0.4](crates/holochain_websocket/CHANGELOG.md#0.0.4)

## [holochain\_conductor\_api-0.0.4](crates/holochain_conductor_api/CHANGELOG.md#0.0.4)

## [holochain\_state-0.0.4](crates/holochain_state/CHANGELOG.md#0.0.4)

## [holochain\_wasm\_test\_utils-0.0.4](crates/holochain_wasm_test_utils/CHANGELOG.md#0.0.4)

## [holochain\_p2p-0.0.4](crates/holochain_p2p/CHANGELOG.md#0.0.4)

## [holochain\_cli\_bundle-0.0.4](crates/holochain_cli_bundle/CHANGELOG.md#0.0.4)

## [holochain\_types-0.0.4](crates/holochain_types/CHANGELOG.md#0.0.4)

## [holochain\_keystore-0.0.4](crates/holochain_keystore/CHANGELOG.md#0.0.4)

## [holochain\_sqlite-0.0.4](crates/holochain_sqlite/CHANGELOG.md#0.0.4)

## [kitsune\_p2p-0.0.4](crates/kitsune_p2p/CHANGELOG.md#0.0.4)

## [kitsune\_p2p\_proxy-0.0.4](crates/kitsune_p2p_proxy/CHANGELOG.md#0.0.4)

## [kitsune\_p2p\_transport\_quic-0.0.4](crates/kitsune_p2p_transport_quic/CHANGELOG.md#0.0.4)

## [kitsune\_p2p\_types-0.0.4](crates/kitsune_p2p_types/CHANGELOG.md#0.0.4)

## [hdk-0.0.104](crates/hdk/CHANGELOG.md#0.0.104)

## [hdk\_derive-0.0.6](crates/hdk_derive/CHANGELOG.md#0.0.6)

## [holochain\_zome\_types-0.0.6](crates/holochain_zome_types/CHANGELOG.md#0.0.6)

### Changed

- `CreateInput`, `DeleteInput`, `DeleteLinkInput` structs invented for zome io
- `EntryDefId` merged into `CreateInput`

### Added

- `ChainTopOrdering` enum added to define chain top ordering behaviour on write

# 20210817.185301

## [holochain-0.0.103](crates/holochain/CHANGELOG.md#0.0.103)

### Fixed

- This release solves the issues with installing happ bundles or registering DNA via the admin API concurrently. [\#881](https://github.com/holochain/holochain/pull/881).

### Changed

- Header builder now uses chain top timestamp for new headers if in the future
- Timestamps in headers require strict inequality in sys validation

## [holochain\_test\_wasm\_common-0.0.3](crates/holochain_test_wasm_common/CHANGELOG.md#0.0.3)

## [holochain\_cascade-0.0.3](crates/holochain_cascade/CHANGELOG.md#0.0.3)

## [holochain\_cli-0.0.4](crates/holochain_cli/CHANGELOG.md#0.0.4)

## [holochain\_cli\_sandbox-0.0.4](crates/holochain_cli_sandbox/CHANGELOG.md#0.0.4)

## [holochain\_websocket-0.0.3](crates/holochain_websocket/CHANGELOG.md#0.0.3)

## [holochain\_conductor\_api-0.0.3](crates/holochain_conductor_api/CHANGELOG.md#0.0.3)

- BREAKING: CONDUCTOR CONFIG CHANGE–related to update to lair 0.0.3
  - `passphrase_service` is now required
    - The only implemented option is `danger_insecure_from_config`

#### Example

``` yaml
---
passphrase_service:
  type: danger_insecure_from_config
  passphrase: "foobar"
```

## [holochain\_state-0.0.3](crates/holochain_state/CHANGELOG.md#0.0.3)

## [holochain\_wasm\_test\_utils-0.0.3](crates/holochain_wasm_test_utils/CHANGELOG.md#0.0.3)

## [holochain\_p2p-0.0.3](crates/holochain_p2p/CHANGELOG.md#0.0.3)

## [holochain\_cli\_bundle-0.0.3](crates/holochain_cli_bundle/CHANGELOG.md#0.0.3)

## [holochain\_types-0.0.3](crates/holochain_types/CHANGELOG.md#0.0.3)

## [holochain\_keystore-0.0.3](crates/holochain_keystore/CHANGELOG.md#0.0.3)

- Updated to lair 0.0.3
  - switch to sqlite/sqlcipher for keystore backing database
  - enable encryption via passphrase (not on windows)

## [holochain\_sqlite-0.0.3](crates/holochain_sqlite/CHANGELOG.md#0.0.3)

## [kitsune\_p2p-0.0.3](crates/kitsune_p2p/CHANGELOG.md#0.0.3)

## [kitsune\_p2p\_proxy-0.0.3](crates/kitsune_p2p_proxy/CHANGELOG.md#0.0.3)

## [kitsune\_p2p\_transport\_quic-0.0.3](crates/kitsune_p2p_transport_quic/CHANGELOG.md#0.0.3)

## [kitsune\_p2p\_types-0.0.3](crates/kitsune_p2p_types/CHANGELOG.md#0.0.3)

## [kitsune\_p2p\_dht\_arc-0.0.2](crates/kitsune_p2p_dht_arc/CHANGELOG.md#0.0.2)

## [mr\_bundle-0.0.3](crates/mr_bundle/CHANGELOG.md#0.0.3)

## [holochain\_util-0.0.3](crates/holochain_util/CHANGELOG.md#0.0.3)

## [hdk-0.0.103](crates/hdk/CHANGELOG.md#0.0.103)

### Changed

- hdk: `sys_time` returns `Timestamp` instead of `Duration`

### Added

- hdk: Added `accept_countersigning_preflight_request`

- hdk: Added `session_times_from_millis`

- hdk: Now supports creating and updating countersigned entries

- hdk: Now supports deserializing countersigned entries in app entry `try_from`

- hdk: implements multi-call for:
  
  - `remote_call`
  - `call`
  - `get`
  - `get_details`
  - `get_links`
  - `get_link_details`
  
  We strictly only needed `remote_call` for countersigning, but feedback from the community was that having to sequentially loop over these common HDK functions is a pain point, so we enabled all of them to be async over a vector of inputs.

## [hdk\_derive-0.0.5](crates/hdk_derive/CHANGELOG.md#0.0.5)

## [holochain\_zome\_types-0.0.5](crates/holochain_zome_types/CHANGELOG.md#0.0.5)

### Added

- Countersigning related functions and structs

## [holo\_hash-0.0.5](crates/holo_hash/CHANGELOG.md#0.0.5)

## [fixt-0.0.5](crates/fixt/CHANGELOG.md#0.0.5)

# 20210722.172107

## [holochain-0.0.102](crates/holochain/CHANGELOG.md#0.0.102)

### Known Issues :exclamation:

- We’ve become aware of a bug that locks up the conductor when installing happ bundles or registering DNA via the admin API concurrently. Please perform these actions sequentially until we’ve resolved the bug.

### Fixed

- Concurrent zome calls could cause the `init()` zome callback to run multiple times concurrently, causing `HeadMoved` errors. This is fixed, so that `init()` can only ever run once.
  - If a zome call has been waiting for another zome call to finish running `init()` for longer than 30 seconds, it will timeout.

### Changed

- Apps now have a more complex status. Apps now can be either enabled/disabled as well as running/stopped, the combination of which is captured by three distinctly named states:
  - “Running” (enabled + running) -\> The app is running normally
  - “Paused” (enabled + stopped) -\> The app is currently stopped due to some minor problem in one of its cells such as failed network access, but will start running again as soon as it’s able. Some Cells may still be running normally.
  - “Disabled” (disabled + stopped) -\> The app is stopped and will remain so until explicitly enabled via `EnableApp` admin method. Apps can be disabled manually via `DisableApp`, or automatically due to an unrecoverable error in a Cell.
- Some admin methods are deprecated due to the app status changes:
  - `ActivateApp` is deprecated in favor of `EnableApp`
  - `DeactivateApp` is deprecated in favor of `DisableApp`
- Apps will be automatically Paused if not all of their cells are able to join the network during startup

### Added

- `InstallAppBundle` command added to admin conductor API. [\#665](https://github.com/holochain/holochain/pull/665)
- `DnaSource` in conductor\_api `RegisterDna` call now can take a `DnaBundle` [\#665](https://github.com/holochain/holochain/pull/665)
- New admin interface methods:
  - `EnableApp` (replaces `ActivateApp`)
  - `DisableApp` (replaces `DeactivateApp`)
  - `StartApp` (used to attempt to manually restart a Paused app)
- Using the 3 level PLRU instance cache from latest holochain wasmer `v0.0.72`

## [holochain\_test\_wasm\_common-0.0.2](crates/holochain_test_wasm_common/CHANGELOG.md#0.0.2)

## [holochain\_cascade-0.0.2](crates/holochain_cascade/CHANGELOG.md#0.0.2)

## [holochain\_cli-0.0.3](crates/holochain_cli/CHANGELOG.md#0.0.3)

## [holochain\_cli\_sandbox-0.0.3](crates/holochain_cli_sandbox/CHANGELOG.md#0.0.3)

## [holochain\_websocket-0.0.2](crates/holochain_websocket/CHANGELOG.md#0.0.2)

## [holochain\_conductor\_api-0.0.2](crates/holochain_conductor_api/CHANGELOG.md#0.0.2)

## [holochain\_state-0.0.2](crates/holochain_state/CHANGELOG.md#0.0.2)

## [holochain\_wasm\_test\_utils-0.0.2](crates/holochain_wasm_test_utils/CHANGELOG.md#0.0.2)

## [holochain\_p2p-0.0.2](crates/holochain_p2p/CHANGELOG.md#0.0.2)

## [holochain\_cli\_bundle-0.0.2](crates/holochain_cli_bundle/CHANGELOG.md#0.0.2)

## [holochain\_types-0.0.2](crates/holochain_types/CHANGELOG.md#0.0.2)

## [holochain\_keystore-0.0.2](crates/holochain_keystore/CHANGELOG.md#0.0.2)

## [holochain\_sqlite-0.0.2](crates/holochain_sqlite/CHANGELOG.md#0.0.2)

## [kitsune\_p2p-0.0.2](crates/kitsune_p2p/CHANGELOG.md#0.0.2)

## [kitsune\_p2p\_proxy-0.0.2](crates/kitsune_p2p_proxy/CHANGELOG.md#0.0.2)

## [kitsune\_p2p\_transport\_quic-0.0.2](crates/kitsune_p2p_transport_quic/CHANGELOG.md#0.0.2)

## [kitsune\_p2p\_types-0.0.2](crates/kitsune_p2p_types/CHANGELOG.md#0.0.2)

## [mr\_bundle-0.0.2](crates/mr_bundle/CHANGELOG.md#0.0.2)

## [holochain\_util-0.0.2](crates/holochain_util/CHANGELOG.md#0.0.2)

## [hdk-0.0.102](crates/hdk/CHANGELOG.md#0.0.102)

### Changed

- hdk: fixed wrong order of recipient and sender in `x_25519_x_salsa20_poly1305_decrypt`

## [hdk\_derive-0.0.4](crates/hdk_derive/CHANGELOG.md#0.0.4)

## [holochain\_zome\_types-0.0.4](crates/holochain_zome_types/CHANGELOG.md#0.0.4)

## [holo\_hash-0.0.4](crates/holo_hash/CHANGELOG.md#0.0.4)

## [fixt-0.0.4](crates/fixt/CHANGELOG.md#0.0.4)

# 20210624.155736

***:exclamation: Performance impact***

Please navigate to the holochain crate release notes further down for details on the performance impact in this release.

## [holochain-0.0.101](crates/holochain/CHANGELOG.md#0.0.101)

This version contains breaking changes to the conductor API as well as a major upgrade to the underlying Wasm runtime.

***:exclamation: Performance impact***

The version of wasmer that is used in this holochain release contains bugs in the scoping of wasmer modules vs. instances, such that it blocks the proper release of memory and slows down execution of concurrent Wasm instances. While we were able to at least mitigate these effects and are coordinating with wasmer to find a proper solution as soon as possible.

The severity of these issues increases with cell concurrency, i.e. using multiple cells with the same DNA. Application development with a single conductor and a few cells are expected to work well unless your machine has serious resource restrictions.

### Added

- `InstallAppBundle` command added to admin conductor API. [\#665](https://github.com/holochain/holochain/pull/665)
- `DnaSource` in conductor\_api `RegisterDna` call now can take a `DnaBundle` [\#665](https://github.com/holochain/holochain/pull/665)

### Removed

- BREAKING:  `InstallAppDnaPayload` in admin conductor API `InstallApp` command now only accepts a hash.  Both properties and path have been removed as per deprecation warning.  Use either `RegisterDna` or `InstallAppBundle` instead. [\#665](https://github.com/holochain/holochain/pull/665)
- BREAKING: `DnaSource(Path)` in conductor\_api `RegisterDna` call now must point to `DnaBundle` as created by `hc dna pack` not a `DnaFile` created by `dna_util` [\#665](https://github.com/holochain/holochain/pull/665)

### CHANGED

- Updated to a version of `holochain_wasmer` that includes a migration to wasmer v2+. [\#773](https://github.com/holochain/holochain/pull/773/files), [\#801](https://github.com/holochain/holochain/pull/80), [\#836](https://github.com/holochain/holochain/pull/836)
- Introduced a simple instance cache to mitigate and potentially outweigh the effects of the aforementioned wasmer conditions [\#848](https://github.com/holochain/holochain/pull/848)

## [holochain\_test\_wasm\_common-0.0.1](crates/holochain_test_wasm_common/CHANGELOG.md#0.0.1)

## [holochain\_cascade-0.0.1](crates/holochain_cascade/CHANGELOG.md#0.0.1)

## [holochain\_cli-0.0.2](crates/holochain_cli/CHANGELOG.md#0.0.2)

### Removed

- temporarily removed `install_app` from `hc`: its not clear if we should restore yet as mostly should be using `install_app_bundle` [\#665](https://github.com/holochain/holochain/pull/665)

## [holochain\_cli\_sandbox-0.0.2](crates/holochain_cli_sandbox/CHANGELOG.md#0.0.2)

## [holochain\_websocket-0.0.1](crates/holochain_websocket/CHANGELOG.md#0.0.1)

## [holochain\_conductor\_api-0.0.1](crates/holochain_conductor_api/CHANGELOG.md#0.0.1)

## [holochain\_state-0.0.1](crates/holochain_state/CHANGELOG.md#0.0.1)

## [holochain\_wasm\_test\_utils-0.0.1](crates/holochain_wasm_test_utils/CHANGELOG.md#0.0.1)

## [holochain\_p2p-0.0.1](crates/holochain_p2p/CHANGELOG.md#0.0.1)

## [holochain\_cli\_bundle-0.0.1](crates/holochain_cli_bundle/CHANGELOG.md#0.0.1)

## [holochain\_types-0.0.1](crates/holochain_types/CHANGELOG.md#0.0.1)

### Changed

- BREAKING: All references to `"uuid"` in the context of DNA has been renamed to `"uid"` to reflect that these IDs are not universally unique, but merely unique with regards to the zome code (the genotype) [\#727](https://github.com/holochain/holochain/pull/727)

## [holochain\_keystore-0.0.1](crates/holochain_keystore/CHANGELOG.md#0.0.1)

## [holochain\_sqlite-0.0.1](crates/holochain_sqlite/CHANGELOG.md#0.0.1)

## [kitsune\_p2p-0.0.1](crates/kitsune_p2p/CHANGELOG.md#0.0.1)

## [kitsune\_p2p\_proxy-0.0.1](crates/kitsune_p2p_proxy/CHANGELOG.md#0.0.1)

## [kitsune\_p2p\_transport\_quic-0.0.1](crates/kitsune_p2p_transport_quic/CHANGELOG.md#0.0.1)

## [kitsune\_p2p\_types-0.0.1](crates/kitsune_p2p_types/CHANGELOG.md#0.0.1)

## [kitsune\_p2p\_dht\_arc-0.0.1](crates/kitsune_p2p_dht_arc/CHANGELOG.md#0.0.1)

## [kitsune\_p2p\_mdns-0.0.1](crates/kitsune_p2p_mdns/CHANGELOG.md#0.0.1)

## [mr\_bundle-0.0.1](crates/mr_bundle/CHANGELOG.md#0.0.1)

## [holochain\_util-0.0.1](crates/holochain_util/CHANGELOG.md#0.0.1)

## [hdk-0.0.101](crates/hdk/CHANGELOG.md#0.0.101)

### Changed

- Added `HdkT` trait to support mocking the host and native rust unit tests

### Added

- Added `sign_ephemeral` and `sign_ephemeral_raw`

## [hdk\_derive-0.0.3](crates/hdk_derive/CHANGELOG.md#0.0.3)

## [holochain\_zome\_types-0.0.3](crates/holochain_zome_types/CHANGELOG.md#0.0.3)

### Changed

- `Signature` is a 64 byte ‘secure primitive’

## [holo\_hash-0.0.3](crates/holo_hash/CHANGELOG.md#0.0.3)

## [fixt-0.0.3](crates/fixt/CHANGELOG.md#0.0.3)

### Changed

- Named bytes fixturators like `SixtyFourBytes` are now fixed length arrays

### Added

- Added `SixtyFourBytesVec` to work like the old `Vec<u8>` implementation

# \[20210304.120604\]

This will include the hdk-0.0.100 release.

## [hdk-0.0.100](crates/hdk/CHANGELOG.md#0.0.100)

### Changed

- hdk: fixup the autogenerated hdk documentation.

# 20210226.155101

This release was initiated for publishing the HDK at version *0.0.100-alpha.1*. We are in the process of redefining the release process around this repository so rough edges are still expected at this point.

### Added

- Added App Validation workflow that runs app validation as authority [\#330](https://github.com/holochain/holochain/pull/330)
- Added validation package to entry defs see for usage [\#344](https://github.com/holochain/holochain/pull/344)
- Implemented the `emit_signals` host function [\#371](https://github.com/holochain/holochain/pull/371), which broadcasts a signal across all app interfaces (fine-grained pub/sub to be done in future work)
- get\_details on a HeaderHash now returns the updates if it’s an entry header
- call host fn (This is an actual function not a macro). Allows you to call a zome that is installed on the same conductor. [\#453](https://github.com/holochain/holochain/pull/453)
- Added create link HeaderHash to the Link type
- `remote_signal` host function to send a signal to a list of agents without blocking on the responses. See [\#546](https://github.com/holochain/holochain/pull/546) or the docs for the hdk.
- `hc` utility. Work with DNA and hApp bundle files, set up sandbox environments for testing and development purposes, make direct admin calls to running conductors, and more.

### Changed

- BREAKING: get\_details and get\_links\_details return SignedHeaderHashed instead of the header types [\#390](https://github.com/holochain/holochain/pull/390)
- BREAKING: ZomeInfo now returns the ZomeId [\#390](https://github.com/holochain/holochain/pull/390)
- BREAKING: HoloHash now serializes as a plain 39-byte sequence, instead of a `{hash, hash_type}` structure [\#459](https://github.com/holochain/holochain/pull/459)
- BREAKING: (Almost) all HDK functions have been converted from macros to functions [\#478](https://github.com/holochain/holochain/pull/478)
- Admin interface method `install_app` has its `app_id` field renamed to `installed_app_id` so as not to conflict with the future concept of an “app id”
- Admin interface method `list_active_app_ids` renamed to `list_active_apps`
- BREAKING: JSON replaced with YAML for DNA Properties as well as the DNA manifest (dna.yaml instead of dna.json) [\#592](https://github.com/holochain/holochain/pull/592)
- BREAKING: format of AppInfo changed

### Removed

- The `dna_util` has absorbed by the new `hc` utility.

### Fixed

- If installing the same app\_id twice, previously the second installation would overwrite the first. Now it is an error to do so.



================================================
File: clippy.toml
================================================
allow-dbg-in-tests = true



================================================
File: config.nix
================================================
{

  # configure holonix itself
  holonix = rec {

    # true = use a github repository as the holonix base (recommended)
    # false = use a local copy of holonix (useful for debugging)
    use-github = true;

    includeHolochainBinaries = false;
    includeScaffolding = false;
    includeTest = false;
    includeNode = false;
    includeDocs = false;
    includeHapps = false;
    includeRelease = false;

    importFn = args: import ./holonix (args // ({
      include = (args.include or { }) // {
        scaffolding = args.include.scaffolding or includeScaffolding;
        test = args.include.test or includeTest;
        holochainBinaries = args.include.holochainBinaries or includeHolochainBinaries;

        node = args.include.node or includeScaffolding;
        docs = args.include.docs or includeDocs;
        happs = args.include.happs or includeHapps;
        release = args.include.release or includeRelease;
      };
    }));
  };

  release = {
    hook = {
      # sanity checks before deploying
      # to stop the release
      # exit 1
      preflight = ''
        hn-release-hook-preflight-manual
      '';

      # bump versions in the repo
      version = ''
        hn-release-hook-version-rust
        hcp-release-hook-version
      '';

      # publish artifacts to the world
      publish = ''
        # crates are published from circle!
      '';
    };

    # the commit hash that the release process should target
    # this will always be behind what ends up being deployed
    # the release process needs to add some commits for changelog etc.
    commit = "8fb82a3a6d8cc69c95c654bd21bf15785a6ca291";

    # the semver for prev and current releases
    # the previous version will be scanned/bumped by release scripts
    # the current version is what the release scripts bump *to*
    version = {
      current = "0.0.13";
      # not used by version hooks in this repo
      previous = "_._._";
    };

    github = {
      # markdown to inject into github releases
      # there is some basic string substitution {{ xxx }}
      # - {{ changelog }} will inject the changelog as at the target commit
      template = ''
        {{ changelog }}

        # Installation

        Use Holonix to work with this repository.

        See:

        - https://github.com/holochain/holonix
        - https://nixos.org/
      '';

      # owner of the github repository that release are deployed to
      owner = "holochain";

      # repository name on github that release are deployed to
      repo = "holochain";

      # canonical local upstream name as per `git remote -v`
      upstream = "origin";
    };
  };
}



================================================
File: CONTRIBUTING.md
================================================
# Contributing

[![Project](https://img.shields.io/badge/project-holochain-blue.svg?style=flat-square)](http://holochain.org/)
[![Discuss](https://img.shields.io/badge/chat-forum%2eholochain%2eorg-blue.svg?style=flat-square)](https://forum.holochain.org)

As an Open Source project, Holochain welcomes contributions of all sorts. Bug reports (and fixes), code and documention contributions, tests, feedback, and more are welcome. This document describes how to most effectively make each type of contribution.

## Social

We are committed to foster a vibrant thriving community, including growing a culture that breaks cycles of marginalization and dominance behavior. In support of this, some open source communities adopt [Codes of Conduct](http://contributor-covenant.org/version/1/3/0/). We are still working on our social protocols, and empower each team to describe its own *Protocols for Inclusion*. Until our teams have published their guidelines, please use the link above as a general guideline.

## Coordination

* For support be sure to explore our [Developer Resources and Documentation](https://developer.holochain.org)
* Chat with us on our [DEV.HC channel on Discord](https://discord.gg/MwPvM4Vffg)
* Ask and answer questions on our [online forums](https://forum.holochain.org)

Please make use of these resources to support your contributions, or simply to contribute your voice.

## Getting started with developing Holochain

To get a development environment and tools set up for developing holochain, you can work through [this guide](https://github.com/holochain/holochain/blob/docs/developer_setup.md).

## Git Hygiene
This section describes our practices and guidelines for using git and making changes to the repo.

* We use Github's pull requests as our code review tool
* We encourage any dev to comment on pull requests and we think of the pull request not as a "please approve my code" but as a space for co-developing, i.e. asynchronous "pair-coding" of a sort.
* We develop features on separate branches
* We use merge (not rebase) so that commits related to a ticket can be retroactively explored.
* In most repos development happens on a `develop` branch which gets merged to `main` when there's a release.

### Pull requests

We warmly welcome pull requests for bug fixes, bug reproductions, documentation improvements, and any other "obviously good" enhancements to the codebase. If you are unsure if an enhancement is "obviously good", please coordinate with us first through a GitHub issue, or through our forums or Discord channel. We reserve the right to close any PR which doesn't fit our overall development trajectory, but we will gladly review any PRs and work with authors who have taken the time to identify a real problem or need and take steps to address it.

To open a PR, fork our Github repo, create a branch whose name describes your fix, and set our `develop` branch as the base branch for your PR.

If you add or change functionality, be sure to add or update both unit tests and integration tests to show that it works. Pull requests without tests compromise our code's quality and cannot be accepted.


## Bug reports

The simplest way to report a bug is via [Github Issues](https://github.com/holochain/holochain/issues/new/choose) by selecting the Bug Report issue type. Please fill out all relevant areas of the bug report, including steps to reproduce. If your report is not specific enough, we will have a hard time addressing it without further follow-up.

## Bug fixes and minimal reproductions

We gladly welcome pull requests that help us identify and fix bugs!

The end goal of addressing any bug is to have a test written in our codebase to reproduce the bug, and of course to implement the fix for the bug. A PR with at least a minimal reproduction demonstrating the bug is extremely helpful, even if the fix has not been discovered.

To write a minimal reproduction of a problem discovered "in the wild", we recommend you to write a sample zome, DNA, or hApp which demonstrates the problem, and open a PR with your failing test. We have a library called [`sweettest`](https://docs.rs/holochain/latest/holochain/sweettest/index.html) which is well-suited to the task of testing the behavior of Holochain applications.

When writing your reproduction PR, you can recreate the problematic part of your app in one of two ways: "inline zomes", or "test wasms".

### How to create "inline zomes"

The quickest, most preferable way to reproduce a problem is through "inline zomes". Inline zomes are written in terms of a collection of functions, like normal Wasm zomes, but they don't get compiled to wasm, and instead are run inline by Rust directly. This lightweight approach to writing zomes is well suited for quick test cases, or for cases that require a multitude of zomes in order to reproduce a problem.

To create a test based on inline zomes, see [existing tests](https://github.com/holochain/holochain/blob/1cff6c77e9877cbc5d98c289432c548065deb4b7/crates/holochain/src/conductor/conductor/tests.rs#L877-L920) using `InlineZomeSet` or `SweetInlineZomes` for guidance. Just put your test in a place that feels appropriate.

### How to create a "test wasm"

Holochain has many "test wasms", which are sample zomes written to demonstrate specific functionality.

It may be necessary to write a test wasm if the problem you've encountered has to do with the actual machinery of executing Wasm code. It may also be a good option if you discovered a problem while writing a zome yourself, in which case you can simply copy and paste the offending code into a new test wasm. Creating test wasms is not the most streamlined process right now, so please follow these instructions carefully.

To create a test wasm:

1. Create a new crate in `crates/test_utils/wasm/wasm_workspace`
  - See the other test wasms for guidance on proper setup. In particular:
  - The `integrity.lib` will become your integrity zome, and `lib.rs` will become your coordinator zome. Your coordinator zome will be named after the crate name, and the integrity zome will be named with a `_integrity` suffix added.
2. Add your test wasm name to the `TestWasm` enum in [crates/test_utils/wasm/src/lib.rs](https://github.com/holochain/holochain/blob/1b663ec03c86462646cc7693391702a1de02b3a6/crates/test_utils/wasm/src/lib.rs#L21).
  - Make sure its PascalCase name matches the snake_case name of the crate.
  - You will have to make two other changes in the same file to specify the mapping to snake case, and the location of the built wasm, which will be straightforward to do by observing how other test wasms have done it.
3. Add your test wasm's crate name to the `[workspace]` section of `crates/test_utils/wasm/wasm_workspace/Cargo.toml`.
4. Build your test wasm (and all others) with `cargo build --features 'build_wasms' --manifest-path=crates/holochain/Cargo.toml`.

To write a test using your test wasm, you can use `sweettest::SweetDnaFile::unique_from_test_wasms(vec![TestWasm::YourWasm])` to set up your DNA. See existing tests which use this function for inspiration. [Here is a simple example](https://github.com/holochain/holochain/blob/1a9d85d79a900ad153843a851797f8d46d6ec0e1/crates/holochain/tests/agent_scaling/mod.rs#L101-L134) to follow for guidance.

## Compiler warnings

Compilation warnings are NOT OK in shared/production level code.

Warnings have a nasty habit of piling up over time. This makes your code increasingly unpleasant for other people to work with.

CI MUST fail or pass, there is no use in the ever noisier "maybe" status.

If you are facing a warning locally you can try:

0. Fixing it
1. Using `#[allow(***)]` inline to surgically override a once-off issue
2. Proposing a global `allow` for a specific rule
  - this is an extreme action to take
  - this should only be considered if it can be shown that:
    - the issue is common (e.g. dozens of `#allow[***]`)
    - disabling it won't cause issues/mess to pile up elsewhere
    - the wider Rust community won't find our codebase harder to work with

If you don't know the best approach, please ask for help!

It is NOT OK to disable `deny` for warnings globally at the CI or makefile/nix level.

You can allow warnings locally during development by setting the `RUSTFLAGS` environment variable.

#### Code style
We use rust-fmt to enforce code style so that we don't spend time arguing about this.

Run the formatter with:

``` shell
nix develop .#coreDev --command cargo fmt
```

or, if you have a version of `cargo` locally installed which matches the version used in the `nix develop` environment:

```shell
cargo fmt
```

## Continuous Integration changes

Please also be aware that extending/changing the CI configuration can be very time consuming. Seemingly minor changes can have large downstream impact.

Some notable things to watch out for:

- Adding changes that cause the CI cache to be dropped on every run
- Changing the compiler/lint rules that are shared by many people
- Changing versions of crates/libs that also impact downstream crates/repos
- Changing the version of Rust used
- Adding/removing tools or external libs

The change may not be immediately apparent to you. The change may break the development environment on a different operating system, e.g. Windows.

At the same time, we do not want to catastrophise and stifle innovation or legitimate upgrades.

If you have a proposal to improve our CI config, that's great! Please open a dedicated branch for the change in isolation so we can discuss the proposal together. And then broadcast the proposal in chat to maximise visibility and the opportunity for everyone to respond.

It is NOT OK to change the behaviour of tests/CI in otherwise unrelated PRs. SOMETIMES it MAY be OK to change CI in a related PR, e.g. adding a new lib that your code requires. DO expect that a change like this will probably attract additional scrutiny during the PR review process, which is unfortunate but important.

Use your best judgement and respect that other people, across all timezones, rely on this repository remaining a productive working environment 24/7/365.

## License
Holochain is licensed under the Cryptographic Autonomy License [![License: CAL v1](https://img.shields.io/badge/License-CAL%201.0-blue.svg)](https://github.com/holochain/cryptographic-autonomy-license) which is the first [Open Source Initiative approved](https://opensource.org/licenses/CAL-1.0) license designed for distributed software. As such it is designed to protect the rights of end-users of applications built on Holochain to own their own data and cryptographic keys. See [this article](https://medium.com/holochain/understanding-the-cryptographic-autonomy-license-172ac920966d) for more detail about licensing requirements of P2P software.

Other components, applications, and libraries we build are typically shared under the [Apache License v2](http://www.apache.org/licenses/LICENSE-2.0) as a simple, lighweight, and flexible way to share code.

Copyright (C) 2019 - 2024, Holochain Foundation



================================================
File: default.nix
================================================
{ ... } @ args:
import ./holonix args



================================================
File: flake.lock
================================================
{
  "nodes": {
    "cargo-chef": {
      "flake": false,
      "locked": {
        "lastModified": 1727084300,
        "narHash": "sha256-ya6hQXFDWMvb265v7vktRcc/kVb833vmq8Z9ArM70F0=",
        "owner": "LukeMathWalker",
        "repo": "cargo-chef",
        "rev": "a228626f314d3aacd21723b49dd5cc4257d3f716",
        "type": "github"
      },
      "original": {
        "owner": "LukeMathWalker",
        "ref": "main",
        "repo": "cargo-chef",
        "type": "github"
      }
    },
    "cargo-rdme": {
      "flake": false,
      "locked": {
        "lastModified": 1718044745,
        "narHash": "sha256-Oa667BTz/PdxZmhGSP+qfPcUbORlk7nP5OrCJyYqVQg=",
        "owner": "orium",
        "repo": "cargo-rdme",
        "rev": "22d756971037ad4c7953db882c5b96a662364f15",
        "type": "github"
      },
      "original": {
        "owner": "orium",
        "ref": "v1.4.4",
        "repo": "cargo-rdme",
        "type": "github"
      }
    },
    "crane": {
      "locked": {
        "lastModified": 1732407143,
        "narHash": "sha256-qJOGDT6PACoX+GbNH2PPx2ievlmtT1NVeTB80EkRLys=",
        "owner": "ipetkov",
        "repo": "crane",
        "rev": "f2b4b472983817021d9ffb60838b2b36b9376b20",
        "type": "github"
      },
      "original": {
        "owner": "ipetkov",
        "repo": "crane",
        "type": "github"
      }
    },
    "empty": {
      "flake": false,
      "locked": {
        "lastModified": 1683792623,
        "narHash": "sha256-pQpattmS9VmO3ZIQUFn66az8GSmB4IvYhTTCFn6SUmo=",
        "owner": "steveej",
        "repo": "empty",
        "rev": "8e328e450e4cd32e072eba9e99fe92cf2a1ef5cf",
        "type": "github"
      },
      "original": {
        "owner": "steveej",
        "repo": "empty",
        "type": "github"
      }
    },
    "flake-compat": {
      "flake": false,
      "locked": {
        "lastModified": 1732722421,
        "narHash": "sha256-HRJ/18p+WoXpWJkcdsk9St5ZiukCqSDgbOGFa8Okehg=",
        "owner": "edolstra",
        "repo": "flake-compat",
        "rev": "9ed2ac151eada2306ca8c418ebd97807bb08f6ac",
        "type": "github"
      },
      "original": {
        "owner": "edolstra",
        "repo": "flake-compat",
        "type": "github"
      }
    },
    "flake-parts": {
      "inputs": {
        "nixpkgs-lib": "nixpkgs-lib"
      },
      "locked": {
        "lastModified": 1730504689,
        "narHash": "sha256-hgmguH29K2fvs9szpq2r3pz2/8cJd2LPS+b4tfNFCwE=",
        "owner": "hercules-ci",
        "repo": "flake-parts",
        "rev": "506278e768c2a08bec68eb62932193e341f55c90",
        "type": "github"
      },
      "original": {
        "id": "flake-parts",
        "type": "indirect"
      }
    },
    "holochain": {
      "flake": false,
      "locked": {
        "lastModified": 1733145535,
        "narHash": "sha256-fDDdYFkkN1kJA32vVF+HKIbLCZTaMBPmZYah9iqB18E=",
        "owner": "holochain",
        "repo": "holochain",
        "rev": "eba9927d03edd8f27a827f8cc0026916b493c9ea",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.3.6",
        "repo": "holochain",
        "type": "github"
      }
    },
    "lair": {
      "flake": false,
      "locked": {
        "lastModified": 1732711885,
        "narHash": "sha256-kpMkLPHEAarG6MPFdJMQQnTk7YkXk9mFcWLyvbBEUVo=",
        "owner": "holochain",
        "repo": "lair",
        "rev": "6e8938a1d574bd2f8d2f66d1983b58951d700774",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "lair_keystore-v0.4.7",
        "repo": "lair",
        "type": "github"
      }
    },
    "launcher": {
      "flake": false,
      "locked": {
        "lastModified": 1733246036,
        "narHash": "sha256-/UpB+zK5Yqhpoo+6I+4yl7D0DPTmh5gOOzipakjpJAA=",
        "owner": "holochain",
        "repo": "hc-launch",
        "rev": "f6f980801f820f036ef133b6dc31efbef6dd0f99",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.3",
        "repo": "hc-launch",
        "type": "github"
      }
    },
    "nix-filter": {
      "locked": {
        "lastModified": 1731533336,
        "narHash": "sha256-oRam5PS1vcrr5UPgALW0eo1m/5/pls27Z/pabHNy2Ms=",
        "owner": "numtide",
        "repo": "nix-filter",
        "rev": "f7653272fd234696ae94229839a99b73c9ab7de0",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "nix-filter",
        "type": "github"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1739580444,
        "narHash": "sha256-+/bSz4EAVbqz8/HsIGLroF8aNaO8bLRL7WfACN+24g4=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "8bb37161a0488b89830168b81c48aed11569cb93",
        "type": "github"
      },
      "original": {
        "id": "nixpkgs",
        "ref": "nixos-unstable",
        "type": "indirect"
      }
    },
    "nixpkgs-lib": {
      "locked": {
        "lastModified": 1730504152,
        "narHash": "sha256-lXvH/vOfb4aGYyvFmZK/HlsNsr/0CVWlwYvo2rxJk3s=",
        "type": "tarball",
        "url": "https://github.com/NixOS/nixpkgs/archive/cc2f28000298e1269cea6612cd06ec9979dd5d7f.tar.gz"
      },
      "original": {
        "type": "tarball",
        "url": "https://github.com/NixOS/nixpkgs/archive/cc2f28000298e1269cea6612cd06ec9979dd5d7f.tar.gz"
      }
    },
    "pre-commit-hooks-nix": {
      "flake": false,
      "locked": {
        "lastModified": 1732021966,
        "narHash": "sha256-mnTbjpdqF0luOkou8ZFi2asa1N3AA2CchR/RqCNmsGE=",
        "owner": "cachix",
        "repo": "pre-commit-hooks.nix",
        "rev": "3308484d1a443fc5bc92012435d79e80458fe43c",
        "type": "github"
      },
      "original": {
        "owner": "cachix",
        "repo": "pre-commit-hooks.nix",
        "type": "github"
      }
    },
    "repo-git": {
      "flake": false,
      "locked": {
        "narHash": "sha256-d6xi4mKdjkX2JFicDIv5niSzpyI0m/Hnm8GGAIU04kY=",
        "type": "file",
        "url": "file:/dev/null"
      },
      "original": {
        "type": "file",
        "url": "file:/dev/null"
      }
    },
    "root": {
      "inputs": {
        "cargo-chef": "cargo-chef",
        "cargo-rdme": "cargo-rdme",
        "crane": "crane",
        "empty": "empty",
        "flake-compat": "flake-compat",
        "flake-parts": "flake-parts",
        "holochain": [
          "empty"
        ],
        "lair": [
          "empty"
        ],
        "launcher": [
          "empty"
        ],
        "nix-filter": "nix-filter",
        "nixpkgs": "nixpkgs",
        "pre-commit-hooks-nix": "pre-commit-hooks-nix",
        "repo-git": "repo-git",
        "rust-overlay": "rust-overlay",
        "scaffolding": [
          "empty"
        ],
        "versions": "versions"
      }
    },
    "rust-overlay": {
      "inputs": {
        "nixpkgs": [
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1739673031,
        "narHash": "sha256-Z/GT8ebbvc4goxN4A0A5ACj26G1HaGJO+VetrPuC5Mo=",
        "owner": "oxalica",
        "repo": "rust-overlay",
        "rev": "538528d55318e0c8af1c307dcf10b7629b988fc3",
        "type": "github"
      },
      "original": {
        "owner": "oxalica",
        "repo": "rust-overlay",
        "type": "github"
      }
    },
    "scaffolding": {
      "flake": false,
      "locked": {
        "lastModified": 1733422567,
        "narHash": "sha256-X7MUZ6wXPcsF6cFC4AK27UiUWpVzhdlrnL+1znfzVfM=",
        "owner": "holochain",
        "repo": "scaffolding",
        "rev": "4d97985a8a93db93c25326a4d75aac0a3ea40a06",
        "type": "github"
      },
      "original": {
        "owner": "holochain",
        "ref": "holochain-0.3",
        "repo": "scaffolding",
        "type": "github"
      }
    },
    "versions": {
      "inputs": {
        "holochain": "holochain",
        "lair": "lair",
        "launcher": "launcher",
        "scaffolding": "scaffolding"
      },
      "locked": {
        "dir": "versions/0_3",
        "lastModified": 1733478632,
        "narHash": "sha256-6458g33e72eCkupEyU3pkFlaaoRICGn+Ku7W9a07N+0=",
        "owner": "holochain",
        "repo": "holochain",
        "rev": "5c4dbe1828d0ebd67afda3f17e16192a91f321a2",
        "type": "github"
      },
      "original": {
        "dir": "versions/0_3",
        "owner": "holochain",
        "repo": "holochain",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}



================================================
File: flake.nix
================================================
{
  description =
    "Holochain is an open-source framework to develop peer-to-peer applications with high levels of security, reliability, and performance.";

  inputs = {
    # empty repo that can be detected as such, used for the input override implementation
    empty.url = "github:steveej/empty";
    empty.flake = false;

    # workaround to allow the passing in of the `.git` directory into the release-automation tests
    repo-git.url = "file+file:/dev/null";
    repo-git.flake = false;

    # nix packages pointing to the github repo
    nixpkgs.url = "nixpkgs/nixos-unstable";

    # lib to build nix packages from rust crates
    crane.url = "github:ipetkov/crane";

    # filter out all .nix files to not affect the input hash
    # when these are changes
    nix-filter.url = "github:numtide/nix-filter";
    # provide downward compatibility for nix-shell/derivation users
    flake-compat = {
      url = "github:edolstra/flake-compat";
      flake = false;
    };

    # To execute checks when making a commit
    # Only /flake-module.nix is needed here -> Importing with `flake=false`.
    pre-commit-hooks-nix.url = "github:cachix/pre-commit-hooks.nix";
    pre-commit-hooks-nix.flake = false;

    # rustup, rust and cargo
    rust-overlay = {
      url = "github:oxalica/rust-overlay";
      inputs.nixpkgs.follows = "nixpkgs";
    };

    versions.url = "github:holochain/holochain?dir=versions/0_3";

    holochain.follows = "empty";
    holochain.flake = false;
    lair.follows = "empty";
    lair.flake = false;
    launcher.follows = "empty";
    launcher.flake = false;
    scaffolding.follows = "empty";
    scaffolding.flake = false;

    cargo-chef = {
      url = "github:LukeMathWalker/cargo-chef/main";
      flake = false;
    };

    cargo-rdme = {
      url = "github:orium/cargo-rdme/v1.4.4";
      flake = false;
    };
  };

  # refer to flake-parts docs https://flake.parts/
  outputs = inputs @ { self, nixpkgs, flake-parts, ... }:
    # all possible parameters for a module: https://flake.parts/module-arguments.html#top-level-module-arguments
    flake-parts.lib.mkFlake { inherit inputs; } {
      systems = [ "aarch64-darwin" "x86_64-linux" "aarch64-linux" ];

      imports =
        # auto import all nix code from `./modules`, treat each one as a flake and merge them
        (
          map (m: "${./.}/nix/modules/${m}")
            (builtins.attrNames (builtins.readDir ./nix/modules))
        )
        ++ [
          (inputs.pre-commit-hooks-nix + /flake-module.nix)
        ];

      perSystem = { pkgs, ... }: {
        legacyPackages = pkgs;
      };
    };
}



================================================
File: LICENSE
================================================
# Cryptographic Autonomy License version 1.0

*This Cryptographic Autonomy License (the “License”) applies to any Work whose owner has marked it with any of the following notices:*

*“Licensed under the Cryptographic Autonomy License version 1.0,” or*

*“SPDX-License-Identifier: CAL-1.0,” or*

*“Licensed under the Cryptographic Autonomy License version 1.0, with Combined Work Exception,” or*

*“SPDX-License-Identifier: CAL-1.0 with Combined-Work-Exception.”*

------

## 1. Purpose

This License gives You unlimited permission to use and modify the software to which it applies (the “Work”), either as-is or in modified form, for Your private purposes, while protecting the owners and contributors to the software from liability. 

This License also strives to protect the freedom and autonomy of third parties who receive the Work from you.  If any non-affiliated third party receives any part, aspect, or element of the Work from You, this License requires that You provide that third party all the permissions and materials needed to independently use and modify the Work without that third party having a loss of data or capability due to your actions.

The full permissions, conditions, and other terms are laid out below.

## 2. Receiving a License

In order to receive this License, You must agree to its rules. The rules of this License are both obligations of Your agreement with the Licensor and conditions to your License. You must not do anything with the Work that triggers a rule You cannot or will not follow. 

### 2.1. Application

The terms of this License apply to the Work as you receive it from Licensor, as well as to any modifications, elaborations, or implementations created by You that contain any licenseable portion of the Work (a “Modified Work”). Unless specified, any reference to the Work also applies to a Modified Work.

### 2.2. Offer and Acceptance

This License is automatically offered to every person and organization. You show that you accept this License and agree to its conditions by taking any action with the Work that, absent this License, would infringe any intellectual property right held by Licensor. 

### 2.3. Compliance and Remedies

Any failure to act according to the terms and conditions of this License places Your use of the Work outside the scope of the License and infringes the intellectual property rights of the Licensor. In the event of infringement, the terms and conditions of this License may be enforced by Licensor under the intellectual property laws of any jurisdiction to which You are subject. You also agree that either the Licensor or a Recipient (as an intended third-party beneficiary) may enforce the terms and conditions of this License against You via specific performance.

## 3. Permissions and Conditions

### 3.1. Permissions Granted

Conditioned on compliance with section 4, and subject to the limitations of section 3.2, Licensor grants You the world-wide, royalty-free, non-exclusive permission to: 

> a) Take any action with the Work that would infringe the non-patent intellectual property laws of any jurisdiction to which You are subject; and
>
> b) Take any action with the Work that would infringe any patent claims that Licensor can license or becomes able to license, to the extent that those claims are embodied in the Work as distributed by Licensor.

### 3.2. Limitations on Permissions Granted

The following limitations apply to the permissions granted in section 3.1:

> a) Licensor does not grant any patent license for claims that are only infringed due to modification of the Work as provided by Licensor, or the combination of the Work as provided by Licensor, directly or indirectly, with any other component, including other software or hardware.
>
> b) Licensor does not grant any license to the trademarks, service marks, or logos of Licensor, except to the extent necessary to comply with the attribution conditions in section 4.1 of this License.

## 4. Conditions

If You exercise any permission granted by this License, such that the Work, or any part, aspect, or element of the Work, is distributed, communicated, made available, or made perceptible to a non-Affiliate third party (a “Recipient”), either via physical delivery or via a network connection to the Recipient, You must comply with the following conditions: 

### 4.1. Provide Access to Source Code

Subject to the exception in section 4.4, You must provide to each Recipient a copy of, or no-charge unrestricted network access to, the Source Code corresponding to the Work.

The “Source Code” of the Work means the form of the Work preferred for making modifications, including any comments, configuration information, documentation, help materials, installation instructions, cryptographic seeds or keys, and any information reasonably necessary for the Recipient to independently compile and use the Source Code and to have full access to the functionality contained in the Work.

#### 4.1.1. Providing Network Access to the Source Code

Network access to the Notices and Source Code may be provided by You or by a third party, such as a public software repository, and must persist during the same period in which You exercise any of the permissions granted to You under this License and for at least one year thereafter.

#### 4.1.2. Source Code for a Modified Work

Subject to the exception in section 4.5, You must provide to each Recipient of a Modified Work Access to Source Code corresponding to those portions of the Work remaining in the Modified Work as well as the modifications used by You to create the Modified Work. The Source Code corresponding to the modifications in the Modified Work must be provided to the Recipient either a) under this License, or b) under a Compatible Open Source License.

A “Compatible Open Source License” means a license accepted by the Open Source Initiative that allows object code created using both Source Code provided under this License and Source Code provided under the other open source license to be distributed together as a single work.

#### 4.1.3. Coordinated Disclosure of Security Vulnerabilities

You may delay providing the Source Code corresponding to a particular modification of the Work for up to ninety (90) days (the “Embargo Period”) if: a) the modification is intended to address a newly-identified vulnerability or a security flaw in the Work, b) disclosure of the vulnerability or security flaw before the end of the Embargo Period would put the data, identity, or autonomy of one or more Recipients of the Work at significant risk, c) You are participating in a coordinated disclosure of the vulnerability or security flaw with one or more additional Licensees, and d) Access to the Source Code pertaining to the modification is provided to all Recipients at the end of the Embargo Period.

### 4.2. Maintain User Autonomy

In addition to providing each Recipient the opportunity to have Access to the Source Code, You cannot use the permissions given under this License to interfere with a Recipient’s ability to fully use an independent copy of the Work generated from the Source Code You provide with the Recipient’s own User Data.

“User Data” means any data that is an input to or an output from the Work, where the presence of the data is necessary for substantially identical use of the Work in an equivalent context chosen by the Recipient, and where the Recipient has an existing ownership interest, an existing right to possess, or where the data has been generated by, for, or has been assigned to the Recipient.

#### 4.2.1. No Withholding User Data

Throughout any period in which You exercise any of the permissions granted to You under this License, You must also provide to any Recipient to whom you provide services via the Work, a no-charge copy, provided in a commonly used electronic form, of the Recipient’s User Data in your possession, to the extent that such User Data is available to You for use in conjunction with the Work. 

#### 4.2.2. No Technical Measures that Limit Access

You may not, by the use of cryptographic methods applied to anything provided to the Recipient, by possession or control of cryptographic keys, seeds, or hashes, by other technological protection measures, or by any other method, limit a Recipient's ability to access any functionality present in the Recipient's independent copy of the Work, or deny a Recipient full control of the Recipient's User Data.

#### 4.2.3. No Legal or Contractual Measures that Limit Access

You may not contractually restrict a Recipient's ability to independently exercise the permissions granted under this License. You waive any legal power to forbid circumvention of technical protection measures that include use of the Work, and You waive any claim that the capabilities of the Work were limited or modified as a means of enforcing the legal rights of third parties against Recipients.

### 4.3. Provide Notices and Attribution

You must retain all licensing, authorship, or attribution notices contained in the Source Code (the “Notices”), and provide all such Notices to each Recipient, together with a statement acknowledging the use of the Work. Notices may be provided directly to a Recipient or via an easy-to-find hyperlink to an Internet location also providing Access to Source Code.

### 4.4. Scope of Conditions in this License

You are required to uphold the conditions of this License only relative to those who are Recipients of the Work from You.  Other than providing Recipients with the applicable Notices, Access to Source Code, and a copy of and full control of their User Data, nothing in this License requires You to provide processing services to or engage in network interactions with anyone. 

### 4.5. Combined Work Exception

As an exception to condition that You provide Recipients Access to Source Code, any Source Code files marked by the Licensor as having the “Combined Work Exception,” or any object code exclusively resulting from Source Code files so marked, may be combined with other Software into a “Larger Work.” So long as you comply with the requirements to provide Recipients the applicable Notices and Access to the Source Code provided to You by Licensor, and you provide Recipients access to their User Data and do not limit Recipient’s ability to independently work with their User Data, any other Software in the Larger Work as well as the Larger Work as a whole may be licensed under the terms of your choice.

## 5. Term and Termination

The term of this License begins when You receive the Work, and continues until terminated for any of the reasons described herein, or until all Licensor’s intellectual property rights in the Software expire, whichever comes first (“Term”). This License cannot be revoked, only terminated for the reasons listed below. 

### 5.1. Effect of Termination

If this License is terminated for any reason, all permissions granted to You under Section 3 by any Licensor automatically terminate. You will immediately cease exercising any permissions granted in this License relative to the Work, including as part of any Modified Work.

### 5.2. Termination for Non-Compliance; Reinstatement

This License terminates automatically if You fail to comply with any of the conditions in section 4. As a special exception to termination for non-compliance, Your permissions for the Work under this License will automatically be reinstated if You come into compliance with all the conditions in section 2 within sixty (60) days of being notified by Licensor or an intended third party beneficiary of Your noncompliance. You are eligible for reinstatement of permissions for the Work one time only, and only for the sixty days immediately after becoming aware of noncompliance. Loss of permissions granted for the Work under this License due to either a) sustained noncompliance lasting more than sixty days or b) subsequent termination for noncompliance after reinstatement, is permanent, unless rights are specifically restored by Licensor in writing. 

### 5.3 Termination Due to Litigation

If You initiate litigation against Licensor, or any Recipient of the Work, either direct or indirect, asserting that the Work directly or indirectly infringes any patent, then all permissions granted to You by this License shall terminate. In the event of termination due to litigation, all permissions validly granted by You under this License, directly or indirectly, shall survive termination. Administrative review procedures, declaratory judgment actions, counterclaims in response to patent litigation, and enforcement actions against former Licensees terminated under this section do not cause termination due to litigation.

## 6. Disclaimer of Warranty and Limit on Liability

As far as the law allows, the Work comes AS-IS, without any warranty of any kind, and no Licensor or contributor will be liable to anyone for any damages related to this software or this license, under any kind of legal claim, or for any type of damages, including indirect, special, incidental, or consequential damages of any type arising as a result of this License or the use of the Work including, without limitation, damages for loss of goodwill, work stoppage, computer failure or malfunction, loss of profits, revenue, or any and all other commercial damages or losses. 

## 7. Other Provisions

### 7.1. Affiliates

An “Affiliate” means any other entity that, directly or indirectly through one or more intermediaries, controls, is controlled by, or is under common control with, the Licensee. Employees of a Licensee and natural persons acting as contractors exclusively providing services to Licensee are also Affiliates.

### 7.2. Choice of Jurisdiction and Governing Law

A Licensor may require that any action or suit by a Licensee relating to a Work provided by Licensor under this License may be brought only in the courts of a particular jurisdiction and under the laws of a particular jurisdiction (excluding its conflict-of-law provisions), if Licensor provides conspicuous notice of the particular jurisdiction to all Licensees.

### 7.3. No Sublicensing

This License is not sublicensable. Each time You provide the Work or a Modified Work to a Recipient, the Recipient automatically receives a license under the terms described in this License. You may not impose any further reservations, conditions, or other provisions on any Recipients’ exercise of the permissions granted herein. 

### 7.4. Attorneys' Fees

In any action to enforce the terms of this License, or seeking damages relating thereto, including by an intended third party beneficiary, the prevailing party shall be entitled to recover its costs and expenses, including, without limitation, reasonable attorneys' fees and costs incurred in connection with such action, including any appeal of such action. A “prevailing party” is the party that achieves, or avoids, compliance with this License, including through settlement. This section shall survive the termination of this License.

### 7.5. No Waiver

Any failure by Licensor to enforce any provision of this License will not constitute a present or future waiver of such provision nor limit Licensor’s ability to enforce such provision at a later time.

### 7.6. Severability

If any provision of this License is held to be unenforceable, such provision shall be reformed only to the extent necessary to make it enforceable. Any invalid or unenforceable portion will be interpreted to the effect and intent of the original portion. If such a construction is not possible, the invalid or unenforceable portion will be severed from this License but the rest of this License will remain in full force and effect.

### 7.7. License for the Text of this License

The text of this license is released under the Creative Commons Attribution-ShareAlike 4.0 International License, with the caveat that any modifications of this license may not use the name “Cryptographic Autonomy License” or any name confusingly similar thereto to describe any derived work of this License.




================================================
File: Makefile
================================================
# holochain Makefile

# the gha workflow sets this globally
# set this also for local executions so we get the same results
F=RUSTFLAGS="-Dwarnings"

# All default features of binaries excluding mutually exclusive features wasmer_sys & wasmer_wamr
DEFAULT_FEATURES=slow_tests,build_wasms,sqlite-encrypted,hc_demo_cli/build_demo
UNSTABLE_FEATURES=chc,unstable-dpki,unstable-sharding,unstable-warrants,unstable-functions,unstable-countersigning,$(DEFAULT_FEATURES)

# mark everything as phony because it doesn't represent a file-system output
.PHONY: default \
	static-all static-fmt static-toml static-clippy static-clippy-unstable \
	static-doc build-workspace-wasmer_sys build-workspace-wasmer_wamr \
	test-workspace-wasmer_sys test-workspace-wasmer_wamr \
	build-workspace-wasmer_sys-unstable \
	test-workspace-wasmer_sys-unstable

# default to running everything (first rule)
default: build-workspace-wasmer_sys \
	test-workspace-wasmer_sys \
	build-workspace-wasmer_wamr \
	test-workspace-wasmer_wamr

# execute all static code validation
static-all: static-fmt static-toml static-clippy static-clippy-unstable static-doc

# ensure committed code is formatted properly
static-fmt:
	$(F) cargo fmt --check

# lint our toml files
static-toml:
	cargo install taplo-cli@0.9.0
	$(F) taplo format --check ./*.toml
	$(F) taplo format --check ./crates/**/*.toml

# ensure our chosen style lints are followed
static-clippy:
	$(F) CHK_SQL_FMT=1 cargo clippy --all-targets --features $(DEFAULT_FEATURES)

static-clippy-unstable:
	$(F) CHK_SQL_FMT=1 cargo clippy --all-targets --features $(UNSTABLE_FEATURES)

# ensure we can build the docs
static-doc:
	RUSTDOCFLAGS=-Dwarnings cargo doc

# build all targets
# this not only builds the test binaries for usage by `test-workspace`,
# but also ensures targets like benchmarks remain buildable.
# NOTE: excludes must match test-workspace nextest params,
#       otherwise some rebuilding will occur due to resolver = "2"
build-workspace-wasmer_sys:
	$(F) cargo build \
		--workspace \
		--locked \
		--all-targets \
		--no-default-features \
		--features $(DEFAULT_FEATURES),wasmer_sys

build-workspace-wasmer_sys-unstable:
	$(F) cargo build \
		--workspace \
		--locked \
		--all-targets \
		--no-default-features \
		--features $(UNSTABLE_FEATURES),wasmer_sys

build-workspace-wasmer_wamr:
	$(F) cargo build \
		--workspace \
		--locked \
		--all-targets \
		--no-default-features \
		--features $(DEFAULT_FEATURES),wasmer_wamr

# execute tests on all crates with wasmer compiler
test-workspace-wasmer_sys:
	cargo install cargo-nextest
	$(F) RUST_BACKTRACE=1 cargo nextest run \
		--workspace \
		--locked \
		--no-default-features \
		--features $(DEFAULT_FEATURES),wasmer_sys

# executes tests on all crates with wasmer compiler and unstable dpki feature
test-workspace-wasmer_sys-unstable:
	cargo install cargo-nextest
	$(F) RUST_BACKTRACE=1 cargo nextest run \
		--workspace \
		--locked \
		--no-default-features \
		--features $(UNSTABLE_FEATURES),wasmer_sys

# execute tests on all crates with wasmer interpreter
test-workspace-wasmer_wamr:
	cargo install cargo-nextest
	$(F) RUST_BACKTRACE=1 cargo nextest run \
		--workspace \
		--locked \
		--no-default-features \
		--features $(DEFAULT_FEATURES),wasmer_wamr



================================================
File: PRINCIPLES.md
================================================
# Holochain core team development principles

This is a living document of principles that we, the Holochain core team, have agreed to uphold in the course of our work on Holochain. The purpose of the doc is to identify the shared principles we want to uphold, which we can refer to, add to, and modify as we go. The intention is not to be a prescription for how we make every decision, but rather a set of guiding principles towards which we strive to move ever closer.

# Documentation

Crate-level docs should describe how that crate is organized into modules, similar to how the introduction of a book often lays out the structure of the book and gives a high-level description of the contents of each of its chapters.

Module-level docs are always up to date with the code in that module.

# Testing

## Test organization

Test code should be as close as possible to the code it is testing.

Unit tests should be in a submodule of the code under test.

It may be hard to know where to find tests of certain functionality since many of our tests are integration tests. The principle we'd like to follow is that it should be possible to discover where to look for a given test by reading the crate-level docs. The docs of one crate or module should describe the structure of what's below, including tests, so that we can hone in on whatever we want to find with the help of the docs.


================================================
File: RELEASE.md
================================================
# Holochain Release process:

## Release candidate test

- Implement fixes, features, changes, and create a release candidate version in the format x.x.x-rc.x
- Compile a version of the ziptest application in the standalone kangaroo app runtime using this release candidate version
- Perform smoke test over 2 consecutive days:
  - Group of 3 testers
  - Day 1:
    - All nodes go online.
    - Each node sends 10 signals to each peer individually.
    - Each node sends 10 signals to "Everyone".
    - Each node creates 10 entries, 1 rep.
    - Wait for entries to appear for all participants.
    - One node goes offline.
    - Remaining nodes create another 10 entries, 1 rep.
    - Wait for entries to appear again.
    - Offline node goes online and waits for entries to appear.
    - Repeat with another node going offline.
    - After 15 minutes create another node and make sure it catches up.
    - One node keeps the conductor running over night and creates 10 entries while other peers are offline.
  - Day 2:
    - All nodes go online and await synchronization.
    - Repeat entry creation while all nodes are online.
    - Repeat one node goes offline procedure.
    - Create a new node and wait for it to synchronize.
- If smoke test passes, full release of the release candidate version is approved.
- If stress test fails, fix and update and release a new rc version and perform smoke test again.

## Full release test

- Once smoke test passes, and full version is released, bump versions in downstream components and re-publish happs, 
  and initiate full testing. This includes the demo apps Talking Stickies and Kando.
- Once testing passes and persistent DHT is functional for the given time period and no bugs have been reported, 
 elevate release to "recommended" status.

## Happy Path estimates:

- Estimated time from a release candidate to smoke test results: 2-3 days
- Estimated time from release candidate smoke test passed to full release: 1-3 days
- Estimated time from full release to tested stable release: 10-16 days (1-2 weeks to bump versions on all tools and test, plus 2 days testing)



================================================
File: release.toml
================================================
sign-commit = true
sign-tag = true
consolidate-commits = true
pre-release-commit-message = "Multi-crate release performed on {{date}}"
post-release-commit-message = "Concluding multi-crate release on {{date}}"



================================================
File: RELEASE_TEST_LOG.md
================================================
# Holochain Release Log

This file documents results of release tests as described in the [Holochain release process](RELEASE.md).

## 2025-03-10: v0.4.2-rc.1

*Success*
- Day 1: Started with 7 nodes and ran through the first test steps of sending signals, creating entries and syncing 
  with a node that has been offline.
- As this is just a regression test with small changes, we concluded the test there.

## 2025-01-27: v0.4.1-rc.2

*Success*
- Day 1: Started with 6 nodes and ran through all test steps successfully. All peer discovery and op syncing was 
  happening within expected timeframes. All steps were completed within a 30 minute call.
- Day 2: All nodes were able to sync the data created after they went offline on day 1. We lost one original node and 
  had a new node join the testing. So a slight deviation from the test script, but otherwise all checks passed.
- Bootstrapping and initial gossip seemed to take a while to start syncing data and then after a few minutes, 
  everything was showing up as expected. Not unusual behavior for Holochain and the main thing is tha data was
  consistently showing up after a few minutes.

## 2025-01-17: v0.4.1-rc.1

*Failure*
- 3 nodes started a new network, peer discovery succeeded on Node A and Node B within 5 minutes. Node C could only see Node A, and no other nodes could see Node C. Logs from Node A indicated that Ops were failing to be integrated due to missing dependencies.
- Sending signals succeeded with 100 % reliability from Node A to Node B, with 50 % reliability from B to A. Node C sent signals with 100% reliability to Node A.
- Entries created by Node A and Node B were received by each other, mostly instantly. Entries created by Node C were not seen by any peers. Entries created by Node A and Node B were not seen by Node C.
- Receiving entries that were created in the absence of a node showed the same pattern.

## 2024-12-17: v0.4.0-rc.2

*Success*
- 3 nodes started a new network, peer discovery succeeded on all nodes within 5 minutes.
- Sending signals to peers succeeded with 100 % reliability.
- Entries created by everyone were received by all peers, mostly instantly. Sometimes it took 60 seconds for the remaining entries to appear.
- Receiving entries that were created in the absence of a node showed a similar pattern. About 50 % of the entries were received immediately after going online, the rest after 60 seconds.
- When a new node is added to an existing network, synchronization of all entries takes about 5 minutes.
- On one occasion one node did not receive the 10 entries published while it was offline. Once the publishing node published another 10 entries, did all 20 come in almost instantly.



================================================
File: rust-toolchain.toml
================================================
[toolchain]
channel = "1.83.0"
components = ["rustfmt", "clippy"]
targets = ["wasm32-unknown-unknown"]
profile = "minimal"



================================================
File: rustfmt.toml
================================================
reorder_imports = true

# unstable but desirable:
# merge_imports = true



================================================
File: shell-rustup.nix
================================================
{ nixpkgs ? import <nixpkgs> { }
, flavor ? "coreDevRustup"
, ...
} @ args:

let
  default = import (builtins.toString ./default.nix) { inherit nixpkgs; };
in

builtins.getAttr flavor default.shells



================================================
File: shell.nix
================================================
{ devShellId ? "coreDev", ... } @ args: (import ./default.nix ({ inherit devShellId; } // args))



================================================
File: .cursorignore
================================================
# Add directories or file patterns to ignore during indexing (e.g. foo/ or *.csv)
target/
**/target/**
.git/


================================================
File: .envrc
================================================
if ! has nix_direnv_version || ! nix_direnv_version 3.0.4; then
  source_url "https://raw.githubusercontent.com/nix-community/nix-direnv/3.0.4/direnvrc" "sha256-DzlYZ33mWF/Gs8DDeyjr8mnVmQGx7ASYqA5WlxwvBG4="
fi

watch_file nix/**

use flake .#coreDev \
  --override-input versions ./versions/weekly \
  --override-input holochain .



================================================
File: crates/fixt/README.md
================================================
# Fixturator

Convenient creation for test fixtures.



================================================
File: crates/fixt/Cargo.toml
================================================
[package]
name = "fixt"
version = "0.5.0-dev.1"
description = "minimum viable fixtures"
license = "Apache-2.0"
homepage = "https://github.com/holochain/holochain"
documentation = "https://docs.rs/fixt"
authors = ["Holochain Core Dev Team <devcore@holochain.org>"]
keywords = ["holochain", "holo", "test", "fixture"]
categories = ["development-tools::testing"]
edition = "2021"

# reminder - do not use workspace deps
[dependencies]
holochain_serialized_bytes = "=0.0.55"
lazy_static = "1.4"
parking_lot = "0.12"
paste = "1.0.12"
rand = "0.8.5"
rand_core = "0.6"
serde = { version = "1.0", features = ["derive"] }
strum = "0.18.0"
strum_macros = "0.18.0"

[lints]
workspace = true

[features]
fixt = []



================================================
File: crates/fixt/CHANGELOG.md
================================================
---
default_semver_increment_mode: !pre_minor dev
---
# Changelog

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/). This project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased](https://github.com/holochain/holochain/compare/fixt-v0.0.2-alpha.1...HEAD)

## 0.5.0-dev.1

- Prevent “TODO” comments from being rendered in cargo docs.

## 0.5.0-dev.0

## 0.4.0

## 0.4.0-dev.4

## 0.4.0-dev.3

## 0.4.0-dev.2

## 0.4.0-dev.1

## 0.4.0-dev.0

## 0.3.0

## 0.3.0-beta-dev.4

## 0.3.0-beta-dev.3

## 0.3.0-beta-dev.2

## 0.3.0-beta-dev.1

## 0.3.0-beta-dev.0

## 0.2.0

## 0.2.0-beta-rc.0

## 0.1.0

## 0.1.0-beta-rc.1

## 0.1.0-beta-rc.0

## 0.0.14

## 0.0.13

## 0.0.12

## 0.0.11

- Docs: Fix intra-doc links in all crates [\#1323](https://github.com/holochain/holochain/pull/1323)

## 0.0.10

## 0.0.9

## 0.0.8

## 0.0.7

## 0.0.6

## 0.0.5

## 0.0.4

## 0.0.3

### Changed

- Named bytes fixturators like `SixtyFourBytes` are now fixed length arrays

### Added

- Added `SixtyFourBytesVec` to work like the old `Vec<u8>` implementation

## 0.0.2-alpha.1

Initially published release.



================================================
File: crates/fixt/src/bool.rs
================================================
use crate::prelude::*;

fixturator!(bool, false, crate::rng().gen(), {
    let mut index = get_fixt_index!();
    index += 1;
    set_fixt_index!(index);
    index % 2 != 0
});

basic_test!(
    bool,
    vec![false; 40],
    vec![true, false]
        .into_iter()
        .cycle()
        .take(20)
        .collect::<Vec<bool>>()
);



================================================
File: crates/fixt/src/bytes.rs
================================================
use crate::prelude::*;
use rand::Rng;

const UNPREDICTABLE_MIN_LEN: usize = 0;
const UNPREDICTABLE_MAX_LEN: usize = 32;

pub type Bytes = Vec<u8>;
pub type BytesNotEmpty = Vec<u8>;

// Simply generate "bytes" which is a `Vec<u8>`
// likely the most interesting is the Unpredictable curve that throws out random bytes in a vec
// of random length between 0 and 32 bytes long
fixturator!(
    Bytes;
    curve Empty vec![];
    curve Unpredictable {
        let mut rng = crate::rng();
        let len = rng.gen_range(UNPREDICTABLE_MIN_LEN..UNPREDICTABLE_MAX_LEN);
        let mut u8_fixturator = U8Fixturator::new(Unpredictable);
        let mut bytes = vec![];
        for _ in 0..len {
            bytes.push(u8_fixturator.next().unwrap());
        }
        bytes
    };
    curve Predictable {
        let mut index = get_fixt_index!();
        let mut u8_fixturator = U8Fixturator::new_indexed(Predictable, index);
        let mut bytes = vec![];
        for _ in 0..32 {
            bytes.push(u8_fixturator.next().unwrap());
        }
        index += 1;
        set_fixt_index!(index);
        bytes
    };
);

// Simply generate "bytes" which is a `Vec<u8>`
// likely the most interesting is the Unpredictable curve that throws out random bytes in a vec
// of random length between 1 and 32 bytes long
// This version of Bytes is never empty.
fixturator!(
    BytesNotEmpty;
    curve Empty vec![0u8];
    curve Unpredictable {
        let mut rng = crate::rng();
        let len = rng.gen_range(1..UNPREDICTABLE_MAX_LEN);
        let mut u8_fixturator = U8Fixturator::new(Unpredictable);
        let mut bytes = vec![];
        for _ in 0..len {
            bytes.push(u8_fixturator.next().unwrap());
        }
        bytes
    };
    curve Predictable {
        let mut index = get_fixt_index!();
        let mut u8_fixturator = U8Fixturator::new_indexed(Predictable, index);
        let mut bytes = vec![];
        for _ in 0..32 {
            bytes.push(u8_fixturator.next().unwrap());
        }
        index += 1;
        set_fixt_index!(index);
        bytes
    };
);

/// A type alias for a `Vec<u8>` whose fixturator is expected to only return
/// a Vec of length 36
pub type ThirtySixBytes = Vec<u8>;

// Simply generate "bytes" which is a Vec<u8> of 36 bytes
fixturator!(
    ThirtySixBytes;
    curve Empty [0; 36].to_vec();
    curve Unpredictable {
        let mut u8_fixturator = U8Fixturator::new(Unpredictable);
        let mut bytes = vec![];
        for _ in 0..36 {
            bytes.push(u8_fixturator.next().unwrap());
        }
        bytes
    };
    curve Predictable {
        let mut u8_fixturator = U8Fixturator::new_indexed(Predictable, get_fixt_index!());
        let mut bytes = vec![];
        for _ in 0..36 {
            bytes.push(u8_fixturator.next().unwrap());
        }
        bytes
    };
);

/// A type alias for a `Vec<u8>` whose fixturator is expected to only return
/// a Vec of length 32
pub type ThirtyTwoBytes = [u8; 32];

// Simply generate "bytes" which is a Vec<u8> of 32 bytes
fixturator!(
    ThirtyTwoBytes;
    curve Empty [0; 32];
    curve Unpredictable {
        rand::thread_rng().gen::<[u8; 32]>()
    };
    curve Predictable {
        let mut u8_fixturator = U8Fixturator::new_indexed(Predictable, get_fixt_index!());
        let mut bytes = vec![];
        for _ in 0..32 {
            bytes.push(u8_fixturator.next().unwrap());
        }
        let mut ret = [0; 32];
        ret.copy_from_slice(&bytes);
        ret
    };
);

/// A type alias for a `Vec<u8>` whose fixturator is expected to only return
/// a Vec of length 64
pub type SixtyFourBytes = [u8; 64];

// Simply generate "bytes" which is a `Vec<u8>` of 32 bytes
fixturator!(
    SixtyFourBytes;
    curve Empty [0; 64];
    curve Unpredictable {
        let bytes: Vec<u8> = (0..64).map(|_| rand::random::<u8>()).collect();
        let mut ret = [0; 64];
        ret.copy_from_slice(&bytes);
        ret
    };
    curve Predictable {
        let mut u8_fixturator = U8Fixturator::new_indexed(Predictable, get_fixt_index!());
        let mut bytes = vec![];
        for _ in 0..64 {
            bytes.push(u8_fixturator.next().unwrap());
        }
        let mut ret = [0; 64];
        ret.copy_from_slice(&bytes);
        ret
    };
);

pub type SixtyFourBytesVec = Vec<u8>;

fixturator!(
    SixtyFourBytesVec;
    curve Empty [0; 64].to_vec();
    curve Unpredictable {
        SixtyFourBytesFixturator::new_indexed(Unpredictable, get_fixt_index!()).next().unwrap().to_vec()
    };
    curve Predictable {
        SixtyFourBytesFixturator::new_indexed(Predictable, get_fixt_index!()).next().unwrap().to_vec()
    };
);



================================================
File: crates/fixt/src/lib.rs
================================================
#![allow(clippy::assign_op_pattern)]

pub mod bool;
pub mod bytes;
pub mod number;
pub mod prelude;
#[deny(missing_docs)]
mod rng;
pub mod serialized_bytes;
pub mod string;
pub mod unit;
pub use paste;

pub use rng::rng;

/// the Fixturator is the struct that we wrap in our FooFixturator newtypes to impl Iterator over
/// each combination of Item and Curve needs its own Iterator implementation for Fixturator
/// Item is the Foo type of FooFixturator, i.e. the type of thing we are generating examples of
/// Curve represents some algorithm capable of generating fixtures
/// the Item is PhantomData because it simply represents a type to output
/// the Curve must be provided when the Fixturator is constructed to allow for paramaterized curves
/// this is most easily handled in most cases with the fixturator! and newtype_fixturator! macros
///
/// The inner index is always a single usize.
/// It can be ignored, e.g. in the case of Unpredictable implementations based on `rand::random()`.
/// If it is used it should be incremented by 1 and/or wrapped back to 0 to derive returned values.
/// Ideally the Curve should allow for efficient calculation of a fixture from any given index,
/// e.g. a fibbonacci curve would be a bad idea as it requires sequential/recursive calculations to
/// reach any specific index, c.f. the direct multiplication in the step function above.
/// Following this standard allows for wrapper structs to delegate their curves to the curves of
/// their inner types by constructing an inner Fixturator directly with the outer index passed in.
/// If we can always assume the inner fixturators can be efficiently constructed at any index this
/// allows us to efficiently compose fixturators.
/// See [ `newtype_fixturator!` ](newtype_fixturator) macro defined below for an example of this.
///
/// Fixturator implements Clone for convenience but note that this will clone the current index.
///
/// Fixturators are lazy and infinite, they must never fail to iterate
/// That is to say, calling fixturator.next().unwrap() must be safe to do and never panic
/// This makes the external interface as easy to compose as possible when building up Fixturators
/// over complex data types that include different curves with various periods.
/// For example, the Predictable bool sequence cycles between true/false with period of 2 while the
/// Predictable string sequence has 10 sample strings that it iterates over. We want to be able to
/// easily support Fixturators over structs containing both string and bool fields, so we wrap the
/// inner Fixturator sequences to keep producing bools and Strings for as needed (rather than
/// forcing the outer struct to stop after 2 bools or manually implement ad-hoc wrapping).
/// Wrapping logic may be subtle, e.g. mapping between a usize index and a u8 Item where the max
/// values do not align, so it is best to centralise the wrapping behaviour inside the Iterator
/// implementations for each <Item, Curve> combination.
/// If you are implementing an iteration over some finite sequence then wrap the iteration back to
/// the start of the sequence once the index exceeds the sequence's bounds or reset the index to 0
/// after seq.len() iterations.
/// essentially, the iteration of a fixturator should work like some_iter.cycle()
pub struct Fixturator<Item, Curve> {
    item: std::marker::PhantomData<Item>,
    pub curve: Curve,
    pub index: usize,
}

impl<Curve, Item> Fixturator<Item, Curve> {
    /// constructs a Fixturator of type <Item, Curve> from a Curve and starting index
    /// raw calls are a little verbose, e.g. `Fixturator::<u32, Predictable>::new(Predictable, 0)`
    /// the starting index is exposed to facilitate wrapper structs to delegate their indexes to
    /// internal Fixturators
    /// See [`newtype_fixturator!`](newtype_fixturator) macro below for an example of this
    pub fn new(curve: Curve, start: usize) -> Self {
        Fixturator::<Item, Curve> {
            curve,
            index: start,
            item: std::marker::PhantomData,
        }
    }
}

// /// set of basic tests that can be used to test any FooFixturator implementation
// /// usage:
// /// - type: the Foo of FooFixturator to be tested
// /// - empty_expected: vector of any length of empties that we predict from Empty
// /// - predictable_expected: vector of any length (can wrap) that we predict from Predictable
// /// - test_unpredictable (optional): whether to try and test the unpredictable case
// /// See the tests in modules in this crate
#[macro_export]
macro_rules! basic_test {
    ( $type:ty, $empty_expected:expr, $predictable_expected:expr ) => {
        basic_test!($type, $empty_expected, $predictable_expected, true);
    };
    ( $type:ty, $empty_expected:expr, $predictable_expected:expr, $test_unpredictable:literal ) => {
        $crate::prelude::paste! {
            #[test]
            #[cfg(test)]
            fn [<$type:lower _empty>] () {
                let empties = [<$type:camel Fixturator>]::new(Empty);
                // we can make many empties from the Empty curve
                assert_eq!(
                    $empty_expected,
                    empties.take($empty_expected.len()).collect::<Vec<$type>>(),
                );
            }
        }

        $crate::prelude::paste! {
            #[test]
            #[cfg(test)]
            fn [<$type:lower _predictable>] () {
                let predictables = [<$type:camel Fixturator>]::new($crate::prelude::Predictable);
                // we can predict some vector of values from the Predictable curve
                assert_eq!(
                    $predictable_expected,
                    predictables.take($predictable_expected.len()).collect::<Vec<$type>>(),
                );
            }
        }

        $crate::prelude::paste! {
            #[test]
            #[cfg(test)]
            fn [<$type:lower _unpredictable>] () {
                if $test_unpredictable {
                    let empties = [<$type:camel Fixturator>]::new(Empty);
                    let unpredictables = [<$type:camel Fixturator>]::new($crate::prelude::Unpredictable);

                    // the Unpredictable curve is not Empty
                    assert_ne!(
                        empties.take(100).collect::<Vec<$type>>(),
                        unpredictables.take(100).collect::<Vec<$type>>(),
                    );

                    let predictables = [<$type:camel Fixturator>]::new($crate::prelude::Predictable);
                    let unpredictables = [<$type:camel Fixturator>]::new($crate::prelude::Unpredictable);

                    // the Unpredictable curve is not Predictable
                    assert_ne!(
                        predictables.take(100).collect::<Vec<$type>>(),
                        unpredictables.take(100).collect::<Vec<$type>>(),
                    );
                }
            }
        }
    };
}

/// implements a FooFixturator for any type Foo
/// this simply wraps `Fixturator<Foo, Curve>` up as `FooFixturator<Curve>`
///
/// this macro serves a few purposes:
/// - we avoid the orphan rule that would prevent us implementing Iterator on Fixturator directly
/// - we avoid the verbosity of type and impl juggling around every new FooFixturator
/// - we create a FooFixturator implementation that is compatible with basic_test! macro
/// - we cover all three basic curves
/// - we standardiize the new() and new_indexed() methods without relying on traits
///
/// the expressions passed into the macro are the body of the next calls for Empty, Unpredictable
/// and Predictable, in order
#[macro_export]
macro_rules! fixturator {
    (
        with_vec $min:literal $max:literal;
        $type:tt;
        $($munch:tt)*
    ) => {
        $crate::prelude::paste! {
            pub type [<$type:camel Vec>] = Vec<$type>;
            fixturator!(
                [<$type:camel Vec>];
                curve Empty vec![];
                curve Unpredictable {
                    let mut index = get_fixt_index!();
                    let mut rng = $crate::rng();
                    let len = rng.gen_range($min..$max);
                    let mut fixturator = [<$type:camel Fixturator>]::new_indexed($crate::prelude::Unpredictable, index);
                    let mut v = vec![];
                    for _ in 0..len {
                        v.push(fixturator.next().unwrap());
                    }
                    index += 1;
                    set_fixt_index!(index);
                    v
                };
                curve Predictable {
                    let mut index = get_fixt_index!();
                    let mut fixturator = [<$type:camel Fixturator>]::new_indexed($crate::prelude::Predictable, index);
                    let mut v = vec![];
                    let min = $min;
                    let max = (index % ($max - min)) + min;
                    for _ in min..max {
                        v.push(fixturator.next().unwrap());
                    }
                    index += 1;
                    set_fixt_index!(index);
                    v
                };
            );
        }
        fixturator!($type; $($munch)*);
    };

    // for an enum Foo with variants with a single inner type
    //
    // fixturator!(Foo; variants [ A(String) B(bool) ];);
    //
    // implements all basic curves using fixturators for the variant inner types
    (
        $type:tt;
        variants [ $( $variant:tt($variant_inner:ty) )* ];
        $($munch:tt)*
    ) => {

        fixturator!(
            $type;
            enum [ $( $variant )* ];

            curve Empty $crate::prelude::paste! { match [<$type:camel Variant>]::random() {
                $(
                    [<$type:camel Variant>]::$variant => $type::$variant(
                        [<$variant_inner:camel Fixturator>]::new_indexed($crate::prelude::Empty, get_fixt_index!()).next().unwrap().into()
                    ),
                )*
            }};

            curve Unpredictable $crate::prelude::paste! { match [<$type:camel Variant>]::random() {
                $(
                    [<$type:camel Variant>]::$variant => $type::$variant(
                        [<$variant_inner:camel Fixturator>]::new_indexed($crate::prelude::Unpredictable, get_fixt_index!()).next().unwrap().into()
                    ),
                )*
            }};

            curve Predictable $crate::prelude::paste! { match [<$type:camel Variant>]::nth(get_fixt_index!()) {
                $(
                    [<$type:camel Variant>]::$variant => $type::$variant(
                        [<$variant_inner:camel Fixturator>]::new_indexed($crate::prelude::Predictable, get_fixt_index!()).next().unwrap().into()
                    ),
                )*
            }};

            $($munch)*
        );
    };

    // for an enum Foo with unit variants with no inner types
    //
    // fixturator!(Foo; unit variants [ A B ] empty B;);
    //
    // implements all basic curves returning the empty curve passed to the macro, or a random
    // variant or an iterating variant from the index
    (
        $type:tt;
        unit variants [ $( $variant:tt )* ] empty $empty:tt;
        $($munch:tt)*
    ) => {
        fixturator!(
            $type;
            enum [ $( $variant )* ];
            curve Empty {
                $crate::prelude::paste! { $type::$empty }
            };
            curve Unpredictable $crate::prelude::paste! { match [<$type:camel Variant>]::random() {
                $(
                        [<$type:camel Variant>]::$variant => $type::$variant,
                )*
            }};
            curve Predictable $crate::prelude::paste! {{
                match [<$type:camel Variant>]::nth(get_fixt_index!()) {
                $(
                    [<$type:camel Variant>]::$variant => $type::$variant,
                )*
            }}};
            $($munch)*
        );
    };

    // for any complex enum
    //
    // fixturator!(Foo; enum [ A B ]; curve ...; curve ...; curve ...;);
    //
    // implements an enum with variants matching Foo as FooVariant
    // this enum can be iterated over as per the strum crate EnumIter
    //
    // it also has convenience methods to match against:
    //
    // - FooVariant::random() for a random variant of Foo
    // - FooVariant::nth(n) for an indexed variant of Foo
    //
    // See the tests in this file for examples.
        (
            $type:tt;
            enum [ $( $variant:tt )* ];
            $($munch:tt)*
        ) => {
            $crate::prelude::paste! {
                #[derive($crate::prelude::strum_macros::EnumIter)]
                enum [<$type:camel Variant>] {
                    $( $variant ),*
                }

                impl [<$type:camel Variant>] {
                    fn random() -> Self {
                        [<$type:camel Variant>]::iter().choose(&mut $crate::rng()).unwrap()
                    }
                    fn nth(index: usize) -> Self {
                        $crate::prelude::paste! {
                            [<$type:camel Variant>]::iter().cycle().nth(index).unwrap()
                        }
                    }
                }
            }

            fixturator!($type; $($munch)* );
    };

    // for any Foo that impl From<Bar>
    //
    // fixturator!(Foo; from Bar;);
    //
    // implements all the curves by building Foo from a BarFixturator
    ( $type:ident; from $from:ty; $($munch:tt)* ) => {
        fixturator!(
            $type;

            curve Empty {
                $type::from(
                    $crate::prelude::paste! {
                        [< $from:camel Fixturator >]::new_indexed($crate::prelude::Empty, get_fixt_index!()).next().unwrap()
                    }
                )
            };
            curve Unpredictable {
                $type::from(
                    $crate::prelude::paste! {
                        [< $from:camel Fixturator >]::new_indexed($crate::prelude::Unpredictable, get_fixt_index!()).next().unwrap()
                    }
                )
            };
            curve Predictable {
                $type::from(
                    $crate::prelude::paste! {
                        [< $from:camel Fixturator >]::new_indexed($crate::prelude::Predictable, get_fixt_index!()).next().unwrap()
                    }
                )
            };
        );
    };

    // for any Foo that has a constructor function like Foo::new( ... )
    //
    // fixturator!(Foo; constructor fn new(String, String, bool););
    //
    // implements all curves by building all the arguments to the named constructor function from
    // the fixturators of the types specified to the macro
    ( $type:ident; constructor fn $fn:tt( $( $newtype:ty ),* ); $($munch:tt)* ) => {
        fixturator!(
            $type;

            curve Empty {
                let index = get_fixt_index!();
                $type::$fn(
                    $(
                        $crate::prelude::paste! {
                            [< $newtype:camel Fixturator >]::new_indexed($crate::prelude::Empty, index).next().unwrap().into()
                        }
                    ),*
                )
            };

            curve Unpredictable {
                let index = get_fixt_index!();
                $type::$fn(
                    $(
                        $crate::prelude::paste! {
                            [< $newtype:camel Fixturator >]::new_indexed($crate::prelude::Unpredictable, index).next().unwrap().into()
                        }
                    ),*
                )
            };
            curve Predictable {
                let index = get_fixt_index!();
                $type::$fn(
                    $(
                        $crate::prelude::paste! {
                            [< $newtype:camel Fixturator >]::new_indexed($crate::prelude::Predictable, index).next().unwrap().into()
                        }
                    ),*
                )
            };

            $($munch)*
        );
    };

    // for any Foo that has a vanilla function like fn make_foo( ... ) -> Foo
    //
    // fixturator!(Foo; vanilla fn make_foo(String, String, bool););
    //
    // implements all curves by building all the arguments to the named vanilla function from
    // the fixturators of the types specified to the macro
    ( $type:ident; vanilla fn $fn:tt( $( $newtype:ty ),* ); $($munch:tt)* ) => {
        fixturator!(
            $type;

            curve Empty {
                $fn(
                    $(
                        $crate::prelude::paste! {
                            [< $newtype:camel Fixturator >]::new_indexed($crate::prelude::Empty, get_fixt_index!()).next().unwrap().into()
                        }
                    ),*
                )
            };

            curve Unpredictable {
                $fn(
                    $(
                        $crate::prelude::paste! {
                            [< $newtype:camel Fixturator >]::new_indexed($crate::prelude::Unpredictable, get_fixt_index!()).next().unwrap().into()
                        }
                    ),*
                )
            };
            curve Predictable {
                $fn(
                    $(
                        $crate::prelude::paste! {
                            [< $newtype:camel Fixturator >]::new_indexed($crate::prelude::Predictable, get_fixt_index!()).next().unwrap().into()
                        }
                    ),*
                )
            };

            $($munch)*
        );
    };

    // implement a single curve for Foo
    //
    // fixturator!(Foo; curve MyCurve { ... };);
    //
    // uses TT munching for multiple curves
    // used internally by this macro for all baseline curves
    // See https://danielkeep.github.io/tlborm/book/pat-incremental-tt-munchers.html
    ( $type:ident; curve $curve:ident $e:expr; $($munch:tt)* ) => {
        curve!( $type, $curve, $e);

        fixturator!( $type; $($munch)* );
    };

    // create a FooFixturator for Foo
    //
    // fixturator!(Foo;);
    //
    // simply creates a newtype around the standard Fixturator struct and implements two methods:
    // - FooFixturator::new(curve) to construct a FooFixturator with curve at index 0
    // - FooFixturator::new(curve, index) to construct a FooFixturator with curve at index
    //
    // intended to be the TT munch endpoint for all patterns in this macro
    // See https://danielkeep.github.io/tlborm/book/pat-incremental-tt-munchers.html
    ( $type:ident; $($munch:tt)* ) => {
        $crate::prelude::paste! {
            #[allow(missing_docs)]
            pub struct [<$type:camel Fixturator>]<Curve>(Fixturator<$type, Curve>);

            #[allow(missing_docs)]
            impl <Curve>[<$type:camel Fixturator>]<Curve> {
                pub fn new(curve: Curve) -> [<$type:camel Fixturator>]<Curve> {
                    Self::new_indexed(curve, 0)
                }
                pub fn new_indexed(curve: Curve, start: usize) -> [<$type:camel Fixturator>]<Curve> {
                    [<$type:camel Fixturator>](Fixturator::<$type, Curve>::new(curve, start))
                }
            }
        }
    };

    // legacy syntax
    //
    // fixturator!(Foo, { /* empty */ }, { /* unpredictable */ }, { /* predictable */ });
    //
    // implements both FooFixturator and all the curves from raw expressions passed to the macro
    //
    // this syntax has several limitations:
    // - positional curve definitions are easy to accidentally mix up
    // - couples all curve definitions together and to FooFixturator creation
    // - undifferentiated logic forces much boilerplate because the macro knows nothing about Foo
    // - forces devs to define curves that might not be needed or make sense yet
    ( $type:ident, $empty:expr, $unpredictable:expr, $predictable:expr ) => {
        fixturator!(
            $type;
            curve Empty $empty;
            curve Unpredictable $unpredictable;
            curve Predictable $predictable;
        );
    };
}

#[macro_export]
macro_rules! get_fixt_index {
    () => {{
        let mut index = 0;
        FIXT_INDEX.with(|f| index = *f.borrow());
        index
    }};
}

#[macro_export]
macro_rules! set_fixt_index {
    ($index:expr) => {{
        FIXT_INDEX.with(|f| *f.borrow_mut() = $index);
    }};
}

#[macro_export]
macro_rules! get_fixt_curve {
    () => {{
        let mut curve = None;
        FIXT_CURVE.with(|f| curve = f.borrow().clone());
        curve.unwrap()
    }};
}

#[macro_export]
/// implement Iterator for a FooFixturator for a given curve
///
/// curve!(Foo, Unpredictable, /* make an Unpredictable Foo here */ );
///
/// simple wrapper around the standard Iterator trait from rust
/// the expression in the third parameter to curve! is just the body of .next() without the need or
/// ability to return an Option - i.e. return a value of type Foo _not_ `Option<Foo>`
/// if the body of the expression changes the index it will be respected, if not then it will be
/// incremented by 1 automatically by the macro
macro_rules! curve {
    ( $type:ident, $curve:ident, $e:expr ) => {
        $crate::prelude::paste! {
            #[allow(missing_docs)]
            impl Iterator for [< $type:camel Fixturator >]<$curve> {
                type Item = $type;

                fn next(&mut self) -> Option<Self::Item> {
                    thread_local!(static FIXT_INDEX: std::cell::RefCell<usize> = std::cell::RefCell::new(0));
                    thread_local!(static FIXT_CURVE: std::cell::RefCell<Option<$curve>> = std::cell::RefCell::new(None));
                    FIXT_INDEX.with(|f| *f.borrow_mut() = self.0.index);
                    FIXT_CURVE.with(|f| *f.borrow_mut() = Some(self.0.curve.clone()));
                    let original_index = self.0.index;
                    let ret = $e;
                    FIXT_INDEX.with(|f| self.0.index = *f.borrow());
                    if original_index == self.0.index {
                        self.0.index += 1;
                    }
                    Some(ret)
                }
            }
        }
    };
}

#[macro_export]
/// tiny convenience macro to make it easy to get the first Foo from its fixturator without using
/// the iterator interface to save a little typing
/// c.f. fixt!(Foo) vs. FooFixturator::new(Unpredictable).next().unwrap();
macro_rules! fixt {
    ( $name:tt ) => {
        $crate::fixt!($name, $crate::prelude::Unpredictable)
    };
    ( $name:tt, $curve:expr ) => {
        $crate::fixt!($name, $curve, 0)
    };
    ( $name:tt, $curve:expr, $index:expr ) => {
        $crate::prelude::paste! { [< $name:camel Fixturator>]::new_indexed($curve, $index).next().unwrap() }
    }
}

/// represents an unpredictable curve
///
/// unpredictable curves seek to:
/// - disrupt 'just so' implementations of algorithms that lean too heavily on fragile assumptions
/// - have a high probability of generating common edge cases that developers fail to cover
///
/// A classic example is broken/forgotten NaN handling in code that uses floats for calculations
///
/// in general this is what we want from our tests, to remind us of where we are _wrong_ about our
/// assumptions in our code.
/// it is likely that you want to use the Unpredictable curve as the defacto choice for testing.
///
/// however, note that unpredictable curves are NOT intended:
/// - to comprehensively cover any particular value space
/// - to replace property/fuzz testing
/// - to algorithmically explore edge-cases in an automated fashion
/// - to assert any particular security or correctness concern
///
/// unpredictable curves are a great way to knock off some low hanging fruit, especially around
/// numeric calculations and utf-8 handling, but are no replacement for stringent approaches.
#[derive(Clone, Copy)]
pub struct Unpredictable;

/// represents a predictable curve
///
/// a predictable curve simply iterates over some known progression of values in the same way every
/// test run.
///
/// predictable curves can be convenient, or even necessary, if an unpredictable curve breaks our
/// ability to make specific assertions about our code.
///
/// for example, we may want to demonstrate that additon works.
/// with an unpredictable curve we can assert things like the arguments being commutative,
/// associative, additive, etc. but then we quickly end up doing a bad version of property testing.
/// better to assert known expected results of addition from various values from a predictable
/// curve and then subject the addition function to real property testing with a dedicated tool.
///
/// this curve is provided as a standard option because there is a real, common tradeoff between
/// test fragility (accuracy) and specificity (precision).
#[derive(Clone, Copy)]
pub struct Predictable;

/// represents a curve over the empty value(s)
/// the concept of "empty" is as slippery as it is of dubious value
/// how many countless hours and bugs have we lost over deciding what "is" and what "isn't"?
/// i'm looking at you, JS and PHP -_-
///
/// regardless, collections with no items, numbers with no magnitude, strings with no chars are all
/// common sources of bugs, so feel free to manifest as much emptiness as you like from this curve.
#[derive(Clone, Copy)]
pub struct Empty;

#[macro_export]
/// a direct delegation of fixtures to the inner type for new types
macro_rules! newtype_fixturator {
    ( $outer:ident<Vec<$inner:ty>> ) => {
        fixturator!(
            $outer,
            $outer(vec![]),
            {
                let mut rng = $crate::rng();
                let vec_len = rng.gen_range(0..5);
                let mut ret = vec![];
                let mut inner_fixturator =
                    $crate::prelude::paste! { [<$inner:camel Fixturator>]::new_indexed($crate::prelude::Unpredictable, get_fixt_index!()) };
                for _ in 0..vec_len {
                    ret.push(inner_fixturator.next().unwrap());
                }
                set_fixt_index!(get_fixt_index!() + 1);
                $outer(ret)
            },
            {
                let mut rng = $crate::rng();
                let vec_len = rng.gen_range(0..5);
                let mut ret = vec![];
                let mut inner_fixturator =
                    $crate::prelude::paste! { [<$inner:camel Fixturator>]::new_indexed($crate::prelude::Predictable, get_fixt_index!()) };
                for _ in 0..vec_len {
                    ret.push(inner_fixturator.next().unwrap());
                }
                set_fixt_index!(get_fixt_index!() + 1);
                $outer(ret)
            }
        );
    };
    ( $outer:ident<$inner:ty> ) => {
        fixturator!(
            $outer,
            {
                let mut index = get_fixt_index!();
                let mut fixturator =
                    $crate::prelude::paste! { [<$inner:camel Fixturator>]::new_indexed($crate::prelude::Empty, index) };
                index += 1;
                set_fixt_index!(index);
                $outer(fixturator.next().unwrap())
            },
            {
                let mut index = get_fixt_index!();
                let mut fixturator =
                    $crate::prelude::paste! { [<$inner:camel Fixturator>]::new_indexed($crate::prelude::Unpredictable, index) };
                index += 1;
                set_fixt_index!(index);
                $outer(fixturator.next().unwrap())
            },
            {
                let mut index = get_fixt_index!();
                let mut fixturator =
                    $crate::prelude::paste! { [<$inner:camel Fixturator>]::new_indexed($crate::prelude::Predictable, index) };
                index += 1;
                set_fixt_index!(index);
                $outer(fixturator.next().unwrap())
            }
        );
    };
}

#[macro_export]
/// a direct delegation of fixtures to the inner type for wasm io types
/// See zome types crate
macro_rules! wasm_io_fixturator {
    ( $outer:ident<$inner:ty> ) => {
        fixturator!(
            $outer,
            {
                let mut fixturator =
                    $crate::prelude::paste! { [<$inner:camel Fixturator>]::new_indexed($crate::prelude::Empty, get_fixt_index!()) };
                set_fixt_index!(get_fixt_index!() + 1);
                $outer::new(fixturator.next().unwrap())
            },
            {
                let mut fixturator =
                    $crate::prelude::paste! { [<$inner:camel Fixturator>]::new_indexed($crate::prelude::Unpredictable, get_fixt_index!()) };
                set_fixt_index!(get_fixt_index!() + 1);
                $outer::new(fixturator.next().unwrap())
            },
            {
                let mut fixturator =
                    $crate::prelude::paste! { [<$inner:camel Fixturator>]::new_indexed($crate::prelude::Predictable, get_fixt_index!()) };
                set_fixt_index!(get_fixt_index!() + 1);
                $outer::new(fixturator.next().unwrap())
            }
        );
    };
}

#[macro_export]
/// Creates a simple way to generate enums that use the strum way of iterating
/// <https://docs.rs/strum/0.18.0/strum/>
/// iterates over all the variants (Predictable) or selects random variants (Unpredictable)
/// You do still need to BYO "empty" variant as the macro doesn't know what to use there
macro_rules! enum_fixturator {
    ( $enum:ident, $empty:expr ) => {
        use rand::seq::IteratorRandom;
        use $crate::prelude::IntoEnumIterator;
        fixturator!(
            $enum,
            $empty,
            { $enum::iter().choose(&mut $crate::rng()).unwrap() },
            {
                let ret = $enum::iter().cycle().nth(self.0.index).unwrap();
                set_fixt_index!(get_fixt_index!() + 1);
                ret
            }
        );
    };
}

#[cfg(test)]
mod tests {
    use crate::prelude::*;
    use crate::string::PREDICTABLE_STRS;

    // in general enums can have a mix of whatever in their variants
    #[derive(PartialEq, Debug)]
    pub enum Foo {
        A,
        B(String),
    }

    fixturator!(
        Foo;
        enum [ A B ];
        curve Empty Foo::A;
        curve Unpredictable match FooVariant::random() {
            FooVariant::A => Foo::A,
            FooVariant::B => Foo::B(fixt!(String)),
        };
        curve Predictable match FooVariant::nth(get_fixt_index!()) {
            FooVariant::A => Foo::A,
            FooVariant::B => Foo::B(StringFixturator::new_indexed(Predictable, get_fixt_index!()).next().unwrap()),
        };
    );

    #[test]
    fn enum_test() {
        assert_eq!(FooFixturator::new(Predictable).next().unwrap(), Foo::A,);

        FooFixturator::new(Unpredictable).next().unwrap();

        assert_eq!(FooFixturator::new(Empty).next().unwrap(), Foo::A,);

        let mut fixt_iter = FooFixturator::new(Predictable);
        assert_eq!(fixt_iter.next().unwrap(), Foo::A);
        let string = StringFixturator::new_indexed(Predictable, 1)
            .next()
            .unwrap();
        assert_eq!(fixt_iter.next().unwrap(), Foo::B(string));
    }

    #[derive(PartialEq, Debug)]
    pub enum UnitFoo {
        A,
        B,
        C,
    }

    fixturator!(
        UnitFoo;
        unit variants [ A B C ] empty B;
    );

    #[test]
    fn unit_variants_test() {
        assert_eq!(
            UnitFooFixturator::new(Predictable).next().unwrap(),
            UnitFoo::A,
        );

        // smoke test Unpredictable
        UnitFooFixturator::new(Unpredictable).next().unwrap();

        assert_eq!(UnitFooFixturator::new(Empty).next().unwrap(), UnitFoo::B,);
    }

    #[derive(PartialEq, Debug, Clone)]
    pub enum VariantFoo {
        A(String),
        B(usize),
        C(bool),
    }

    fixturator!(
        VariantFoo;
        variants [ A(String) B(usize) C(bool) ];
    );

    #[test]
    fn variant_variants_test() {
        let mut predictable_fixturator = VariantFooFixturator::new(Predictable);
        for expected in [
            VariantFoo::A("💯".into()),
            VariantFoo::B(1),
            VariantFoo::C(true),
            VariantFoo::A(".".into()),
            VariantFoo::B(4),
            VariantFoo::C(false),
        ]
        .iter()
        {
            assert_eq!(expected.to_owned(), predictable_fixturator.next().unwrap(),);
        }

        let mut unpredictable_fixturator = VariantFooFixturator::new(Unpredictable);
        for _ in 0..10 {
            // smoke test
            unpredictable_fixturator.next().unwrap();
        }

        let mut empty_fixturator = VariantFooFixturator::new(Empty);
        for _ in 0..10 {
            match empty_fixturator.next().unwrap() {
                VariantFoo::A(s) => assert_eq!(s, ""),
                VariantFoo::B(n) => assert_eq!(n, 0),
                VariantFoo::C(b) => assert!(!b),
            }
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct StringFoo(String);

    impl From<String> for StringFoo {
        fn from(s: String) -> Self {
            Self(s)
        }
    }

    fixturator!(StringFoo; from String;);

    #[test]
    fn from_test() {
        let mut predictable_fixturator = StringFooFixturator::new(Predictable);
        for expected in PREDICTABLE_STRS.iter() {
            assert_eq!(
                StringFoo::from(expected.to_string()),
                predictable_fixturator.next().unwrap()
            );
        }

        let mut unpredictable_fixturator = StringFooFixturator::new(Unpredictable);
        for _ in 0..10 {
            // smoke test
            unpredictable_fixturator.next().unwrap();
        }

        let mut empty_fixturator = StringFooFixturator::new(Empty);
        for _ in 0..10 {
            assert_eq!(
                StringFoo::from("".to_string()),
                empty_fixturator.next().unwrap(),
            );
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct ConstructedFoo {
        bar: bool,
    }

    impl ConstructedFoo {
        fn from_bar(bar: bool) -> Self {
            Self { bar }
        }
    }

    fixturator!(
        ConstructedFoo;
        constructor fn from_bar(bool);
    );

    #[test]
    fn constructor_test() {
        let mut predictable_fixturator = ConstructedFooFixturator::new(Predictable);
        for expected in [true, false].iter().cycle().take(5) {
            assert_eq!(
                ConstructedFoo::from_bar(*expected),
                predictable_fixturator.next().unwrap(),
            );
        }

        let mut unpredictable_fixturator = ConstructedFooFixturator::new(Unpredictable);
        for _ in 0..10 {
            // smoke test
            unpredictable_fixturator.next().unwrap();
        }

        let mut empty_fixturator = ConstructedFooFixturator::new(Empty);
        for _ in 0..10 {
            assert_eq!(
                ConstructedFoo::from_bar(false),
                empty_fixturator.next().unwrap(),
            );
        }
    }
}



================================================
File: crates/fixt/src/number.rs
================================================
use crate::prelude::*;
use rand::seq::SliceRandom;

macro_rules! fixturator_unsigned {
    ( $t:ident ) => {
        fixturator!(
            $t,
            0,
            {
                let mut rng = crate::rng();
                if rng.gen() {
                    rng.gen()
                } else {
                    vec![<$t>::MAX, <$t>::MIN, 1]
                        .choose(&mut rng)
                        .unwrap()
                        .to_owned()
                }
            },
            {
                let ret = get_fixt_index!() as $t;
                set_fixt_index!(ret.wrapping_add(1) as usize);
                ret
            }
        );
    };
}

fixturator_unsigned!(u8);
fixturator_unsigned!(u16);
fixturator_unsigned!(u32);
fixturator_unsigned!(u64);
fixturator_unsigned!(u128);
fixturator_unsigned!(usize);

// we can exhaustively enumerate u8 wrapping, which should give us confidence in the u16 behaviour
// given that it uses the same macro
basic_test!(
    u8,
    vec![0; 40],
    (0_u8..=255_u8).cycle().take(1000).collect::<Vec<u8>>()
);
basic_test!(u16, vec![0; 40], (0..1000).collect::<Vec<u16>>());
basic_test!(u32, vec![0; 40], (0..1000).collect::<Vec<u32>>());
basic_test!(u64, vec![0; 40], (0..1000).collect::<Vec<u64>>());
basic_test!(u128, vec![0; 40], (0..1000).collect::<Vec<u128>>());
basic_test!(usize, vec![0; 40], (0..1000).collect::<Vec<usize>>());

macro_rules! fixturator_signed {
    ( $t:ident ) => {
        fixturator!(
            $t,
            0,
            {
                let mut rng = crate::rng();
                if rng.gen() {
                    rng.gen()
                } else {
                    vec![<$t>::MAX, <$t>::MIN, 1]
                        .choose(&mut rng)
                        .unwrap()
                        .to_owned()
                }
            },
            {
                let ret = get_fixt_index!() as $t;
                set_fixt_index!(ret.wrapping_add(1) as usize);
                // negate odds
                let ret = if ret % 2 == 0 { ret } else { -ret };
                ret
            }
        );
    };
}

fixturator_signed!(i8);
fixturator_signed!(i16);
fixturator_signed!(i32);
fixturator_signed!(i64);
fixturator_signed!(i128);
fixturator_signed!(isize);

basic_test!(
    i8,
    vec![0; 40],
    (0_i8..=127_i8)
        .map(|i| if i % 2 == 0 { i } else { -i })
        .take(127)
        .collect::<Vec<i8>>()
);
basic_test!(
    i16,
    vec![0; 40],
    (0..1000)
        .map(|i| if i % 2 == 0 { i } else { -i })
        .take(1000)
        .collect::<Vec<i16>>()
);
basic_test!(
    i32,
    vec![0; 40],
    (0..1000)
        .map(|i| if i % 2 == 0 { i } else { -i })
        .take(1000)
        .collect::<Vec<i32>>()
);
basic_test!(
    i64,
    vec![0; 40],
    (0..1000)
        .map(|i| if i % 2 == 0 { i } else { -i })
        .take(1000)
        .collect::<Vec<i64>>()
);
basic_test!(
    i128,
    vec![0; 40],
    (0..1000)
        .map(|i| if i % 2 == 0 { i } else { -i })
        .take(1000)
        .collect::<Vec<i128>>()
);
basic_test!(
    isize,
    vec![0; 40],
    (0..1000)
        .map(|i| if i % 2 == 0 { i } else { -i })
        .take(1000)
        .collect::<Vec<isize>>()
);

macro_rules! fixturator_float {
    ( $t:ident ) => {
        fixturator!(
            $t,
            0.0,
            {
                let mut rng = crate::rng();
                if rng.gen() {
                    rng.gen()
                } else {
                    vec![$t::NEG_INFINITY, $t::INFINITY, $t::NAN, -1.0, 0.0, 1.0]
                        .choose(&mut rng)
                        .unwrap()
                        .to_owned()
                }
            },
            {
                let mut index = get_fixt_index!();
                let ret = index as $t;

                let signed_ret = if index % 2 == 0 { ret } else { -ret - 0.5 };
                index += 1;
                set_fixt_index!(index);
                signed_ret
            }
        );
    };
}

fixturator_float!(f32);
fixturator_float!(f64);

basic_test!(
    f32,
    vec![0.0; 40],
    (0_usize..1000)
        .map(|u| {
            let f = u as f32;
            if u % 2 == 0 {
                f
            } else {
                -f - 0.5
            }
        })
        .take(1000)
        .collect::<Vec<f32>>()
);
basic_test!(
    f64,
    vec![0.0; 40],
    (0_usize..1000)
        .map(|u| {
            let f = u as f64;
            if u % 2 == 0 {
                f
            } else {
                -f - 0.5
            }
        })
        .take(1000)
        .collect::<Vec<f64>>()
);



================================================
File: crates/fixt/src/prelude.rs
================================================
pub use crate::basic_test;
pub use crate::bool::BoolFixturator;
pub use crate::bytes::Bytes;
pub use crate::bytes::BytesFixturator;
pub use crate::bytes::BytesNotEmpty;
pub use crate::bytes::BytesNotEmptyFixturator;
pub use crate::bytes::SixtyFourBytesFixturator;
pub use crate::bytes::SixtyFourBytesVecFixturator;
pub use crate::bytes::ThirtySixBytesFixturator;
pub use crate::bytes::ThirtyTwoBytesFixturator;
pub use crate::curve;
pub use crate::enum_fixturator;
pub use crate::fixt;
pub use crate::fixturator;
pub use crate::get_fixt_curve;
pub use crate::get_fixt_index;
pub use crate::newtype_fixturator;
pub use crate::number::*;
pub use crate::serialized_bytes::SerializedBytesFixturator;
pub use crate::set_fixt_index;
pub use crate::string::CharFixturator;
pub use crate::string::StringFixturator;
pub use crate::unit::UnitFixturator;
pub use crate::wasm_io_fixturator;
pub use crate::Empty;
pub use crate::Fixturator;
pub use crate::Predictable;
pub use crate::Unpredictable;
pub use paste::paste;
pub use rand::prelude::*;
pub use strum::IntoEnumIterator;
pub use strum_macros;



================================================
File: crates/fixt/src/rng.rs
================================================
//! Seedable random number generator to be used in all fixturator randomness
//!
//! In tests, when an unpredictable value causes a test failure, it's important to
//! be able to re-run the test with the same values. This module provides a RNG
//! whose seed will be set automatically and printed to stdout before each test run.
//! To use a previous seed, just set the FIXT_SEED environment variable to the value
//! of a previous run'

use parking_lot::Mutex;
use rand::rngs::StdRng;
use rand::RngCore;
use rand::SeedableRng;
use std::sync::Arc;

lazy_static::lazy_static! {
    /// The singleton global RNG for test randomness
    static ref FIXT_RNG: FixtRng = {
        let seed: u64 = match std::env::var("FIXT_SEED") {
            Ok(seed_str) => {
                seed_str.parse().expect("Expected integer for FIXT_SEED")
            }
            Err(std::env::VarError::NotPresent) => { rand::random() },
            Err(std::env::VarError::NotUnicode(v)) => { panic!("Invalid FIXT_SEED value: {:?}", v) },
        };
        println!("Fixturator seed: {}", seed);
        FixtRng(Arc::new(
            Mutex::new(StdRng::seed_from_u64(seed))
        ))
    };
}

/// A seedable RNG which uses an Arc and a Mutex to allow easy cloneability and thread safety.
/// A singleton global instance is created in this module. See module-level docs for more info.
#[derive(Clone)]
pub struct FixtRng(Arc<Mutex<StdRng>>);

impl RngCore for FixtRng {
    fn next_u32(&mut self) -> u32 {
        self.0.lock().next_u32()
    }

    fn next_u64(&mut self) -> u64 {
        self.0.lock().next_u64()
    }

    fn fill_bytes(&mut self, dest: &mut [u8]) {
        self.0.lock().fill_bytes(dest)
    }

    fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), rand_core::Error> {
        self.0.lock().try_fill_bytes(dest)
    }
}

/// Access the seeded random number generator. This should be used in all places where
/// tests produce random values.
pub fn rng() -> FixtRng {
    FIXT_RNG.clone()
}



================================================
File: crates/fixt/src/serialized_bytes.rs
================================================
// @todo move all this out to the serialized bytes crate
use crate::prelude::*;
use holochain_serialized_bytes::prelude::*;
use rand::seq::SliceRandom;

#[derive(Clone, Copy)]
/// there are many different types of things that we could reasonably serialize in our examples
/// a list of things that we serialize iteratively (Predictable) or randomly (Unpredictable)
pub enum ThingsToSerialize {
    Unit,
    Bool,
    Number,
    String,
}

pub const THINGS_TO_SERIALIZE: [ThingsToSerialize; 4] = [
    ThingsToSerialize::Unit,
    ThingsToSerialize::Bool,
    ThingsToSerialize::Number,
    ThingsToSerialize::String,
];

/// Serialization wrapper for bools
#[derive(serde::Serialize, serde::Deserialize, SerializedBytes, Debug)]
struct BoolWrap(bool);
/// Serialization wrapper for u32 (number)
#[derive(serde::Serialize, serde::Deserialize, SerializedBytes, Debug)]
struct U32Wrap(u32);
/// Serialzation wrapper for Strings
#[derive(serde::Serialize, serde::Deserialize, SerializedBytes, Debug)]
struct StringWrap(String);

fixturator!(
    SerializedBytes,
    { SerializedBytes::try_from(()).unwrap() },
    {
        // randomly select a thing to serialize
        let thing_to_serialize = THINGS_TO_SERIALIZE
            .to_vec()
            .choose(&mut crate::rng())
            .unwrap()
            .to_owned();

        // serialize a thing based on a delegated fixturator
        match thing_to_serialize {
            ThingsToSerialize::Unit =>
            {
                #[allow(clippy::unit_arg)]
                UnitFixturator::new(Unpredictable)
                    .next()
                    .unwrap()
                    .try_into()
                    .unwrap()
            }
            ThingsToSerialize::Bool => BoolWrap(BoolFixturator::new(Unpredictable).next().unwrap())
                .try_into()
                .unwrap(),
            ThingsToSerialize::Number => U32Wrap(U32Fixturator::new(Unpredictable).next().unwrap())
                .try_into()
                .unwrap(),
            ThingsToSerialize::String => {
                StringWrap(StringFixturator::new(Unpredictable).next().unwrap())
                    .try_into()
                    .unwrap()
            }
        }
    },
    {
        let mut index = get_fixt_index!();
        // iteratively select a thing to serialize
        let thing_to_serialize = THINGS_TO_SERIALIZE
            .iter()
            .copied()
            .cycle()
            .nth(index)
            .unwrap();

        // serialize a thing based on a delegated fixturator
        let ret: SerializedBytes = match thing_to_serialize {
            ThingsToSerialize::Unit =>
            {
                #[allow(clippy::unit_arg)]
                UnitFixturator::new_indexed(Predictable, index)
                    .next()
                    .unwrap()
                    .try_into()
                    .unwrap()
            }
            ThingsToSerialize::Bool => BoolWrap(
                BoolFixturator::new_indexed(Predictable, index)
                    .next()
                    .unwrap(),
            )
            .try_into()
            .unwrap(),
            ThingsToSerialize::Number => U32Wrap(
                U32Fixturator::new_indexed(Predictable, index)
                    .next()
                    .unwrap(),
            )
            .try_into()
            .unwrap(),
            ThingsToSerialize::String => StringWrap(
                StringFixturator::new_indexed(Predictable, index)
                    .next()
                    .unwrap(),
            )
            .try_into()
            .unwrap(),
        };

        index += 1;
        set_fixt_index!(index);
        ret
    }
);



================================================
File: crates/fixt/src/string.rs
================================================
use crate::prelude::*;
use rand::Rng;

pub const EMPTY_CHAR: char = '\u{0000}';
pub const PREDICTABLE_CHARS: &str = "💯❤💩.!foobarbaz!.💩❤💯";

fixturator!(char, EMPTY_CHAR, crate::rng().gen(), {
    let mut index = get_fixt_index!();
    let ret = PREDICTABLE_CHARS
        .chars()
        .nth(index % PREDICTABLE_CHARS.chars().count())
        .unwrap();
    index += 1;
    set_fixt_index!(index);
    ret
});

#[cfg(test)]
basic_test!(
    char,
    vec![EMPTY_CHAR; 40],
    PREDICTABLE_CHARS
        .chars()
        .cycle()
        .take(40)
        .collect::<Vec<char>>()
);

pub const EMPTY_STR: &str = "";
pub const PREDICTABLE_STRS: [&str; 10] =
    ["💯", "❤", "💩", ".", "!", "foo", "bar", "baz", "bing", "!"];
pub const UNPREDICTABLE_MIN_LEN: usize = 0;
pub const UNPREDICTABLE_MAX_LEN: usize = 64;

fixturator!(
    String,
    String::from(EMPTY_STR),
    {
        let mut rng = crate::rng();
        let len = rng.gen_range(UNPREDICTABLE_MIN_LEN..UNPREDICTABLE_MAX_LEN);
        let vec: Vec<char> = (0..len).map(|_| rng.gen()).collect();
        let string: String = vec.iter().collect();
        string
    },
    {
        let mut index = get_fixt_index!();
        let ret = PREDICTABLE_STRS
            .iter()
            .cycle()
            .nth(index)
            .unwrap()
            .to_string();
        index += 1;
        set_fixt_index!(index);
        ret
    }
);

#[cfg(test)]
basic_test!(
    String,
    vec![String::from(EMPTY_STR); 40],
    PREDICTABLE_STRS
        .iter()
        .map(|s| s.to_string())
        .cycle()
        .take(40)
        .collect::<Vec<String>>()
);



================================================
File: crates/fixt/src/unit.rs
================================================
use crate::prelude::*;

type Unit = ();
fixturator!(Unit, (), (), ());
basic_test!(Unit, vec![(); 40], vec![(); 40], false);



================================================
File: crates/fixt/test/Cargo.toml
================================================
[package]
name = "fixt_test"
version = "0.0.1"
description = "tests the fixturator macros in an external crate"
license = "Apache-2.0"
homepage = "https://github.com/holochain/holochain"
documentation = "https://docs.rs/fixt_test"
authors = ["Holochain Core Dev Team <devcore@holochain.org>"]
keywords = ["holochain", "holo", "test", "fixture"]
categories = ["fixtures"]
edition = "2021"

# reminder - do not use workspace deps
[dependencies]
fixt = { path = "..", version = "^0.5.0-dev.1"}
paste = "1.0.12"



================================================
File: crates/fixt/test/CHANGELOG.md
================================================
---
default_semver_increment_mode: !pre_minor dev
---
# Changelog

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/). This project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## \[Unreleased\]



================================================
File: crates/fixt/test/src/lib.rs
================================================
/// this is in a separate crate from the fixt crate to show that we've addressed the orphan rule
/// and other issues e.g. pub/private data
use ::fixt::prelude::*;

#[derive(Debug, PartialEq, Clone)]
pub struct MyNewType(bool);

newtype_fixturator!(MyNewType<bool>);
basic_test!(
    MyNewType,
    vec![MyNewType(false); 40],
    vec![MyNewType(true), MyNewType(false)]
        .into_iter()
        .cycle()
        .take(40)
        .collect::<Vec<MyNewType>>()
);



================================================
File: crates/hc/README.md
================================================
# holochain_cli

Provides the `hc` binary, a helpful CLI tool for working with Holochain.

## Docs

This command gives you a suite of tools for developing, inspecting, executing, and testing your Holochain apps. Some top-level subcommands are implemented as separate crates, and others are separate binaries -- commands whose names start with `hc-` and are automatically made available as subcommands if they exist in your shell's path. Here is a list of all available subcommands:

- `hc dna`, `hc app`, and `hc web-app` scaffold, bundle, and unbundle DNAs, hApps and web hApps respectively. See [holochain_cli_bundle](https://github.com/holochain/holochain/tree/develop/crates/hc_bundle) for more info.
- `hc sandbox` creates and executes temporary or persistent conductor configurations for you to run test instances of your hApp with. See [holochain_cli_sandbox](https://github.com/holochain/holochain/tree/develop/crates/hc_sandbox) for more info.
- `hc run-local-services` runs local bootstrap and WebRTC signal servers for peers to establish connections with each other. This is useful for running tests. See [holochain_cli_run_local_services](https://github.com/holochain/holochain/tree/develop/crates/hc_run_local_services) for more info.
- `hc scaffold` generates integrity, coordinator, UI, and test code for hApps using interactive prompts. See [holochain/scaffolding](https://github.com/holochain/scaffolding).
- `hc launch` runs sandboxed hApp instances with live-reloading UI windows. See [hc_launch in holochain/launcher](https://github.com/holochain/launcher/tree/main/crates/hc_launch) for more info.

## Installation

### Quick install

Follow the [quick start guide](https://developer.holochain.org/quick-start/) on the Holochain Developer Portal to get set up with all the Holochain development tools, including the `hc` CLI and official extensions.

### Build from source

#### Requirements

- [Rust](https://rustup.rs/)
- [Holochain](https://github.com/holochain/holochain) binary on the path

#### Building

From github:

```shell
cargo install holochain_cli --git https://github.com/holochain/holochain
```

From the holochain repo:

```shell
cargo install --path crates/hc
```



================================================
File: crates/hc/Cargo.toml
================================================
[package]
name = "holochain_cli"
version = "0.5.0-dev.21"
homepage = "https://github.com/holochain/holochain"
documentation = "https://docs.rs/holochain_cli"
authors = ["Holochain Core Dev Team <devcore@holochain.org>"]
keywords = ["holochain", "holo"]
categories = [
  "command-line-utilities",
  "development-tools::build-utils",
  "filesystem",
]
edition = "2021"
license = "Apache-2.0"
description = "Provides the `hc` binary, a helpful CLI tool for working with Holochain."

[[bin]]
name = "hc"
path = "src/bin/hc.rs"

[lib]
name = "holochain_cli"
path = "src/lib.rs"

# reminder - do not use workspace deps
[dependencies]
anyhow = "1.0"
clap = { version = "4.0", features = ["derive", "cargo"] }
lazy_static = "1.4"
holochain_cli_bundle = { path = "../hc_bundle", version = "^0.5.0-dev.21", default-features = false }
holochain_cli_sandbox = { path = "../hc_sandbox", version = "^0.5.0-dev.21" }
holochain_cli_run_local_services = { path = "../hc_run_local_services", version = "^0.5.0-dev.12" }
holochain_trace = { version = "^0.5.0-dev.1", path = "../holochain_trace" }
tokio = { version = "1.36.0", features = ["full"] }

[lints]
workspace = true

[features]
default = ["wasmer_sys"]

chc = ["holochain_cli_sandbox/chc"]

wasmer_sys = ["holochain_cli_bundle/wasmer_sys"]
wasmer_wamr = ["holochain_cli_bundle/wasmer_wamr"]



================================================
File: crates/hc/CHANGELOG.md
================================================
---
default_semver_increment_mode: !pre_minor dev
---
# Changelog

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/). This project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## Unreleased

## 0.5.0-dev.21

## 0.5.0-dev.20

## 0.5.0-dev.19

## 0.5.0-dev.18

## 0.5.0-dev.17

## 0.5.0-dev.16

## 0.5.0-dev.15

## 0.5.0-dev.14

## 0.5.0-dev.13

## 0.5.0-dev.12

## 0.5.0-dev.11

## 0.5.0-dev.10

## 0.5.0-dev.9

## 0.5.0-dev.8

## 0.5.0-dev.7

## 0.5.0-dev.6

## 0.5.0-dev.5

## 0.5.0-dev.4

## 0.5.0-dev.3

## 0.5.0-dev.2

## 0.5.0-dev.1

## 0.5.0-dev.0

## 0.4.0

## 0.4.0-dev.28

## 0.4.0-dev.27

## 0.4.0-dev.26

## 0.4.0-dev.25

## 0.4.0-dev.24

## 0.4.0-dev.23

## 0.4.0-dev.22

## 0.4.0-dev.21

## 0.4.0-dev.20

## 0.4.0-dev.19

## 0.4.0-dev.18

## 0.4.0-dev.17

## 0.4.0-dev.16

## 0.4.0-dev.15

## 0.4.0-dev.14

## 0.4.0-dev.13

## 0.4.0-dev.12

## 0.4.0-dev.11

## 0.4.0-dev.10

## 0.4.0-dev.9

## 0.4.0-dev.8

## 0.4.0-dev.7

## 0.4.0-dev.6

## 0.4.0-dev.5

## 0.4.0-dev.4

## 0.4.0-dev.3

## 0.4.0-dev.2

## 0.4.0-dev.1

## 0.4.0-dev.0

## 0.3.0

## 0.3.0-beta-dev.47

## 0.3.0-beta-dev.46

## 0.3.0-beta-dev.45

## 0.3.0-beta-dev.44

## 0.3.0-beta-dev.43

## 0.3.0-beta-dev.42

## 0.3.0-beta-dev.41

## 0.3.0-beta-dev.40

## 0.3.0-beta-dev.39

## 0.3.0-beta-dev.38

## 0.3.0-beta-dev.37

## 0.3.0-beta-dev.36

## 0.3.0-beta-dev.35

## 0.3.0-beta-dev.34

## 0.3.0-beta-dev.33

## 0.3.0-beta-dev.32

## 0.3.0-beta-dev.31

## 0.3.0-beta-dev.30

## 0.3.0-beta-dev.29

## 0.3.0-beta-dev.28

## 0.3.0-beta-dev.27

## 0.3.0-beta-dev.26

## 0.3.0-beta-dev.25

## 0.3.0-beta-dev.24

## 0.3.0-beta-dev.23

## 0.3.0-beta-dev.22

## 0.3.0-beta-dev.21

## 0.3.0-beta-dev.20

## 0.3.0-beta-dev.19

## 0.3.0-beta-dev.18

## 0.3.0-beta-dev.17

- Adds `chc` feature which is recommended if you want to work with a Holochain instance that is built with its `chc` feature. If you are not using CHC you can safely ignore this feature.

## 0.3.0-beta-dev.16

## 0.3.0-beta-dev.15

## 0.3.0-beta-dev.14

## 0.3.0-beta-dev.13

## 0.3.0-beta-dev.12

## 0.3.0-beta-dev.11

## 0.3.0-beta-dev.10

## 0.3.0-beta-dev.9

## 0.3.0-beta-dev.8

## 0.3.0-beta-dev.7

## 0.3.0-beta-dev.6

## 0.3.0-beta-dev.5

## 0.3.0-beta-dev.4

## 0.3.0-beta-dev.3

## 0.3.0-beta-dev.2

## 0.3.0-beta-dev.1

- Improved documentation in README, code comments, help text, and error messages.
- Updated from structopt 0.3 to clap 4. [\#2125](https://github.com/holochain/holochain/pull/2125)
- `hc signal-srv` is now `hc run-local-services` and runs both a webrtc signaling server, and the holochain bootstrap server locally. [\#2353](https://github.com/holochain/holochain/pull/2353)

## 0.3.0-beta-dev.0

## 0.2.0

## 0.2.0-beta-rc.7

- Adds a new `hc signal-srv` command to run a local holochain webrtc signal server that can be passed into a command like `hc sandbox generate network webrtc ws://127.0.0.1:xxx`. [\#2265](https://github.com/holochain/holochain/pull/2265)

## 0.2.0-beta-rc.6

## 0.2.0-beta-rc.5

## 0.2.0-beta-rc.4

## 0.2.0-beta-rc.3

- Adds new commands to the `hc` CLI which print out JSON schemas for DNA, hApp and web hApps. Use `hc dna schema`, `hc app schema` and `hc web-app schema` to print schemas which can be saved and used as editing aids in your IDE.

## 0.2.0-beta-rc.2

## 0.2.0-beta-rc.1

## 0.2.0-beta-rc.0

## 0.1.0

## 0.1.0-beta-rc.4

## 0.1.0-beta-rc.3

## 0.1.0-beta-rc.2

## 0.1.0-beta-rc.1

## 0.1.0-beta-rc.0

## 0.0.71

- Added handling of `hc` extensions. This allows for existing executables in the system whose names match `hc-<COMMAND>` to be executed with `hc <COMMAND>`.

## 0.0.70

## 0.0.69

## 0.0.68

## 0.0.67

## 0.0.66

## 0.0.65

## 0.0.64

## 0.0.63

## 0.0.62

## 0.0.61

## 0.0.60

## 0.0.59

## 0.0.58

## 0.0.57

## 0.0.56

## 0.0.55

## 0.0.54

## 0.0.53

## 0.0.52

## 0.0.51

## 0.0.50

## 0.0.49

## 0.0.48

## 0.0.47

## 0.0.46

## 0.0.45

## 0.0.44

## 0.0.43

## 0.0.42

## 0.0.41

## 0.0.40

## 0.0.39

## 0.0.38

## 0.0.37

## 0.0.36

## 0.0.35

## 0.0.34

## 0.0.33

## 0.0.32

- Fixed broken links in Rust docs [\#1284](https://github.com/holochain/holochain/pull/1284)

## 0.0.31

## 0.0.30

## 0.0.29

## 0.0.28

## 0.0.27

## 0.0.26

## 0.0.25

## 0.0.24

## 0.0.23

## 0.0.22

## 0.0.21

## 0.0.20

## 0.0.19

## 0.0.18

## 0.0.17

## 0.0.16

## 0.0.15

## 0.0.14

## 0.0.13

## 0.0.12

## 0.0.11

## 0.0.10

## 0.0.9

## 0.0.8

## 0.0.7

- Added the `hc web-app` sub-command for bundling up a UI with a previously created hApp bundle.  It uses the same same behavior as `hc dna` and `hc app` to specify the .yaml manifest file.

## 0.0.6

## 0.0.5

## 0.0.4

## 0.0.3

## 0.0.2

### Removed

- temporarily removed `install_app` from `hc`: its not clear if we should restore yet as mostly should be using `install_app_bundle` [\#665](https://github.com/holochain/holochain/pull/665)



================================================
File: crates/hc/src/external_subcommands.rs
================================================
use std::{
    env, fs,
    path::{Path, PathBuf},
};

use crate::builtin_commands;

/// List all runnable commands.
pub fn list_external_subcommands() -> Vec<String> {
    let prefix = "hc-";
    let suffix = env::consts::EXE_SUFFIX;
    let mut commands = Vec::new();

    let builtin_cmds = builtin_commands();

    for dir in search_directories() {
        let entries = match fs::read_dir(dir) {
            Ok(entries) => entries,
            _ => continue,
        };
        for entry in entries.filter_map(|e| e.ok()) {
            let path = entry.path();
            let filename = match path.file_name().and_then(|s| s.to_str()) {
                Some(filename) => filename,
                _ => continue,
            };
            if !filename.starts_with(prefix) || !filename.ends_with(suffix) {
                continue;
            }
            let end = filename.len() - suffix.len();
            let subcommand = filename[prefix.len()..end].to_string();
            if is_executable(entry.path())
                && !builtin_cmds.contains(&filename.to_string())
                && !commands.contains(&subcommand)
            {
                commands.push(subcommand);
            }
        }
    }

    commands
}
#[cfg(unix)]
fn is_executable<P: AsRef<Path>>(path: P) -> bool {
    use std::os::unix::prelude::*;
    fs::metadata(path)
        .map(|metadata| metadata.is_file() && metadata.permissions().mode() & 0o111 != 0)
        .unwrap_or(false)
}
#[cfg(windows)]
fn is_executable<P: AsRef<Path>>(path: P) -> bool {
    path.as_ref().is_file()
}

fn search_directories() -> Vec<PathBuf> {
    let path_dirs = if let Some(val) = env::var_os("PATH") {
        env::split_paths(&val).collect()
    } else {
        vec![]
    };

    path_dirs
}



================================================
File: crates/hc/src/lib.rs
================================================
#![warn(missing_docs)]

//! A library and CLI to help create, run, and interact with Holochain conductor setups.
//! **Warning this is still WIP and subject to change**
//! There's probably a few bugs. If you find one please open an [issue](https://github.com/holochain/holochain/issues)
//! or make a PR.
//!
//! ## CLI
//!
//! The `hc` CLI makes it easy to create, modify, and run hApps that
//! you are working on or someone has sent you.
//! It has been designed to use sensible defaults but still give you
//! the configurability when that's required.
//!
//! Setups are stored in tmp directories by default and the paths are
//! persisted in a `.hc` file which is created wherever you are using
//! the CLI.

use std::process::Command;

// Useful to have this public when using this as a library.
use clap::{crate_version, Parser, Subcommand};
pub use holochain_cli_bundle as hc_bundle;
use holochain_cli_run_local_services as hc_run_local_services;
use holochain_cli_sandbox as hc_sandbox;
use lazy_static::lazy_static;

mod external_subcommands;

// TODO: change this so it inherits clap's formatting.
// Clap 3 and 4 format helptext using colours and bold/underline respectively.
// https://github.com/clap-rs/clap/pull/4765 introduces the ability to style your own help text
// using a library like `color_print`.
// https://github.com/clap-rs/clap/issues/4786 requests that the styler's built-in helper methods
// be exposed to consumers, thereby allowing us to durably make our styling consistent
// with whatever clap's happens to be at the moment.
// I'd prefer the latter approach, if it lands.
lazy_static! {
    static ref HELP: &'static str = {
        let extensions = external_subcommands::list_external_subcommands()
            .into_iter()
            .map(|s| format!("  {}\t  Run \"hc {} help\" to see its help", s, s))
            .collect::<Vec<String>>()
            .join("\n");

        let extensions_str = match extensions.len() {
            0 => String::from(""),
            _ => format!(
                r#"
Extensions:
{extensions}"#
            ),
        };

        let s = format!(
            r#"Holochain CLI

Work with DNA, hApp and web-hApp bundle files, set up sandbox environments for testing and development purposes, make direct admin calls to running conductors, and more.
{extensions_str}"#
        );
        Box::leak(s.into_boxed_str())
    };
}

fn builtin_commands() -> Vec<String> {
    ["hc-web-app", "hc-dna", "hc-app", "hc-sandbox"]
        .iter()
        .map(|s| s.to_string())
        .collect()
}

/// The main entry-point for the command.
#[allow(clippy::large_enum_variant)]
#[derive(Debug, Parser)]
#[command(about = *HELP, infer_subcommands = true, allow_external_subcommands = true, version = crate_version!())]
pub struct Cli {
    /// The `hc` subcommand to run.
    #[command(subcommand)]
    pub subcommand: CliSubcommand,
}

/// Describes all the possible CLI arguments for `hc`, including external subcommands like `hc-scaffold`.
#[derive(Debug, Subcommand)]
#[allow(clippy::large_enum_variant)]
pub enum CliSubcommand {
    /// Work with DNA bundles.
    Dna(hc_bundle::HcDnaBundle),
    /// Work with hApp bundles.
    App(hc_bundle::HcAppBundle),
    /// Work with web-hApp bundles.
    WebApp(hc_bundle::HcWebAppBundle),
    /// Work with sandboxed environments for testing and development.
    Sandbox(hc_sandbox::HcSandbox),
    /// Run a local bootstrap and WebRTC signalling server.
    RunLocalServices(hc_run_local_services::HcRunLocalServices),
    /// Allow redirect of external subcommands (like `hc-scaffold` and `hc-launch`).
    #[command(external_subcommand)]
    External(Vec<String>),
}

impl CliSubcommand {
    /// Run this command.
    pub async fn run(self) -> anyhow::Result<()> {
        match self {
            CliSubcommand::App(cmd) => cmd.run().await?,
            CliSubcommand::Dna(cmd) => cmd.run().await?,
            CliSubcommand::WebApp(cmd) => cmd.run().await?,
            CliSubcommand::Sandbox(cmd) => cmd.run().await?,
            CliSubcommand::RunLocalServices(cmd) => cmd.run().await,
            CliSubcommand::External(args) => {
                let command_suffix = args.first().expect("Missing subcommand name");
                Command::new(format!("hc-{}", command_suffix))
                    .args(&args[1..])
                    .status()
                    .expect("Failed to run external subcommand");
            }
        }
        Ok(())
    }
}



================================================
File: crates/hc/src/bin/hc.rs
================================================
use clap::Parser;
use holochain_cli as hc;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    if std::env::var_os("RUST_LOG").is_some() {
        holochain_trace::init_fmt(holochain_trace::Output::Log).ok();
    }
    let cli = hc::Cli::parse();
    cli.subcommand.run().await
}



================================================
File: crates/hc_bundle/README.md
================================================
# hc_bundle

[![Project](https://img.shields.io/badge/project-holochain-blue.svg?style=flat-square)](http://holochain.org/)
[![Forum](https://img.shields.io/badge/chat-forum%2eholochain%2enet-blue.svg?style=flat-square)](https://forum.holochain.org)
[![Chat](https://img.shields.io/badge/chat-chat%2eholochain%2enet-blue.svg?style=flat-square)](https://chat.holochain.org)

[![License: Apache-2.0](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://www.apache.org/licenses/LICENSE-2.0)

Utilities to create DNA, hApp, and web-hApp bundle files from a source working directory and manifest file, and vice-versa.
This crate defines three separate subcommands for the `hc` CLI tool, one for each type of bundle.
All subcommands are very similar and have nearly identical flags and options.

This crate also defines standalone binaries for each subcommand, `hc-dna`, `hc-app`, and `hc-web-app`.

`hc app` and `hc web-app` are very similar, only differing by the addition of a `--recursive` flag.
