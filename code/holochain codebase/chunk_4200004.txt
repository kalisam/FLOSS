pub const INVALID_ID: &str = "never_validates";

#[derive(
    Default, Debug, PartialEq, Clone, SerializedBytes, serde::Serialize, serde::Deserialize,
)]
#[repr(transparent)]
#[serde(transparent)]
pub struct Post(pub String);
#[derive(
    Default, Debug, PartialEq, Clone, SerializedBytes, serde::Serialize, serde::Deserialize,
)]
#[repr(transparent)]
#[serde(transparent)]
pub struct Msg(pub String);

/// A CellId plus ZomeName: the full "path" to a zome in the conductor
#[derive(Clone, Debug, derive_more::From, derive_more::Into)]
pub struct ZomePath(CellId, ZomeName);

impl ZomePath {
    pub fn cell_id(&self) -> &CellId {
        &self.0
    }

    pub fn zome_name(&self) -> &ZomeName {
        &self.1
    }
}

/// Type from the validate wasm
// TODO: Maybe we can dry this up by putting the wasm types
// somewhere outside the wasm?
#[derive(Deserialize, Serialize, SerializedBytes, Debug, Clone)]
pub enum ThisWasmEntry {
    AlwaysValidates,
    NeverValidates,
}

#[derive(Deserialize, Serialize, SerializedBytes, Debug, Clone)]
pub enum MaybeLinkable {
    AlwaysLinkable,
    NeverLinkable,
}

/// A freely callable version of the host fn api, so that host functions
/// can be called from Rust instead of Wasm
#[derive(Clone)]
pub struct HostFnCaller {
    pub authored_db: DbWrite<DbKindAuthored>,
    pub dht_db: DbWrite<DbKindDht>,
    pub dht_db_cache: DhtDbQueryCache,
    pub cache: DbWrite<DbKindCache>,
    pub dpki: Option<DpkiImpl>,
    pub ribosome: RealRibosome,
    pub zome_path: ZomePath,
    pub network: HolochainP2pDna,
    pub keystore: MetaLairClient,
    pub signal_tx: broadcast::Sender<Signal>,
    pub call_zome_handle: CellConductorReadHandle,
}

impl HostFnCaller {
    /// Create HostFnCaller for the first zome.
    // #[deprecated = "use create_for_zome"]
    pub async fn create(
        cell_id: &CellId,
        handle: &ConductorHandle,
        dna_file: &DnaFile,
    ) -> HostFnCaller {
        Self::create_for_zome(cell_id, handle, dna_file, 0).await
    }

    /// Create HostFnCaller for a specific zome if there are multiple.
    pub async fn create_for_zome(
        cell_id: &CellId,
        handle: &ConductorHandle,
        dna_file: &DnaFile,
        zome_index: usize,
    ) -> HostFnCaller {
        let authored_db = handle
            .get_or_create_authored_db(cell_id.dna_hash(), cell_id.agent_pubkey().clone())
            .unwrap();
        let dht_db = handle.get_dht_db(cell_id.dna_hash()).unwrap();
        let dht_db_cache = handle.get_dht_db_cache(cell_id.dna_hash()).unwrap();
        let cache = handle.get_cache_db(cell_id).await.unwrap();
        let keystore = handle.keystore().clone();
        let network = handle
            .holochain_p2p()
            .to_dna(cell_id.dna_hash().clone(), None);

        let zome_path = (
            cell_id.clone(),
            dna_file
                .dna()
                .integrity_zomes
                .get(zome_index)
                .unwrap()
                .0
                .clone(),
        )
            .into();
        let ribosome = handle.get_ribosome(dna_file.dna_hash()).unwrap();
        let signal_tx = handle.get_signal_tx(cell_id).await.unwrap();
        let call_zome_handle =
            CellConductorApi::new(handle.clone(), cell_id.clone()).into_call_zome_handle();
        HostFnCaller {
            authored_db,
            dht_db,
            dht_db_cache,
            cache,
            dpki: None,
            ribosome,
            zome_path,
            network,
            keystore,
            signal_tx,
            call_zome_handle,
        }
    }

    pub fn authored_db(&self) -> DbWrite<DbKindAuthored> {
        self.authored_db.clone()
    }

    pub fn dht_db(&self) -> DbWrite<DbKindDht> {
        self.dht_db.clone()
    }

    #[cfg_attr(feature = "instrument", tracing::instrument(skip(self), fields(cell_id = %self.zome_path.cell_id())))]
    pub async fn unpack(&self) -> (Arc<RealRibosome>, Arc<CallContext>, SourceChainWorkspace) {
        let HostFnCaller {
            authored_db,
            dht_db,
            cache,
            dpki,
            network,
            keystore,
            ribosome,
            signal_tx,
            zome_path,
            call_zome_handle,
            dht_db_cache,
        } = self.clone();

        let (cell_id, zome_name) = zome_path.into();

        let workspace = SourceChainWorkspace::new(
            authored_db,
            dht_db,
            dht_db_cache,
            cache,
            keystore.clone(),
            cell_id.agent_pubkey().clone(),
            Arc::new(ribosome.dna_def().as_content().clone()),
        )
        .await
        .unwrap();
        let host_access = ZomeCallHostAccess::new(
            workspace.clone().into(),
            keystore,
            dpki,
            network,
            signal_tx,
            call_zome_handle,
        );
        let ribosome = Arc::new(ribosome);
        let zome = ribosome.dna_def().get_zome(&zome_name).unwrap();
        let call_context = Arc::new(CallContext::new(
            zome,
            FunctionName::new("not_sure_what_should_be_here"),
            host_access.into(),
            // Auth as the author.
            InvocationAuth::Cap(cell_id.agent_pubkey().clone(), None),
        ));
        (ribosome, call_context, workspace)
    }
}

impl HostFnCaller {
    pub fn get_entry_type(
        &self,
        zome: impl Into<TestWasmPair<ZomeName>>,
        index: impl Into<EntryDefIndex>,
    ) -> ScopedEntryDefIndex {
        let TestWasmPair { integrity, .. } = zome.into();
        let zome_index = self
            .ribosome
            .dna_def()
            .integrity_zomes
            .iter()
            .position(|(z, _)| *z == integrity)
            .unwrap();
        let zome_types = self
            .ribosome
            .zome_types()
            .in_scope_subset(&[ZomeIndex(zome_index as u8)]);
        zome_types
            .entries
            .get(ZomeTypesKey {
                zome_index: 0.into(),
                type_index: index.into(),
            })
            .unwrap()
    }
    pub fn get_entry_link(
        &self,
        zome: impl Into<TestWasmPair<ZomeName>>,
        index: impl Into<LinkType>,
    ) -> ScopedLinkType {
        let TestWasmPair { integrity, .. } = zome.into();
        let zome_index = self
            .ribosome
            .dna_def()
            .integrity_zomes
            .iter()
            .position(|(z, _)| *z == integrity)
            .unwrap();
        let zome_types = self
            .ribosome
            .zome_types()
            .in_scope_subset(&[ZomeIndex(zome_index as u8)]);
        zome_types
            .links
            .get(ZomeTypesKey {
                zome_index: 0.into(),
                type_index: index.into(),
            })
            .unwrap()
    }
    pub async fn commit_entry<E: Into<EntryDefLocation>>(
        &self,
        entry: Entry,
        entry_def_id: E,
        visibility: EntryVisibility,
    ) -> ActionHash {
        let (ribosome, call_context, workspace) = self.unpack().await;
        let input = CreateInput::new(
            entry_def_id.into(),
            visibility,
            entry,
            ChainTopOrdering::default(),
        );
        let output = host_fn::create::create(ribosome, call_context, input).unwrap();

        // Write
        workspace
            .source_chain()
            .flush(
                self.network.storage_arcs().await.unwrap(),
                self.network.chc(),
            )
            .await
            .unwrap();

        output
    }

    pub async fn delete_entry<'env>(&self, input: DeleteInput) -> ActionHash {
        let (ribosome, call_context, workspace) = self.unpack().await;
        let output = {
            let r = host_fn::delete::delete(ribosome, call_context, input);
            let r = r.map_err(|e| {
                debug!(%e);
                e
            });
            r.unwrap()
        };

        // Write
        workspace
            .source_chain()
            .flush(
                self.network.storage_arcs().await.unwrap(),
                self.network.chc(),
            )
            .await
            .unwrap();

        output
    }

    pub async fn update_entry(
        &self,
        entry: Entry,
        original_action_address: ActionHash,
    ) -> ActionHash {
        let (ribosome, call_context, workspace) = self.unpack().await;
        let input = UpdateInput {
            original_action_address,
            entry,
            chain_top_ordering: Default::default(),
        };

        let output = { host_fn::update::update(ribosome, call_context, input).unwrap() };

        // Write
        workspace
            .source_chain()
            .flush(
                self.network.storage_arcs().await.unwrap(),
                self.network.chc(),
            )
            .await
            .unwrap();

        output
    }

    pub async fn get(&self, entry_hash: AnyDhtHash, options: GetOptions) -> Vec<Option<Record>> {
        let (ribosome, call_context, _) = self.unpack().await;
        let input = GetInput::new(entry_hash, options);
        host_fn::get::get(ribosome, call_context, vec![input]).unwrap()
    }

    pub async fn get_details<'env>(
        &self,
        entry_hash: AnyDhtHash,
        options: GetOptions,
    ) -> Vec<Option<Details>> {
        let (ribosome, call_context, _) = self.unpack().await;
        let input = GetInput::new(entry_hash, options);
        host_fn::get_details::get_details(ribosome, call_context, vec![input]).unwrap()
    }

    pub async fn create_link<'env>(
        &self,
        base: AnyLinkableHash,
        target: AnyLinkableHash,
        zome_index: impl Into<ZomeIndex>,
        link_type: impl Into<LinkType>,
        link_tag: LinkTag,
    ) -> ActionHash {
        let (ribosome, call_context, workspace) = self.unpack().await;
        let input = CreateLinkInput::new(
            base,
            target,
            zome_index.into(),
            link_type.into(),
            link_tag,
            ChainTopOrdering::default(),
        );
        let output = { host_fn::create_link::create_link(ribosome, call_context, input).unwrap() };

        // Write
        workspace
            .source_chain()
            .flush(
                self.network.storage_arcs().await.unwrap(),
                self.network.chc(),
            )
            .await
            .unwrap();

        output
    }

    pub async fn delete_link<'env>(&self, link_add_hash: ActionHash) -> ActionHash {
        let (ribosome, call_context, workspace) = self.unpack().await;
        let output = {
            host_fn::delete_link::delete_link(
                ribosome,
                call_context,
                DeleteLinkInput::new(link_add_hash, ChainTopOrdering::default()),
            )
            .unwrap()
        };

        // Write
        workspace
            .source_chain()
            .flush(
                self.network.storage_arcs().await.unwrap(),
                self.network.chc(),
            )
            .await
            .unwrap();

        output
    }

    pub async fn get_links<'env>(
        &self,
        base: AnyLinkableHash,
        type_query: LinkTypeFilter,
        link_tag: Option<LinkTag>,
        _options: GetLinksOptions,
    ) -> Vec<Link> {
        let (ribosome, call_context, workspace) = self.unpack().await;
        let mut input = GetLinksInputBuilder::try_new(base, type_query).unwrap();
        if let Some(link_tag) = link_tag {
            input = input.tag_prefix(link_tag);
        }
        let output = {
            host_fn::get_links::get_links(ribosome, call_context, vec![input.build()])
                .unwrap()
                .into_iter()
                .next()
                .unwrap()
        };

        // Write
        workspace
            .source_chain()
            .flush(
                self.network.storage_arcs().await.unwrap(),
                self.network.chc(),
            )
            .await
            .unwrap();

        output
    }

    pub async fn get_link_details<'env>(
        &self,
        base: AnyLinkableHash,
        type_query: LinkTypeFilter,
        tag: LinkTag,
        _options: GetLinksOptions,
    ) -> Vec<(SignedActionHashed, Vec<SignedActionHashed>)> {
        let (ribosome, call_context, workspace) = self.unpack().await;
        let input = GetLinksInputBuilder::try_new(base, type_query)
            .unwrap()
            .tag_prefix(tag)
            .build();
        let output = {
            host_fn::get_link_details::get_link_details(ribosome, call_context, vec![input])
                .unwrap()
                .into_iter()
                .next()
                .unwrap()
        };

        // Write
        workspace
            .source_chain()
            .flush(
                self.network.storage_arcs().await.unwrap(),
                self.network.chc(),
            )
            .await
            .unwrap();

        output.into()
    }

    pub async fn get_agent_activity(
        &self,
        agent: &AgentPubKey,
        query: &ChainQueryFilter,
        request: ActivityRequest,
    ) -> AgentActivity {
        let (ribosome, call_context, _) = self.unpack().await;
        let input = GetAgentActivityInput::new(agent.clone(), query.clone(), request);
        host_fn::get_agent_activity::get_agent_activity(ribosome, call_context, input).unwrap()
    }

    pub async fn call_zome_direct(&self, invocation: ZomeCallInvocation) -> ExternIO {
        let (ribosome, call_context, workspace) = self.unpack().await;

        let (_, output) = {
            let host_access = call_context.host_context();
            let zcha = unwrap_to!(host_access => HostContext::ZomeCall).clone();
            call_zome_function_authorized((*ribosome).clone(), zcha, invocation)
                .await
                .unwrap()
        };

        // Write
        workspace
            .source_chain()
            .flush(
                self.network.storage_arcs().await.unwrap(),
                self.network.chc(),
            )
            .await
            .unwrap();
        unwrap_to!(output.unwrap() => ZomeCallResponse::Ok).to_owned()
    }
}

#[macro_export]
macro_rules! test_entry_impl {
    ($type:ident) => {
        impl TryFrom<$type> for Entry {
            type Error = EntryError;
            fn try_from(n: $type) -> Result<Self, Self::Error> {
                Ok(Entry::App(SerializedBytes::try_from(n)?.try_into()?))
            }
        }

        impl TryFrom<Entry> for $type {
            type Error = SerializedBytesError;
            fn try_from(entry: Entry) -> Result<Self, Self::Error> {
                let entry = unwrap_to!(entry => Entry::App).clone();
                $type::try_from(entry.into_sb())
            }
        }
    };
}

test_entry_impl!(ThisWasmEntry);
test_entry_impl!(Post);
test_entry_impl!(Msg);
test_entry_impl!(MaybeLinkable);



================================================
File: crates/holochain/src/test_utils/inline_zomes.rs
================================================
//! Collection of commonly used InlineZomes

use holo_hash::*;
use holochain_types::inline_zome::InlineEntryTypes;
use holochain_types::inline_zome::InlineZomeSet;
use holochain_zome_types::prelude::*;

use crate::sweettest::SweetInlineZomes;

/// An InlineZome with simple Create and Read operations
pub fn simple_create_read_zome() -> InlineIntegrityZome {
    InlineIntegrityZome::new_unique(InlineEntryTypes::entry_defs(), 0)
        .function("create", move |api, ()| {
            let entry = Entry::app(().try_into().unwrap()).unwrap();
            let hash = api.create(CreateInput::new(
                InlineZomeSet::get_entry_location(&api, InlineEntryTypes::A),
                EntryVisibility::Public,
                entry,
                ChainTopOrdering::default(),
            ))?;
            Ok(hash)
        })
        .function("read", |api, hash: ActionHash| {
            api.get(vec![GetInput::new(hash.into(), GetOptions::default())])
                .map(|e| e.into_iter().next().unwrap())
                .map_err(Into::into)
        })
        .function("read_details", |api, hash: ActionHash| {
            api.get_details(vec![GetInput::new(hash.into(), GetOptions::default())])
                .map(|e| e.into_iter().next().unwrap())
                .map_err(Into::into)
        })
}

/// An InlineZome with a function to create many random entries at once,
/// and a function to read the entry at a hash
pub fn batch_create_zome() -> InlineIntegrityZome {
    use rand::Rng;

    #[derive(Copy, Clone, Debug, Serialize, Deserialize, SerializedBytes)]
    struct RandNum(u64);

    impl Default for RandNum {
        fn default() -> Self {
            Self(rand::thread_rng().gen())
        }
    }

    InlineIntegrityZome::new_unique(InlineEntryTypes::entry_defs(), 0)
        .function("create_batch", move |api, num: usize| {
            let hashes = std::iter::repeat_with(|| {
                api.create(CreateInput::new(
                    InlineZomeSet::get_entry_location(&api, InlineEntryTypes::A),
                    EntryVisibility::Public,
                    Entry::app(RandNum::default().try_into().unwrap()).unwrap(),
                    ChainTopOrdering::default(),
                ))
                .unwrap()
            })
            .take(num)
            .collect::<Vec<_>>();
            Ok(hashes)
        })
        .function("read", |api, hash: ActionHash| {
            api.get(vec![GetInput::new(hash.into(), GetOptions::default())])
                .map(|e| e.into_iter().next().unwrap())
                .map_err(Into::into)
        })
}

#[derive(
    Debug,
    Clone,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    serde::Serialize,
    serde::Deserialize,
    SerializedBytes,
    derive_more::From,
)]
#[serde(transparent)]
#[repr(transparent)]
/// Newtype for simple_crud_zome entry type
pub struct AppString(pub String);

impl AppString {
    /// Constructor
    pub fn new<S: Into<String>>(s: S) -> Self {
        AppString(s.into())
    }
}

/// An InlineZome with simple Create and Read operations
pub fn simple_crud_zome() -> InlineZomeSet {
    let string_entry_def = EntryDef::default_from_id("string");
    let unit_entry_def = EntryDef::default_from_id("unit");
    let bytes_entry_def = EntryDef::default_from_id("bytes");

    SweetInlineZomes::new(vec![string_entry_def, unit_entry_def, bytes_entry_def], 0)
        .function("create_string", move |api, s: AppString| {
            let entry = Entry::app(s.try_into().unwrap()).unwrap();
            let hash = api.create(CreateInput::new(
                InlineZomeSet::get_entry_location(&api, EntryDefIndex(0)),
                EntryVisibility::Public,
                entry,
                ChainTopOrdering::default(),
            ))?;
            Ok(hash)
        })
        .function("create_unit", move |api, ()| {
            let entry = Entry::app(().try_into().unwrap()).unwrap();
            let hash = api.create(CreateInput::new(
                InlineZomeSet::get_entry_location(&api, EntryDefIndex(1)),
                EntryVisibility::Public,
                entry,
                ChainTopOrdering::default(),
            ))?;
            Ok(hash)
        })
        .function("create_bytes", move |api, bs: Bytes| {
            let entry = Entry::app(UnsafeBytes::from(bs.to_vec()).into()).unwrap();
            let hash = api.create(CreateInput::new(
                InlineZomeSet::get_entry_location(&api, EntryDefIndex(2)),
                EntryVisibility::Public,
                entry,
                ChainTopOrdering::default(),
            ))?;
            Ok(hash)
        })
        .function("delete", move |api, action_hash: ActionHash| {
            let hash = api.delete(DeleteInput::new(action_hash, ChainTopOrdering::default()))?;
            Ok(hash)
        })
        .function("read", |api, hash: ActionHash| {
            api.get(vec![GetInput::new(hash.into(), GetOptions::default())])
                .map(|e| e.into_iter().next().unwrap())
                .map_err(Into::into)
        })
        .function("read_multi", |api, hashes: Vec<ActionHash>| {
            let gets = hashes
                .iter()
                .map(|h| GetInput::new(h.clone().into(), GetOptions::default()))
                .collect();
            api.get(gets).map_err(Into::into)
        })
        .function("read_entry", |api, hash: EntryHash| {
            api.get(vec![GetInput::new(hash.into(), GetOptions::default())])
                .map_err(Into::into)
        })
        .function("emit_signal", |api, ()| {
            api.emit_signal(AppSignal::new(ExternIO::encode(()).unwrap()))
                .map_err(Into::into)
        })
        .0
}



================================================
File: crates/holochain/src/test_utils/network_simulation.rs
================================================
//! Types to help with building simulated networks.
//! Note this is an experimental prototype.
#![warn(missing_docs)]

use std::collections::{BTreeMap, HashMap};
use std::sync::Arc;

use ::fixt::prelude::*;
use hdk::prelude::*;
use holo_hash::{DhtOpHash, DnaHash};
use holochain_conductor_api::conductor::ConductorConfig;
use holochain_p2p::dht_arc::{DhtArcRange, DhtLocation};
use holochain_p2p::{AgentPubKeyExt, DhtOpHashExt, DnaHashExt};
use holochain_sqlite::error::DatabaseResult;
use holochain_sqlite::store::{p2p_put_single, AsP2pStateTxExt};
use holochain_state::prelude::from_blob;
use holochain_types::dht_op::{ChainOp, ChainOpHashed, ChainOpType};
use holochain_types::inline_zome::{InlineEntryTypes, InlineZomeSet};
use holochain_types::prelude::DnaFile;
use kitsune_p2p::agent_store::AgentInfoSigned;
use kitsune_p2p::dht::arq::ArqSize;
use kitsune_p2p::dht::spacetime::SpaceDimension;
use kitsune_p2p::dht::Arq;
use kitsune_p2p::{fixt::*, KitsuneAgent, KitsuneOpHash};
use kitsune_p2p_bin_data::{KitsuneBinType, KitsuneSpace};
use kitsune_p2p_types::config::KitsuneP2pConfig;
use rand::distributions::Alphanumeric;
use rand::distributions::Standard;
use rand::Rng;
use rusqlite::{params, Connection, OptionalExtension, Transaction};

use crate::sweettest::{SweetConductor, SweetDnaFile};

#[derive(SerializedBytes, serde::Serialize, serde::Deserialize, Debug)]
/// Data to use to simulate a dht network.
pub struct MockNetworkData {
    /// The hashes authored by each agent.
    pub authored: HashMap<Arc<AgentPubKey>, Vec<Arc<DhtOpHash>>>,
    /// DhtOpHash -> KitsuneOpHash
    pub op_hash_to_kit: HashMap<Arc<DhtOpHash>, Arc<KitsuneOpHash>>,
    /// KitsuneOpHash -> DhtOpHash
    pub op_kit_to_hash: HashMap<Arc<KitsuneOpHash>, Arc<DhtOpHash>>,
    /// AgentPubKey -> KitsuneAgent
    pub agent_hash_to_kit: HashMap<Arc<AgentPubKey>, Arc<KitsuneAgent>>,
    /// KitsuneAgent -> AgentPubKey
    pub agent_kit_to_hash: HashMap<Arc<KitsuneAgent>, Arc<AgentPubKey>>,
    /// Agent storage arcs.
    pub agent_to_arq: HashMap<Arc<AgentPubKey>, Arq>,
    /// Agents peer info.
    pub agent_to_info: HashMap<Arc<AgentPubKey>, AgentInfoSigned>,
    /// Hashes ordered by their basis location.
    pub ops_by_loc: BTreeMap<DhtLocation, Vec<Arc<DhtOpHash>>>,
    /// Hash to basis location.
    pub op_to_loc: HashMap<Arc<DhtOpHash>, DhtLocation>,
    /// The DhtOps
    pub ops: HashMap<Arc<DhtOpHash>, ChainOpHashed>,
    /// The uuid for the integrity zome (also for the dna).
    pub integrity_uuid: String,
    /// The uuid for the coordinator zome.
    pub coordinator_uuid: String,
}

struct GeneratedData {
    integrity_uuid: String,
    coordinator_uuid: String,
    peer_data: Vec<AgentInfoSigned>,
    authored: HashMap<Arc<AgentPubKey>, Vec<Arc<DhtOpHash>>>,
    ops: HashMap<Arc<DhtOpHash>, ChainOpHashed>,
}

impl MockNetworkData {
    fn new(data: GeneratedData) -> Self {
        let GeneratedData {
            integrity_uuid,
            coordinator_uuid,
            peer_data,
            authored,
            ops,
        } = data;
        let (agent_hash_to_kit, agent_kit_to_hash): (HashMap<_, _>, HashMap<_, _>) = authored
            .keys()
            .map(|agent| {
                let k_agent = agent.to_kitsune();
                ((agent.clone(), k_agent.clone()), (k_agent, agent.clone()))
            })
            .unzip();
        let mut op_hash_to_kit = HashMap::with_capacity(ops.len());
        let mut op_kit_to_hash = HashMap::with_capacity(ops.len());
        let mut ops_by_loc = BTreeMap::new();
        let mut op_to_loc = HashMap::with_capacity(ops.len());
        for (hash, op) in &ops {
            let k_hash = hash.to_kitsune();
            op_hash_to_kit.insert(hash.clone(), k_hash.clone());
            op_kit_to_hash.insert(k_hash, hash.clone());

            let loc = op.dht_basis().get_loc();

            ops_by_loc
                .entry(loc)
                .or_insert_with(Vec::new)
                .push(hash.clone());
            op_to_loc.insert(hash.clone(), loc);
        }
        let agent_to_info: HashMap<_, _> = peer_data
            .into_iter()
            .map(|info| (agent_kit_to_hash[&info.agent].clone(), info))
            .collect();
        let agent_to_arq = agent_to_info
            .iter()
            .map(|(k, v)| (k.clone(), v.storage_arq))
            .collect();
        Self {
            authored,
            op_hash_to_kit,
            op_kit_to_hash,
            agent_hash_to_kit,
            agent_kit_to_hash,
            agent_to_arq,
            agent_to_info,
            ops_by_loc,
            op_to_loc,
            ops,
            integrity_uuid,
            coordinator_uuid,
        }
    }

    /// Number of agents in this simulation.
    /// This doesn't include any real agents.
    pub fn num_agents(&self) -> usize {
        self.agent_to_info.len()
    }

    /// The simulated agents.
    pub fn agents(&self) -> impl Iterator<Item = &Arc<AgentPubKey>> {
        self.agent_to_info.keys()
    }

    /// The coverage of the simulated dht.
    pub fn coverage(&self) -> f64 {
        ((50.0 / self.num_agents() as f64) * 2.0).clamp(0.0, 1.0)
    }

    /// The agent info of the simulated agents.
    pub fn agent_info(&self) -> impl Iterator<Item = &AgentInfoSigned> {
        self.agent_to_info.values()
    }

    /// Hashes that an agent is an authority for.
    pub fn hashes_authority_for(&self, agent: &AgentPubKey) -> Vec<Arc<DhtOpHash>> {
        let arq = self.agent_to_arq[agent];
        if arq.is_empty() {
            Vec::with_capacity(0)
        } else if arq.is_full(SpaceDimension::standard()) {
            self.ops_by_loc.values().flatten().cloned().collect()
        } else {
            let (start, end) = arq.to_dht_arc_range_std().to_bounds_grouped().unwrap();
            if start <= end {
                self.ops_by_loc
                    .range(start..=end)
                    .flat_map(|(_, hash)| hash)
                    .cloned()
                    .collect()
            } else {
                self.ops_by_loc
                    .range(..=end)
                    .flat_map(|(_, hash)| hash)
                    .chain(self.ops_by_loc.range(start..).flat_map(|(_, hash)| hash))
                    .cloned()
                    .collect()
            }
        }
    }
}

/// Generate test data for a simulated network using holochain.
/// The data can be cached to the tmp directory
/// which can save time on running tests or it can
/// be all held in memory.
pub async fn generate_test_data(
    num_agents: usize,
    min_num_ops_held: usize,
    in_memory: bool,
    force_new_data: bool,
) -> (MockNetworkData, Connection) {
    let cached = if !in_memory || !force_new_data {
        get_cached().filter(|data| data.authored.len() == num_agents)
    } else {
        None
    };
    let is_cached = cached.is_some();
    let (data, dna_hash) = match cached {
        Some(cached) => {
            let dna_file = data_zome(
                cached.integrity_uuid.clone(),
                cached.coordinator_uuid.clone(),
            )
            .await;
            let dna_hash = dna_file.dna_hash().clone();
            (cached, dna_hash)
        }
        None => {
            let integrity_uuid = nanoid::nanoid!();
            let coordinator_uuid = nanoid::nanoid!();

            let dna_file = data_zome(integrity_uuid.clone(), coordinator_uuid.clone()).await;
            let dna_hash = dna_file.dna_hash().clone();
            let data = create_test_data(
                num_agents,
                min_num_ops_held,
                dna_file,
                integrity_uuid,
                coordinator_uuid,
            )
            .await;
            (data, dna_hash)
        }
    };
    let generated_data = GeneratedData {
        ops: data.ops,
        peer_data: reset_peer_data(data.peer_data, &dna_hash).await,
        integrity_uuid: data.integrity_uuid,
        coordinator_uuid: data.coordinator_uuid,
        authored: data.authored,
    };
    let data = MockNetworkData::new(generated_data);
    let conn = cache_data(in_memory, &data, is_cached);
    (data, conn)
}

fn cache_data(in_memory: bool, data: &MockNetworkData, is_cached: bool) -> Connection {
    let mut conn = if in_memory {
        Connection::open_in_memory().unwrap()
    } else {
        let p = std::env::temp_dir().join("mock_test_data");
        std::fs::create_dir(&p).ok();
        let p = p.join("mock_test_data.sqlite3");
        Connection::open(p).unwrap()
    };
    if is_cached && !in_memory {
        return conn;
    }
    holochain_sqlite::schema::SCHEMA_CELL
        .initialize(&mut conn, None)
        .unwrap();
    holochain_sqlite::schema::SCHEMA_P2P_STATE
        .initialize(&mut conn, None)
        .unwrap();
    let mut txn = conn
        .transaction_with_behavior(rusqlite::TransactionBehavior::Exclusive)
        .unwrap();
    txn.execute(
        "
        CREATE TABLE IF NOT EXISTS Authored (
            agent       BLOB    NOT NULL,
            dht_op_hash BLOB    NOT NUll
        )
        ",
        [],
    )
    .unwrap();
    txn.execute(
        "
        CREATE TABLE IF NOT EXISTS Uuid(
            integrity_uuid TEXT NOT NULL,
            coordinator_uuid TEXT NOT NULL
        )
        ",
        [],
    )
    .unwrap();
    txn.execute(
        "
        INSERT INTO Uuid (integrity_uuid, coordinator_uuid) VALUES(?)
        ",
        [&data.integrity_uuid, &data.coordinator_uuid],
    )
    .unwrap();
    for op in data.ops.values() {
        holochain_state::test_utils::mutations_helpers::insert_valid_integrated_op(
            &mut txn,
            &op.downcast(),
        )
        .unwrap();
    }
    for (author, ops) in &data.authored {
        for op in ops {
            txn.execute(
                "
                    INSERT INTO Authored (agent, dht_op_hash)
                    VALUES(?, ?)
                    ",
                params![author, op.as_hash()],
            )
            .unwrap();
        }
    }
    for agent in data.agent_to_info.values() {
        p2p_put_single(agent.space.clone(), &mut txn, agent).unwrap();
    }
    txn.commit().unwrap();
    conn
}

fn get_cached() -> Option<GeneratedData> {
    let p = std::env::temp_dir()
        .join("mock_test_data")
        .join("mock_test_data.sqlite3");
    p.exists().then_some(()).and_then(|_| {
        let mut conn = Connection::open(p).ok()?;
        let mut txn = conn
            .transaction_with_behavior(rusqlite::TransactionBehavior::Exclusive)
            .unwrap();
        // If there's no uuid then there's no data.
        let integrity_uuid = txn
            .query_row("SELECT integrity_uuid FROM Uuid", [], |row| row.get(0))
            .optional()
            .ok()
            .flatten()?;
        let coordinator_uuid = txn
            .query_row("SELECT coordinator_uuid FROM Uuid", [], |row| row.get(0))
            .optional()
            .ok()
            .flatten()?;
        let ops = get_chain_ops(&mut txn);
        let peer_data = txn
            .p2p_list_agents(Arc::new(KitsuneSpace::new(vec![0; 36])))
            .unwrap();
        let authored = txn
            .prepare("SELECT agent, dht_op_hash FROM Authored")
            .unwrap()
            .query_map([], |row| Ok((Arc::new(row.get(0)?), Arc::new(row.get(1)?))))
            .unwrap()
            .map(Result::unwrap)
            .fold(HashMap::<_, Vec<_>>::new(), |mut map, (agent, hash)| {
                map.entry(agent).or_default().push(hash);
                map
            });

        Some(GeneratedData {
            integrity_uuid,
            coordinator_uuid,
            peer_data,
            authored,
            ops,
        })
    })
}

async fn create_test_data(
    num_agents: usize,
    approx_num_ops_held: usize,
    dna_file: DnaFile,
    integrity_uuid: String,
    coordinator_uuid: String,
) -> GeneratedData {
    let coverage = ((50.0 / num_agents as f64) * 2.0).clamp(0.0, 1.0);
    let num_storage_buckets = (1.0 / coverage).round() as u32;
    let bucket_size = u32::MAX / num_storage_buckets;
    let buckets = (0..num_storage_buckets)
        .map(|i| DhtArcRange::from_bounds(i * bucket_size, i * bucket_size + bucket_size))
        .collect::<Vec<_>>();
    let mut bucket_counts = vec![0; buckets.len()];
    let mut entries = Vec::with_capacity(buckets.len() * approx_num_ops_held);
    let rng = rand::thread_rng();
    let mut rand_entry = rng.sample_iter(&Standard);
    let rand_entry = rand_entry.by_ref();

    loop {
        let d: Vec<u8> = rand_entry.take(10).collect();
        let d = UnsafeBytes::from(d);
        let entry = Entry::app(d.into()).unwrap();
        let hash = EntryHash::with_data_sync(&entry);
        let loc = hash.get_loc();
        if let Some(index) = buckets.iter().position(|b| b.contains(loc)) {
            if bucket_counts[index] < approx_num_ops_held * 100 {
                entries.push(entry);
                bucket_counts[index] += 1;
            }
        }
        if bucket_counts
            .iter()
            .all(|&c| c >= approx_num_ops_held * 100)
        {
            break;
        }
    }

    let mut tuning =
        kitsune_p2p_types::config::tuning_params_struct::KitsuneP2pTuningParams::default();
    tuning.gossip_strategy = "none".to_string();
    tuning.disable_publish = true;

    // This is gonna get dropped at the end of this fn.
    let tmpdir = tempfile::TempDir::new().unwrap();
    let mut network = KitsuneP2pConfig::mem();
    network.tuning_params = Arc::new(tuning);
    let config = ConductorConfig {
        network,
        data_root_path: Some(tmpdir.path().to_path_buf().into()),
        ..Default::default()
    };
    let mut conductor = SweetConductor::from_config(config).await;

    let apps = conductor
        .setup_apps("app", num_agents, [&dna_file])
        .await
        .unwrap();

    let cells = apps.cells_flattened();
    let mut entries = entries.into_iter();
    let entries = entries.by_ref();
    for (i, cell) in cells.iter().enumerate() {
        eprintln!("Calling {}", i);
        let e = entries.take(approx_num_ops_held).collect::<Vec<_>>();
        conductor
            .call::<_, ()>(&cell.zome("zome1"), "create_many", e)
            .await;
    }
    let mut authored = HashMap::new();
    let mut ops = HashMap::new();
    for (i, cell) in cells.iter().enumerate() {
        eprintln!("Extracting data {}", i);
        let db = cell.authored_db().clone();
        let data = db
            .read_async({
                let agent_pk = cell.agent_pubkey().clone();
                move |txn| -> DatabaseResult<HashMap<Arc<DhtOpHash>, ChainOpHashed>> {
                    Ok(get_authored_chain_ops(txn, &agent_pk))
                }
            })
            .await
            .unwrap();
        let hashes = data.keys().cloned().collect::<Vec<_>>();
        authored.insert(Arc::new(cell.agent_pubkey().clone()), hashes);
        ops.extend(data);
    }

    let peer_data = conductor.get_agent_infos(None).await.unwrap();

    GeneratedData {
        integrity_uuid,
        coordinator_uuid,
        peer_data,
        authored,
        ops,
    }
}

/// Set the peers to seem like they come from separate nodes and have accurate storage arcs.
async fn reset_peer_data(peers: Vec<AgentInfoSigned>, dna_hash: &DnaHash) -> Vec<AgentInfoSigned> {
    let coverage = ((50.0 / peers.len() as f64) * 2.0).clamp(0.0, 1.0);
    let space_hash = dna_hash.to_kitsune();
    let mut peer_data = Vec::with_capacity(peers.len());
    let rng = rand::thread_rng();
    let mut rand_string = rng.sample_iter(&Alphanumeric);
    let rand_string = rand_string.by_ref();
    for peer in peers {
        let rand_string: String = rand_string.take(16).map(char::from).collect();
        let info = AgentInfoSigned::sign(
            space_hash.clone(),
            peer.agent.clone(),
            ArqSize::from_half_len(((u32::MAX / 2) as f64 * coverage) as u32),
            vec![url2::url2!(
                "kitsune-proxy://CIW6PxKxs{}MSmB7kLD8xyyj4mqcw/kitsune-quic/h/localhost/p/5778/-",
                rand_string
            )
            .into()],
            peer.signed_at_ms,
            (std::time::UNIX_EPOCH.elapsed().unwrap() + std::time::Duration::from_secs(60_000_000))
                .as_millis() as u64,
            |_| async move { Ok(Arc::new(fixt!(KitsuneSignature, Predictable))) },
        )
        .await
        .unwrap();
        peer_data.push(info);
    }
    peer_data
}

fn get_chain_ops(txn: &mut Transaction<'_>) -> HashMap<Arc<DhtOpHash>, ChainOpHashed> {
    txn.prepare(
        "
                SELECT DhtOp.hash, DhtOp.type AS dht_type,
                Action.blob AS action_blob, Entry.blob AS entry_blob
                FROM DhtOp
                JOIN Action ON DhtOp.action_hash = Action.hash
                LEFT JOIN Entry ON Action.entry_hash = Entry.hash
            ",
    )
    .unwrap()
    .query_map([], |row| {
        let op_type: ChainOpType = row.get("dht_type")?;
        let action = from_blob::<SignedAction>(row.get("action_blob")?).unwrap();
        let hash: DhtOpHash = row.get("hash")?;
        // Check the entry isn't private before gossiping it.
        let e: Option<Vec<u8>> = row.get("entry_blob")?;
        let entry = e.map(|entry| from_blob::<Entry>(entry).unwrap());
        let op = ChainOp::from_type(op_type, action, entry).unwrap();
        let op = ChainOpHashed::with_pre_hashed(op, hash.clone());
        Ok((Arc::new(hash), op))
    })
    .unwrap()
    .collect::<Result<HashMap<_, _>, _>>()
    .unwrap()
}

fn get_authored_chain_ops(
    txn: &Transaction<'_>,
    author: &AgentPubKey,
) -> HashMap<Arc<DhtOpHash>, ChainOpHashed> {
    txn.prepare(
        "
                SELECT DhtOp.hash, DhtOp.type AS dht_type,
                Action.blob AS action_blob, Entry.blob AS entry_blob
                FROM DHtOp
                JOIN Action ON DhtOp.action_hash = Action.hash
                LEFT JOIN Entry ON Action.entry_hash = Entry.hash
                WHERE
                Action.author = ?
            ",
    )
    .unwrap()
    .query_map([author], |row| {
        let op_type: ChainOpType = row.get("dht_type")?;
        let action = from_blob::<SignedAction>(row.get("action_blob")?).unwrap();
        let hash: DhtOpHash = row.get("hash")?;
        // Check the entry isn't private before gossiping it.
        let e: Option<Vec<u8>> = row.get("entry_blob")?;
        let entry = e.map(|entry| from_blob::<Entry>(entry).unwrap());
        let op = ChainOp::from_type(op_type, action, entry).unwrap();
        let op = ChainOpHashed::with_pre_hashed(op, hash.clone());
        Ok((Arc::new(hash), op))
    })
    .unwrap()
    .collect::<Result<HashMap<_, _>, _>>()
    .unwrap()
}

/// The zome to use for this simulation.
/// Currently this is a limitation of this prototype that
/// you must use the data generation zome in the actual simulation
/// so the Dna record matches.
/// Hopefully this limitation can be overcome in the future.
pub async fn data_zome(integrity_uuid: String, coordinator_uuid: String) -> DnaFile {
    let integrity_zome_name = "integrity_zome1";
    let coordinator_zome_name = "zome1";

    let zomes = InlineZomeSet::new(
        [(
            integrity_zome_name,
            integrity_uuid.clone(),
            InlineEntryTypes::entry_defs(),
            0,
        )],
        [(coordinator_zome_name, coordinator_uuid)],
    )
    .function(
        coordinator_zome_name,
        "create_many",
        move |api, entries: Vec<Entry>| {
            for entry in entries {
                api.create(CreateInput::new(
                    InlineZomeSet::get_entry_location(&api, InlineEntryTypes::A),
                    EntryVisibility::Public,
                    entry,
                    ChainTopOrdering::default(),
                ))?;
            }
            Ok(())
        },
    )
    .function(coordinator_zome_name, "read", |api, hash: ActionHash| {
        api.get(vec![GetInput::new(hash.into(), GetOptions::default())])
            .map(|e| e.into_iter().next().unwrap())
            .map_err(Into::into)
    });
    let (dna_file, _, _) = SweetDnaFile::from_inline_zomes(integrity_uuid, zomes).await;
    dna_file
}



================================================
File: crates/holochain/src/test_utils/wait_for.rs
================================================
#![allow(missing_docs)]
use std::time::Duration;

#[macro_export]
macro_rules! wait_for {
    ($wait:expr, $test:expr, $check:expr, $assert:expr) => {{
        let mut w = $wait;
        let assert = $assert;
        loop {
            let o = $test;
            let check = $check;
            if !w.wait_any().await || check(&o) {
                assert(o);
                break;
            }
        }
    }};
}

#[macro_export]
macro_rules! wait_for_10s {
    ($test:expr, $check:expr, $assert:expr) => {{
        let wait_for = $crate::test_utils::WaitFor::ten_s();
        $crate::wait_for!(wait_for, $test, $check, $assert)
    }};
}

#[macro_export]
macro_rules! wait_for_1m {
    ($test:expr, $check:expr, $assert:expr) => {
        let wait_for = $crate::test_utils::WaitFor::one_m();
        $crate::wait_for!(wait_for, $test, $check, $assert)
    };
}

#[macro_export]
macro_rules! assert_retry {
    ($wait:expr, $test:expr $(, $reason:literal)?) => {
        $crate::wait_for!($wait, $test, |x: &bool| *x, |x: bool| assert!(x $(, $reason)?))
    };
}

#[macro_export]
macro_rules! assert_eq_retry {
    ($wait:expr, $test:expr, $check:expr $(, $reason:literal)?) => {
        $crate::wait_for!($wait, $test, |x| x == &$check, |x| assert_eq!(x, $check $(, $reason)?))
    };
}

#[macro_export]
macro_rules! assert_retry_10s {
    ($test:expr $(, $reason:literal)? $(,)?) => {
        let wait_for = $crate::test_utils::WaitFor::ten_s();
        $crate::assert_retry!(wait_for, $test  $(, $reason:literal)?)
    };
}

#[macro_export]
macro_rules! assert_eq_retry_10s {
    ($test:expr, $check:expr $(, $reason:literal)? $(,)?) => {
        let wait_for = $crate::test_utils::WaitFor::ten_s();
        $crate::assert_eq_retry!(wait_for, $test, $check  $(, $reason:literal)?)
    };
}

#[macro_export]
macro_rules! assert_retry_1m {
    ($test:expr $(, $reason:literal)? $(,)?) => {
        let wait_for = $crate::test_utils::WaitFor::one_m();
        $crate::assert_retry!(wait_for, $test $(, $reason:literal)?)
    };
}

#[macro_export]
macro_rules! assert_eq_retry_1m {
    ($test:expr, $check:expr $(, $reason:literal)? $(,)?) => {
        let wait_for = $crate::test_utils::WaitFor::one_m();
        $crate::assert_eq_retry!(wait_for, $test, $check  $(, $reason:literal)?)
    };
}

#[macro_export]
macro_rules! assert_eq_retry_5m {
    ($test:expr, $check:expr $(, $reason:literal)? $(,)?) => {
        let wait_for = $crate::test_utils::WaitFor::five_m();
        $crate::assert_eq_retry!(wait_for, $test, $check  $(, $reason:literal)?)
    };
}

#[derive(Debug, Clone)]
/// Generic waiting for some test property to
/// be true. This allows early exit from waiting when
/// the condition becomes true but will wait up to a
/// maximum if the condition is not true.
pub struct WaitFor {
    num_attempts: u32,
    attempt: u32,
    delay: Duration,
}

impl WaitFor {
    /// Create a new wait for from a number of attempts and delay in between attempts
    pub fn new(total: Duration, num_attempts: u32) -> Self {
        Self {
            num_attempts,
            attempt: 0,
            delay: total / num_attempts,
        }
    }

    /// Wait for 1s checking every 100ms.
    pub fn one_s() -> Self {
        Self::new(std::time::Duration::from_secs(1), 10)
    }

    /// Wait for 10s checking every 100ms.
    pub fn ten_s() -> Self {
        Self::new(std::time::Duration::from_secs(10), 100)
    }

    /// Wait for 1 minute checking every 500ms.
    pub fn one_m() -> Self {
        Self::new(std::time::Duration::from_secs(60), 120)
    }

    /// Wait for 5 minutes checking every 1000ms.
    pub fn five_m() -> Self {
        Self::new(std::time::Duration::from_secs(5 * 60), 5 * 60)
    }

    /// Wait for some time before trying again.
    /// Will return false when you should stop waiting.
    #[cfg_attr(feature = "instrument", tracing::instrument(skip(self)))]
    pub async fn wait_any(&mut self) -> bool {
        if self.attempt >= self.num_attempts {
            return false;
        }
        self.attempt += 1;
        tracing::debug!(attempt = ?self.attempt, out_of = ?self.num_attempts, delaying_for = ?self.delay);
        tokio::time::sleep(self.delay).await;
        true
    }
}

#[tokio::test]
async fn wait_for_tests() {
    wait_for!(WaitFor::one_s(), true, |&x| x, |x: bool| assert!(x));
    wait_for!(WaitFor::one_s(), false, |&x| x, |x: bool| assert!(!x));
}



================================================
File: crates/holochain/src/test_utils/hc_stress_test/local_behavior_1.rs
================================================
use super::*;

const B1_SYNC_TIME: std::time::Duration = std::time::Duration::from_secs(120);

struct Loc1PubData {
    pub_time: std::time::Instant,
    author: usize,
    found_shallow: std::collections::HashSet<usize>,
    found_full: std::collections::HashSet<usize>,
}

/// Local Behavior 1
/// - small means 32 bytes to 1024 bytes
/// - large means 1 MiB to 3 MiB
/// - starts conductors in sequence on a 2 s interval:
///   - 1 null node that shuts down after ~30 s
///   - 1 full query large publisher, pub every ~5 m, query every ~15 s
///   - 1 full query small publisher, pub every ~1 m, query every ~15 s
///   - 1 shallow query small publisher, pub every ~1 m, query every ~15 s
///   - 1 small single publisher that shuts down after ~3 m
///   - 1 large single publisher that shuts down after ~3 m
/// - starts additional nodes on 1 m intervals:
///   - shallow query only node that shuts down after ~3 m, query every ~15 s
pub struct LocalBehavior1 {
    runner: Option<HcStressTestRunner<Self>>,

    start_at: std::time::Instant,

    large_publish_count: usize,
    small_publish_count: usize,

    shallow_found_in_time: usize,
    shallow_found_later: usize,

    full_found_in_time: usize,
    full_found_later: usize,

    // this should only include nodes that run shallow or full queries
    shallow_validate_nodes: std::collections::HashMap<usize, std::time::Instant>,
    // this should only include nodes that run full queries
    full_validate_nodes: std::collections::HashMap<usize, std::time::Instant>,

    pub_data: std::collections::HashMap<ActionHash, Loc1PubData>,
}

impl std::fmt::Debug for LocalBehavior1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("LocalBehavior1")
            .field("runtime", &self.start_at.elapsed())
            .field("large_publish_count", &self.large_publish_count)
            .field("small_publish_count", &self.small_publish_count)
            .field("shallow_found_in_time", &self.shallow_found_in_time)
            .field("shallow_found_later", &self.shallow_found_later)
            .field("full_found_in_time", &self.full_found_in_time)
            .field("full_found_later", &self.full_found_later)
            .finish()
    }
}

impl Report for LocalBehavior1 {
    fn spawn(&mut self, _node_id: usize) {}

    fn shutdown(&mut self, node_id: usize, _runtime: std::time::Duration) {
        self.validate();
        self.shallow_validate_nodes.remove(&node_id);
        self.full_validate_nodes.remove(&node_id);
    }

    fn publish(
        &mut self,
        node_id: usize,
        _runtime: std::time::Duration,
        byte_count: usize,
        hash: ActionHash,
    ) {
        if byte_count > 1024 {
            self.large_publish_count += 1;
        } else {
            self.small_publish_count += 1;
        }
        self.pub_data.insert(
            hash,
            Loc1PubData {
                pub_time: std::time::Instant::now(),
                author: node_id,
                found_shallow: std::collections::HashSet::new(),
                found_full: std::collections::HashSet::new(),
            },
        );
    }

    fn fetch_shallow(
        &mut self,
        node_id: usize,
        _runtime: std::time::Duration,
        hash_list: Vec<ActionHash>,
    ) {
        for hash in hash_list {
            if let Some(pub_data) = self.pub_data.get_mut(&hash) {
                if node_id != pub_data.author && pub_data.found_shallow.insert(node_id) {
                    if pub_data.pub_time.elapsed() > B1_SYNC_TIME {
                        self.shallow_found_later += 1;
                    } else {
                        self.shallow_found_in_time += 1;
                    }
                }
            }
        }
    }

    fn fetch_full(&mut self, node_id: usize, _runtime: std::time::Duration, hash: ActionHash) {
        if let Some(pub_data) = self.pub_data.get_mut(&hash) {
            if node_id != pub_data.author && pub_data.found_full.insert(node_id) {
                if pub_data.pub_time.elapsed() > B1_SYNC_TIME {
                    self.full_found_later += 1;
                } else {
                    self.full_found_in_time += 1;
                }
            }
        }
    }
}

impl LocalBehavior1 {
    /// LocalBehavior1 Constructor.
    pub fn new() -> Arc<Mutex<Self>> {
        let this = Arc::new(Mutex::new(Self {
            runner: None,
            start_at: std::time::Instant::now(),
            large_publish_count: 0,
            small_publish_count: 0,
            shallow_found_in_time: 0,
            shallow_found_later: 0,
            full_found_in_time: 0,
            full_found_later: 0,
            shallow_validate_nodes: std::collections::HashMap::new(),
            full_validate_nodes: std::collections::HashMap::new(),
            pub_data: std::collections::HashMap::new(),
        }));

        let runner = HcStressTestRunner::new(this.clone());
        this.lock().unwrap().runner = Some(runner);

        {
            let this = this.clone();
            tokio::task::spawn(async move {
                let network_seed = random_network_seed();
                let rendezvous = SweetLocalRendezvous::new().await;

                println!("spawn 1 null node that shuts down after ~30 s");
                let node = loc_test_conductor(network_seed.clone(), rendezvous.clone()).await;
                this.lock().unwrap().runner.as_ref().unwrap().add_node(
                    node,
                    SHUTDOWN_30_S,
                    vec![(0, BehaviorPublish::None)],
                    vec![(0, BehaviorQuery::None)],
                );

                tokio::time::sleep(std::time::Duration::from_secs(2)).await;

                println!("spawn 1 full query large publisher, pub every ~5 m, query every ~15 s");
                let node = loc_test_conductor(network_seed.clone(), rendezvous.clone()).await;
                let node_id = this.lock().unwrap().runner.as_ref().unwrap().add_node(
                    node,
                    BehaviorLifetime::Forever,
                    vec![(0, PUBLISH_LARGE_5_M)],
                    vec![(0, QUERY_FULL_15_S)],
                );
                this.lock()
                    .unwrap()
                    .shallow_validate_nodes
                    .insert(node_id, std::time::Instant::now());
                this.lock()
                    .unwrap()
                    .full_validate_nodes
                    .insert(node_id, std::time::Instant::now());

                tokio::time::sleep(std::time::Duration::from_secs(2)).await;

                println!("spawn 1 full query small publisher, pub every ~1 m, query every ~15 s");
                let node = loc_test_conductor(network_seed.clone(), rendezvous.clone()).await;
                let node_id = this.lock().unwrap().runner.as_ref().unwrap().add_node(
                    node,
                    BehaviorLifetime::Forever,
                    vec![(0, PUBLISH_SMALL_1_M)],
                    vec![(0, QUERY_FULL_15_S)],
                );
                this.lock()
                    .unwrap()
                    .shallow_validate_nodes
                    .insert(node_id, std::time::Instant::now());
                this.lock()
                    .unwrap()
                    .full_validate_nodes
                    .insert(node_id, std::time::Instant::now());

                tokio::time::sleep(std::time::Duration::from_secs(2)).await;

                println!(
                    "spawn 1 shallow query small publisher, pub every ~1 m, query every ~15 s"
                );
                let node = loc_test_conductor(network_seed.clone(), rendezvous.clone()).await;
                let node_id = this.lock().unwrap().runner.as_ref().unwrap().add_node(
                    node,
                    BehaviorLifetime::Forever,
                    vec![(0, PUBLISH_SMALL_1_M)],
                    vec![(0, QUERY_SHALLOW_15_S)],
                );
                this.lock()
                    .unwrap()
                    .shallow_validate_nodes
                    .insert(node_id, std::time::Instant::now());

                tokio::time::sleep(std::time::Duration::from_secs(2)).await;

                println!("spawn 1 small single publisher that shuts down after ~3 m");
                let node = loc_test_conductor(network_seed.clone(), rendezvous.clone()).await;
                this.lock().unwrap().runner.as_ref().unwrap().add_node(
                    node,
                    SHUTDOWN_3_M,
                    vec![(0, PUBLISH_SMALL_SINGLE)],
                    vec![(0, BehaviorQuery::None)],
                );

                tokio::time::sleep(std::time::Duration::from_secs(2)).await;

                println!("spawn 1 large single publisher that shuts down after ~3 m");
                let node = loc_test_conductor(network_seed.clone(), rendezvous.clone()).await;
                this.lock().unwrap().runner.as_ref().unwrap().add_node(
                    node,
                    SHUTDOWN_3_M,
                    vec![(0, PUBLISH_LARGE_SINGLE)],
                    vec![(0, BehaviorQuery::None)],
                );

                loop {
                    for _ in 0..6 {
                        tokio::time::sleep(std::time::Duration::from_secs(30)).await;
                        this.lock().unwrap().validate();
                    }

                    println!("spawn shallow query only node that shuts down after ~3 m, query every ~15 s");
                    let node = loc_test_conductor(network_seed.clone(), rendezvous.clone()).await;
                    let node_id = this.lock().unwrap().runner.as_ref().unwrap().add_node(
                        node,
                        SHUTDOWN_3_M,
                        vec![(0, BehaviorPublish::None)],
                        vec![(0, QUERY_SHALLOW_15_S)],
                    );
                    this.lock()
                        .unwrap()
                        .shallow_validate_nodes
                        .insert(node_id, std::time::Instant::now());
                }
            });
        }

        this
    }

    fn validate(&mut self) {
        // first make sure everything that has been published
        // has been seen shalowly by at least one non-authoring node
        for (_, pub_data) in self.pub_data.iter() {
            if pub_data.pub_time.elapsed() > B1_SYNC_TIME
                && (pub_data.found_shallow.is_empty() || pub_data.found_full.is_empty())
            {
                panic!("published item was not queried by anyone in {B1_SYNC_TIME:?}!");
            }
        }

        // now go through and ensure all querying nodes
        // can see everything they didn't publish,
        // so long as they have been online for at least sync time

        for (node_id, online) in self.shallow_validate_nodes.iter() {
            if online.elapsed() < B1_SYNC_TIME {
                continue;
            }

            for (hash, pub_data) in self.pub_data.iter() {
                if pub_data.pub_time.elapsed() > B1_SYNC_TIME
                    && pub_data.author != *node_id
                    && !pub_data.found_shallow.contains(node_id)
                {
                    panic!(
                        "node {node_id} could not shallow discover {hash} within {B1_SYNC_TIME:?}"
                    );
                }
            }
        }

        for (node_id, online) in self.full_validate_nodes.iter() {
            if online.elapsed() < B1_SYNC_TIME {
                continue;
            }

            for (hash, pub_data) in self.pub_data.iter() {
                if pub_data.pub_time.elapsed() > B1_SYNC_TIME
                    && pub_data.author != *node_id
                    && !pub_data.found_full.contains(node_id)
                {
                    panic!("node {node_id} could not full get {hash} within {B1_SYNC_TIME:?}");
                }
            }
        }
    }
}

async fn loc_test_conductor(network_seed: String, rendezvous: DynSweetRendezvous) -> HcStressTest {
    let config = SweetConductorConfig::rendezvous(true);
    let conductor = SweetConductor::from_config_rendezvous(config, rendezvous).await;
    let dna = HcStressTest::test_dna(network_seed).await;
    HcStressTest::new(conductor, &[dna]).await
}



================================================
File: crates/holochain/src/test_utils/hc_stress_test/local_behavior_2.rs
================================================
use super::*;

/// LocalBehavior2 was largely specified by the Holo team.
/// The target is 10 DNAs each run by 70 nodes for 3 weeks with
/// initial entry / link creation and occasional bursts of
/// additional entry / link creation.
/// Then only a handful of the dnas making any requests
/// roughly every 5 minutes.
/// We can't really run 700 dnas on one local system,
/// so this behavior will allow configuring that amount.
pub struct LocalBehavior2 {
    runner: Option<HcStressTestRunner<Self>>,

    start_at: std::time::Instant,

    total_publish_count: usize,
    total_shallow_fetch_count: usize,
    total_full_fetch_count: usize,
}

impl std::fmt::Debug for LocalBehavior2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("LocalBehavior2")
            .field("runtime", &self.start_at.elapsed())
            .field("total_publish_count", &self.total_publish_count)
            .field("total_shallow_fetch_count", &self.total_shallow_fetch_count)
            .field("total_full_fetch_count", &self.total_full_fetch_count)
            .finish()
    }
}

impl Report for LocalBehavior2 {
    fn spawn(&mut self, _node_id: usize) {}

    fn shutdown(&mut self, _node_id: usize, _runtime: std::time::Duration) {}

    fn publish(
        &mut self,
        _node_id: usize,
        _runtime: std::time::Duration,
        _byte_count: usize,
        _hash: ActionHash,
    ) {
        self.total_publish_count += 1;
    }

    fn fetch_shallow(
        &mut self,
        _node_id: usize,
        _runtime: std::time::Duration,
        hash_list: Vec<ActionHash>,
    ) {
        self.total_shallow_fetch_count += hash_list.len();
    }

    fn fetch_full(&mut self, _node_id: usize, _runtime: std::time::Duration, _hash: ActionHash) {
        self.total_full_fetch_count += 1;
    }
}

impl LocalBehavior2 {
    /// LocalBehavior2 Constructor.
    pub fn new(dna_count: u8, node_count: u8) -> Arc<Mutex<Self>> {
        let this = Arc::new(Mutex::new(Self {
            runner: None,
            start_at: std::time::Instant::now(),
            total_publish_count: 0,
            total_shallow_fetch_count: 0,
            total_full_fetch_count: 0,
        }));

        let runner = HcStressTestRunner::new(this.clone());
        this.lock().unwrap().runner = Some(runner);

        {
            let this = this.clone();

            tokio::task::spawn(async move {
                let mut dna_files = Vec::new();
                for _ in 0..dna_count {
                    dna_files.push(HcStressTest::test_dna(random_network_seed()).await);
                }

                let rendezvous = SweetLocalRendezvous::new().await;

                for i in 0..node_count {
                    println!("spawn node {}/{node_count} with {dna_count} DNAs", i + 1,);

                    let node = loc_test_conductor(&dna_files, rendezvous.clone()).await;

                    let mut pub_behavior = Vec::new();
                    let mut query_behavior = Vec::new();

                    for cell in 0..dna_count {
                        if cell == 0 {
                            pub_behavior.push((
                                cell,
                                BehaviorPublish::Publish {
                                    byte_count_min: 1024,
                                    byte_count_max: 4096,
                                    publish_count: None,
                                    wait_min: std::time::Duration::from_secs(60 * 60 * 24 * 2),
                                    wait_max: std::time::Duration::from_secs(60 * 60 * 24 * 3),
                                },
                            ));
                        } else {
                            pub_behavior.push((
                                cell,
                                BehaviorPublish::Publish {
                                    byte_count_min: 1024,
                                    byte_count_max: 4096,
                                    publish_count: Some(1),
                                    wait_min: std::time::Duration::from_secs(20),
                                    wait_max: std::time::Duration::from_secs(60),
                                },
                            ));
                        }
                        query_behavior.push((
                            cell,
                            BehaviorQuery::Full {
                                wait_min: std::time::Duration::from_secs(60 * 4),
                                wait_max: std::time::Duration::from_secs(60 * 6),
                            },
                        ));
                    }

                    this.lock().unwrap().runner.as_ref().unwrap().add_node(
                        node,
                        BehaviorLifetime::Forever,
                        pub_behavior,
                        query_behavior,
                    );

                    // take some time to start up,
                    // booting holochain is very CPU intensive.
                    tokio::time::sleep(std::time::Duration::from_secs(20)).await;
                }
            });
        }

        this
    }
}

async fn loc_test_conductor(dna_files: &[DnaFile], rendezvous: DynSweetRendezvous) -> HcStressTest {
    let config = SweetConductorConfig::rendezvous(true);
    let conductor = SweetConductor::from_config_rendezvous(config, rendezvous).await;
    HcStressTest::new(conductor, dna_files).await
}



================================================
File: crates/holochain/src/test_utils/test_conductor/test_handle.rs
================================================
//! A wrapper around ConductorHandle with more convenient methods for testing
// TODO [ B-03669 ] move to own crate

use super::test_cell::TestCell;
use crate::conductor::api::ZomeCall;
use crate::conductor::handle::ConductorHandle;
use crate::core::ribosome::ZomeCallInvocation;
use hdk::prelude::*;
use holochain_types::prelude::*;
use unwrap_to::unwrap_to;

/// A wrapper around ConductorHandle with more convenient methods for testing.
#[derive(Clone, shrinkwraprs::Shrinkwrap, derive_more::From)]
pub struct TestConductorHandle(pub(crate) ConductorHandle);

impl TestConductorHandle {
    /// Opinionated app setup. Creates one app per agent, using the given DnaFiles.
    ///
    /// All InstalledAppIds and RoleNames are auto-generated. In tests driven directly
    /// by Rust, you typically won't care what these values are set to, but in case you
    /// do, they are set as so:
    /// - InstalledAppId: {app_id_prefix}-{agent_pub_key}
    /// - RoleName: {dna_hash}
    ///
    /// Returns the list of generated InstalledAppIds, in the same order as Agents passed in.
    pub async fn setup_app_for_agents_with_no_membrane_proof(
        &self,
        app_id_prefix: &str,
        agents: &[AgentPubKey],
        dna_files: &[DnaFile],
    ) -> SetupOutput {
        for dna_file in dna_files {
            self.0
                .register_dna(dna_file.clone())
                .await
                .expect("Could not install DNA")
        }

        let mut info = Vec::new();

        for agent in agents {
            let installed_app_id = format!("{}{}", app_id_prefix, agent);
            let cell_ids: Vec<TestCell> = dna_files
                .iter()
                .map(|f| CellId::new(f.dna_hash().clone(), agent.clone()))
                .map(|cell_id| TestCell {
                    cell_id,
                    handle: self.clone(),
                })
                .collect();
            let cells = cell_ids
                .iter()
                .map(|cell| {
                    (
                        InstalledCell::new(
                            cell.cell_id().clone(),
                            format!("{}", cell.cell_id().dna_hash()),
                        ),
                        None,
                    )
                })
                .collect();
            self.0
                .clone()
                .install_app(installed_app_id.clone(), cells)
                .await
                .expect("Could not install app");
            info.push((installed_app_id, cell_ids));
        }

        for (installed_app_id, _) in info.iter() {
            self.0
                .activate_app(installed_app_id.clone())
                .await
                .expect("Could not activate app");
        }

        self.0
            .clone()
            .setup_cells()
            .await
            .expect("Could not setup cells");

        info
    }
}

/// Return type of opinionated setup function
pub type SetupOutput = Vec<(InstalledAppId, Vec<TestCell>)>;

/// Helper to destructure the nested app setup return value as nested tuples.
/// Each level of nesting can contain 1-4 items, i.e. up to 4 agents with 4 DNAs each.
/// Beyond 4, and this will PANIC! (But it's just for tests so it's fine.)
#[macro_export]
macro_rules! destructure_test_cells {
    ($blob:expr) => {{
        use $crate::test_utils::itertools::Itertools;
        let blob: $crate::test_utils::test_conductor::SetupOutput = $blob;
        blob.into_iter()
            .map(|(_, v)| {
                v.into_iter()
                    .collect_tuple()
                    .expect("Wrong number of DNAs in destructuring pattern, or too many (must be 4 or less)")
            })
            .collect_tuple()
            .expect("Wrong number of Agents in destructuring pattern, or too many (must be 4 or less)")
    }};
}
#[macro_export]
macro_rules! destructure_test_cell_vec {
    ($vec:expr) => {{
        use $crate::test_utils::itertools::Itertools;
        let vec: Vec<$crate::test_utils::test_conductor::SetupOutput> = $vec;
        vec.into_iter()
            .map(|blob| destructure_test_cells!(blob))
            .collect_tuple()
            .expect("Wrong number of Conductors in destructuring pattern, or too many (must be 4 or less)")
    }};
}

impl TestConductorHandle {
    /// Call a zome function with automatic de/serialization of input and output
    /// and unwrapping of nested errors.
    pub async fn call_zome_ok<'a, I, O, F, E>(&'a self, invocation: TestZomeCall<'a, I, F, E>) -> O
    where
        E: std::fmt::Debug,
        FunctionName: From<F>,
        SerializedBytes: TryFrom<I, Error = E>,
        O: TryFrom<SerializedBytes, Error = E> + std::fmt::Debug,
    {
        let response = self.0.call_zome(invocation.into()).await.unwrap().unwrap();
        unwrap_to!(response => ZomeCallResponse::Ok)
            .clone()
            .into_inner()
            .try_into()
            .expect("Couldn't deserialize zome call output")
    }

    /// `call_zome_ok`, but with arguments provided individually
    pub async fn call_zome_ok_flat<I, O, Z, F>(
        &self,
        cell_id: &CellId,
        zome_name: Z,
        fn_name: F,
        cap_secret: Option<CapSecret>,
        provenance: Option<AgentPubKey>,
        payload: I,
    ) -> O
    where
        ZomeName: From<Z>,
        FunctionName: From<F>,
        I: Serialize,
        O: DeserializeOwned + std::fmt::Debug,
    {
        let payload = ExternIO::encode(payload).expect("Couldn't serialize payload");
        let provenance = provenance.unwrap_or_else(|| cell_id.agent_pubkey().clone());
        let call = ZomeCall {
            cell_id: cell_id.clone(),
            zome_name: zome_name.into(),
            fn_name: fn_name.into(),
            cap_secret,
            provenance,
            payload,
        };
        let response = self.0.call_zome(call).await.unwrap().unwrap();
        unwrap_to!(response => ZomeCallResponse::Ok)
            .decode()
            .expect("Couldn't deserialize zome call output")
    }
}

/// A top-level call into a zome function,
/// i.e. coming from outside the Cell from an external Interface
#[derive(Clone, Debug)]
pub struct TestZomeCall<'a, P, F, E>
where
    SerializedBytes: TryFrom<P, Error = E>,
    E: std::fmt::Debug,
    FunctionName: From<F>,
{
    /// The Id of the `Cell` in which this Zome-call would be invoked
    pub cell_id: &'a CellId,
    /// The Zome containing the function that would be invoked
    pub zome: &'a Zome,
    /// The capability request authorization.
    /// This can be `None` and still succeed in the case where the function
    /// in the zome being called has been given an Unrestricted status
    /// via a `CapGrant`. Otherwise, it will be necessary to provide a `CapSecret` for every call.
    pub cap_secret: Option<CapSecret>,
    /// The name of the Zome function to call
    pub fn_name: F,
    /// The data to be serialized and passed as an argument to the Zome call
    pub payload: P,
    /// If None, the AgentPubKey from the CellId is used (a common case)
    pub provenance: Option<AgentPubKey>,
}

impl<'a, P, F> From<TestZomeCall<'a, P, F>> for ZomeCallInvocation
where
    P: Serialize,
    FunctionName: From<F>,
{
    fn from(tzci: TestZomeCall<'a, P, F>) -> Self {
        let TestZomeCall {
            cell_id,
            zome,
            fn_name,
            cap_secret,
            provenance,
            payload,
        } = tzci;
        let payload = ExternIO::encode(payload).expect("Couldn't serialize payload");
        let provenance = provenance.unwrap_or_else(|| cell_id.agent_pubkey().clone());
        ZomeCallInvocation {
            cell_id: cell_id.clone(),
            zome: zome.clone(),
            fn_name: fn_name.into(),
            cap_secret,
            provenance,
            payload,
        }
    }
}

impl<'a, P, F, E> From<TestZomeCall<'a, P, F, E>> for ZomeCall
where
    SerializedBytes: TryFrom<P, Error = E>,
    E: std::fmt::Debug,
    FunctionName: From<F>,
{
    fn from(tzci: TestZomeCall<'a, P, F, E>) -> Self {
        ZomeCallInvocation::from(tzci).into()
    }
}



================================================
File: crates/holochain/tests/integration.rs
================================================
//! Linking holochain integration tests is SLOW
//! Put them all in the same binary so we only have to do it once.

mod tests;



================================================
File: crates/holochain/tests/tests/agent_activity.rs
================================================
use holo_hash::ActionHash;
use holochain::sweettest::{await_consistency, SweetConductorBatch, SweetDnaFile};
use holochain_wasm_test_utils::TestWasm;
use holochain_zome_types::prelude::AgentActivity;
use holochain_zome_types::query::ChainStatus;
use matches::assert_matches;

#[tokio::test(flavor = "multi_thread")]
async fn get_agent_activity() {
    holochain_trace::test_run();

    let mut conductor_batch = SweetConductorBatch::from_standard_config_rendezvous(2).await;

    let (dna, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::Crd]).await;

    let cells = conductor_batch
        .setup_app("alice", [&dna])
        .await
        .unwrap()
        .cells_flattened();

    let alice_cell = cells.first().unwrap();
    let bob_cell = cells.last().unwrap();

    let mut created_hashes = Vec::new();
    for _ in 0..5 {
        let created: ActionHash = conductor_batch[0]
            .call(
                &alice_cell.zome(TestWasm::Crd.coordinator_zome_name()),
                "create",
                (),
            )
            .await;

        created_hashes.push(created);
    }

    // TODO No way to force a network call to get the agent activity, so we have to wait for a sync
    //      first and then check the agent activity
    await_consistency(std::time::Duration::from_secs(60), [alice_cell, bob_cell])
        .await
        .unwrap();

    let agent_activity: AgentActivity = conductor_batch[1]
        .call(
            &bob_cell.zome(TestWasm::Crd.coordinator_zome_name()),
            "get_agent_activity",
            alice_cell.agent_pubkey().clone(),
        )
        .await;

    assert_matches!(agent_activity.status, ChainStatus::Valid(_));
    assert_eq!(4 + 5, agent_activity.valid_activity.len()); // 4 initial + 5 creates
    assert_eq!(
        created_hashes,
        agent_activity
            .valid_activity
            .iter()
            .skip(4)
            .map(|a| a.1.clone())
            .collect::<Vec<_>>()
    );
    assert_eq!(0, agent_activity.rejected_activity.len());
    assert_eq!(
        8,
        agent_activity.highest_observed.clone().unwrap().action_seq
    );
    assert_eq!(
        1,
        agent_activity.highest_observed.clone().unwrap().hash.len()
    );
    assert_eq!(
        created_hashes.last().unwrap(),
        agent_activity
            .highest_observed
            .unwrap()
            .hash
            .first()
            .unwrap()
    );
}



================================================
File: crates/holochain/tests/tests/app_interface_security.rs
================================================
use either::Either;
use holochain::sweettest::{websocket_client_by_port, SweetConductor, SweetDnaFile, WsPollRecv};
use holochain_conductor_api::{
    AdminRequest, AdminResponse, AppAuthenticationRequest, AppAuthenticationToken, AppRequest,
    AppResponse, IssueAppAuthenticationTokenPayload,
};
use holochain_types::prelude::InstalledAppId;
use holochain_types::websocket::AllowedOrigins;
use holochain_wasm_test_utils::TestWasm;
use holochain_websocket::{
    connect, ConnectRequest, ReceiveMessage, WebsocketConfig, WebsocketError,
};
use matches::assert_matches;
use std::net::ToSocketAddrs;
use std::sync::Arc;

#[tokio::test(flavor = "multi_thread")]
async fn app_allowed_origins() {
    holochain_trace::test_run();

    let conductor = SweetConductor::from_standard_config().await;

    let port = conductor
        .clone()
        .add_app_interface(
            either::Either::Left(0),
            "http://localhost:3000".to_string().into(),
            None,
        )
        .await
        .unwrap();

    assert!(connect(
        Arc::new(WebsocketConfig::CLIENT_DEFAULT),
        ConnectRequest::new(
            format!("localhost:{port}")
                .to_socket_addrs()
                .unwrap()
                .next()
                .unwrap()
        )
    )
    .await
    .is_err());

    let token = create_multi_use_token(&conductor, "test-app".into()).await;

    check_app_port(port, "http://localhost:3000", token).await;
}

#[tokio::test(flavor = "multi_thread")]
async fn app_allowed_origins_independence() {
    holochain_trace::test_run();

    let conductor = SweetConductor::from_standard_config().await;

    let token = create_multi_use_token(&conductor, "test-app".into()).await;

    let port_1 = conductor
        .clone()
        .add_app_interface(
            Either::Left(0),
            "http://localhost:3001".to_string().into(),
            None,
        )
        .await
        .unwrap();

    let port_2 = conductor
        .clone()
        .add_app_interface(
            Either::Left(0),
            "http://localhost:3002".to_string().into(),
            None,
        )
        .await
        .unwrap();

    // Check that access to another port's origin is blocked

    assert!(connect(
        Arc::new(WebsocketConfig::CLIENT_DEFAULT),
        ConnectRequest::new(
            format!("localhost:{port_1}")
                .to_socket_addrs()
                .unwrap()
                .next()
                .unwrap()
        )
        .try_set_header("origin", "http://localhost:3002")
        .unwrap()
    )
    .await
    .is_err());

    assert!(connect(
        Arc::new(WebsocketConfig::CLIENT_DEFAULT),
        ConnectRequest::new(
            format!("localhost:{port_2}")
                .to_socket_addrs()
                .unwrap()
                .next()
                .unwrap()
        )
        .try_set_header("origin", "http://localhost:3001")
        .unwrap()
    )
    .await
    .is_err());

    // Check that correct access is allowed

    check_app_port(port_1, "http://localhost:3001", token.clone()).await;
    check_app_port(port_2, "http://localhost:3002", token).await;
}

#[tokio::test(flavor = "multi_thread")]
async fn app_interface_requires_auth() {
    holochain_trace::test_run();

    let conductor = SweetConductor::from_standard_config().await;

    // App interface with no restrictions, but should still require auth
    let app_port = conductor
        .clone()
        .add_app_interface(Either::Left(0), AllowedOrigins::Any, None)
        .await
        .unwrap();

    let (app_tx, app_rx) = websocket_client_by_port(app_port).await.unwrap();
    let _app_rx = WsPollRecv::new::<AppResponse>(app_rx);

    // Try to send a request before authenticating, results in connection closed
    let err = app_tx
        .request::<_, AppResponse>(AppRequest::AppInfo)
        .await
        .unwrap_err();
    assert_matches!(err, WebsocketError::Close(_));

    let token = create_token(&conductor, "test-app".into()).await;

    // Try to authenticate against the connection which is supposed to be closed
    let err = app_tx
        .authenticate(AppAuthenticationRequest {
            token: token.clone(),
        })
        .await
        .unwrap_err();
    assert_matches!(err, WebsocketError::Close(_));

    // Token didn't get used above, so create a new connection and try to use it
    let (app_tx, app_rx) = websocket_client_by_port(app_port).await.unwrap();
    let _app_rx = WsPollRecv::new::<AppResponse>(app_rx);

    app_tx
        .authenticate(AppAuthenticationRequest {
            token: token.clone(),
        })
        .await
        .unwrap();

    // Authentication should have worked, so now we can make requests
    let response: AppResponse = app_tx
        .request(AppRequest::ListWasmHostFunctions)
        .await
        .unwrap();
    assert!(matches!(response, AppResponse::ListWasmHostFunctions(_)));
}

#[tokio::test(flavor = "multi_thread")]
#[cfg_attr(target_os = "macos", ignore = "flaky")]
async fn app_interface_can_handle_bad_auth_payload() {
    holochain_trace::test_run();

    let conductor = SweetConductor::from_standard_config().await;

    let app_port = conductor
        .clone()
        .add_app_interface(Either::Left(0), AllowedOrigins::Any, None)
        .await
        .unwrap();

    let (app_tx, app_rx) = websocket_client_by_port(app_port).await.unwrap();
    let _app_rx = WsPollRecv::new::<AppResponse>(app_rx);

    // Send a payload that is clearly not an authentication request, which should kill the connection
    // but NOT the interface
    app_tx.authenticate(AppRequest::AppInfo).await.unwrap();

    let token = create_token(&conductor, "test-app".into()).await;

    // Try to authenticate against the connection which should be closed
    let err = app_tx
        .authenticate(AppAuthenticationRequest {
            token: token.clone(),
        })
        .await
        .unwrap_err();
    assert_matches!(err, WebsocketError::Close(_));

    // Open a new connection
    let (app_tx, app_rx) = websocket_client_by_port(app_port).await.unwrap();
    let _app_rx = WsPollRecv::new::<AppResponse>(app_rx);

    // Now authenticate properly
    app_tx
        .authenticate(AppAuthenticationRequest {
            token: token.clone(),
        })
        .await
        .unwrap();

    // Authentication should have worked, so now we can make requests
    let response: AppResponse = app_tx
        .request(AppRequest::ListWasmHostFunctions)
        .await
        .unwrap();
    assert!(matches!(response, AppResponse::ListWasmHostFunctions(_)));
}

#[tokio::test(flavor = "multi_thread")]
async fn app_interfaces_can_be_bound_to_apps() {
    holochain_trace::test_run();

    let conductor = SweetConductor::from_standard_config().await;

    // App interface with an app restriction
    let app_port = conductor
        .clone()
        .add_app_interface(
            Either::Left(0),
            AllowedOrigins::Any,
            Some("test-app".to_string()),
        )
        .await
        .unwrap();

    let token = create_token(&conductor, "other-app".into()).await;

    // Try to use the app interface with a token for a different app
    let (app_tx, app_rx) = websocket_client_by_port(app_port).await.unwrap();
    let _app_rx = WsPollRecv::new::<AppResponse>(app_rx);

    // Authentication fails and connection closes but we don't get an error here, have to try to use
    // the connection to see that it's closed.
    app_tx
        .authenticate(AppAuthenticationRequest {
            token: token.clone(),
        })
        .await
        .unwrap();

    let err = app_tx
        .request::<_, AppResponse>(AppRequest::ListWasmHostFunctions)
        .await
        .unwrap_err();
    assert_matches!(err, WebsocketError::Close(_));

    // Now create a token for the correct app and try again
    let token = create_token(&conductor, "test-app".into()).await;

    let (app_tx, app_rx) = websocket_client_by_port(app_port).await.unwrap();
    let _app_rx = WsPollRecv::new::<AppResponse>(app_rx);

    app_tx
        .authenticate(AppAuthenticationRequest {
            token: token.clone(),
        })
        .await
        .unwrap();

    // This authentication should have worked, so make a request to demonstrate that.
    let response: AppResponse = app_tx
        .request(AppRequest::ListWasmHostFunctions)
        .await
        .unwrap();
    assert!(matches!(response, AppResponse::ListWasmHostFunctions(_)));
}

#[tokio::test(flavor = "multi_thread")]
async fn signals_are_not_sent_until_after_auth() {
    holochain_trace::test_run();

    let mut conductor = SweetConductor::from_standard_config().await;

    let (dna_file, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::EmitSignal]).await;

    let app = conductor
        .setup_app("test-app", &[dna_file.clone()])
        .await
        .unwrap();

    // emit a signal
    let _: () = conductor
        .easy_call_zome(
            app.agent(),
            None,
            app.cells().first().unwrap().cell_id().clone(),
            TestWasm::EmitSignal.coordinator_zome_name(),
            "emit",
            (),
        )
        .await
        .unwrap();

    // App interface with an app restriction
    let app_port = conductor
        .clone()
        .add_app_interface(
            Either::Left(0),
            AllowedOrigins::Any,
            Some("test-app".to_string()),
        )
        .await
        .unwrap();

    let (app_tx, mut app_rx) = websocket_client_by_port(app_port).await.unwrap();

    // We should not receive any signals yet
    tokio::time::timeout(std::time::Duration::from_millis(10), async {
        let receive = app_rx.recv::<AppResponse>().await.unwrap();
        panic!("Should not have received anything but got {:?}", receive);
    })
    .await
    .unwrap_err();

    // Now create a token and authenticate
    let token = create_token(&conductor, "test-app".into()).await;

    // Only after authenticating should we be subscribed to signals
    app_tx
        .authenticate(AppAuthenticationRequest {
            token: token.clone(),
        })
        .await
        .unwrap();

    // The original signal is gone, we weren't subscribed yet
    tokio::time::timeout(std::time::Duration::from_millis(10), async {
        let receive = app_rx.recv::<AppResponse>().await.unwrap();
        panic!("Should not have received anything but got {:?}", receive);
    })
    .await
    .unwrap_err();

    // emit another signal
    let _: () = conductor
        .easy_call_zome(
            app.agent(),
            None,
            app.cells().first().unwrap().cell_id().clone(),
            TestWasm::EmitSignal.coordinator_zome_name(),
            "emit",
            (),
        )
        .await
        .unwrap();

    // Now we do get the signal
    let receive = app_rx.recv::<AppResponse>().await.unwrap();
    match receive {
        ReceiveMessage::Signal(_) => (),
        _ => panic!("Expected signal but got {:?}", receive),
    }
}

#[tokio::test(flavor = "multi_thread")]
async fn signals_are_restricted_by_app() {
    holochain_trace::test_run();

    let mut conductor = SweetConductor::from_standard_config().await;

    let (dna_file, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::EmitSignal]).await;

    let app_1 = conductor
        .setup_app("test-app-1", &[dna_file.clone()])
        .await
        .unwrap();

    let _app_2 = conductor
        .setup_app("test-app-2", &[dna_file.clone()])
        .await
        .unwrap();

    // App interface with an app restriction for app 1
    let app_1_port = conductor
        .clone()
        .add_app_interface(
            Either::Left(0),
            AllowedOrigins::Any,
            Some("test-app-1".to_string()),
        )
        .await
        .unwrap();

    // App interface with an app restriction for app 2
    let app_2_port = conductor
        .clone()
        .add_app_interface(
            Either::Left(0),
            AllowedOrigins::Any,
            Some("test-app-2".to_string()),
        )
        .await
        .unwrap();

    // App interface without an app restriction
    let app_3_port = conductor
        .clone()
        .add_app_interface(Either::Left(0), AllowedOrigins::Any, None)
        .await
        .unwrap();

    // Create connections to each interface, with two connections to the interface without an app restriction
    let (app_1_tx, mut app_1_rx) = websocket_client_by_port(app_1_port).await.unwrap();

    let (app_2_tx, mut app_2_rx) = websocket_client_by_port(app_2_port).await.unwrap();

    let (app_3_tx_app_1, mut app_3_rx_app_1) = websocket_client_by_port(app_3_port).await.unwrap();

    let (app_3_tx_app_2, mut app_3_rx_app_2) = websocket_client_by_port(app_3_port).await.unwrap();

    // Authenticate each connection with the appropriate app
    let token_1 = create_token(&conductor, "test-app-1".into()).await;
    app_1_tx
        .authenticate(AppAuthenticationRequest {
            token: token_1.clone(),
        })
        .await
        .unwrap();

    let token_2 = create_token(&conductor, "test-app-2".into()).await;
    app_2_tx
        .authenticate(AppAuthenticationRequest {
            token: token_2.clone(),
        })
        .await
        .unwrap();

    let token_3 = create_token(&conductor, "test-app-1".into()).await;
    app_3_tx_app_1
        .authenticate(AppAuthenticationRequest {
            token: token_3.clone(),
        })
        .await
        .unwrap();

    let token_4 = create_token(&conductor, "test-app-2".into()).await;
    app_3_tx_app_2
        .authenticate(AppAuthenticationRequest {
            token: token_4.clone(),
        })
        .await
        .unwrap();

    // Emit a signal from app 1
    let _: () = conductor
        .easy_call_zome(
            app_1.agent(),
            None,
            app_1.cells().first().unwrap().cell_id().clone(),
            TestWasm::EmitSignal.coordinator_zome_name(),
            "emit",
            (),
        )
        .await
        .unwrap();

    // Now check that the right connections see the signal

    // app_1_rx is connected to the app_1 interface, so should see the signal
    let receive = app_1_rx.recv::<AppResponse>().await.unwrap();
    match receive {
        ReceiveMessage::Signal(_) => (),
        _ => panic!("Expected signal but got {:?}", receive),
    }

    // app_2_rx is connected to the app_2 interface, so should not see the signal
    tokio::time::timeout(std::time::Duration::from_millis(10), async {
        let receive = app_2_rx.recv::<AppResponse>().await.unwrap();
        panic!("Should not have received anything but got {:?}", receive);
    })
    .await
    .unwrap_err();

    // app_3_rx_app_1 is connected to the app_3 which has no restriction but the connection is for
    // app_1 so should see the signal
    let receive = app_3_rx_app_1.recv::<AppResponse>().await.unwrap();
    match receive {
        ReceiveMessage::Signal(_) => (),
        _ => panic!("Expected signal but got {:?}", receive),
    }

    // app_3_rx_app_2 is connected to the app_3 which has no restriction but the connection is for
    // app_2 so should not see the signal
    tokio::time::timeout(std::time::Duration::from_millis(10), async {
        let receive = app_3_rx_app_2.recv::<AppResponse>().await.unwrap();
        panic!("Should not have received anything but got {:?}", receive);
    })
    .await
    .unwrap_err();
}

#[tokio::test(flavor = "multi_thread")]
async fn revoke_app_auth_token() {
    holochain_trace::test_run();

    let conductor = SweetConductor::from_standard_config().await;

    let app_port = conductor
        .clone()
        .add_app_interface(Either::Left(0), AllowedOrigins::Any, None)
        .await
        .unwrap();

    let (app_tx, app_rx) = websocket_client_by_port(app_port).await.unwrap();
    let _app_rx = WsPollRecv::new::<AppResponse>(app_rx);

    // Create a multi-use token
    let token = create_multi_use_token(&conductor, "test-app".into()).await;

    // Demonstrate that the token is valid by connecting, authenticating and sending a request
    app_tx
        .authenticate(AppAuthenticationRequest {
            token: token.clone(),
        })
        .await
        .unwrap();

    let listed: AppResponse = app_tx
        .request(AppRequest::ListWasmHostFunctions)
        .await
        .unwrap();
    assert!(matches!(listed, AppResponse::ListWasmHostFunctions(_)));

    // Now revoke the token, although it would otherwise be valid for another use!
    revoke_token(&conductor, token.clone()).await;

    // Try to connect and authenticate again
    let (app_tx, app_rx) = websocket_client_by_port(app_port).await.unwrap();
    let _app_rx = WsPollRecv::new::<AppResponse>(app_rx);

    app_tx
        .authenticate(AppAuthenticationRequest { token })
        .await
        .unwrap();

    // Authentication should have failed
    let err = app_tx
        .request::<_, AppResponse>(AppRequest::ListWasmHostFunctions)
        .await
        .unwrap_err();
    assert_matches!(err, WebsocketError::Close(_));
}

async fn check_app_port(port: u16, origin: &str, token: AppAuthenticationToken) {
    let (client, rx) = connect(
        Arc::new(WebsocketConfig::CLIENT_DEFAULT),
        ConnectRequest::new(
            format!("localhost:{port}")
                .to_socket_addrs()
                .unwrap()
                .next()
                .unwrap(),
        )
        .try_set_header("origin", origin)
        .unwrap(),
    )
    .await
    .unwrap();

    let _rx = WsPollRecv::new::<AppResponse>(rx);

    client
        .authenticate(AppAuthenticationRequest { token })
        .await
        .unwrap();

    let request = AppRequest::ListWasmHostFunctions;
    let _: AppResponse = client.request(request).await.unwrap();
}

async fn create_token(
    conductor: &SweetConductor,
    for_installed_app_id: InstalledAppId,
) -> AppAuthenticationToken {
    let (admin_tx, _admin_rx) = conductor.admin_ws_client::<AdminResponse>().await;
    let issued: AdminResponse = admin_tx
        .request(AdminRequest::IssueAppAuthenticationToken(
            for_installed_app_id.into(),
        ))
        .await
        .unwrap();

    match issued {
        AdminResponse::AppAuthenticationTokenIssued(issued) => issued.token,
        _ => panic!("Unexpected response"),
    }
}

async fn create_multi_use_token(
    conductor: &SweetConductor,
    for_installed_app_id: InstalledAppId,
) -> AppAuthenticationToken {
    let (admin_sender, _admin_rx) = conductor.admin_ws_client::<AdminResponse>().await;

    let token_response: AdminResponse = admin_sender
        .request(AdminRequest::IssueAppAuthenticationToken(
            IssueAppAuthenticationTokenPayload::for_installed_app_id(for_installed_app_id)
                .single_use(false)
                .expiry_seconds(0),
        ))
        .await
        .unwrap();

    match token_response {
        AdminResponse::AppAuthenticationTokenIssued(issued) => issued.token,
        _ => panic!("unexpected response"),
    }
}

async fn revoke_token(conductor: &SweetConductor, token: AppAuthenticationToken) {
    let (admin_sender, _admin_rx) = conductor.admin_ws_client::<AdminResponse>().await;

    let token_response: AdminResponse = admin_sender
        .request(AdminRequest::RevokeAppAuthenticationToken(token))
        .await
        .unwrap();
    match token_response {
        AdminResponse::AppAuthenticationTokenRevoked => (),
        _ => panic!("unexpected response"),
    };
}



================================================
File: crates/holochain/tests/tests/countersigning.rs
================================================
use hdk::prelude::{PreflightRequest, PreflightRequestAcceptance};
use holo_hash::{ActionHash, EntryHash};
use holochain::conductor::api::error::{ConductorApiError, ConductorApiResult};
use holochain::conductor::CellError;
use holochain::core::workflow::WorkflowError;
use holochain::prelude::CountersigningSessionState;
use holochain::sweettest::{
    await_consistency, SweetConductorBatch, SweetConductorConfig, SweetDnaFile,
};
use holochain_state::prelude::{IncompleteCommitReason, SourceChainError};
use holochain_types::app::DisabledAppReason;
use holochain_types::prelude::Signal;
use holochain_types::signal::SystemSignal;
use holochain_wasm_test_utils::TestWasm;
use holochain_zome_types::countersigning::Role;
use matches::assert_matches;
use std::time::Duration;
use tokio::sync::broadcast::Receiver;

mod session_interaction_over_websocket;

#[tokio::test(flavor = "multi_thread")]
#[cfg_attr(target_os = "windows", ignore = "flaky")]
async fn listen_for_countersigning_completion() {
    holochain_trace::test_run();

    let config = SweetConductorConfig::rendezvous(true).no_dpki();
    let mut conductors = SweetConductorBatch::from_config_rendezvous(2, config).await;

    let (dna, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::CounterSigning]).await;
    let apps = conductors.setup_app("app", &[dna]).await.unwrap();
    let cells = apps.cells_flattened();
    let alice = &cells[0];
    let bob = &cells[1];

    // Need an initialised source chain for countersigning, so commit anything
    let alice_zome = alice.zome(TestWasm::CounterSigning);
    let _: ActionHash = conductors[0]
        .call_fallible(&alice_zome, "create_a_thing", ())
        .await
        .unwrap();
    let bob_zome = bob.zome(TestWasm::CounterSigning);
    let _: ActionHash = conductors[1]
        .call_fallible(&bob_zome, "create_a_thing", ())
        .await
        .unwrap();

    await_consistency(30, vec![alice, bob]).await.unwrap();

    // Set up the session and accept it for both agents
    let preflight_request: PreflightRequest = conductors[0]
        .call_fallible(
            &alice_zome,
            "generate_countersigning_preflight_request_fast",
            vec![
                (alice.agent_pubkey().clone(), vec![Role(0)]),
                (bob.agent_pubkey().clone(), vec![]),
            ],
        )
        .await
        .unwrap();
    let alice_acceptance: PreflightRequestAcceptance = conductors[0]
        .call_fallible(
            &alice_zome,
            "accept_countersigning_preflight_request",
            preflight_request.clone(),
        )
        .await
        .unwrap();
    let alice_response =
        if let PreflightRequestAcceptance::Accepted(ref response) = alice_acceptance {
            response
        } else {
            unreachable!();
        };
    let bob_acceptance: PreflightRequestAcceptance = conductors[1]
        .call_fallible(
            &bob_zome,
            "accept_countersigning_preflight_request",
            preflight_request.clone(),
        )
        .await
        .unwrap();
    let bob_response = if let PreflightRequestAcceptance::Accepted(ref response) = bob_acceptance {
        response
    } else {
        unreachable!();
    };

    let (_, _): (ActionHash, EntryHash) = conductors[0]
        .call_fallible(
            &alice_zome,
            "create_a_countersigned_thing_with_entry_hash",
            vec![alice_response.clone(), bob_response.clone()],
        )
        .await
        .unwrap();

    let (_, _): (ActionHash, EntryHash) = conductors[1]
        .call_fallible(
            &bob_zome,
            "create_a_countersigned_thing_with_entry_hash",
            vec![alice_response.clone(), bob_response.clone()],
        )
        .await
        .unwrap();

    let alice_rx = conductors[0].subscribe_to_app_signals("app".into());
    let bob_rx = conductors[1].subscribe_to_app_signals("app".into());

    wait_for_completion(alice_rx, preflight_request.app_entry_hash.clone()).await;
    wait_for_completion(bob_rx, preflight_request.app_entry_hash).await;
}

// Regression test to check that it's possible to continue a countersigning session following
// a failed commit that required dependencies that couldn't be fetched.
#[tokio::test(flavor = "multi_thread")]
async fn retry_countersigning_commit_on_missing_deps() {
    holochain_trace::test_run();

    let config = SweetConductorConfig::rendezvous(true).no_dpki();
    let mut conductors = SweetConductorBatch::from_config_rendezvous(2, config).await;
    for conductor in conductors.iter_mut() {
        conductor.shutdown().await;
    }
    // Allow bootstrapping and network comms so that peers can find each other, and exchange DPKI info,
    // but before creating any data, disable publish and recent gossip.
    // Now the only way peers can get data is through get requests!
    for conductor in conductors.iter_mut() {
        conductor.update_config(|c| SweetConductorConfig::from(c).historical_only().into());
        conductor.startup().await;
    }
    let (dna, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::CounterSigning]).await;
    let apps = conductors.setup_app("app", &[dna]).await.unwrap();
    let cells = apps.cells_flattened();
    let alice = &cells[0];
    let bob = &cells[1];

    // Need an initialised source chain for countersigning, so commit anything
    let alice_zome = alice.zome(TestWasm::CounterSigning);
    let _: ActionHash = conductors[0]
        .call_fallible(&alice_zome, "create_a_thing", ())
        .await
        .unwrap();
    let bob_zome = bob.zome(TestWasm::CounterSigning);
    let _: ActionHash = conductors[1]
        .call_fallible(&bob_zome, "create_a_thing", ())
        .await
        .unwrap();

    // Make sure both peers can see each other so that we know get requests should succeed when
    // fetching agent activity
    conductors[0]
        .wait_for_peer_visible([bob.agent_pubkey().clone()], None, Duration::from_secs(30))
        .await
        .unwrap();
    conductors[1]
        .wait_for_peer_visible(
            [alice.agent_pubkey().clone()],
            None,
            Duration::from_secs(30),
        )
        .await
        .unwrap();

    // Set up the session and accept it for both agents
    let preflight_request: PreflightRequest = conductors[0]
        .call_fallible(
            &alice_zome,
            "generate_countersigning_preflight_request_fast",
            vec![
                (alice.agent_pubkey().clone(), vec![Role(0)]),
                (bob.agent_pubkey().clone(), vec![]),
            ],
        )
        .await
        .unwrap();
    let alice_acceptance: PreflightRequestAcceptance = conductors[0]
        .call_fallible(
            &alice_zome,
            "accept_countersigning_preflight_request",
            preflight_request.clone(),
        )
        .await
        .unwrap();
    let alice_response =
        if let PreflightRequestAcceptance::Accepted(ref response) = alice_acceptance {
            response
        } else {
            unreachable!();
        };
    let bob_acceptance: PreflightRequestAcceptance = conductors[1]
        .call_fallible(
            &bob_zome,
            "accept_countersigning_preflight_request",
            preflight_request.clone(),
        )
        .await
        .unwrap();
    let bob_response = if let PreflightRequestAcceptance::Accepted(ref response) = bob_acceptance {
        response
    } else {
        unreachable!();
    };

    // Take Bob's app offline so that Alice can't get his activity
    conductors[1]
        .disable_app("app".into(), DisabledAppReason::User)
        .await
        .unwrap();

    // Alice shouldn't be able to commit yet, because she doesn't have Bob's activity
    let result: ConductorApiResult<(ActionHash, EntryHash)> = conductors[0]
        .call_fallible(
            &alice_zome,
            "create_a_countersigned_thing_with_entry_hash",
            vec![alice_response.clone(), bob_response.clone()],
        )
        .await;
    match result {
        Ok(_) => {
            panic!("Expected commit to fail due to missing dependencies");
        }
        Err(ConductorApiError::CellError(CellError::WorkflowError(e))) => {
            match *e {
                WorkflowError::SourceChainError(SourceChainError::IncompleteCommit(
                    IncompleteCommitReason::DepMissingFromDht(_),
                )) => {
                    // Expected
                }
                _ => {
                    panic!("Expected IncompleteCommit error, got: {:?}", e);
                }
            }
        }
        _ => {
            panic!("Expected CellError::WorkflowError, got: {:?}", result);
        }
    }

    // Bring Bob's app back online
    conductors[1].enable_app("app".into()).await.unwrap();

    tokio::time::sleep(Duration::from_secs(5)).await;

    // Bob should be able to get Alice's chain head when we commit, so let's do that.
    let (_, _): (ActionHash, EntryHash) = conductors[1]
        .call_fallible(
            &bob_zome,
            "create_a_countersigned_thing_with_entry_hash",
            vec![alice_response.clone(), bob_response.clone()],
        )
        .await
        .unwrap();

    // Now that Bob is available again, Alice should also be able to get his chain head and complete
    // her commit
    let (_, _): (ActionHash, EntryHash) = conductors[0]
        .call_fallible(
            &alice_zome,
            "create_a_countersigned_thing_with_entry_hash",
            vec![alice_response.clone(), bob_response.clone()],
        )
        .await
        .unwrap();

    // Listen for the session to complete, which it should in spite of the error that
    // Alice had initially.

    let alice_rx = conductors[0].subscribe_to_app_signals("app".into());
    let bob_rx = conductors[1].subscribe_to_app_signals("app".into());

    wait_for_completion(alice_rx, preflight_request.app_entry_hash.clone()).await;
    wait_for_completion(bob_rx, preflight_request.app_entry_hash).await;
}

#[tokio::test(flavor = "multi_thread")]
async fn alice_can_recover_when_bob_abandons_a_countersigning_session() {
    holochain_trace::test_run();

    let config = SweetConductorConfig::rendezvous(true)
        .no_dpki()
        .tune_conductor(|c| {
            c.countersigning_resolution_retry_delay = Some(Duration::from_secs(3));
        });
    let mut conductors = SweetConductorBatch::from_config_rendezvous(3, config).await;

    let (dna, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::CounterSigning]).await;
    let apps = conductors.setup_app("app", &[dna]).await.unwrap();
    let cells = apps.cells_flattened();
    let alice = &cells[0];
    let bob = &cells[1];
    let carol = &cells[2];

    // Subscribe early in the test to avoid missing signals later
    let alice_signal_rx = conductors[0].subscribe_to_app_signals("app".into());
    let bob_signal_rx = conductors[1].subscribe_to_app_signals("app".into());

    // Need an initialised source chain for countersigning, so commit anything
    let alice_zome = alice.zome(TestWasm::CounterSigning);
    let _: ActionHash = conductors[0]
        .call_fallible(&alice_zome, "create_a_thing", ())
        .await
        .unwrap();
    let bob_zome = bob.zome(TestWasm::CounterSigning);
    let _: ActionHash = conductors[1]
        .call_fallible(&bob_zome, "create_a_thing", ())
        .await
        .unwrap();

    await_consistency(30, vec![alice, bob, carol])
        .await
        .unwrap();

    // Set up the session and accept it for both agents
    let preflight_request: PreflightRequest = conductors[0]
        .call_fallible(
            &alice_zome,
            "generate_countersigning_preflight_request_fast",
            vec![
                (alice.agent_pubkey().clone(), vec![Role(0)]),
                (bob.agent_pubkey().clone(), vec![]),
            ],
        )
        .await
        .unwrap();
    let alice_acceptance: PreflightRequestAcceptance = conductors[0]
        .call_fallible(
            &alice_zome,
            "accept_countersigning_preflight_request",
            preflight_request.clone(),
        )
        .await
        .unwrap();
    let alice_response =
        if let PreflightRequestAcceptance::Accepted(ref response) = alice_acceptance {
            response
        } else {
            unreachable!();
        };
    let bob_acceptance: PreflightRequestAcceptance = conductors[1]
        .call_fallible(
            &bob_zome,
            "accept_countersigning_preflight_request",
            preflight_request.clone(),
        )
        .await
        .unwrap();
    let bob_response = if let PreflightRequestAcceptance::Accepted(ref response) = bob_acceptance {
        response
    } else {
        unreachable!();
    };

    // Alice doesn't realise that Bob is a very bad man, and goes ahead and commits
    let (_, _): (ActionHash, EntryHash) = conductors[0]
        .call_fallible(
            &alice_zome,
            "create_a_countersigned_thing_with_entry_hash",
            vec![alice_response.clone(), bob_response.clone()],
        )
        .await
        .unwrap();

    // Bob does not commit, and instead abandons the session

    // Bob's session should time out and be abandoned
    wait_for_abandoned(bob_signal_rx, preflight_request.app_entry_hash.clone()).await;

    // Alice session should also get abandoned
    wait_for_abandoned(alice_signal_rx, preflight_request.app_entry_hash.clone()).await;

    // Alice will now be allowed to commit other entries
    let _: ActionHash = conductors[0]
        .call_fallible(&alice_zome, "create_a_thing", ())
        .await
        .unwrap();

    // Everyone's DHT should sync
    await_consistency(60, [alice, bob, carol]).await.unwrap();
}

#[tokio::test(flavor = "multi_thread")]
async fn alice_can_recover_from_a_session_timeout() {
    holochain_trace::test_run();

    let config = SweetConductorConfig::rendezvous(true)
        .no_dpki()
        .tune_conductor(|c| {
            c.countersigning_resolution_retry_limit = Some(3);
            c.countersigning_resolution_retry_delay = Some(Duration::from_secs(3));
        });
    let mut conductors = SweetConductorBatch::from_config_rendezvous(3, config).await;

    let (dna, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::CounterSigning]).await;
    let apps = conductors.setup_app("app", &[dna]).await.unwrap();
    let cells = apps.cells_flattened();
    let alice = &cells[0];
    let bob = &cells[1];
    let carol = &cells[2];

    // Make sure the conductors are gossiping before creating posts
    conductors[0]
        .require_initial_gossip_activity_for_cell(alice, 3, Duration::from_secs(30))
        .await
        .unwrap();

    // Need an initialised source chain for countersigning, so commit anything
    let alice_zome = alice.zome(TestWasm::CounterSigning);
    let _: ActionHash = conductors[0]
        .call_fallible(&alice_zome, "create_a_thing", ())
        .await
        .unwrap();
    let bob_zome = bob.zome(TestWasm::CounterSigning);
    let _: ActionHash = conductors[1]
        .call_fallible(&bob_zome, "create_a_thing", ())
        .await
        .unwrap();

    await_consistency(30, vec![alice, bob, carol])
        .await
        .unwrap();

    // Set up the session and accept it for both agents
    let preflight_request: PreflightRequest = conductors[0]
        .call_fallible(
            &alice_zome,
            "generate_countersigning_preflight_request_fast",
            vec![
                (alice.agent_pubkey().clone(), vec![Role(0)]),
                (bob.agent_pubkey().clone(), vec![]),
            ],
        )
        .await
        .unwrap();
    let alice_acceptance: PreflightRequestAcceptance = conductors[0]
        .call_fallible(
            &alice_zome,
            "accept_countersigning_preflight_request",
            preflight_request.clone(),
        )
        .await
        .unwrap();
    let alice_response =
        if let PreflightRequestAcceptance::Accepted(ref response) = alice_acceptance {
            response
        } else {
            unreachable!();
        };
    let bob_acceptance: PreflightRequestAcceptance = conductors[1]
        .call_fallible(
            &bob_zome,
            "accept_countersigning_preflight_request",
            preflight_request.clone(),
        )
        .await
        .unwrap();
    let bob_response = if let PreflightRequestAcceptance::Accepted(ref response) = bob_acceptance {
        response
    } else {
        unreachable!();
    };

    // Alice makes her commit, but before Bob can do the same, disaster strikes...
    let (_, _): (ActionHash, EntryHash) = conductors[0]
        .call_fallible(
            &alice_zome,
            "create_a_countersigned_thing_with_entry_hash",
            vec![alice_response.clone(), bob_response.clone()],
        )
        .await
        .unwrap();

    // Give Alice some time to publish her session.
    // TODO Does Holochain not block on this network operation?
    tokio::time::sleep(Duration::from_secs(3)).await;

    conductors[0].shutdown().await;

    // Bob can't know what has happened to Alice and makes his commit
    let (_, _): (ActionHash, EntryHash) = conductors[1]
        .call_fallible(
            &bob_zome,
            "create_a_countersigned_thing_with_entry_hash",
            vec![alice_response.clone(), bob_response.clone()],
        )
        .await
        .unwrap();

    tracing::info!("Waiting for Bob completion");

    // Luckily Carol is still online, she should get both Alice and Bob's signatures.
    // She will send these to Bob, and he can complete his session.
    // Bob's session should time out and be abandoned
    wait_for_completion(
        conductors[1].subscribe_to_app_signals("app".into()),
        preflight_request.app_entry_hash.clone(),
    )
    .await;

    // Alice comes back online, and should be able to recover her session. It will take finding
    // her session in her source chain and then trying to build a signature bundle from the network.
    conductors[0].startup().await;

    tracing::warn!("Alice is back online");

    // Alice session should now get completed
    wait_for_completion(
        conductors[0].subscribe_to_app_signals("app".into()),
        preflight_request.app_entry_hash.clone(),
    )
    .await;

    // Alice will now be allowed to commit other entries
    let _: ActionHash = conductors[0]
        .call_fallible(&alice_zome, "create_a_thing", ())
        .await
        .unwrap();

    // Everyone's DHT should sync
    await_consistency(60, [alice, bob, carol]).await.unwrap();
}

#[cfg(feature = "chc")]
#[tokio::test(flavor = "multi_thread")]
async fn complete_session_with_chc_enabled() {
    holochain_trace::test_run();

    let mut config = SweetConductorConfig::rendezvous(true).no_dpki();
    config.chc_url = Some(url2::Url2::parse(
        holochain::conductor::chc::CHC_LOCAL_MAGIC_URL,
    ));

    let mut conductors = SweetConductorBatch::from_config_rendezvous(2, config).await;

    let (dna, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::CounterSigning]).await;
    let apps = conductors.setup_app("app", &[dna]).await.unwrap();
    let cells = apps.cells_flattened();
    let alice = &cells[0];
    let bob = &cells[1];

    conductors[0]
        .require_initial_gossip_activity_for_cell(alice, 2, Duration::from_secs(30))
        .await
        .unwrap();

    let alice_chc = conductors[0].get_chc(alice.cell_id()).unwrap();

    // Need an initialised source chain for countersigning, so commit anything
    let alice_zome = alice.zome(TestWasm::CounterSigning);
    let _: ActionHash = conductors[0]
        .call_fallible(&alice_zome, "create_a_thing", ())
        .await
        .unwrap();
    let bob_zome = bob.zome(TestWasm::CounterSigning);
    let _: ActionHash = conductors[1]
        .call_fallible(&bob_zome, "create_a_thing", ())
        .await
        .unwrap();

    await_consistency(60, vec![alice, bob]).await.unwrap();

    // Set up the session and accept it for both agents
    let preflight_request: PreflightRequest = conductors[0]
        .call_fallible(
            &alice_zome,
            "generate_countersigning_preflight_request",
            vec![
                (alice.agent_pubkey().clone(), vec![Role(0)]),
                (bob.agent_pubkey().clone(), vec![]),
            ],
        )
        .await
        .unwrap();
    let alice_acceptance: PreflightRequestAcceptance = conductors[0]
        .call_fallible(
            &alice_zome,
            "accept_countersigning_preflight_request",
            preflight_request.clone(),
        )
        .await
        .unwrap();
    let alice_response =
        if let PreflightRequestAcceptance::Accepted(ref response) = alice_acceptance {
            response
        } else {
            unreachable!();
        };
    let bob_acceptance: PreflightRequestAcceptance = conductors[1]
        .call_fallible(
            &bob_zome,
            "accept_countersigning_preflight_request",
            preflight_request.clone(),
        )
        .await
        .unwrap();
    let bob_response = if let PreflightRequestAcceptance::Accepted(ref response) = bob_acceptance {
        response
    } else {
        unreachable!();
    };

    let before_chain = get_all_records(&alice_chc).await.unwrap();

    let (_, _): (ActionHash, EntryHash) = conductors[0]
        .call_fallible(
            &alice_zome,
            "create_a_countersigned_thing_with_entry_hash",
            vec![alice_response.clone(), bob_response.clone()],
        )
        .await
        .unwrap();

    let between_chain = get_all_records(&alice_chc).await.unwrap();

    let (_, _): (ActionHash, EntryHash) = conductors[1]
        .call_fallible(
            &bob_zome,
            "create_a_countersigned_thing_with_entry_hash",
            vec![alice_response.clone(), bob_response.clone()],
        )
        .await
        .unwrap();

    let alice_rx = conductors[0].subscribe_to_app_signals("app".into());
    let bob_rx = conductors[1].subscribe_to_app_signals("app".into());

    wait_for_completion(alice_rx, preflight_request.app_entry_hash.clone()).await;
    wait_for_completion(bob_rx, preflight_request.app_entry_hash).await;

    let after_chain = get_all_records(&alice_chc).await.unwrap();

    // Should not appear in the CHC after commit, must wait for publish
    assert_eq!(before_chain.len(), between_chain.len());

    // Should appear in the CHC after publish
    assert_eq!(before_chain.len() + 1, after_chain.len());
}

#[cfg(feature = "chc")]
#[tokio::test(flavor = "multi_thread")]
async fn session_rollback_with_chc_enabled() {
    holochain_trace::test_run();

    let mut config = SweetConductorConfig::rendezvous(true).no_dpki();
    config.chc_url = Some(url2::Url2::parse(
        holochain::conductor::chc::CHC_LOCAL_MAGIC_URL,
    ));

    let mut conductors = SweetConductorBatch::from_config_rendezvous(2, config).await;

    let (dna, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::CounterSigning]).await;
    let apps = conductors.setup_app("app", &[dna]).await.unwrap();
    let cells = apps.cells_flattened();
    let alice = &cells[0];
    let bob = &cells[1];

    let alice_chc = conductors[0].get_chc(alice.cell_id()).unwrap();

    // Make sure the conductors are gossiping before continuing
    conductors[0]
        .require_initial_gossip_activity_for_cell(alice, 2, Duration::from_secs(30))
        .await
        .unwrap();

    // Subscribe early in the test to avoid missing signals later
    let alice_signal_rx = conductors[0].subscribe_to_app_signals("app".into());
    let bob_signal_rx = conductors[1].subscribe_to_app_signals("app".into());

    // Need an initialised source chain for countersigning, so commit anything
    let alice_zome = alice.zome(TestWasm::CounterSigning);
    let _: ActionHash = conductors[0]
        .call_fallible(&alice_zome, "create_a_thing", ())
        .await
        .unwrap();
    let bob_zome = bob.zome(TestWasm::CounterSigning);
    let _: ActionHash = conductors[1]
        .call_fallible(&bob_zome, "create_a_thing", ())
        .await
        .unwrap();

    await_consistency(30, vec![alice, bob]).await.unwrap();

    // Set up the session and accept it for both agents
    let preflight_request: PreflightRequest = conductors[0]
        .call_fallible(
            &alice_zome,
            "generate_countersigning_preflight_request_fast",
            vec![
                (alice.agent_pubkey().clone(), vec![Role(0)]),
                (bob.agent_pubkey().clone(), vec![]),
            ],
        )
        .await
        .unwrap();
    let alice_acceptance: PreflightRequestAcceptance = conductors[0]
        .call_fallible(
            &alice_zome,
            "accept_countersigning_preflight_request",
            preflight_request.clone(),
        )
        .await
        .unwrap();
    let alice_response =
        if let PreflightRequestAcceptance::Accepted(ref response) = alice_acceptance {
            response
        } else {
            unreachable!();
        };
    let bob_acceptance: PreflightRequestAcceptance = conductors[1]
        .call_fallible(
            &bob_zome,
            "accept_countersigning_preflight_request",
            preflight_request.clone(),
        )
        .await
        .unwrap();
    let bob_response = if let PreflightRequestAcceptance::Accepted(ref response) = bob_acceptance {
        response
    } else {
        unreachable!();
    };

    let before_chain = get_all_records(&alice_chc).await.unwrap();

    // Alice goes ahead and commits. This must not go to the CHC yet!
    let (_, _): (ActionHash, EntryHash) = conductors[0]
        .call_fallible(
            &alice_zome,
            "create_a_countersigned_thing_with_entry_hash",
            vec![alice_response.clone(), bob_response.clone()],
        )
        .await
        .unwrap();

    let between_chain = get_all_records(&alice_chc).await.unwrap();

    // Bob does not commit, and instead abandons the session

    // Bob's session should time out and be abandoned
    wait_for_abandoned(bob_signal_rx, preflight_request.app_entry_hash.clone()).await;

    // Alice session should also get abandoned
    wait_for_abandoned(alice_signal_rx, preflight_request.app_entry_hash.clone()).await;

    let after_chain = get_all_records(&alice_chc).await.unwrap();

    // Alice will now be allowed to commit other entries
    let _: ActionHash = conductors[0]
        .call_fallible(&alice_zome, "create_a_thing", ())
        .await
        .unwrap();

    let future_chain = get_all_records(&alice_chc).await.unwrap();

    // Should not appear in the CHC after commit, must wait for publish
    assert_eq!(before_chain.len(), between_chain.len());
    // Publish didn't happen, so should not have been added to the CHC
    assert_eq!(between_chain.len(), after_chain.len());
    // Now we've written something new to the chain, so the CHC should have been updated
    assert_eq!(before_chain.len() + 1, future_chain.len());

    // Everyone's DHT should sync
    await_consistency(60, [alice, bob]).await.unwrap();
}

// This test is flaky on macos (locally?).
// The problem only occurs when DPKI is enabled. The app is slow to react on the websocket, and therefore
// the ws is closed and kept closed for 5 mins before it's re-connected.
// As this is exclusive to DPKI, it's got something to do with DPKI execution, perhaps init or wasm
// compilation, and is unrelated to websockets or kitsune.
// When work on DPKI is resumed and this test is still flaky, this could serve as starting point for further
// investigation.
#[cfg(feature = "chc")]
#[tokio::test(flavor = "multi_thread")]
#[cfg_attr(
    target_os = "windows",
    ignore = "flaky, and even on linux, a thread experiences a panic even though the test passes."
)]
async fn multiple_agents_on_same_conductor_with_chc_enabled() {
    holochain_trace::test_run();

    let mut config = SweetConductorConfig::rendezvous(true).no_dpki();
    config.chc_url = Some(url2::Url2::parse(
        holochain::conductor::chc::CHC_LOCAL_MAGIC_URL,
    ));

    let mut conductors = SweetConductorBatch::from_config_rendezvous(2, config).await;

    let (dna, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::CounterSigning]).await;
    let apps = conductors.setup_app("app", &[dna.clone()]).await.unwrap();
    let cells = apps.cells_flattened();
    let alice = &cells[0];
    let bob = &cells[1];

    // Carol installs the same DNA on the conductor that Alice is using
    let carol_app = conductors[0].setup_app("app2", &[dna]).await.unwrap();
    let carol = &carol_app.cells()[0];

    // Make sure the conductors are gossiping before continuing
    conductors[0]
        .require_initial_gossip_activity_for_cell(alice, 2, Duration::from_secs(30))
        .await
        .unwrap();

    let alice_chc = conductors[0].get_chc(alice.cell_id()).unwrap();
    let carol_chc = conductors[0].get_chc(carol.cell_id()).unwrap();

    // Need an initialised source chain for countersigning, so commit anything
    let alice_zome = alice.zome(TestWasm::CounterSigning);
    let _: ActionHash = conductors[0]
        .call_fallible(&alice_zome, "create_a_thing", ())
        .await
        .unwrap();
    let bob_zome = bob.zome(TestWasm::CounterSigning);
    let _: ActionHash = conductors[1]
        .call_fallible(&bob_zome, "create_a_thing", ())
        .await
        .unwrap();
    let carol_zome = carol.zome(TestWasm::CounterSigning);
    let _: ActionHash = conductors[0]
        .call_fallible(&carol_zome, "create_a_thing", ())
        .await
        .unwrap();

    await_consistency(60, vec![alice, bob, carol])
        .await
        .unwrap();

    // Set up the session and accept it for both Alice and Bob
    let preflight_request: PreflightRequest = conductors[0]
        .call_fallible(
            &alice_zome,
            "generate_countersigning_preflight_request",
            vec![
                (alice.agent_pubkey().clone(), vec![Role(0)]),
                (bob.agent_pubkey().clone(), vec![]),
            ],
        )
        .await
        .unwrap();
    let alice_acceptance: PreflightRequestAcceptance = conductors[0]
        .call_fallible(
            &alice_zome,
            "accept_countersigning_preflight_request",
            preflight_request.clone(),
        )
        .await
        .unwrap();
    let alice_response =
        if let PreflightRequestAcceptance::Accepted(ref response) = alice_acceptance {
            response
        } else {
            unreachable!();
        };
    let bob_acceptance: PreflightRequestAcceptance = conductors[1]
        .call_fallible(
            &bob_zome,
            "accept_countersigning_preflight_request",
            preflight_request.clone(),
        )
        .await
        .unwrap();
    let bob_response = if let PreflightRequestAcceptance::Accepted(ref response) = bob_acceptance {
        response
    } else {
        unreachable!();
    };

    let before_chain = get_all_records(&alice_chc).await.unwrap();

    let (_, _): (ActionHash, EntryHash) = conductors[0]
        .call_fallible(
            &alice_zome,
            "create_a_countersigned_thing_with_entry_hash",
            vec![alice_response.clone(), bob_response.clone()],
        )
        .await
        .unwrap();

    let between_chain = get_all_records(&alice_chc).await.unwrap();

    let (_, _): (ActionHash, EntryHash) = conductors[1]
        .call_fallible(
            &bob_zome,
            "create_a_countersigned_thing_with_entry_hash",
            vec![alice_response.clone(), bob_response.clone()],
        )
        .await
        .unwrap();

    let alice_rx = conductors[0].subscribe_to_app_signals("app".into());
    let bob_rx = conductors[1].subscribe_to_app_signals("app".into());

    wait_for_completion(alice_rx, preflight_request.app_entry_hash.clone()).await;
    wait_for_completion(bob_rx, preflight_request.app_entry_hash).await;

    let after_chain = get_all_records(&alice_chc).await.unwrap();

    // Should not appear in the CHC after commit, must wait for publish
    assert_eq!(before_chain.len(), between_chain.len());

    // Should appear in the CHC after publish
    assert_eq!(before_chain.len() + 1, after_chain.len());

    await_consistency(30, vec![alice, bob, carol])
        .await
        .unwrap();

    // Now Carol should be able to do a session with Bob

    // Set up the session and accept it for both Carol and Bob
    let preflight_request: PreflightRequest = conductors[0]
        .call_fallible(
            &carol_zome,
            "generate_countersigning_preflight_request_fast",
            vec![
                (carol.agent_pubkey().clone(), vec![Role(0)]),
                (bob.agent_pubkey().clone(), vec![]),
            ],
        )
        .await
        .unwrap();
    let carol_acceptance: PreflightRequestAcceptance = conductors[0]
        .call_fallible(
            &carol_zome,
            "accept_countersigning_preflight_request",
            preflight_request.clone(),
        )
        .await
        .unwrap();
    let carol_response =
        if let PreflightRequestAcceptance::Accepted(ref response) = carol_acceptance {
            response
        } else {
            unreachable!();
        };
    let bob_acceptance: PreflightRequestAcceptance = conductors[1]
        .call_fallible(
            &bob_zome,
            "accept_countersigning_preflight_request",
            preflight_request.clone(),
        )
        .await
        .unwrap();
    let bob_response = if let PreflightRequestAcceptance::Accepted(ref response) = bob_acceptance {
        response
    } else {
        unreachable!();
    };

    let before_chain = get_all_records(&carol_chc).await.unwrap();

    let (_, _): (ActionHash, EntryHash) = conductors[0]
        .call_fallible(
            &carol_zome,
            "create_a_countersigned_thing_with_entry_hash",
            vec![carol_response.clone(), bob_response.clone()],
        )
        .await
        .unwrap();

    let between_chain = get_all_records(&carol_chc).await.unwrap();

    let (_, _): (ActionHash, EntryHash) = conductors[1]
        .call_fallible(
            &bob_zome,
            "create_a_countersigned_thing_with_entry_hash",
            vec![carol_response.clone(), bob_response.clone()],
        )
        .await
        .unwrap();

    let carol_rx = conductors[0].subscribe_to_app_signals("app2".into());
    let bob_rx = conductors[1].subscribe_to_app_signals("app".into());

    wait_for_completion(carol_rx, preflight_request.app_entry_hash.clone()).await;
    wait_for_completion(bob_rx, preflight_request.app_entry_hash).await;

    let after_chain = get_all_records(&carol_chc).await.unwrap();

    // Should not appear in the CHC after commit, must wait for publish
    assert_eq!(before_chain.len(), between_chain.len());

    // Should appear in the CHC after publish
    assert_eq!(before_chain.len() + 1, after_chain.len());
}

#[tokio::test(flavor = "multi_thread")]
#[cfg_attr(target_os = "windows", ignore = "flaky")]
#[cfg(feature = "chc")]
async fn chc_should_respect_chain_lock() {
    holochain_trace::test_run();

    let mut config = SweetConductorConfig::rendezvous(true).no_dpki();
    config.chc_url = Some(url2::Url2::parse(
        holochain::conductor::chc::CHC_LOCAL_MAGIC_URL,
    ));
    let mut conductors = SweetConductorBatch::from_config_rendezvous(2, config).await;

    let (dna, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::CounterSigning]).await;
    let apps = conductors.setup_app("app", &[dna]).await.unwrap();
    let cells = apps.cells_flattened();
    let alice = &cells[0];
    let bob = &cells[1];

    // Need an initialised source chain for countersigning, so commit anything
    let alice_zome = alice.zome(TestWasm::CounterSigning);
    let _: ActionHash = conductors[0]
        .call_fallible(&alice_zome, "create_a_thing", ())
        .await
        .unwrap();
    let bob_zome = bob.zome(TestWasm::CounterSigning);
    let _: ActionHash = conductors[1]
        .call_fallible(&bob_zome, "create_a_thing", ())
        .await
        .unwrap();

    await_consistency(30, vec![alice, bob]).await.unwrap();

    // Set up the session and accept it for both agents
    let preflight_request: PreflightRequest = conductors[0]
        .call_fallible(
            &alice_zome,
            "generate_countersigning_preflight_request_fast",
            vec![
                (alice.agent_pubkey().clone(), vec![Role(0)]),
                (bob.agent_pubkey().clone(), vec![]),
            ],
        )
        .await
        .unwrap();
    let alice_acceptance: PreflightRequestAcceptance = conductors[0]
        .call_fallible(
            &alice_zome,
            "accept_countersigning_preflight_request",
            preflight_request.clone(),
        )
        .await
        .unwrap();
    let alice_response =
        if let PreflightRequestAcceptance::Accepted(ref response) = alice_acceptance {
            response
        } else {
            unreachable!();
        };
    let bob_acceptance: PreflightRequestAcceptance = conductors[1]
        .call_fallible(
            &bob_zome,
            "accept_countersigning_preflight_request",
            preflight_request.clone(),
        )
        .await
        .unwrap();
    let bob_response = if let PreflightRequestAcceptance::Accepted(ref response) = bob_acceptance {
        response
    } else {
        unreachable!();
    };

    // After accept, Alice's chain is locked and she should not be able to commit
    conductors[0]
        .call_fallible::<_, ActionHash>(&alice_zome, "create_a_thing", ())
        .await
        .unwrap_err();

    let (_, _): (ActionHash, EntryHash) = conductors[0]
        .call_fallible(
            &alice_zome,
            "create_a_countersigned_thing_with_entry_hash",
            vec![alice_response.clone(), bob_response.clone()],
        )
        .await
        .unwrap();

    // The same is true after committing the countersigning entry, the chain is still locked!
    conductors[0]
        .call_fallible::<_, ActionHash>(&alice_zome, "create_a_thing", ())
        .await
        .unwrap_err();

    let (_, _): (ActionHash, EntryHash) = conductors[1]
        .call_fallible(
            &bob_zome,
            "create_a_countersigned_thing_with_entry_hash",
            vec![alice_response.clone(), bob_response.clone()],
        )
        .await
        .unwrap();

    let alice_rx = conductors[0].subscribe_to_app_signals("app".into());
    let bob_rx = conductors[1].subscribe_to_app_signals("app".into());

    wait_for_completion(alice_rx, preflight_request.app_entry_hash.clone()).await;
    wait_for_completion(bob_rx, preflight_request.app_entry_hash).await;

    // Now a commit should succeed because the session has finished and we shouldn't be behind the CHC.
    conductors[0]
        .call_fallible::<_, ActionHash>(&alice_zome, "create_a_thing", ())
        .await
        .unwrap();
}

#[tokio::test(flavor = "multi_thread")]
#[cfg_attr(target_os = "windows", ignore = "flaky")]
#[cfg(feature = "unstable-functions")]
async fn should_be_able_to_schedule_functions_during_session() {
    holochain_trace::test_run();

    let config = SweetConductorConfig::rendezvous(true).no_dpki();
    let mut conductors = SweetConductorBatch::from_config_rendezvous(2, config).await;

    let (dna, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::CounterSigning]).await;
    let apps = conductors.setup_app("app", &[dna]).await.unwrap();
    let cells = apps.cells_flattened();
    let alice = &cells[0];
    let bob = &cells[1];

    // Make sure the conductors are gossiping before creating posts
    conductors[0]
        .require_initial_gossip_activity_for_cell(alice, 2, Duration::from_secs(30))
        .await
        .unwrap();

    // Need an initialised source chain for countersigning, so commit anything
    let alice_zome = alice.zome(TestWasm::CounterSigning);
    let _: ActionHash = conductors[0]
        .call_fallible(&alice_zome, "create_a_thing", ())
        .await
        .unwrap();
    let bob_zome = bob.zome(TestWasm::CounterSigning);
    let _: ActionHash = conductors[1]
        .call_fallible(&bob_zome, "create_a_thing", ())
        .await
        .unwrap();

    await_consistency(30, vec![alice, bob]).await.unwrap();

    // Set up the session and accept it for both agents
    let preflight_request: PreflightRequest = conductors[0]
        .call_fallible(
            &alice_zome,
            "generate_countersigning_preflight_request_fast",
            vec![
                (alice.agent_pubkey().clone(), vec![Role(0)]),
                (bob.agent_pubkey().clone(), vec![]),
            ],
        )
        .await
        .unwrap();

    let alice_acceptance: PreflightRequestAcceptance = conductors[0]
        .call_fallible(
            &alice_zome,
            "accept_countersigning_preflight_request",
            preflight_request.clone(),
        )
        .await
        .unwrap();
    assert_matches!(alice_acceptance, PreflightRequestAcceptance::Accepted(_));

    conductors[0]
        .call_fallible::<_, ()>(&alice_zome, "schedule_signal", ())
        .await
        .unwrap();

    let bob_acceptance: PreflightRequestAcceptance = conductors[1]
        .call_fallible(
            &bob_zome,
            "accept_countersigning_preflight_request",
            preflight_request.clone(),
        )
        .await
        .unwrap();
    assert_matches!(bob_acceptance, PreflightRequestAcceptance::Accepted(_));

    conductors[1]
        .call_fallible::<_, ()>(&bob_zome, "schedule_signal", ())
        .await
        .unwrap();

    let sig = conductors[0]
        .subscribe_to_app_signals("app".into())
        .recv()
        .await
        .unwrap();
    match sig {
        Signal::App { signal, .. } => {
            let msg = signal.into_inner().decode::<String>().unwrap();
            assert_eq!("scheduled hello", msg);
        }
        _ => panic!("Expected App signal"),
    }

    let sig = conductors[1]
        .subscribe_to_app_signals("app".into())
        .recv()
        .await
        .unwrap();
    match sig {
        Signal::App { signal, .. } => {
            let msg = signal.into_inner().decode::<String>().unwrap();
            assert_eq!("scheduled hello", msg);
        }
        _ => panic!("Expected App signal"),
    }
}

#[tokio::test(flavor = "multi_thread")]
async fn alice_can_force_abandon_session_when_automatic_resolution_has_failed_after_shutdown() {
    holochain_trace::test_run();

    let config = SweetConductorConfig::rendezvous(true)
        .tune_conductor(|c| {
            c.countersigning_resolution_retry_limit = Some(3);
            c.countersigning_resolution_retry_delay = Some(Duration::from_secs(3));
        })
        .tune(|params| {
            // Incredible, but true: set the timeout for a network
            params.tx5_implicit_timeout_ms = 3_000;
        });
    let mut conductors = SweetConductorBatch::from_config_rendezvous(2, config).await;

    let (dna, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::CounterSigning]).await;
    let app_id = "app";
    let apps = conductors.setup_app(app_id, &[dna]).await.unwrap();
    let cells = apps.cells_flattened();
    let alice = &cells[0];
    let bob = &cells[1];

    // Need an initialised source chain for countersigning, so commit anything
    let alice_zome = alice.zome(TestWasm::CounterSigning);
    let _: ActionHash = conductors[0]
        .call_fallible(&alice_zome, "create_a_thing", ())
        .await
        .unwrap();
    let bob_zome = bob.zome(TestWasm::CounterSigning);
    let _: ActionHash = conductors[1]
        .call_fallible(&bob_zome, "create_a_thing", ())
        .await
        .unwrap();

    await_consistency(30, vec![alice, bob]).await.unwrap();

    // Set up the session and accept it for both agents.
    let preflight_request: PreflightRequest = conductors[0]
        .call_fallible(
            &alice_zome,
            "generate_countersigning_preflight_request_fast",
            vec![
                (alice.agent_pubkey().clone(), vec![Role(0)]),
                (bob.agent_pubkey().clone(), vec![]),
            ],
        )
        .await
        .unwrap();
    let alice_acceptance: PreflightRequestAcceptance = conductors[0]
        .call_fallible(
            &alice_zome,
            "accept_countersigning_preflight_request",
            preflight_request.clone(),
        )
        .await
        .unwrap();
    let alice_response =
        if let PreflightRequestAcceptance::Accepted(ref response) = alice_acceptance {
            response
        } else {
            unreachable!();
        };
    let bob_acceptance: PreflightRequestAcceptance = conductors[1]
        .call_fallible(
            &bob_zome,
            "accept_countersigning_preflight_request",
            preflight_request.clone(),
        )
        .await
        .unwrap();
    let bob_response = if let PreflightRequestAcceptance::Accepted(ref response) = bob_acceptance {
        response
    } else {
        unreachable!();
    };

    // Alice makes her commit and shuts down.
    let (_, _): (ActionHash, EntryHash) = conductors[0]
        .call_fallible(
            &alice_zome,
            "create_a_countersigned_thing_with_entry_hash",
            vec![alice_response.clone(), bob_response.clone()],
        )
        .await
        .unwrap();
    conductors[0].shutdown().await;

    // Alice comes back online.
    conductors[0].startup().await;

    // Wait until Alice's session has been attempted to be resolved.
    tokio::time::timeout(Duration::from_secs(30), async {
        loop {
            let state = conductors[0]
            .raw_handle()
            .get_countersigning_session_state(alice.cell_id())
            .await
            .unwrap();
            if matches!(
                state,
                Some(CountersigningSessionState::Unknown { resolution, .. }) if resolution.attempts >= 1
            ) {
                break;
            }
            tokio::time::sleep(Duration::from_millis(1000)).await;
        }
    })
    .await
    .unwrap();

    let mut alice_app_signal_rx = conductors[0].subscribe_to_app_signals(app_id.to_string());
    let mut bob_app_signal_rx = conductors[1].subscribe_to_app_signals(app_id.to_string());

    // Alice abandons the session.
    conductors[0]
        .abandon_countersigning_session(alice.cell_id())
        .await
        .unwrap();

    // Await countersigning session abandoned signal for Alice.
    match alice_app_signal_rx.recv().await.unwrap() {
        Signal::System(SystemSignal::AbandonedCountersigning(entry_hash)) => {
            assert_eq!(entry_hash, preflight_request.app_entry_hash.clone());
        }
        _ => panic!("Expected System signal"),
    }
    // Alice's session should be gone from memory.
    let alice_state = conductors[0]
        .raw_handle()
        .get_countersigning_session_state(alice.cell_id())
        .await
        .unwrap();
    assert_matches!(alice_state, None);

    // Await countersigning session abandoned signal for Bob.
    match bob_app_signal_rx.recv().await.unwrap() {
        Signal::System(SystemSignal::AbandonedCountersigning(entry_hash)) => {
            assert_eq!(entry_hash, preflight_request.app_entry_hash.clone());
        }
        _ => panic!("Expected System signal"),
    }
    // Bob's session should be gone from memory.
    let bob_state = conductors[1]
        .raw_handle()
        .get_countersigning_session_state(bob.cell_id())
        .await
        .unwrap();
    assert_matches!(bob_state, None);
}

#[tokio::test(flavor = "multi_thread")]
async fn alice_can_force_publish_session_when_automatic_resolution_has_failed_after_shutdown() {
    holochain_trace::test_run();

    let config = SweetConductorConfig::rendezvous(true)
        .tune_conductor(|c| {
            c.countersigning_resolution_retry_limit = Some(3);
            c.countersigning_resolution_retry_delay = Some(Duration::from_secs(3));
        })
        .tune(|params| {
            // Incredible, but true: set the timeout for a network
            params.tx5_implicit_timeout_ms = 3_000;
        });
    let mut conductors = SweetConductorBatch::from_config_rendezvous(2, config).await;

    let (dna, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::CounterSigning]).await;
    let app_id = "app";
    let apps = conductors.setup_app(app_id, &[dna]).await.unwrap();
    let cells = apps.cells_flattened();
    let alice = &cells[0];
    let bob = &cells[1];

    // Need an initialised source chain for countersigning, so commit anything
    let alice_zome = alice.zome(TestWasm::CounterSigning);
    let _: ActionHash = conductors[0]
        .call_fallible(&alice_zome, "create_a_thing", ())
        .await
        .unwrap();
    let bob_zome = bob.zome(TestWasm::CounterSigning);
    let _: ActionHash = conductors[1]
        .call_fallible(&bob_zome, "create_a_thing", ())
        .await
        .unwrap();

    await_consistency(30, vec![alice, bob]).await.unwrap();

    // Set up the session and accept it for both agents.
    let preflight_request: PreflightRequest = conductors[0]
        .call_fallible(
            &alice_zome,
            "generate_countersigning_preflight_request_fast",
            vec![
                (alice.agent_pubkey().clone(), vec![Role(0)]),
                (bob.agent_pubkey().clone(), vec![]),
            ],
        )
        .await
        .unwrap();
    let alice_acceptance: PreflightRequestAcceptance = conductors[0]
        .call_fallible(
            &alice_zome,
            "accept_countersigning_preflight_request",
            preflight_request.clone(),
        )
        .await
        .unwrap();
    let alice_response =
        if let PreflightRequestAcceptance::Accepted(ref response) = alice_acceptance {
            response
        } else {
            unreachable!();
        };
    let bob_acceptance: PreflightRequestAcceptance = conductors[1]
        .call_fallible(
            &bob_zome,
            "accept_countersigning_preflight_request",
            preflight_request.clone(),
        )
        .await
        .unwrap();
    let bob_response = if let PreflightRequestAcceptance::Accepted(ref response) = bob_acceptance {
        response
    } else {
        unreachable!();
    };

    // Alice makes her commit and shuts down.
    let (_, _): (ActionHash, EntryHash) = conductors[0]
        .call_fallible(
            &alice_zome,
            "create_a_countersigned_thing_with_entry_hash",
            vec![alice_response.clone(), bob_response.clone()],
        )
        .await
        .unwrap();
    conductors[0].shutdown().await;

    // Bob can't know what has happened to Alice, makes his commit and shuts down.
    let (_, _): (ActionHash, EntryHash) = conductors[1]
        .call_fallible(
            &bob_zome,
            "create_a_countersigned_thing_with_entry_hash",
            vec![alice_response.clone(), bob_response.clone()],
        )
        .await
        .unwrap();
    conductors[1].shutdown().await;

    // Alice comes back online.
    conductors[0].startup().await;

    // Bob comes back online too.
    conductors[1].startup().await;

    // Wait until Alice's session has been attempted to be resolved.
    tokio::time::timeout(Duration::from_secs(30), async {
        loop {
            let state = conductors[0]
            .raw_handle()
            .get_countersigning_session_state(alice.cell_id())
            .await
            .unwrap();
            if matches!(
                state,
                Some(CountersigningSessionState::Unknown { resolution, .. }) if resolution.attempts >= 1
            ) {
                break;
            }
            tokio::time::sleep(Duration::from_millis(1000)).await;
        }
    })
    .await
    .unwrap();

    let mut alice_app_signal_rx = conductors[0].subscribe_to_app_signals(app_id.to_string());
    let mut bob_app_signal_rx = conductors[1].subscribe_to_app_signals(app_id.to_string());

    // Alice publishes the session.
    conductors[0]
        .publish_countersigning_session(alice.cell_id())
        .await
        .unwrap();

    // Await countersigning success signal for Alice.
    match alice_app_signal_rx.recv().await.unwrap() {
        Signal::System(SystemSignal::SuccessfulCountersigning(entry_hash)) => {
            assert_eq!(entry_hash, preflight_request.app_entry_hash.clone());
        }
        _ => panic!("Expected System signal"),
    }
    // Alice's session should be gone from memory.
    let alice_state = conductors[0]
        .raw_handle()
        .get_countersigning_session_state(alice.cell_id())
        .await
        .unwrap();
    assert_matches!(alice_state, None);

    // Await countersigning success signal for Bob.
    match bob_app_signal_rx.recv().await.unwrap() {
        Signal::System(SystemSignal::SuccessfulCountersigning(entry_hash)) => {
            assert_eq!(entry_hash, preflight_request.app_entry_hash.clone());
        }
        _ => panic!("Expected System signal"),
    }
    // Bob's session should be gone from memory.
    let bob_state = conductors[1]
        .raw_handle()
        .get_countersigning_session_state(bob.cell_id())
        .await
        .unwrap();
    assert_matches!(bob_state, None);
}

async fn wait_for_completion(mut signal_rx: Receiver<Signal>, expected_hash: EntryHash) {
    let signal = tokio::time::timeout(std::time::Duration::from_secs(30), signal_rx.recv())
        .await
        .unwrap()
        .unwrap();
    match signal {
        Signal::System(SystemSignal::SuccessfulCountersigning(hash)) => {
            assert_eq!(expected_hash, hash);
        }
        _ => {
            panic!(
                "Expected SuccessfulCountersigning signal, got: {:?}",
                signal
            );
        }
    }
}

async fn wait_for_abandoned(mut signal_rx: Receiver<Signal>, expected_hash: EntryHash) {
    let signal = tokio::time::timeout(std::time::Duration::from_secs(30), signal_rx.recv())
        .await
        .unwrap()
        .unwrap();
    match signal {
        Signal::System(SystemSignal::AbandonedCountersigning(hash)) => {
            assert_eq!(expected_hash, hash);
        }
        _ => {
            panic!(
                "Expected SuccessfulCountersigning signal, got: {:?}",
                signal
            );
        }
    }
}

#[cfg(feature = "chc")]
async fn get_all_records(
    chc: &holochain_chc::ChcImpl,
) -> holochain_chc::ChcResult<
    Vec<(
        hdk::prelude::SignedActionHashed,
        Option<(
            std::sync::Arc<holochain_chc::EncryptedEntry>,
            hdk::prelude::Signature,
        )>,
    )>,
> {
    use holochain_types::fixt::SignatureFixturator;

    chc.get_record_data_request(holochain_chc::GetRecordsRequest {
        payload: holochain_chc::GetRecordsPayload {
            since_hash: None,
            nonce: holochain_nonce::fresh_nonce(hdk::prelude::Timestamp::now())
                .unwrap()
                .0,
        },
        signature: fixt::fixt!(Signature),
    })
    .await
}



================================================
File: crates/holochain/tests/tests/graft_records_onto_source_chain.rs
================================================
#![cfg(feature = "test_utils")]
#![cfg(feature = "chc")]

use ::fixt::prelude::*;
use hdk::prelude::*;
use holo_hash::fixt::AgentPubKeyFixturator;
use holochain::conductor::api::error::ConductorApiError;
use holochain::sweettest::{
    DynSweetRendezvous, SweetConductor, SweetConductorConfig, SweetDnaFile, SweetInlineZomes,
};
use holochain::test_utils::inline_zomes::simple_crud_zome;
use holochain_keystore::MetaLairClient;
use holochain_sqlite::db::{DbKindAuthored, DbWrite};
use holochain_sqlite::error::DatabaseResult;
use holochain_state::prelude::{CascadeTxnWrapper, StateMutationError, Store};
use holochain_types::record::SignedActionHashedExt;

/// Test that records can be manually grafted onto a source chain.
#[tokio::test(flavor = "multi_thread")]
async fn grafting() {
    let (dna_file, _, _) = SweetDnaFile::unique_from_inline_zomes(simple_crud_zome()).await;
    let mut config = SweetConductorConfig::standard().no_dpki();
    config.chc_url = Some(url2::Url2::parse(
        holochain::conductor::chc::CHC_LOCAL_MAGIC_URL,
    ));
    let mut conductor = SweetConductor::from_config(config.clone()).await;
    let keystore = conductor.keystore();

    let apps = conductor.setup_app("app", [&dna_file]).await.unwrap();
    let (alice,) = apps.into_tuple();
    let zome = alice.zome(SweetInlineZomes::COORDINATOR);

    // Trigger init.
    let _: Vec<Option<Record>> = conductor
        .call(
            &zome,
            "read_entry",
            EntryHash::from(alice.cell_id().agent_pubkey().clone()),
        )
        .await;

    // Get the current chain source chain.
    let get_chain = |env: DbWrite<DbKindAuthored>| async move {
        env.read_async(move |txn| -> DatabaseResult<Vec<(ActionHash, u32)>> {
            let chain: Vec<(ActionHash, u32)> = txn
                .prepare("SELECT hash, seq FROM Action ORDER BY seq")
                .unwrap()
                .query_map([], |row| Ok((row.get(0)?, row.get(1)?)))
                .unwrap()
                .collect::<Result<_, _>>()
                .unwrap();
            Ok(chain)
        })
        .await
        .unwrap()
    };

    // Get the source chain.
    let chain = get_chain(alice.authored_db().clone()).await;
    let original_records: Vec<_> = alice
        .authored_db()
        .read_async({
            let query_chain = chain.clone();
            move |txn| -> DatabaseResult<Vec<_>> {
                Ok(query_chain
                    .iter()
                    .map(|h| {
                        CascadeTxnWrapper::from(txn)
                            .get_record(&h.0.clone().into())
                            .unwrap()
                            .unwrap()
                    })
                    .collect())
            }
        })
        .await
        .unwrap();
    // Chain should be 4 long.
    assert_eq!(chain.len(), 4);
    // Last seq should be 3.
    assert_eq!(chain.last().unwrap().1, 3);

    // Inject an action with the wrong author.
    let entry = Entry::app(().try_into().unwrap()).unwrap();
    let mut action = Create {
        author: fixt!(AgentPubKey),
        timestamp: Timestamp::now(),
        action_seq: 4,
        prev_action: chain.last().unwrap().0.clone(),
        entry_type: EntryType::App(AppEntryDef::new(
            1.into(),
            0.into(),
            EntryVisibility::Public,
        )),
        entry_hash: EntryHash::with_data_sync(&entry),
        weight: Default::default(),
    };
    let sah = SignedActionHashed::with_presigned(
        ActionHashed::from_content_sync(action.clone()),
        fixt!(Signature),
    );
    let record = Record::new(sah, Some(entry.clone()));
    let result = conductor
        .clone()
        .graft_records_onto_source_chain(alice.cell_id().clone(), false, vec![record])
        .await;
    // This gets rejected.
    assert!(matches!(
        result,
        Err(ConductorApiError::StateMutationError(
            StateMutationError::AuthorsMustMatch
        ))
    ));

    // Insert with correct author.
    action.author = alice.agent_pubkey().clone();

    let record = make_record(&conductor.keystore(), action.clone().into()).await;
    let hash = record.action_address().clone();
    conductor
        .clone()
        .graft_records_onto_source_chain(alice.cell_id().clone(), false, vec![record])
        .await
        .expect("Should pass with valid agent");

    let chain = get_chain(alice.authored_db().clone()).await;
    // Chain should be 5 long.
    assert_eq!(chain.len(), 5);
    // Last action should be the one we just grafted.
    assert_eq!(chain.last().unwrap().0, hash);

    // Make the action a fork
    action.action_seq = 3;
    action.prev_action = chain[2].0.clone();

    let record = make_record(&conductor.keystore(), action.clone().into()).await;
    let hash = record.action_address().clone();
    let result = conductor
        .clone()
        .graft_records_onto_source_chain(alice.cell_id().clone(), false, vec![record.clone()])
        .await;

    // Validation is off so forking is possible.
    assert!(result.is_ok());

    let chain = get_chain(alice.authored_db().clone()).await;
    // Chain should be 4 long, since the previous fork was cut off
    assert_eq!(chain.len(), 4);
    // The new action will be in the chain
    assert!(chain.iter().any(|i| i.0 == hash));

    // Graft records.
    let result = conductor
        .clone()
        .graft_records_onto_source_chain(alice.cell_id().clone(), false, vec![record.clone()])
        .await;

    // An invalid chain is still possible because validation is off.
    // Note this cell is now in an invalid state.
    assert!(result.is_ok());

    let chain2 = get_chain(alice.authored_db().clone()).await;
    // The chain is unchanged from adding the same action back in.
    assert_eq!(chain, chain2);

    // Restore the original records
    let result = conductor
        .clone()
        .graft_records_onto_source_chain(alice.cell_id().clone(), false, original_records.clone())
        .await;

    assert!(result.is_ok());
    let chain = get_chain(alice.authored_db().clone()).await;
    // Chain should be 4 long.
    assert_eq!(chain.len(), 4);
    // Last seq should be 3.
    assert_eq!(chain.last().unwrap().1, 3);

    // Make the action a fork
    action.action_seq = 2;
    action.prev_action = chain[1].0.clone();
    action.timestamp = Timestamp::from_micros(0);
    let record = make_record(&conductor.keystore(), action.clone().into()).await;

    // Insert an invalid action with validation on.
    let result = conductor
        .clone()
        .graft_records_onto_source_chain(alice.cell_id().clone(), true, vec![record.clone()])
        .await;

    // Fork is detected
    assert!(result.is_err());

    // Restore and validate the original records
    // (there has been no change at this point, but it helps for clarity to reset the chain anyway)
    conductor
        .clone()
        .graft_records_onto_source_chain(alice.cell_id().clone(), true, original_records.clone())
        // Restoring the original records is ok because they
        // will pass validation.
        .await
        .expect("Should restore original chain");

    drop(conductor);

    // Start a second conductor.
    let conductor =
        SweetConductor::create_with_defaults(config, Some(keystore), None::<DynSweetRendezvous>)
            .await;

    // The dna needs to be installed first.
    conductor.register_dna(dna_file.clone()).await.unwrap();

    let mut payload = holochain::sweettest::get_install_app_payload_from_dnas(
        "app",
        Some(alice.agent_pubkey().clone()),
        &[(dna_file, None)],
        None,
    )
    .await;

    let _records = conductor
        .get_chc(alice.cell_id())
        .unwrap()
        .clone()
        .get_record_data(None)
        .await
        .unwrap();

    // This results in an error since the CHC already contains genesis, but this
    // is just to create the necessary cell for grafting onto.
    payload.ignore_genesis_failure = true;
    let install_result = conductor.raw_handle().install_app_bundle(payload).await;
    assert!(install_result.is_err());

    // Insert the chain from the original conductor.
    conductor
        .clone()
        .graft_records_onto_source_chain(alice.cell_id().clone(), true, original_records.clone())
        .await
        .expect("Can cold start");

    let chain = get_chain(alice.authored_db().clone()).await;
    // Chain should be 4 long.
    assert_eq!(chain.len(), 4);
    // Last seq should be 3.
    assert_eq!(chain.last().unwrap().1, 3);
}

async fn make_record(keystore: &MetaLairClient, action: Action) -> Record {
    let sah = SignedActionHashed::sign(keystore, ActionHashed::from_content_sync(action.clone()))
        .await
        .unwrap();
    let entry = Entry::app(().try_into().unwrap()).unwrap();
    Record::new(sah, Some(entry.clone()))
}



================================================
File: crates/holochain/tests/tests/hc_stress_test.rs
================================================
use holochain::sweettest::*;
use holochain::test_utils::hc_stress_test::*;
use holochain_types::prelude::*;

#[tokio::test(flavor = "multi_thread")]
async fn hc_stress_test_check_zome_functions() {
    // this is a sanity check to make sure the zome functions work
    // so that we can make more complex behavioral tests

    let conductor = SweetConductor::from_standard_config().await;
    let dna = HcStressTest::test_dna(random_network_seed()).await;
    let mut test = HcStressTest::new(conductor, &[dna]).await;

    let rec = test.create_file(0, "hello world").await;
    println!("create: {:?}", rec);
    assert_eq!("hello world", HcStressTest::record_to_file_data(&rec),);

    let all = test.get_all_images(0).await;
    println!("all: {:?}", all);
    assert_eq!(1, all.len());

    for hash in all {
        let rec = test.get_file(0, hash.clone()).await.unwrap();
        println!("get: {hash:?}: {:?}", rec);
        assert_eq!("hello world", HcStressTest::record_to_file_data(&rec),);
    }
}

#[cfg(feature = "glacial_tests")]
#[tokio::test(flavor = "multi_thread")]
// NOTE: this test doesn't run correctly on one particular mac CI runner
#[cfg(not(target_os = "macos"))]
async fn hc_stress_test_3_min_behavior_1() {
    let test = LocalBehavior1::new();

    for _ in 0..6 {
        tokio::time::sleep(std::time::Duration::from_secs(30)).await;

        println!("{:#?}", &*test.lock().unwrap());
    }
}

#[cfg(feature = "glacial_tests")]
#[tokio::test(flavor = "multi_thread")]
// NOTE: this test doesn't run correctly on one particular mac CI runner
#[cfg(not(target_os = "macos"))]
async fn hc_stress_test_3_min_behavior_2() {
    let test = LocalBehavior2::new(4, 4);

    for _ in 0..6 {
        tokio::time::sleep(std::time::Duration::from_secs(30)).await;

        println!("{:#?}", &*test.lock().unwrap());
    }
}



================================================
File: crates/holochain/tests/tests/init.rs
================================================
use std::sync::atomic::{AtomicBool, AtomicU8, Ordering};
use std::sync::Arc;

use assert2::{assert, let_assert};
use hdk::prelude::{WasmError, WasmErrorInner};
use holochain::conductor::api::error::ConductorApiError;
use holochain::conductor::CellError;
use holochain::core::ribosome::error::RibosomeError;
use holochain::core::workflow::WorkflowError;
use holochain::prelude::*;
use holochain::sweettest::*;
use holochain_wasm_test_utils::TestWasm;

#[tokio::test(flavor = "multi_thread")]
async fn call_init_in_inline_zomes_passes() {
    let config = SweetConductorConfig::standard().no_dpki();
    let mut conductor = SweetConductor::from_config(config).await;
    let agent = SweetAgents::one(conductor.keystore()).await;
    let is_init_called = Arc::new(AtomicBool::new(false));
    let is_init_called_clone = is_init_called.clone();
    let zome = SweetInlineZomes::new(vec![], 0)
        .function("init", move |_, _: ()| {
            is_init_called_clone.store(true, Ordering::Relaxed);
            Ok(InitCallbackResult::Pass)
        })
        .function("touch", |_, _: ()| {
            // Simple Zome to just trigger a call to init.
            Ok(())
        });

    let (dna, _, _) = SweetDnaFile::unique_from_inline_zomes(zome).await;
    let app = conductor
        .setup_app_for_agent("app", agent, &[dna])
        .await
        .unwrap();
    let (cell,) = app.into_tuple();

    let () = conductor
        .call(&cell.zome(SweetInlineZomes::COORDINATOR), "touch", ())
        .await;

    assert!(is_init_called.load(Ordering::Relaxed));
}

#[tokio::test(flavor = "multi_thread")]
async fn call_init_across_cells_passes() {
    let config = SweetConductorConfig::standard().no_dpki();
    let mut conductor = SweetConductor::from_config(config).await;
    let agent = SweetAgents::one(conductor.keystore()).await;
    let is_init_called = Arc::new(AtomicBool::new(false));
    let is_init_called_clone = is_init_called.clone();
    let zome_1 = SweetInlineZomes::new(vec![], 0)
        .function("init", move |_, _: ()| {
            is_init_called_clone.store(true, Ordering::Relaxed);
            Ok(InitCallbackResult::Pass)
        })
        .function("touch", |_, _: ()| {
            // Just triggers init
            Ok(())
        });
    let (dna_1, _, _) = SweetDnaFile::unique_from_inline_zomes(zome_1).await;
    let cell_id_1 = CellId::new(dna_1.dna_hash().clone(), agent.clone());

    let zome_2 = SweetInlineZomes::new(vec![], 0).function("cross_cell_call", move |api, _: ()| {
        // Just calls into the other zome.
        api.call(vec![Call {
            target: CallTarget::ConductorCell(CallTargetCell::OtherCell(cell_id_1.clone())),
            zome_name: SweetInlineZomes::COORDINATOR.into(),
            fn_name: "touch".into(),
            cap_secret: None,
            payload: ExternIO::encode(()).unwrap(),
        }])?;
        Ok(())
    });
    let (dna_2, _, _) = SweetDnaFile::unique_from_inline_zomes(zome_2).await;

    let app = conductor
        .setup_app_for_agent("app", agent, &[dna_1, dna_2])
        .await
        .unwrap();
    let (_cell_1, cell_2) = app.into_tuple();

    let () = conductor
        .call(
            &cell_2.zome(SweetInlineZomes::COORDINATOR),
            "cross_cell_call",
            (),
        )
        .await;

    assert!(is_init_called.load(Ordering::Relaxed));
}

#[tokio::test(flavor = "multi_thread")]
async fn call_init_from_init_across_cells() {
    let config = SweetConductorConfig::standard().no_dpki();
    let mut conductor = SweetConductor::from_config(config).await;
    let agent = SweetAgents::one(conductor.keystore()).await;
    let inits = Arc::new(AtomicU8::new(0));
    let inits1 = inits.clone();
    let inits2 = inits.clone();
    let zome1 = SweetInlineZomes::new(vec![], 0)
        .function("init", move |api, _: ()| {
            api.create(CreateInput::new(
                EntryDefLocation::CapGrant,
                EntryVisibility::Private,
                Entry::CapGrant(CapGrantEntry {
                    tag: "".into(),
                    access: ().into(),
                    functions: GrantedFunctions::Listed(
                        vec![("no-init".into(), "xxx".into())].into_iter().collect(),
                    ),
                }),
                ChainTopOrdering::default(),
            ))?;
            inits1.fetch_add(1, Ordering::SeqCst);
            Ok(InitCallbackResult::Pass)
        })
        .function("touch", |_api, _: ()| {
            // just triggers init
            Ok(())
        });
    let (dna1, _, _) = SweetDnaFile::unique_from_inline_zomes(zome1).await;
    let cellid1 = CellId::new(dna1.dna_hash().clone(), agent.clone());

    let zome2 = SweetInlineZomes::new(vec![], 0)
        .function("init", move |api, _: ()| {
            api.call(vec![Call {
                target: CallTarget::ConductorCell(CallTargetCell::OtherCell(cellid1.clone())),
                zome_name: SweetInlineZomes::COORDINATOR.into(),
                fn_name: "touch".into(),
                cap_secret: None,
                payload: ExternIO::encode(()).unwrap(),
            }])?;
            inits2.fetch_add(1, Ordering::SeqCst);
            Ok(InitCallbackResult::Pass)
        })
        .function("touch", |_api, _: ()| {
            // just triggers init
            Ok(())
        });
    let (dna2, _, _) = SweetDnaFile::unique_from_inline_zomes(zome2).await;

    let app = conductor
        .setup_app_for_agent("app", agent, &[dna1, dna2])
        .await
        .unwrap();
    let (_cell1, cell2) = app.into_tuple();

    let () = conductor
        .call(&cell2.zome(SweetInlineZomes::COORDINATOR), "touch", ())
        .await;

    assert_eq!(inits.load(Ordering::SeqCst), 2);
}

#[tokio::test(flavor = "multi_thread")]
async fn call_init_with_invalid_return_type_in_inline_zomes() {
    let config = SweetConductorConfig::standard().no_dpki();
    let mut conductor = SweetConductor::from_config(config).await;
    let agent = SweetAgents::one(conductor.keystore()).await;
    let zome = SweetInlineZomes::new(vec![], 0)
        .function("init", |_, _: ()| Ok(42))
        .function("touch", |_, _: ()| {
            // Simple Zome to just trigger a call to init.
            Ok(())
        });

    let (dna, _, _) = SweetDnaFile::unique_from_inline_zomes(zome).await;
    let app = conductor
        .setup_app_for_agent("app", agent, &[dna])
        .await
        .unwrap();
    let (cell,) = app.into_tuple();

    let err = conductor
        .call_fallible::<_, ()>(&cell.zome(SweetInlineZomes::COORDINATOR), "touch", ())
        .await
        .unwrap_err();

    let_assert!(ConductorApiError::CellError(CellError::WorkflowError(workflow_err)) = err);
    let_assert!(
        WorkflowError::RibosomeError(RibosomeError::CallbackInvalidReturnType(err_msg)) =
            *workflow_err
    );
    assert!(err_msg.starts_with("invalid value: integer `42`"));
}

#[tokio::test(flavor = "multi_thread")]
async fn call_init_with_invalid_return_type_across_cells() {
    let config = SweetConductorConfig::standard().no_dpki();
    let mut conductor = SweetConductor::from_config(config).await;
    let agent = SweetAgents::one(conductor.keystore()).await;
    let zome_1 = SweetInlineZomes::new(vec![], 0)
        .function("init", move |_, _: ()| Ok(42))
        .function("touch", |_, _: ()| {
            // Simple Zome to just trigger a call to init.
            Ok(())
        });
    let (dna_1, _, _) = SweetDnaFile::unique_from_inline_zomes(zome_1).await;
    let cell_id_1 = CellId::new(dna_1.dna_hash().clone(), agent.clone());

    let zome_2 = SweetInlineZomes::new(vec![], 0).function("cross_cell_call", move |api, _: ()| {
        // Just call the other zome.
        api.call(vec![Call {
            target: CallTarget::ConductorCell(CallTargetCell::OtherCell(cell_id_1.clone())),
            zome_name: SweetInlineZomes::COORDINATOR.into(),
            fn_name: "touch".into(),
            cap_secret: None,
            payload: ExternIO::encode(()).unwrap(),
        }])?;
        Ok(())
    });
    let (dna_2, _, _) = SweetDnaFile::unique_from_inline_zomes(zome_2).await;

    let app = conductor
        .setup_app_for_agent("app", agent, &[dna_1, dna_2])
        .await
        .unwrap();
    let (_cell_1, cell_2) = app.into_tuple();

    let err = conductor
        .call_fallible::<_, ()>(
            &cell_2.zome(SweetInlineZomes::COORDINATOR),
            "cross_cell_call",
            (),
        )
        .await
        .unwrap_err();

    let_assert!(ConductorApiError::Other(other_err) = err);
    // Can't downcast the `Box<dyn Error>` to a concrete type so just compare the error message.
    assert!(other_err
        .to_string()
        .contains("The callback has an invalid return type: invalid value: integer `42`"));
}

#[tokio::test(flavor = "multi_thread")]
async fn call_init_with_invalid_return_type_from_init_across_cells() {
    let config = SweetConductorConfig::standard().no_dpki();
    let mut conductor = SweetConductor::from_config(config).await;
    let agent = SweetAgents::one(conductor.keystore()).await;
    let zome_1 = SweetInlineZomes::new(vec![], 0)
        .function("init", move |_, _: ()| Ok(42))
        .function("touch", |_, _: ()| {
            // Simple Zome to just trigger a call to init.
            Ok(())
        });
    let (dna_1, _, _) = SweetDnaFile::unique_from_inline_zomes(zome_1).await;
    let cell_id_1 = CellId::new(dna_1.dna_hash().clone(), agent.clone());

    let zome_2 = SweetInlineZomes::new(vec![], 0)
        .function("init", move |api, _: ()| {
            api.call(vec![Call {
                target: CallTarget::ConductorCell(CallTargetCell::OtherCell(cell_id_1.clone())),
                zome_name: SweetInlineZomes::COORDINATOR.into(),
                fn_name: "touch".into(),
                cap_secret: None,
                payload: ExternIO::encode(()).unwrap(),
            }])?;
            Ok(InitCallbackResult::Pass)
        })
        .function("touch", |_, _: ()| {
            // Simple Zome to just trigger a call to init.
            Ok(())
        });
    let (dna_2, _, _) = SweetDnaFile::unique_from_inline_zomes(zome_2).await;

    let app = conductor
        .setup_app_for_agent("app", agent, &[dna_1, dna_2])
        .await
        .unwrap();
    let (_cell_1, cell_2) = app.into_tuple();

    let err = conductor
        .call_fallible::<_, ()>(&cell_2.zome(SweetInlineZomes::COORDINATOR), "touch", ())
        .await
        .unwrap_err();

    let_assert!(ConductorApiError::CellError(CellError::WorkflowError(workflow_err)) = err);
    let_assert!(
        WorkflowError::RibosomeError(RibosomeError::InlineZomeError(
            InlineZomeError::HostFnApiError(HostFnApiError::RibosomeError(wasm_runtime_err))
        )) = *workflow_err
    );
    let_assert!(
        WasmError { error, .. } = wasm_runtime_err
            .source()
            .unwrap()
            .downcast_ref::<WasmError>()
            .unwrap()
    );
    let_assert!(WasmErrorInner::Host(err_msg) = error);
    assert!(
        err_msg.starts_with("The callback has an invalid return type: invalid value: integer `42`")
    );
}

#[tokio::test(flavor = "multi_thread")]
async fn call_init_with_invalid_parameters_in_inline_zomes() {
    let config = SweetConductorConfig::standard().no_dpki();
    let mut conductor = SweetConductor::from_config(config).await;
    let agent = SweetAgents::one(conductor.keystore()).await;
    let zome = SweetInlineZomes::new(vec![], 0)
        .function("init", |_, _: usize| Ok(InitCallbackResult::Pass))
        .function("touch", |_, _: ()| {
            // Simple Zome to just trigger a call to init.
            Ok(())
        });

    let (dna, _, _) = SweetDnaFile::unique_from_inline_zomes(zome).await;
    let app = conductor
        .setup_app_for_agent("app", agent, &[dna])
        .await
        .unwrap();
    let (cell,) = app.into_tuple();

    let err = conductor
        .call_fallible::<_, ()>(&cell.zome(SweetInlineZomes::COORDINATOR), "touch", ())
        .await
        .unwrap_err();

    let_assert!(ConductorApiError::CellError(CellError::WorkflowError(workflow_err)) = err);
    let_assert!(
        WorkflowError::RibosomeError(RibosomeError::CallbackInvalidParameters(err_msg)) =
            *workflow_err
    );
    assert!(err_msg == "invalid type: unit value, expected usize");
}

#[tokio::test(flavor = "multi_thread")]
async fn call_init_with_invalid_parameters_across_cells() {
    let config = SweetConductorConfig::standard().no_dpki();
    let mut conductor = SweetConductor::from_config(config).await;
    let agent = SweetAgents::one(conductor.keystore()).await;
    let zome_1 = SweetInlineZomes::new(vec![], 0)
        .function("init", move |_, _: usize| Ok(InitCallbackResult::Pass))
        .function("touch", |_, _: ()| {
            // Simple Zome to just trigger a call to init.
            Ok(())
        });
    let (dna_1, _, _) = SweetDnaFile::unique_from_inline_zomes(zome_1).await;
    let cell_id_1 = CellId::new(dna_1.dna_hash().clone(), agent.clone());

    let zome_2 = SweetInlineZomes::new(vec![], 0).function("cross_cell_call", move |api, _: ()| {
        // Simple Zome to just call the other zome.
        api.call(vec![Call {
            target: CallTarget::ConductorCell(CallTargetCell::OtherCell(cell_id_1.clone())),
            zome_name: SweetInlineZomes::COORDINATOR.into(),
            fn_name: "touch".into(),
            cap_secret: None,
            payload: ExternIO::encode(()).unwrap(),
        }])?;
        Ok(())
    });
    let (dna_2, _, _) = SweetDnaFile::unique_from_inline_zomes(zome_2).await;

    let app = conductor
        .setup_app_for_agent("app", agent, &[dna_1, dna_2])
        .await
        .unwrap();
    let (_cell_1, cell_2) = app.into_tuple();

    let err = conductor
        .call_fallible::<_, ()>(
            &cell_2.zome(SweetInlineZomes::COORDINATOR),
            "cross_cell_call",
            (),
        )
        .await
        .unwrap_err();

    let_assert!(ConductorApiError::Other(other_err) = err);
    // Can't downcast the `Box<dyn Error>` to a concrete type so just compare the error message.
    assert!(other_err
        .to_string()
        .contains("The callback has invalid parameters: invalid type: unit value, expected usize"));
}

#[tokio::test(flavor = "multi_thread")]
async fn call_init_with_invalid_parameters_from_init_across_cells() {
    let config = SweetConductorConfig::standard().no_dpki();
    let mut conductor = SweetConductor::from_config(config).await;
    let agent = SweetAgents::one(conductor.keystore()).await;
    let zome_1 = SweetInlineZomes::new(vec![], 0)
        .function("init", move |_, _: usize| Ok(InitCallbackResult::Pass))
        .function("touch", |_, _: ()| {
            // Simple Zome to just trigger a call to init.
            Ok(())
        });
    let (dna_1, _, _) = SweetDnaFile::unique_from_inline_zomes(zome_1).await;
    let cell_id_1 = CellId::new(dna_1.dna_hash().clone(), agent.clone());

    let zome_2 = SweetInlineZomes::new(vec![], 0)
        .function("init", move |api, _: ()| {
            api.call(vec![Call {
                target: CallTarget::ConductorCell(CallTargetCell::OtherCell(cell_id_1.clone())),
                zome_name: SweetInlineZomes::COORDINATOR.into(),
                fn_name: "touch".into(),
                cap_secret: None,
                payload: ExternIO::encode(()).unwrap(),
            }])?;
            Ok(InitCallbackResult::Pass)
        })
        .function("touch", |_, _: ()| {
            // Simple Zome to just trigger a call to init.
            Ok(())
        });
    let (dna_2, _, _) = SweetDnaFile::unique_from_inline_zomes(zome_2).await;

    let app = conductor
        .setup_app_for_agent("app", agent, &[dna_1, dna_2])
        .await
        .unwrap();
    let (_cell_1, cell_2) = app.into_tuple();

    let err = conductor
        .call_fallible::<_, ()>(&cell_2.zome(SweetInlineZomes::COORDINATOR), "touch", ())
        .await
        .unwrap_err();

    let_assert!(ConductorApiError::CellError(CellError::WorkflowError(workflow_err)) = err);
    let_assert!(
        WorkflowError::RibosomeError(RibosomeError::InlineZomeError(
            InlineZomeError::HostFnApiError(HostFnApiError::RibosomeError(wasm_runtime_err))
        )) = *workflow_err
    );
    let_assert!(
        WasmError { error, .. } = wasm_runtime_err
            .source()
            .unwrap()
            .downcast_ref::<WasmError>()
            .unwrap()
    );
    let_assert!(WasmErrorInner::Host(err_msg) = error);
    assert_eq!(
        err_msg,
        "The callback has invalid parameters: invalid type: unit value, expected usize"
    );
}

#[tokio::test(flavor = "multi_thread")]
async fn call_init_directly_only_calls_once() {
    let config = SweetConductorConfig::standard().no_dpki();
    let mut conductor = SweetConductor::from_config(config).await;

    let (dna, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::InitSingle]).await;
    let app = conductor.setup_app("app", &[dna]).await.unwrap();

    let zome = app.cells()[0].zome(TestWasm::InitSingle);
    let callback_result = conductor
        .call_fallible::<_, InitCallbackResult>(&zome, "init", ())
        .await
        .unwrap();

    assert!(
        matches!(callback_result, InitCallbackResult::Pass),
        "Wanted Pass but was: {:?}",
        callback_result
    );

    let callback_result = conductor
        .call::<_, InitCallbackResult>(&zome, "init", ())
        .await;

    assert!(
        matches!(callback_result, InitCallbackResult::Pass),
        "Wanted Pass but was: {:?}",
        callback_result
    );
}



================================================
File: crates/holochain/tests/tests/migration.rs
================================================
//! These tests are being created to start tracking migration patterns for happs. The tests are
//! not necessarily representing best practise but more the current options that Holochain provides
//! for migrating from one app version to another.

use holo_hash::ActionHash;
use holochain::sweettest::{SweetAgents, SweetConductor, SweetConductorConfig, SweetDnaFile};
use holochain_serialized_bytes::prelude::*;
use holochain_wasm_test_utils::TestWasm;
use holochain_zome_types::prelude::{random_network_seed, YamlProperties};

#[tokio::test(flavor = "multi_thread")]
async fn migrate_dna_with_second_app_install() {
    holochain_trace::test_run();

    #[derive(Debug, serde::Serialize, serde::Deserialize, SerializedBytes)]
    struct TestProperties {
        pub prev_dna_hash: holo_hash::DnaHash,
    }

    // Matches the new definition of `MyType`
    #[derive(Debug, serde::Serialize, serde::Deserialize, SerializedBytes)]
    struct MyType {
        value: String,
        amount: u32,
    }

    let config = SweetConductorConfig::standard().no_dpki_mustfix();
    let mut conductor = SweetConductor::from_config(config).await;

    let alice = SweetAgents::one(conductor.keystore()).await;

    // Install the first version of the app
    let (dna, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::MigrateInitial]).await;

    let app_initial = conductor
        .setup_app_for_agent("app_initial", alice.clone(), &[dna.clone()])
        .await
        .unwrap();

    let alice_cells = app_initial.into_cells();
    let alice_cell = alice_cells.first().unwrap();

    // Create some data in the first version of the app
    let _: ActionHash = conductor
        .call(&alice_cell.zome(TestWasm::MigrateInitial), "create", ())
        .await;

    // Prepare the DNA for the new app version
    let mut mapping = serde_yaml::Mapping::new();
    mapping.insert(
        "prev_dna_hash".into(),
        serde_yaml::Value::String(dna.dna_hash().clone().to_string()),
    );
    let properties = YamlProperties::new(serde_yaml::Value::Mapping(mapping));
    let (new_dna, _, _) = SweetDnaFile::from_test_wasms(
        random_network_seed(),
        vec![TestWasm::MigrateNew],
        properties.try_into().unwrap(),
    )
    .await;

    // Choose to close the chain for the first version of the app
    let _: ActionHash = conductor
        .call(
            &alice_cell.zome(TestWasm::MigrateInitial),
            "close_chain_for_new",
            new_dna.dna_hash().clone(),
        )
        .await;

    // Install the new version of the app
    let app_new = conductor
        .setup_app_for_agent("app_2", alice.clone(), &[new_dna.clone()])
        .await
        .unwrap();

    let alice_cells = app_new.into_cells();
    let alice_cell = alice_cells.first().unwrap();

    // Create some data in the new version of the app
    let _: ActionHash = conductor
        .call(&alice_cell.zome(TestWasm::MigrateNew), "create", ())
        .await;

    // Now try to get all the data from the new version of the app, which is supposed to include the data from the first version
    let results: Vec<MyType> = conductor
        .call(
            &alice_cell.zome(TestWasm::MigrateNew),
            "get_all_my_types",
            (),
        )
        .await;

    assert_eq!(2, results.len());

    assert_eq!(results[0].value, "test");
    assert_eq!(results[0].amount, 0);

    assert_eq!(results[1].value, "test new");
    assert_eq!(results[1].amount, 4);
}



================================================
File: crates/holochain/tests/tests/mod.rs
================================================
mod agent_activity;
mod agent_scaling;
mod app_installation;
mod app_interface_security;
mod authored_test;
mod clone_cell;
#[cfg(feature = "unstable-dpki")]
mod conductor_services;
// Countersigning HDK functions needed
#[cfg(feature = "unstable-countersigning")]
mod countersigning;
mod dht_arc;
mod dna_properties;
mod graft_records_onto_source_chain;
mod hc_stress_test;
mod init;
mod inline_zome_spec;
mod integrity_zome;
mod lair_in_proc_restart;
mod migration;
mod multi_conductor;
mod new_lair;
mod publish;
mod regression;
mod send_signal;
mod ser_regression;
#[cfg(not(target_os = "macos"))]
mod sharded_gossip;
mod signals;
mod test_cli;
mod test_utils;
mod validate;
mod websocket;
mod websocket_stress;



================================================
File: crates/holochain/tests/tests/send_signal.rs
================================================
use std::net::ToSocketAddrs;
use std::sync::Arc;

use holochain::sweettest::{
    authenticate_app_ws_client, SweetConductor, SweetConductorConfig, SweetDnaFile,
    SweetLocalRendezvous,
};
use holochain_conductor_api::AppResponse;
use holochain_types::prelude::InstalledAppId;
use holochain_types::signal::Signal;
use holochain_types::websocket::AllowedOrigins;
use holochain_wasm_test_utils::TestWasm;
use holochain_websocket::{ConnectRequest, WebsocketConfig};

#[tokio::test(flavor = "multi_thread")]
async fn send_signal_after_conductor_restart() {
    holochain_trace::test_run();

    let mut conductor = SweetConductor::from_config_rendezvous(
        SweetConductorConfig::rendezvous(true),
        SweetLocalRendezvous::new().await,
    )
    .await;
    let (dna_file, _, _) = SweetDnaFile::from_test_wasms(
        "network_seed".to_string(),
        vec![TestWasm::EmitSignal],
        Default::default(),
    )
    .await;
    let installed_app_id: InstalledAppId = "app_id".into();
    let app = conductor
        .setup_app(&installed_app_id, &[dna_file])
        .await
        .unwrap();
    let alice = app.agent();
    let alice_cell_id = app.cells()[0].cell_id().to_owned();

    // add app interface
    let app_interface_port_1 = (*conductor)
        .clone()
        .add_app_interface(either::Either::Left(0), AllowedOrigins::Any, None)
        .await
        .unwrap();

    // connect app websocket
    let (app_ws_tx_1, mut app_ws_rx_1) = holochain_websocket::connect(
        Arc::new(WebsocketConfig::CLIENT_DEFAULT),
        ConnectRequest::new(
            format!("localhost:{app_interface_port_1}")
                .to_socket_addrs()
                .unwrap()
                .next()
                .unwrap(),
        ),
    )
    .await
    .unwrap();
    authenticate_app_ws_client(
        app_ws_tx_1,
        conductor
            .get_arbitrary_admin_websocket_port()
            .expect("No admin port on this conductor"),
        installed_app_id.clone(),
    )
    .await;

    // emit a signal
    let _: () = conductor
        .easy_call_zome(
            alice,
            None,
            alice_cell_id.clone(),
            TestWasm::EmitSignal.coordinator_zome_name(),
            "emit",
            (),
        )
        .await
        .unwrap();

    let received_signal_1 = app_ws_rx_1.recv::<AppResponse>().await.unwrap();
    if let holochain_websocket::ReceiveMessage::Signal(v) = received_signal_1 {
        if let Ok(Signal::App {
            cell_id,
            zome_name,
            signal,
        }) = Signal::try_from_vec(v)
        {
            assert_eq!(cell_id, alice_cell_id);
            assert_eq!(zome_name, TestWasm::EmitSignal.coordinator_zome_name());
            let signal = signal.into_inner();
            println!("SIGNAL: {signal:?}");
            signal.decode::<()>().unwrap();
        } else {
            panic!("not the expected app signal");
        }
    } else {
        panic!("not the expected app signal");
    }

    // restart conductor
    conductor.shutdown().await;
    conductor.startup().await;

    // emitting signal without connected app ws must not produce an error
    let _: () = conductor
        .easy_call_zome(
            alice,
            None,
            alice_cell_id.clone(),
            TestWasm::EmitSignal.coordinator_zome_name(),
            "emit",
            (),
        )
        .await
        .unwrap();

    let app_interfaces = conductor.list_app_interfaces().await.unwrap();
    let app_interface_port_1 = app_interfaces[0].port;

    // reconnect app websocket
    let (app_ws_tx_1, mut app_ws_rx_1) = holochain_websocket::connect(
        Arc::new(WebsocketConfig::CLIENT_DEFAULT),
        ConnectRequest::new(
            format!("localhost:{app_interface_port_1}")
                .to_socket_addrs()
                .unwrap()
                .next()
                .unwrap(),
        ),
    )
    .await
    .unwrap();
    authenticate_app_ws_client(
        app_ws_tx_1,
        conductor
            .get_arbitrary_admin_websocket_port()
            .expect("No admin port on this conductor"),
        installed_app_id,
    )
    .await;

    // add a second app interface without websocket connection
    let _ = (*conductor)
        .clone()
        .add_app_interface(either::Either::Left(0), AllowedOrigins::Any, None)
        .await
        .unwrap();

    // emitting signal again must not produce an error
    let _: () = conductor
        .easy_call_zome(
            alice,
            None,
            alice_cell_id.clone(),
            TestWasm::EmitSignal.coordinator_zome_name(),
            "emit",
            (),
        )
        .await
        .unwrap();

    // signal can be received by connected websocket
    let received_signal_2 = app_ws_rx_1.recv::<AppResponse>().await.unwrap();
    if let holochain_websocket::ReceiveMessage::Signal(v) = received_signal_2 {
        if let Ok(Signal::App {
            cell_id,
            zome_name,
            signal,
        }) = Signal::try_from_vec(v)
        {
            assert_eq!(cell_id, alice_cell_id);
            assert_eq!(zome_name, TestWasm::EmitSignal.coordinator_zome_name());
            signal.into_inner().decode::<()>().unwrap();
        } else {
            panic!("not the expected app signal");
        }
    } else {
        panic!("not the expected app signal");
    }
}



================================================
File: crates/holochain/tests/tests/validate.rs
================================================
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;

use assert2::{assert, let_assert};
use holochain::conductor::api::error::ConductorApiError;
use holochain::conductor::CellError;
use holochain::core::workflow::WorkflowError;
use holochain::prelude::*;
use holochain::sweettest::*;
use holochain_state::source_chain::SourceChainError;

#[tokio::test(flavor = "multi_thread")]
async fn call_to_validate_in_inline_zomes_passes() {
    let config = SweetConductorConfig::standard().no_dpki();
    let mut conductor = SweetConductor::from_config(config).await;
    let agent = SweetAgents::one(conductor.keystore()).await;
    let is_validate_called = Arc::new(AtomicBool::new(false));
    let is_validate_called_clone = is_validate_called.clone();
    let zome = SweetInlineZomes::new(vec![], 0)
        .integrity_function("validate", move |_, _: Op| {
            is_validate_called_clone.store(true, Ordering::Relaxed);
            Ok(ValidateCallbackResult::Valid)
        })
        .function("touch", |_, _: ()| {
            // Simple Zome to just trigger a call to validate.
            Ok(())
        });

    let (dna, _, _) = SweetDnaFile::unique_from_inline_zomes(zome).await;
    let app = conductor
        .setup_app_for_agent("app", agent, &[dna])
        .await
        .unwrap();
    let (cell,) = app.into_tuple();

    let () = conductor
        .call(&cell.zome(SweetInlineZomes::COORDINATOR), "touch", ())
        .await;

    assert!(is_validate_called.load(Ordering::Relaxed));
}

#[tokio::test(flavor = "multi_thread")]
async fn call_validate_across_cells_passes() {
    let config = SweetConductorConfig::standard().no_dpki();
    let mut conductor = SweetConductor::from_config(config).await;
    let agent = SweetAgents::one(conductor.keystore()).await;
    let is_validate_called = Arc::new(AtomicBool::new(false));
    let is_validate_called_clone = is_validate_called.clone();
    let zome_1 = SweetInlineZomes::new(vec![], 0)
        .integrity_function("validate", move |_, _: Op| {
            is_validate_called_clone.store(true, Ordering::Relaxed);
            Ok(ValidateCallbackResult::Valid)
        })
        .function("touch", |_, _: ()| {
            // Simple Zome to just trigger a call to validate.
            Ok(())
        });
    let (dna_1, _, _) = SweetDnaFile::unique_from_inline_zomes(zome_1).await;
    let cell_id_1 = CellId::new(dna_1.dna_hash().clone(), agent.clone());

    let zome_2 = SweetInlineZomes::new(vec![], 0).function("cross_cell_call", move |api, _: ()| {
        // Simple Zome to just call the other zome.
        api.call(vec![Call {
            target: CallTarget::ConductorCell(CallTargetCell::OtherCell(cell_id_1.clone())),
            zome_name: SweetInlineZomes::COORDINATOR.into(),
            fn_name: "touch".into(),
            cap_secret: None,
            payload: ExternIO::encode(()).unwrap(),
        }])?;

        Ok(())
    });
    let (dna_2, _, _) = SweetDnaFile::unique_from_inline_zomes(zome_2).await;

    let app = conductor
        .setup_app_for_agent("app", agent, &[dna_1, dna_2])
        .await
        .unwrap();
    let (_cell_1, cell_2) = app.into_tuple();

    let () = conductor
        .call(
            &cell_2.zome(SweetInlineZomes::COORDINATOR),
            "cross_cell_call",
            (),
        )
        .await;

    assert!(is_validate_called.load(Ordering::Relaxed));
}

#[tokio::test(flavor = "multi_thread")]
async fn call_validate_with_invalid_return_type_in_inline_zomes() {
    let config = SweetConductorConfig::standard().no_dpki();
    let mut conductor = SweetConductor::from_config(config).await;
    let agent = SweetAgents::one(conductor.keystore()).await;
    let zome = SweetInlineZomes::new(vec![], 0)
        .integrity_function("validate", |_, _: Op| Ok(42))
        .function("touch", |_, _: ()| {
            // Simple Zome to just trigger a call to validate.
            Ok(())
        });

    let (dna, _, _) = SweetDnaFile::unique_from_inline_zomes(zome).await;
    let app = conductor
        .setup_app_for_agent("app", agent, &[dna])
        .await
        .unwrap();
    let (cell,) = app.into_tuple();

    let err = conductor
        .call_fallible::<_, ()>(&cell.zome(SweetInlineZomes::COORDINATOR), "touch", ())
        .await
        .unwrap_err();

    let_assert!(ConductorApiError::CellError(CellError::WorkflowError(workflow_err)) = err);
    let_assert!(
        WorkflowError::SourceChainError(SourceChainError::Other(other_err)) = *workflow_err
    );
    // Can't downcast the `Box<dyn Error>` to a concrete type so just compare the error message.
    assert!(other_err
        .to_string()
        .starts_with("The callback has an invalid return type: invalid value: integer `42`"));
}

#[tokio::test(flavor = "multi_thread")]
async fn call_validate_with_invalid_return_type_across_cells() {
    let config = SweetConductorConfig::standard().no_dpki();
    let mut conductor = SweetConductor::from_config(config).await;
    let agent = SweetAgents::one(conductor.keystore()).await;
    let zome_1 = SweetInlineZomes::new(vec![], 0)
        .integrity_function("validate", |_, _: Op| Ok(42))
        .function("touch", |_, _: ()| {
            // Simple Zome to just trigger a call to validate.
            Ok(())
        });
    let (dna_1, _, _) = SweetDnaFile::unique_from_inline_zomes(zome_1).await;
    let cell_id_1 = CellId::new(dna_1.dna_hash().clone(), agent.clone());

    let zome_2 = SweetInlineZomes::new(vec![], 0).function("cross_cell_call", move |api, _: ()| {
        // Simple Zome to just trigger a call to validate.
        api.call(vec![Call {
            target: CallTarget::ConductorCell(CallTargetCell::OtherCell(cell_id_1.clone())),
            zome_name: SweetInlineZomes::COORDINATOR.into(),
            fn_name: "touch".into(),
            cap_secret: None,
            payload: ExternIO::encode(()).unwrap(),
        }])?;

        Ok(())
    });
    let (dna_2, _, _) = SweetDnaFile::unique_from_inline_zomes(zome_2).await;

    let app = conductor
        .setup_app_for_agent("app", agent, &[dna_1, dna_2])
        .await
        .unwrap();
    let (_cell_1, cell_2) = app.into_tuple();

    let err = conductor
        .call_fallible::<_, ()>(
            &cell_2.zome(SweetInlineZomes::COORDINATOR),
            "cross_cell_call",
            (),
        )
        .await
        .unwrap_err();

    let_assert!(ConductorApiError::Other(other_err) = err);
    // Can't downcast the `Box<dyn Error>` to a concrete type so just compare the error message.
    assert!(other_err
        .to_string()
        .contains("The callback has an invalid return type: invalid value: integer `42`"));
}

#[tokio::test(flavor = "multi_thread")]
async fn call_validate_with_invalid_parameters_in_inline_zomes() {
    let config = SweetConductorConfig::standard().no_dpki();
    let mut conductor = SweetConductor::from_config(config).await;
    let agent = SweetAgents::one(conductor.keystore()).await;
    let zome = SweetInlineZomes::new(vec![], 0)
        .integrity_function("validate", |_, _: usize| Ok(ValidateCallbackResult::Valid))
        .function("touch", |_, _: ()| {
            // Simple Zome to just trigger a call to validate.
            Ok(())
        });

    let (dna, _, _) = SweetDnaFile::unique_from_inline_zomes(zome).await;
    let app = conductor
        .setup_app_for_agent("app", agent, &[dna])
        .await
        .unwrap();
    let (cell,) = app.into_tuple();

    let err = conductor
        .call_fallible::<_, ()>(&cell.zome(SweetInlineZomes::COORDINATOR), "touch", ())
        .await
        .unwrap_err();

    let_assert!(ConductorApiError::CellError(CellError::WorkflowError(workflow_err)) = err);
    let_assert!(
        WorkflowError::SourceChainError(SourceChainError::Other(other_err)) = *workflow_err
    );
    // Can't downcast the `Box<dyn Error>` to a concrete type so just compare the error message.
    assert!(
        other_err.to_string()
            == "The callback has invalid parameters: wrong msgpack marker FixMap(1)"
    );
}

#[tokio::test(flavor = "multi_thread")]
async fn call_validate_with_invalid_parameters_across_cells() {
    let config = SweetConductorConfig::standard().no_dpki();
    let mut conductor = SweetConductor::from_config(config).await;
    let agent = SweetAgents::one(conductor.keystore()).await;
    let zome_1 = SweetInlineZomes::new(vec![], 0)
        .integrity_function("validate", move |_, _: usize| {
            Ok(ValidateCallbackResult::Valid)
        })
        .function("touch", |_, _: ()| {
            // Simple Zome to just trigger a call to validate.
            Ok(())
        });
    let (dna_1, _, _) = SweetDnaFile::unique_from_inline_zomes(zome_1).await;
    let cell_id_1 = CellId::new(dna_1.dna_hash().clone(), agent.clone());

    let zome_2 = SweetInlineZomes::new(vec![], 0).function("cross_cell_call", move |api, _: ()| {
        // Simple Zome to call the other zome
        api.call(vec![Call {
            target: CallTarget::ConductorCell(CallTargetCell::OtherCell(cell_id_1.clone())),
            zome_name: SweetInlineZomes::COORDINATOR.into(),
            fn_name: "touch".into(),
            cap_secret: None,
            payload: ExternIO::encode(()).unwrap(),
        }])?;

        Ok(())
    });
    let (dna_2, _, _) = SweetDnaFile::unique_from_inline_zomes(zome_2).await;

    let app = conductor
        .setup_app_for_agent("app", agent, &[dna_1, dna_2])
        .await
        .unwrap();
    let (_cell_1, cell_2) = app.into_tuple();

    let err = conductor
        .call_fallible::<_, ()>(
            &cell_2.zome(SweetInlineZomes::COORDINATOR),
            "cross_cell_call",
            (),
        )
        .await
        .unwrap_err();

    let_assert!(ConductorApiError::Other(other_err) = err);
    // Can't downcast the `Box<dyn Error>` to a concrete type so just compare the error message.
    assert!(other_err
        .to_string()
        .contains("The callback has invalid parameters: wrong msgpack marker FixMap(1)"));
}



================================================
