File: crates/holochain/tests/tests/websocket_stress.rs
================================================
#![cfg(feature = "glacial_tests")]

use futures::sink::SinkExt;
use futures::stream::StreamExt;
use holochain::conductor::{
    api::{AdminRequest, AdminResponse},
    Conductor,
};
use holochain_conductor_api::conductor::ConductorConfig;
use holochain_conductor_api::conductor::KeystoreConfig;
use holochain_conductor_api::AdminInterfaceConfig;
use holochain_conductor_api::InterfaceDriver;
use holochain_websocket::WireMessage;
use tempfile::TempDir;
use tokio_tungstenite::*;
use tungstenite::Message;

use std::sync::atomic::{AtomicU64, Ordering};

static ID: AtomicU64 = AtomicU64::new(1);

use holochain_serialized_bytes as hsb;
use holochain_types::websocket::AllowedOrigins;

const MINUTES_LONG_BEHAVED_COUNT: usize = 10;
const MINUTES_LONG_BAD_COUNT: usize = 10;
const SECONDS_LONG_BEHAVED_COUNT: usize = 100;
const SECONDS_LONG_BAD_COUNT: usize = 100;

static CONS_MADE: AtomicU64 = AtomicU64::new(0);
static MSGS: AtomicU64 = AtomicU64::new(0);
static GOOD_CLOSE: AtomicU64 = AtomicU64::new(0);
static BAD_CLOSE: AtomicU64 = AtomicU64::new(0);

#[tokio::test(flavor = "multi_thread")]
pub async fn websocket_stress() {
    let tmp_dir = TempDir::new().unwrap();
    let data_root_path = tmp_dir.path().to_path_buf();
    let config = ConductorConfig {
        admin_interfaces: Some(vec![AdminInterfaceConfig {
            driver: InterfaceDriver::Websocket {
                port: 0,
                allowed_origins: AllowedOrigins::Any,
            },
        }]),
        data_root_path: Some(data_root_path.into()),
        keystore: KeystoreConfig::DangerTestKeystore,
        ..Default::default()
    };
    let conductor_handle = Conductor::builder().config(config).build().await.unwrap();
    let port = conductor_handle
        .get_arbitrary_admin_websocket_port()
        .expect("No admin port open on conductor");

    for _ in 0..MINUTES_LONG_BEHAVED_COUNT {
        tokio::task::spawn(run_client(port, 30, false));
    }

    for _ in 0..MINUTES_LONG_BAD_COUNT {
        tokio::task::spawn(run_client(port, 30, true));
    }

    for _ in 0..SECONDS_LONG_BEHAVED_COUNT {
        tokio::task::spawn(run_client(port, 1, false));
    }

    for _ in 0..SECONDS_LONG_BAD_COUNT {
        tokio::task::spawn(run_client(port, 1, true));
    }

    for _ in 0..(6 * 4/* 4 minutes */) {
        tokio::time::sleep(std::time::Duration::from_secs(10)).await;

        println!(
            "Connections: {}, Messages: {}, Graceful Closes: {}, Bad Closes: {}",
            CONS_MADE.load(Ordering::Relaxed),
            MSGS.load(Ordering::Relaxed),
            GOOD_CLOSE.load(Ordering::Relaxed),
            BAD_CLOSE.load(Ordering::Relaxed),
        );
    }
}

async fn run_client(port: u16, wait: u64, is_bad: bool) {
    let req: Vec<u8> = hsb::UnsafeBytes::from(hsb::encode(&AdminRequest::ListDnas).unwrap())
        .try_into()
        .unwrap();

    loop {
        let (mut client, _) = connect_async(format!("ws://127.0.0.1:{}", port))
            .await
            .unwrap();
        CONS_MADE.fetch_add(1, Ordering::Relaxed);

        for _ in 0..5 {
            let this_id = ID.fetch_add(1, Ordering::Relaxed);
            let msg = WireMessage::Request {
                id: this_id,
                data: req.clone(),
            };
            let msg: Vec<u8> = hsb::UnsafeBytes::from(hsb::encode(&msg).unwrap())
                .try_into()
                .unwrap();

            client.send(Message::Binary(msg)).await.unwrap();

            while let Some(msg) = client.next().await {
                let rsp: Vec<u8> = msg.unwrap().into_data();
                let rsp: WireMessage = hsb::decode(&rsp).unwrap();
                if let WireMessage::Response { id, data } = rsp {
                    if id == this_id {
                        if let Some(data) = data {
                            let rsp: AdminResponse = hsb::decode(&data).unwrap();
                            assert!(matches!(rsp, AdminResponse::DnasListed { .. }));
                            break;
                        } else {
                            panic!("no data");
                        }
                    }
                }
            }

            MSGS.fetch_add(1, Ordering::Relaxed);

            tokio::time::sleep(std::time::Duration::from_secs(wait)).await;
        }

        if is_bad {
            client.send(Message::Binary(req.clone())).await.unwrap();
            BAD_CLOSE.fetch_add(1, Ordering::Relaxed);
        } else {
            client.close(None).await.unwrap();
            GOOD_CLOSE.fetch_add(1, Ordering::Relaxed);
        }

        drop(client);
    }
}



================================================
File: crates/holochain/tests/tests/agent_scaling/mod.rs
================================================
#![cfg(feature = "test_utils")]

use futures::future;
use futures::FutureExt;
use hdk::prelude::GetLinksInputBuilder;
use holochain::sweettest::*;
use holochain_serialized_bytes::prelude::*;
use holochain_types::inline_zome::InlineZomeSet;
use holochain_types::prelude::*;
use holochain_wasm_test_utils::TestWasm;

#[derive(serde::Serialize, serde::Deserialize, Debug, SerializedBytes, derive_more::From)]
struct BaseTarget(AnyLinkableHash, AnyLinkableHash);

fn links_zome() -> InlineIntegrityZome {
    InlineIntegrityZome::new_unique(vec![], 1)
        .function("create_link", move |api, base_target: BaseTarget| {
            let hash = api.create_link(CreateLinkInput::new(
                base_target.0,
                base_target.1,
                ZomeIndex(0),
                LinkType::new(0),
                ().into(),
                ChainTopOrdering::default(),
            ))?;
            Ok(hash)
        })
        .function(
            "get_links",
            move |api: BoxApi, base: AnyLinkableHash| -> InlineZomeResult<Vec<Vec<Link>>> {
                Ok(api.get_links(vec![GetLinksInputBuilder::try_new(
                    base,
                    InlineZomeSet::dep_link_filter(&api),
                )
                .unwrap()
                .build()])?)
            },
        )
}

/// A single link with an AgentPubKey for the base and target is committed by
/// one agent, and after a delay, all agents can get the link
#[tokio::test(flavor = "multi_thread")]
#[cfg(feature = "slow_tests")]
async fn many_agents_can_reach_consistency_agent_links() {
    holochain_trace::test_run();
    const NUM_AGENTS: usize = 20;

    let (dna_file, _, _) = SweetDnaFile::unique_from_inline_zomes(("links", links_zome())).await;

    // Create a Conductor
    let mut conductor = SweetConductor::from_standard_config().await;

    let apps = conductor
        .setup_apps("app", NUM_AGENTS, &[dna_file])
        .await
        .unwrap();
    let cells = apps.cells_flattened();
    let alice = cells[0].zome("links");

    // Must have integrated or be able to get the agent key to link from it
    await_consistency(10, &cells[..]).await.unwrap();

    let base: AnyLinkableHash = cells[0].agent_pubkey().clone().into();
    let target: AnyLinkableHash = cells[1].agent_pubkey().clone().into();

    let _: ActionHash = conductor
        .call(
            &alice,
            "create_link",
            BaseTarget(base.clone(), target.clone()),
        )
        .await;

    await_consistency(10, &cells[..]).await.unwrap();

    let mut seen = [0usize; NUM_AGENTS];

    for (i, cell) in cells.iter().enumerate() {
        let links: Vec<Vec<Link>> = conductor
            .call(&cell.zome("links"), "get_links", base.clone())
            .await;
        seen[i] = links.into_iter().next().unwrap().len();
    }

    assert_eq!(seen.to_vec(), [1; NUM_AGENTS].to_vec());
}

/// A single link with a Path for the base and target is committed by one
/// agent, and after a delay, all agents can get the link
#[tokio::test(flavor = "multi_thread")]
#[cfg(feature = "slow_tests")]
async fn many_agents_can_reach_consistency_normal_links() {
    holochain_trace::test_run();
    const NUM_AGENTS: usize = 30;

    let (dna_file, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::Link]).await;

    // Create a Conductor
    let mut conductor = SweetConductor::from_standard_config().await;

    let apps = conductor
        .setup_apps("app", NUM_AGENTS, &[dna_file])
        .await
        .unwrap();
    let cells = apps.cells_flattened();
    let alice = cells[0].zome(TestWasm::Link);

    let _: ActionHash = conductor.call(&alice, "create_link", ()).await;

    await_consistency(10, &cells[..]).await.unwrap();

    let mut num_seen = 0;

    for cell in &cells {
        let links: Vec<Link> = conductor
            .call(&cell.zome(TestWasm::Link), "get_links", ())
            .await;
        num_seen += links.len();
    }

    assert_eq!(num_seen, NUM_AGENTS);
}

#[tokio::test(flavor = "multi_thread")]
#[cfg(feature = "test_utils")]
// This could become a bench.
#[ignore = "Slow test for CI that is only useful for timing"]
async fn stuck_conductor_wasm_calls() -> anyhow::Result<()> {
    holochain_trace::test_run();
    // Bundle the single zome into a DnaFile
    let (dna_file, _, _) =
        SweetDnaFile::unique_from_test_wasms(vec![TestWasm::MultipleCalls]).await;

    // Create a Conductor
    let mut conductor = SweetConductor::from_standard_config().await;

    // Install DNA and install and enable apps in conductor
    let alice = conductor
        .setup_app("app", &[dna_file])
        .await
        .unwrap()
        .into_cells()
        .into_iter()
        .next()
        .unwrap();
    let alice = alice.zome(TestWasm::MultipleCalls);

    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize, SerializedBytes)]
    pub struct TwoInt(pub u32, pub u32);

    // Make init run to avoid head moved errors
    let _: () = conductor.call(&alice, "slow_fn", TwoInt(0, 0)).await;

    let all_now = std::time::Instant::now();
    tracing::debug!("starting slow fn");

    // NB: there's currently no reason to independently create a bunch of tasks here,
    // since they are all running in series. Hence, there is no reason to put the SweetConductor
    // in an Arc. However, maybe this test was written to make it easy to try running some
    // or all of the closures concurrently, in which case the Arc is indeed necessary.
    let conductor_arc = std::sync::Arc::new(conductor);
    let mut handles = Vec::new();
    for i in 0..1000 {
        let h = tokio::task::spawn({
            let alice = alice.clone();
            let conductor = conductor_arc.clone();
            async move {
                let now = std::time::Instant::now();
                tracing::debug!("starting slow fn {}", i);
                let _: () = conductor.call(&alice, "slow_fn", TwoInt(i, 5)).await;
                tracing::debug!("finished slow fn {} in {}", i, now.elapsed().as_secs());
            }
        });
        handles.push(h);
    }

    for h in handles {
        h.await.unwrap();
    }

    tracing::debug!("finished all slow fn in {}", all_now.elapsed().as_secs());

    Ok(())
}

/// Check that many agents on the same conductor can all make lots of zome calls at once
/// without causing extremely ill effects
#[tokio::test(flavor = "multi_thread")]
#[cfg(feature = "slow_tests")]
#[ignore = "performance test meant to be run manually"]
async fn many_concurrent_zome_calls_dont_gunk_up_the_works() {
    use holochain_conductor_api::{AppRequest, AppResponse, ZomeCallParamsSigned};
    use std::time::Instant;

    holochain_trace::test_run();
    const NUM_AGENTS: usize = 30;

    let (dna_file, _, _) =
        SweetDnaFile::unique_from_test_wasms(vec![TestWasm::MultipleCalls]).await;

    // Create a Conductor
    let mut conductor = SweetConductor::from_standard_config().await;

    let apps = conductor
        .setup_apps("app", NUM_AGENTS, &[dna_file])
        .await
        .unwrap();
    let installed_app_id = apps[0].installed_app_id().clone();
    let cells = apps.cells_flattened();
    let zomes: Vec<_> = cells
        .iter()
        .map(|c| c.zome(TestWasm::MultipleCalls))
        .collect();
    let mut clients: Vec<_> = future::join_all((0..NUM_AGENTS).map(|_| {
        conductor
            .app_ws_client::<AppResponse>(installed_app_id.clone())
            .map(|(tx, _)| tx)
    }))
    .await;

    async fn all_call(
        conductor: &SweetConductor,
        zomes: &[holochain::sweettest::SweetZome],
        n: u32,
    ) {
        let start = Instant::now();
        let calls = future::join_all(zomes.iter().map(|zome| {
            conductor
                .call::<_, ()>(zome, "create_entry_multiple", n)
                .map(|r| (r, Instant::now()))
        }))
        .await;

        assert_eq!(calls.len(), NUM_AGENTS);

        for (i, (_, time)) in calls.iter().enumerate() {
            println!("{:>3}: {:?}", i, time.duration_since(start));
        }
    }

    async fn call_all_ws(
        conductor: &SweetConductor,
        cells: &[SweetCell],
        clients: &mut [holochain_websocket::WebsocketSender],
        n: u32,
    ) {
        let calls = future::join_all(std::iter::zip(cells, clients.iter_mut()).map(
            |(cell, client)| async move {
                let (nonce, expires_at) = holochain_nonce::fresh_nonce(Timestamp::now()).unwrap();
                let cell_id = cell.cell_id().clone();
                let call = ZomeCallParamsSigned::try_from_params(
                    conductor.raw_handle().keystore(),
                    ZomeCallParams {
                        cell_id: cell_id.clone(),
                        zome_name: TestWasm::MultipleCalls.into(),
                        fn_name: "create_entry_multiple".into(),
                        cap_secret: None,
                        provenance: cell_id.agent_pubkey().clone(),
                        payload: ExternIO::encode(n).unwrap(),
                        nonce,
                        expires_at,
                    },
                )
                .await
                .unwrap();

                let start = Instant::now();
                let res: AppResponse = client
                    .request(AppRequest::CallZome(Box::new(call)))
                    .await
                    .unwrap();
                match res {
                    AppResponse::ZomeCalled(_) => Instant::now().duration_since(start),
                    other => panic!("unexpected ws response: {:?}", other),
                }
            },
        ))
        .await;

        for (i, duration) in calls.iter().enumerate() {
            println!("{:>3}: {:?}", i, duration);
        }
    }

    println!("----------------------");
    call_all_ws(&conductor, &cells, clients.as_mut_slice(), 10).await;
    println!("----------------------");
    call_all_ws(&conductor, &cells, clients.as_mut_slice(), 100).await;
    println!("----------------------");
    call_all_ws(&conductor, &cells, clients.as_mut_slice(), 100).await;

    for _ in 0..10 {
        println!("----------------------");
        let start = Instant::now();
        all_call(&conductor, &zomes, 100).await;
        println!("overall {:?}", Instant::now().duration_since(start));
    }
}



================================================
File: crates/holochain/tests/tests/app_installation/mod.rs
================================================
use std::collections::HashMap;
use std::path::PathBuf;

use ::fixt::prelude::*;
use holochain::sweettest::*;
use holochain_conductor_api::{AppInfoStatus, CellInfo};
use holochain_types::prelude::*;
use holochain_wasm_test_utils::TestWasm;

#[tokio::test(flavor = "multi_thread")]
async fn can_install_app_with_custom_modifiers_overridden_correctly() {
    let conductor = SweetConductor::from_standard_config().await;

    let (dna, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::Create]).await;
    let path = PathBuf::from(format!("{}", dna.dna_hash()));

    let manifest_network_seed = String::from("initial seed from the manifest");
    let manifest_properties = YamlProperties::new(serde_yaml::Value::String(String::from(
        "some properties in the manifest",
    )));
    let manifest_origin_time = Timestamp::now().saturating_sub(&std::time::Duration::from_secs(1));
    let manifest_quantum_time = std::time::Duration::from_secs(60);

    let modifiers = DnaModifiersOpt::default()
        .with_network_seed(manifest_network_seed.clone())
        .with_properties(manifest_properties.clone())
        .with_origin_time(manifest_origin_time)
        .with_quantum_time(manifest_quantum_time);

    let role_name_1 = String::from("role1");
    let role_name_2 = String::from("role2");

    let roles = vec![
        AppRoleManifest {
            name: role_name_1.clone(),
            dna: AppRoleDnaManifest {
                location: Some(DnaLocation::Bundled(path.clone())),
                modifiers: modifiers.clone(),
                // Note that there is no installed hash provided. We'll check that this changes later.
                installed_hash: None,
                clone_limit: 0,
            },
            provisioning: Some(CellProvisioning::Create { deferred: false }),
        },
        AppRoleManifest {
            name: role_name_2.clone(),
            dna: AppRoleDnaManifest {
                location: Some(DnaLocation::Bundled(path.clone())),
                modifiers: modifiers.clone(),
                // Note that there is no installed hash provided. We'll check that this changes later.
                installed_hash: None,
                clone_limit: 0,
            },
            provisioning: Some(CellProvisioning::Create { deferred: false }),
        },
    ];

    let manifest = AppManifestCurrentBuilder::default()
        .name("test_app".into())
        .description(None)
        .roles(roles)
        .build()
        .unwrap();

    let resources = vec![(path.clone(), DnaBundle::from_dna_file(dna.clone()).unwrap())];

    let bundle = AppBundle::new(manifest.clone().into(), resources, PathBuf::from("."))
        .await
        .unwrap();

    //- Test that installing with custom modifiers correctly overwrites the values and that the dna hash
    //  differs from the dna hash when installed without custom modifiers
    let custom_network_seed = String::from("modified seed");
    let custom_properties = YamlProperties::new(serde_yaml::Value::String(String::from(
        "some properties provided at install time",
    )));
    let custom_origin_time = Timestamp::now();
    let custom_quantum_time = std::time::Duration::from_secs(5 * 60);

    let custom_modifiers = DnaModifiersOpt::default()
        .with_network_seed(custom_network_seed.clone())
        .with_origin_time(custom_origin_time)
        .with_quantum_time(custom_quantum_time)
        .with_properties(custom_properties.clone());

    let role_settings = (
        role_name_1.clone(),
        RoleSettings::Provisioned {
            membrane_proof: Default::default(),
            modifiers: Some(custom_modifiers),
        },
    );

    let network_seed_override = "overridden by network_seed field";

    let bundle_bytes = bundle.encode().unwrap();
    conductor
        .clone()
        .install_app_bundle(InstallAppPayload {
            agent_key: None,
            source: AppBundleSource::Bytes(bundle_bytes.clone()),
            installed_app_id: Some("app_0".into()),
            network_seed: Some(network_seed_override.into()),
            roles_settings: None,
            ignore_genesis_failure: false,
            allow_throwaway_random_agent_key: true,
        })
        .await
        .unwrap();

    conductor
        .clone()
        .install_app_bundle(InstallAppPayload {
            agent_key: None,
            source: AppBundleSource::Bytes(bundle_bytes),
            installed_app_id: Some("app_1".into()),
            network_seed: Some(network_seed_override.into()),
            roles_settings: Some(HashMap::from([role_settings])),
            ignore_genesis_failure: false,
            allow_throwaway_random_agent_key: true,
        })
        .await
        .unwrap();

    // - Check that the dna hash differs between the app installed with and the one installed without
    //   custom modifiers

    let app_info_0 = conductor
        .get_app_info(&"app_0".to_string())
        .await
        .unwrap()
        .unwrap();

    let dna_hash_0 = match app_info_0
        .cell_info
        .into_iter()
        .find(|(role_name, _)| role_name == &role_name_1)
        .unwrap()
        .1[0]
        .clone()
    {
        CellInfo::Provisioned(c) => c.cell_id.dna_hash().clone(),
        _ => panic!("wrong cell type."),
    };

    let app_info_1 = conductor
        .get_app_info(&"app_1".to_string())
        .await
        .unwrap()
        .unwrap();

    let dna_hash_1 = match app_info_1
        .cell_info
        .into_iter()
        .find(|(role_name, _)| role_name == &role_name_1)
        .unwrap()
        .1[0]
        .clone()
    {
        CellInfo::Provisioned(c) => c.cell_id.dna_hash().clone(),
        _ => panic!("wrong cell type."),
    };

    assert_ne!(dna_hash_0, dna_hash_1);

    let manifest = app_info_1.manifest;

    // - Check that the modifers have been set correctly and only for the specified role
    let installed_app_role_1 = manifest
        .app_roles()
        .into_iter()
        .find(|r| r.name == role_name_1)
        .unwrap();

    let installed_app_role_2 = manifest
        .app_roles()
        .into_iter()
        .find(|r| r.name == role_name_2)
        .unwrap();

    assert_eq!(
        installed_app_role_1.dna.modifiers.network_seed,
        Some(custom_network_seed)
    );
    assert_eq!(
        installed_app_role_1.dna.modifiers.properties,
        Some(custom_properties)
    );
    assert_eq!(
        installed_app_role_1.dna.modifiers.origin_time,
        Some(custom_origin_time)
    );
    assert_eq!(
        installed_app_role_1.dna.modifiers.quantum_time,
        Some(custom_quantum_time)
    );

    assert_eq!(
        installed_app_role_2.dna.modifiers.network_seed,
        Some(network_seed_override.into())
    );
    assert_eq!(
        installed_app_role_2.dna.modifiers.properties,
        Some(manifest_properties.clone())
    );
    assert_eq!(
        installed_app_role_2.dna.modifiers.origin_time,
        Some(manifest_origin_time)
    );
    assert_eq!(
        installed_app_role_2.dna.modifiers.quantum_time,
        Some(manifest_quantum_time)
    );
}

#[tokio::test(flavor = "multi_thread")]
async fn install_app_with_custom_modifier_fields_none_does_not_override_existing_fields() {
    let conductor = SweetConductor::from_standard_config().await;

    let (dna, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::Create]).await;
    let path = PathBuf::from(format!("{}", dna.dna_hash()));

    let manifest_network_seed = String::from("initial seed from the manifest");
    let manifest_properties = YamlProperties::new(serde_yaml::Value::String(String::from(
        "some properties in the manifest",
    )));
    let manifest_origin_time = Timestamp::now().saturating_sub(&std::time::Duration::from_secs(1));
    let manifest_quantum_time = std::time::Duration::from_secs(60);

    let modifiers = DnaModifiersOpt::default()
        .with_network_seed(manifest_network_seed.clone())
        .with_properties(manifest_properties.clone())
        .with_origin_time(manifest_origin_time)
        .with_quantum_time(manifest_quantum_time);

    let role_name = String::from("role");

    let roles = vec![AppRoleManifest {
        name: role_name.clone(),
        dna: AppRoleDnaManifest {
            location: Some(DnaLocation::Bundled(path.clone())),
            modifiers: modifiers.clone(),
            // Note that there is no installed hash provided. We'll check that this changes later.
            installed_hash: None,
            clone_limit: 0,
        },
        provisioning: Some(CellProvisioning::Create { deferred: false }),
    }];

    let manifest = AppManifestCurrentBuilder::default()
        .name("test_app".into())
        .description(None)
        .roles(roles)
        .build()
        .unwrap();

    let resources = vec![(path.clone(), DnaBundle::from_dna_file(dna.clone()).unwrap())];

    let bundle = AppBundle::new(manifest.clone().into(), resources, PathBuf::from("."))
        .await
        .unwrap();

    //- Test that modifier fields that are None in the modifiers map do not overwrite existing
    //  modifiers from the manifest
    let custom_modifiers = DnaModifiersOpt::default();

    let role_settings = (
        role_name.clone(),
        RoleSettings::Provisioned {
            membrane_proof: Default::default(),
            modifiers: Some(custom_modifiers.clone()),
        },
    );

    let bundle_bytes = bundle.encode().unwrap();
    conductor
        .clone()
        .install_app_bundle(InstallAppPayload {
            agent_key: None,
            source: AppBundleSource::Bytes(bundle_bytes),
            installed_app_id: Some("app".into()),
            network_seed: None,
            roles_settings: Some(HashMap::from([role_settings])),
            ignore_genesis_failure: false,
            allow_throwaway_random_agent_key: true,
        })
        .await
        .unwrap();

    let manifest = conductor
        .get_app_info(&"app".to_string())
        .await
        .unwrap()
        .unwrap()
        .manifest;

    let installed_app_role_1 = manifest
        .app_roles()
        .into_iter()
        .find(|r| r.name == role_name)
        .unwrap();

    // Check that the modifers have been set correctly
    assert_eq!(
        installed_app_role_1.dna.modifiers.network_seed,
        Some(manifest_network_seed.clone())
    );
    assert_eq!(
        installed_app_role_1.dna.modifiers.properties,
        Some(manifest_properties.clone())
    );
    assert_eq!(
        installed_app_role_1.dna.modifiers.origin_time,
        Some(manifest_origin_time)
    );
    assert_eq!(
        installed_app_role_1.dna.modifiers.quantum_time,
        Some(manifest_quantum_time)
    );
}

#[tokio::test(flavor = "multi_thread")]
async fn installing_with_modifiers_for_non_existing_role_fails() {
    let conductor = SweetConductor::from_standard_config().await;
    let (dna, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::Create]).await;
    let bundle = app_bundle_from_dnas(&[("role-name".into(), dna)], false, None).await;

    //- Check that installing with modifiers for a non-existent role fails
    let role_settings = (
        "unknown role name".into(),
        RoleSettings::Provisioned {
            membrane_proof: Default::default(),
            modifiers: Some(DnaModifiersOpt::default()),
        },
    );

    let bundle_bytes = bundle.encode().unwrap();
    let result = conductor
        .clone()
        .install_app_bundle(InstallAppPayload {
            agent_key: None,
            source: AppBundleSource::Bytes(bundle_bytes),
            installed_app_id: Some("app_3".into()),
            network_seed: Some("final seed".into()),
            roles_settings: Some(HashMap::from([role_settings])),
            ignore_genesis_failure: false,
            allow_throwaway_random_agent_key: true,
        })
        .await;

    assert!(result.is_err());
}

#[tokio::test(flavor = "multi_thread")]
async fn providing_membrane_proof_overrides_deferred_provisioning() {
    //- Check that if providing a membrane proof in the role settings for an app with `allow_deferred_memproofs`
    //  set to `true` in the app manifest, membrane proofs are not deferred and the app has
    //  AppInfoStatus::Running after installation
    let conductor = SweetConductor::from_standard_config().await;
    let (dna, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::Foo]).await;
    let app_id = "app-id".to_string();
    let role_name = "role".to_string();
    let bundle = app_bundle_from_dnas(&[(role_name.clone(), dna)], true, None).await;

    let role_settings = (
        role_name,
        RoleSettings::Provisioned {
            membrane_proof: Some(MembraneProof::new(fixt!(SerializedBytes))),
            modifiers: None,
        },
    );

    let bundle_bytes = bundle.encode().unwrap();
    //- Install with a membrane proof provided in the roles_settings
    let app = conductor
        .clone()
        .install_app_bundle(InstallAppPayload {
            source: AppBundleSource::Bytes(bundle_bytes),
            agent_key: None,
            installed_app_id: Some(app_id.clone()),
            roles_settings: Some(HashMap::from([role_settings])),
            network_seed: None,
            ignore_genesis_failure: false,
            allow_throwaway_random_agent_key: true,
        })
        .await
        .unwrap();

    assert_eq!(app.role_assignments().len(), 1);

    //- Status is now Disabled with the normal `NeverStarted` reason.
    let app_info = conductor.get_app_info(&app_id).await.unwrap().unwrap();

    assert_eq!(
        app_info.status,
        AppInfoStatus::Disabled {
            reason: DisabledAppReason::NeverStarted
        }
    );

    conductor.enable_app(app_id.clone()).await.unwrap();

    //- Status is Running, i.e. membrane proof provisioning has not been deferred
    let app_info = conductor.get_app_info(&app_id).await.unwrap().unwrap();

    assert_eq!(app_info.status, AppInfoStatus::Running);
}



================================================
File: crates/holochain/tests/tests/authored_test/mod.rs
================================================
use std::time::Duration;

use rusqlite::named_params;

use holo_hash::AnyDhtHash;
use holochain::sweettest::*;
use holochain::test_utils::wait_for_integration;
use holochain_sqlite::error::DatabaseResult;
use holochain_wasm_test_utils::TestWasm;
use holochain_zome_types::prelude::*;

/// - Alice commits an entry and it is in their authored store
/// - Bob doesn't have the entry in their authored store
/// - Bob does have the entry in their integrated store
/// - Bob commits the entry and it is now in their authored store
#[tokio::test(flavor = "multi_thread")]
async fn authored_test() {
    holochain_trace::test_run();
    // Check if the correct number of ops are integrated
    // every 100 ms for a maximum of 10 seconds but early exit
    // if they are there.
    let num_attempts = 100;
    let delay_per_attempt = Duration::from_millis(100);

    let zomes = vec![TestWasm::Create];
    let mut conductor = SweetConductor::from_standard_config().await;
    let (dna, _, _) = SweetDnaFile::unique_from_test_wasms(zomes).await;
    let ((alice,), (bob,)) = conductor
        .setup_apps("app", 2, [&dna])
        .await
        .unwrap()
        .into_tuples();

    let handle = conductor.raw_handle();

    let _: ActionHash = conductor
        .call(&alice.zome(TestWasm::Create), "create_entry", ())
        .await;

    let record: Option<Record> = conductor
        .call(&alice.zome(TestWasm::Create), "get_entry", ())
        .await;

    let entry_hash = record.unwrap().action().entry_hash().cloned().unwrap();

    // publish these commits
    let triggers = handle.get_cell_triggers(alice.cell_id()).await.unwrap();
    triggers.integrate_dht_ops.trigger(&"authored_test");

    // Alice commits the entry
    alice
        .authored_db()
        .read_async({
            let basis: AnyDhtHash = entry_hash.clone().into();
            let alice_pk = alice.cell_id().agent_pubkey().clone();

            move |txn| -> DatabaseResult<()> {
                let has_authored_entry: bool = txn.query_row(
                    "SELECT EXISTS(SELECT 1 FROM DhtOp JOIN Action ON DhtOp.action_hash = Action.hash
                    WHERE basis_hash = :hash AND Action.author = :author)",
                    named_params! {
                    ":hash": basis,
                    ":author": alice_pk,
                },
                    |row| row.get(0),
                )?;

                assert!(has_authored_entry);

                Ok(())
            }
        })
        .await
        .unwrap();

    // Integration should have 3 ops in it.
    // Plus another 14 (2x7) for genesis.
    // Init is not run because we aren't calling the zome.
    let expected_count = 3 + 14;

    wait_for_integration(
        bob.dht_db(),
        expected_count,
        num_attempts,
        delay_per_attempt,
    )
    .await
    .unwrap();

    bob
        .authored_db()
        .read_async({
            let basis: AnyDhtHash = entry_hash.clone().into();
            let bob_pk = bob.cell_id().agent_pubkey().clone();

            move |txn| -> DatabaseResult<()> {
                let has_authored_entry: bool = txn.query_row(
                    "SELECT EXISTS(SELECT 1 FROM DhtOp JOIN Action ON DhtOp.action_hash = Action.hash
                    WHERE basis_hash = :hash AND Action.author = :author)",
                    named_params! {
                    ":hash": basis,
                    ":author": bob_pk,
                },
                    |row| row.get(0),
                )?;
                // Bob Should not have the entry in their authored table
                assert!(!has_authored_entry);

                Ok(())
            }
        })
        .await
        .unwrap();

    bob.dht_db()
        .read_async({
            let basis: AnyDhtHash = entry_hash.clone().into();

            move |txn| -> DatabaseResult<()> {
                let has_integrated_entry: bool = txn.query_row(
                    "SELECT EXISTS(SELECT 1 FROM DhtOp WHERE basis_hash = :hash)",
                    named_params! {
                        ":hash": basis,
                    },
                    |row| row.get(0),
                )?;

                assert!(has_integrated_entry);

                Ok(())
            }
        })
        .await
        .unwrap();

    // Now bob commits the entry
    let _: ActionHash = conductor
        .call(&bob.zome(TestWasm::Create), "create_entry", ())
        .await;

    // Produce and publish these commits
    let triggers = handle.get_cell_triggers(bob.cell_id()).await.unwrap();
    triggers.publish_dht_ops.trigger(&"");

    bob
        .authored_db()
        .read_async({
            let basis: AnyDhtHash = entry_hash.clone().into();
            let bob_pk = bob.cell_id().agent_pubkey().clone();

            move |txn| -> DatabaseResult<()> {
                let has_authored_entry: bool = txn.query_row(
                    "SELECT EXISTS(SELECT 1 FROM DhtOp JOIN Action ON DhtOp.action_hash = Action.hash
                    WHERE basis_hash = :hash AND Action.author = :author)",
                    named_params! {
                    ":hash": basis,
                    ":author": bob_pk,
                },
                    |row| row.get(0),
                )?;

                // Bob Should have the entry in their authored table because they committed it.
                assert!(has_authored_entry);

                Ok(())
            }
        })
        .await
        .unwrap();
}



================================================
File: crates/holochain/tests/tests/clone_cell/mod.rs
================================================
use holochain::sweettest::*;
use holochain_conductor_api::CellInfo;
use holochain_types::prelude::*;
use holochain_wasm_test_utils::TestWasm;

#[tokio::test(flavor = "multi_thread")]
async fn create_clone_cell() {
    holochain_trace::test_run();

    let mut conductor = SweetConductor::from_standard_config().await;
    let (dna_file, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::Clone]).await;

    let app = conductor.setup_app("app", [&dna_file]).await.unwrap();
    let (cell,) = app.clone().into_tuple();

    let zome = SweetZome::new(
        cell.cell_id().clone(),
        TestWasm::Clone.coordinator_zome_name(),
    );
    let request = CreateCloneCellInput {
        cell_id: cell.cell_id().clone(),
        modifiers: DnaModifiersOpt::none().with_network_seed("clone 1".to_string()),
        membrane_proof: None,
        name: Some("Clone 1".to_string()),
    };
    let _: ClonedCell = conductor.call(&zome, "create_clone", request).await;

    let apps = conductor.list_apps(None).await.unwrap();
    assert_eq!(1, apps.len());

    let cell_infos = apps
        .first()
        .unwrap()
        .cell_info
        .get(&dna_file.dna_hash().to_string())
        .unwrap();
    assert_eq!(2, cell_infos.len());
    assert_eq!(
        1,
        cell_infos
            .iter()
            .filter(|c| matches!(c, CellInfo::Cloned(_)))
            .count()
    );
}

#[tokio::test(flavor = "multi_thread")]
async fn disable_enable_and_delete_clone_cell() {
    holochain_trace::test_run();

    let mut conductor = SweetConductor::from_standard_config().await;
    let (dna_file, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::Clone]).await;

    let app = conductor.setup_app("app", [&dna_file]).await.unwrap();
    let (cell,) = app.clone().into_tuple();

    let zome = SweetZome::new(
        cell.cell_id().clone(),
        TestWasm::Clone.coordinator_zome_name(),
    );
    let request = CreateCloneCellInput {
        cell_id: cell.cell_id().clone(),
        modifiers: DnaModifiersOpt::none().with_network_seed("clone 1".to_string()),
        membrane_proof: None,
        name: Some("Clone 1".to_string()),
    };
    let cloned_cell: ClonedCell = conductor.call(&zome, "create_clone", request).await;

    let request = DisableCloneCellInput {
        clone_cell_id: CloneCellId::CloneId(cloned_cell.clone_id.clone()),
    };
    let _: () = conductor.call(&zome, "disable_clone", request).await;

    // Try and call the disabled clone cell, should fail
    let clone_zome = SweetZome::new(
        cloned_cell.cell_id.clone(),
        TestWasm::Clone.coordinator_zome_name(),
    );
    let request = CreateCloneCellInput {
        cell_id: cell.cell_id().clone(),
        modifiers: DnaModifiersOpt::none().with_network_seed("clone 2".to_string()),
        membrane_proof: None,
        name: Some("Clone 2".to_string()),
    };
    conductor
        .call_fallible::<_, ClonedCell>(&clone_zome, "create_clone", request)
        .await
        .unwrap_err();

    // Re-enable the clone cell
    let request = EnableCloneCellInput {
        clone_cell_id: CloneCellId::CloneId(cloned_cell.clone_id.clone()),
    };
    let _: ClonedCell = conductor.call(&zome, "enable_clone", request).await;

    // Try again to create a second clone cell, should succeed
    let request = CreateCloneCellInput {
        cell_id: cell.cell_id().clone(),
        modifiers: DnaModifiersOpt::none().with_network_seed("clone 2".to_string()),
        membrane_proof: None,
        name: Some("Clone 2".to_string()),
    };
    conductor
        .call::<_, ClonedCell>(&clone_zome, "create_clone", request)
        .await;

    // Now disable and delete the clone
    let request = DisableCloneCellInput {
        clone_cell_id: CloneCellId::CloneId(cloned_cell.clone_id.clone()),
    };
    let _: () = conductor.call(&zome, "disable_clone", request).await;

    let request = DeleteCloneCellInput {
        clone_cell_id: CloneCellId::CloneId(cloned_cell.clone_id.clone()),
    };
    let _: () = conductor.call(&zome, "delete_clone", request).await;

    let apps = conductor.list_apps(None).await.unwrap();
    assert_eq!(1, apps.len());

    let cell_infos = apps
        .first()
        .unwrap()
        .cell_info
        .get(&dna_file.dna_hash().to_string())
        .unwrap();
    // Still two cells, the original and the second clone
    assert_eq!(2, cell_infos.len());
    assert_eq!(
        1,
        cell_infos
            .iter()
            .filter(|c| matches!(c, CellInfo::Cloned(_)))
            .count()
    );
}

#[tokio::test(flavor = "multi_thread")]
async fn prevents_cross_app_clone_operations() {
    holochain_trace::test_run();

    let mut conductor = SweetConductor::from_standard_config().await;
    let (dna_file, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::Clone]).await;

    let app = conductor.setup_app("app", [&dna_file]).await.unwrap();
    let (cell,) = app.clone().into_tuple();

    let zome = SweetZome::new(
        cell.cell_id().clone(),
        TestWasm::Clone.coordinator_zome_name(),
    );
    let request = CreateCloneCellInput {
        cell_id: cell.cell_id().clone(),
        modifiers: DnaModifiersOpt::none().with_network_seed("clone 1".to_string()),
        membrane_proof: None,
        name: Some("Clone 1".to_string()),
    };
    let cloned_cell: ClonedCell = conductor.call(&zome, "create_clone", request).await;

    let (other_dna_file, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::Clone]).await;
    let other_app = conductor
        .setup_app("other app", [&other_dna_file])
        .await
        .unwrap();
    let (other_cell,) = other_app.clone().into_tuple();

    let apps = conductor.list_apps(None).await.unwrap();
    tracing::info!(?apps, "have apps");

    // Should fail to create a clone cell against the other app
    let other_zome = SweetZome::new(
        other_cell.cell_id().clone(),
        TestWasm::Clone.coordinator_zome_name(),
    );
    let other_request = CreateCloneCellInput {
        // Targeting the cell from the original app
        cell_id: cell.cell_id().clone(),
        modifiers: DnaModifiersOpt::none().with_network_seed("other clone 1".to_string()),
        membrane_proof: None,
        name: Some("Other clone 1".to_string()),
    };
    conductor
        .call_fallible::<_, ClonedCell>(&other_zome, "create_clone", other_request)
        .await
        .unwrap_err();

    // Should fail to disable the clone cell from the other app
    let other_request = DisableCloneCellInput {
        clone_cell_id: CloneCellId::CloneId(cloned_cell.clone_id.clone()),
    };
    conductor
        .call_fallible::<_, ()>(&other_zome, "disable_clone", other_request)
        .await
        .unwrap_err();

    // Actually disable the clone cell from the original app
    let request = DisableCloneCellInput {
        clone_cell_id: CloneCellId::CloneId(cloned_cell.clone_id.clone()),
    };
    let _: () = conductor.call(&zome, "disable_clone", request).await;

    // Try to enable the clone cell from the other app, should fail
    let other_request = EnableCloneCellInput {
        clone_cell_id: CloneCellId::CloneId(cloned_cell.clone_id.clone()),
    };
    conductor
        .call_fallible::<_, ClonedCell>(&other_zome, "enable_clone", other_request)
        .await
        .unwrap_err();

    // Try to delete the clone cell from the other app, should fail
    let other_request = DeleteCloneCellInput {
        clone_cell_id: CloneCellId::CloneId(cloned_cell.clone_id.clone()),
    };
    conductor
        .call_fallible::<_, ()>(&other_zome, "delete_clone", other_request)
        .await
        .unwrap_err();

    // Enable the cell again
    let request = EnableCloneCellInput {
        clone_cell_id: CloneCellId::CloneId(cloned_cell.clone_id.clone()),
    };
    let _: ClonedCell = conductor.call(&zome, "enable_clone", request).await;

    // Finally check the clone is still there
    let apps = conductor.list_apps(None).await.unwrap();
    assert_eq!(2, apps.len());

    let cell_infos = apps
        .iter()
        .find(|app| app.installed_app_id == "app")
        .unwrap()
        .cell_info
        .get(&dna_file.dna_hash().to_string())
        .unwrap();
    assert_eq!(2, cell_infos.len());
    assert_eq!(
        1,
        cell_infos
            .iter()
            .filter(|c| matches!(c, CellInfo::Cloned(_)))
            .count()
    );
}

#[tokio::test(flavor = "multi_thread")]
async fn create_clone_cell_from_a_clone() {
    holochain_trace::test_run();

    let mut conductor = SweetConductor::from_standard_config().await;
    let (dna_file, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::Clone]).await;

    let app = conductor.setup_app("app", [&dna_file]).await.unwrap();
    let (cell,) = app.clone().into_tuple();

    let zome = SweetZome::new(
        cell.cell_id().clone(),
        TestWasm::Clone.coordinator_zome_name(),
    );
    let request = CreateCloneCellInput {
        cell_id: cell.cell_id().clone(),
        modifiers: DnaModifiersOpt::none().with_network_seed("clone 1".to_string()),
        membrane_proof: None,
        name: Some("Clone 1".to_string()),
    };
    let cloned_cell: ClonedCell = conductor.call(&zome, "create_clone", request).await;

    let clone_zome = SweetZome::new(
        cloned_cell.cell_id.clone(),
        TestWasm::Clone.coordinator_zome_name(),
    );
    let request = CreateCloneCellInput {
        // Clone the original cell
        cell_id: cell.cell_id().clone(),
        modifiers: DnaModifiersOpt::none().with_network_seed("clone 2".to_string()),
        membrane_proof: None,
        name: Some("Clone 2".to_string()),
    };
    // Send the request to the clone cell
    let _: ClonedCell = conductor.call(&clone_zome, "create_clone", request).await;

    let apps = conductor.list_apps(None).await.unwrap();
    assert_eq!(1, apps.len());

    let cell_infos = apps
        .first()
        .unwrap()
        .cell_info
        .get(&dna_file.dna_hash().to_string())
        .unwrap();
    assert_eq!(3, cell_infos.len());
    assert_eq!(
        2,
        cell_infos
            .iter()
            .filter(|c| matches!(c, CellInfo::Cloned(_)))
            .count()
    );
}

#[tokio::test(flavor = "multi_thread")]
async fn create_clone_of_another_cell_in_same_app() {
    holochain_trace::test_run();

    let mut conductor = SweetConductor::from_standard_config().await;
    let (dna_file_1, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::Clone]).await;
    let (dna_file_2, _, _) =
        SweetDnaFile::unique_from_test_wasms(vec![TestWasm::DnaProperties]).await;

    let app = conductor
        .setup_app("app", [&dna_file_1, &dna_file_2])
        .await
        .unwrap();
    let (cell_1, cell_2) = app.clone().into_tuple();

    let zome = SweetZome::new(
        cell_1.cell_id().clone(),
        TestWasm::Clone.coordinator_zome_name(),
    );
    let request = CreateCloneCellInput {
        // Try to clone cell 2 from cell 1
        cell_id: cell_2.cell_id().clone(),
        modifiers: DnaModifiersOpt::none().with_network_seed("clone 1".to_string()),
        membrane_proof: None,
        name: Some("Clone 1".to_string()),
    };
    let _: ClonedCell = conductor.call(&zome, "create_clone", request).await;

    let apps = conductor.list_apps(None).await.unwrap();
    assert_eq!(1, apps.len());

    let cell_infos = apps
        .first()
        .unwrap()
        .cell_info
        .get(&dna_file_2.dna_hash().to_string())
        .unwrap();
    assert_eq!(2, cell_infos.len());
    assert_eq!(
        1,
        cell_infos
            .iter()
            .filter(|c| matches!(c, CellInfo::Cloned(_)))
            .count()
    );
}



================================================
File: crates/holochain/tests/tests/conductor_services/mod.rs
================================================
use holochain::{
    conductor::config::DpkiConfig, sweettest::*, test_utils::inline_zomes::simple_create_read_zome,
};
use holochain_conductor_services::KeyState;
use holochain_types::prelude::*;

#[tokio::test(flavor = "multi_thread")]
async fn initialize_dpki() {
    holochain_trace::test_run();

    let mut config = SweetConductorConfig::standard();
    config.dpki = DpkiConfig::production(None);
    let mut conductor = SweetConductor::from_config(config).await;

    assert!(conductor.running_services().dpki.is_some());

    // Install app
    {
        let (app_dna_file, _, _) =
            SweetDnaFile::unique_from_inline_zomes(("simple", simple_create_read_zome())).await;

        conductor
            .setup_app("installed_app_id", &[app_dna_file])
            .await
            .unwrap();
    }
}

/// Crude check that an agent without the same DPKI instance as others can't
/// validate actions
#[tokio::test(flavor = "multi_thread")]
#[cfg_attr(target_os = "windows", ignore = "flaky")]
async fn validate_with_dpki() {
    holochain_trace::test_run();

    let rendezvous = SweetLocalRendezvous::new().await;
    let config = SweetConductorConfig::rendezvous(true);

    let mut conductors = SweetConductorBatch::new(vec![
        SweetConductor::from_config_rendezvous(config.clone(), rendezvous.clone()).await,
        SweetConductor::from_config_rendezvous(config.clone(), rendezvous.clone()).await,
        SweetConductor::from_config_rendezvous(config.clone().no_dpki(), rendezvous.clone()).await,
    ]);

    let (app_dna_file, _, _) =
        SweetDnaFile::unique_from_inline_zomes(("simple", simple_create_read_zome())).await;

    let ((alice,), (bob,), (carol,)) = conductors
        .setup_app("app", [&app_dna_file])
        .await
        .unwrap()
        .into_tuples();

    async fn key_state(conductor: &SweetConductor, agent: &AgentPubKey) -> KeyState {
        conductor
            .running_services()
            .dpki
            .as_ref()
            .unwrap()
            .state()
            .await
            .key_state(agent.clone(), Timestamp::now())
            .await
            .unwrap()
    }

    assert!(matches!(
        key_state(&conductors[0], alice.agent_pubkey()).await,
        KeyState::Valid(_)
    ));
    assert!(matches!(
        key_state(&conductors[0], bob.agent_pubkey()).await,
        KeyState::NotFound
    ));
    assert!(matches!(
        key_state(&conductors[1], alice.agent_pubkey()).await,
        KeyState::NotFound
    ));
    assert!(matches!(
        key_state(&conductors[1], bob.agent_pubkey()).await,
        KeyState::Valid(_)
    ));

    println!("--------------------------------------------");
    println!("AGENTS:");
    println!("alice: {:?}", alice.agent_pubkey());
    println!("bob:   {:?}", bob.agent_pubkey());
    println!("carol: {:?}", carol.agent_pubkey());
    println!("--------------------------------------------");

    await_consistency(30, &conductors.dpki_cells()[0..=1])
        .await
        .unwrap();
    await_consistency(30, [&alice, &bob]).await.unwrap();

    // Both now see each other in DPKI
    assert!(matches!(
        key_state(&conductors[0], bob.agent_pubkey()).await,
        KeyState::Valid(_)
    ));
    assert!(matches!(
        key_state(&conductors[1], alice.agent_pubkey()).await,
        KeyState::Valid(_)
    ));

    let hash: ActionHash = conductors[0]
        .call(&alice.zome("simple"), "create", ())
        .await;

    await_consistency(30, [&alice, &bob]).await.unwrap();

    // Carol is nowhere to be found since she never installed DPKI
    assert!(matches!(
        key_state(&conductors[0], carol.agent_pubkey()).await,
        KeyState::NotFound
    ));
    assert!(matches!(
        key_state(&conductors[1], carol.agent_pubkey()).await,
        KeyState::NotFound
    ));

    let record_bob: Option<Record> = conductors[1]
        .call(&bob.zome("simple"), "read", hash.clone())
        .await;
    let record_carol: Option<Record> = conductors[2]
        .call(&carol.zome("simple"), "read", hash.clone())
        .await;

    assert!(record_bob.is_some());

    // Carol can't get the record. This doesn't necessarily prove that DPKI
    // is working, but it at least demonstrates something basic about validation.
    // A better test would check the *reason* why the record couldn't be fetched.
    assert!(
        record_carol.is_none(),
        "Carol should not be able to communicate with the other two"
    );
}



================================================
File: crates/holochain/tests/tests/countersigning/session_interaction_over_websocket.rs
================================================
//! Test countersigning session interaction over websockets with full Holochain conductor.
//!
//! Tests run the Holochain binary and communicate over websockets.

use crate::tests::test_utils::{
    attach_app_interface, call_zome_fn, call_zome_fn_fallible, check_timeout, create_config,
    register_and_install_dna, start_holochain_with_lair, start_local_services, write_config,
    SupervisedChild,
};
use ed25519_dalek::SigningKey;
use hdk::prelude::{CapAccess, GrantZomeCallCapabilityPayload, GrantedFunctions, ZomeCallCapGrant};
use hdk::prelude::{
    CapSecret, CellId, FunctionName, PreflightRequest, PreflightRequestAcceptance, Role,
};
use holo_hash::{ActionHash, AgentPubKey};
use holochain::prelude::{
    CountersigningSessionState, DhtOp, Signal, SystemSignal, CAP_SECRET_BYTES,
};
use holochain::sweettest::{authenticate_app_ws_client, websocket_client_by_port, WsPollRecv};
use holochain::{
    conductor::{api::error::ConductorApiError, error::ConductorError},
    prelude::CountersigningError,
};
use holochain_conductor_api::conductor::{ConductorTuningParams, KeystoreConfig};
use holochain_conductor_api::AppRequest;
use holochain_conductor_api::{AdminRequest, AdminResponse, AppResponse};
use holochain_serialized_bytes::{SerializedBytes, SerializedBytesError};
use holochain_types::test_utils::{fake_dna_zomes, write_fake_dna_file};
use holochain_wasm_test_utils::TestWasm;
use holochain_websocket::{ReceiveMessage, WebsocketReceiver, WebsocketSender};
use kitsune_p2p_types::config::{KitsuneP2pConfig, TransportConfig};
use matches::assert_matches;
use rand::rngs::OsRng;
use serde::{de::DeserializeOwned, Serialize};
use std::cmp::Ordering;
use std::collections::BTreeSet;
use std::path::PathBuf;
use std::time::Duration;
use tempfile::TempDir;
use url2::Url2;

const APP_ID: &str = "test";

// Test countersigning interaction calls.
// - two agents on two conductors
// - alice commits a countersigned entry, bob does not commit, and alice shuts down the conductor (puts her session in unresolved state)
// - alice makes call to abandon the session
// - again alice and bob accept a new preflight request
// - bob commits the countersigned entry and shuts down (session unresolved)
// - alice commits the countersigned entry too while bob is offline and restarts her conductor (session unresolved)
// - alice makes call to publish entry
// - bob starts up conductor again
// - await dht sync
#[tokio::test(flavor = "multi_thread")]
#[cfg(feature = "slow_tests")]
async fn countersigning_session_interaction_calls() {
    holochain_trace::test_run();

    // Start local bootstrap and signal servers.
    let (_local_services, bootstrap_url_recv, signal_url_recv) = start_local_services().await;
    let bootstrap_url = bootstrap_url_recv.await.unwrap();
    let signal_url = signal_url_recv.await.unwrap();

    let network_seed = uuid::Uuid::new_v4().to_string();

    // Set up two agents on two conductors.
    let mut alice = Agent::setup(
        bootstrap_url.clone(),
        signal_url.clone(),
        network_seed.clone(),
    )
    .await;

    // Attach app interface to Alice's conductor.
    let (alice_app_tx, mut alice_app_rx) = alice.connect_app_interface().await;
    // Spawn task listening to app socket messages, preventing app socket to be dropped.
    tokio::spawn(async move { while alice_app_rx.recv::<AppResponse>().await.is_ok() {} });

    let mut bob = Agent::setup(bootstrap_url, signal_url, network_seed.clone()).await;

    // Attach app interface to Bob's conductor.
    let (bob_app_tx, mut bob_app_rx) = bob.connect_app_interface().await;
    // Spawn task listening to app socket messages, preventing app socket to be dropped.
    // Bob will later listen for an abandoned session signal.
    let (bob_session_abandonded_tx, mut bob_session_abandonded_rx) = tokio::sync::mpsc::channel(1);
    tokio::spawn(async move {
        while let Ok(ReceiveMessage::Signal(signal)) = bob_app_rx.recv::<AppResponse>().await {
            match Signal::try_from_vec(signal).unwrap() {
                Signal::System(SystemSignal::AbandonedCountersigning(entry_hash)) => {
                    let _ = bob_session_abandonded_tx.send(entry_hash).await;
                }
                _ => unreachable!(),
            }
        }
    });

    // Await peers to discover each other.
    tokio::time::timeout(
        Duration::from_secs(5),
        expect_bootstrapping_completed(&[&alice, &bob]),
    )
    .await
    .unwrap();

    println!(
        "Agents Alice {} and Bob {} set up and see each other.\n",
        alice.cell_id.agent_pubkey(),
        bob.cell_id.agent_pubkey()
    );

    // Initialize Alice's source chain.
    let _: ActionHash = alice.call_zome(&alice_app_tx, "create_a_thing", &()).await;

    // Initialize Bob's source chain.
    let _: ActionHash = bob.call_zome(&bob_app_tx, "create_a_thing", &()).await;

    // Await DHT sync of both agents.
    tokio::time::timeout(Duration::from_secs(30), await_dht_sync(&[&alice, &bob]))
        .await
        .unwrap();

    // Countersigning session state should not be in Alice's conductor memory yet.
    assert_matches!(get_session_state(&alice.cell_id, &alice_app_tx).await, None);
    // Countersigning session state should not be in Bob's conductor memory yet.
    assert_matches!(get_session_state(&bob.cell_id, &bob_app_tx).await, None);

    // Abandoning a session of a non-existing cell should return an error.
    let response: AppResponse = request(
        AppRequest::AbandonCountersigningSession(Box::new(bob.cell_id.clone())),
        &alice_app_tx,
    )
    .await;
    let expected_error = AppResponse::Error(
        ConductorApiError::ConductorError(ConductorError::CountersigningError(
            CountersigningError::WorkspaceDoesNotExist(bob.cell_id.clone()),
        ))
        .into(),
    );
    assert_eq!(format!("{:?}", response), format!("{:?}", expected_error));

    // Abandoning a non-existing session of an existing cell should return an error.
    let response: AppResponse = request(
        AppRequest::AbandonCountersigningSession(Box::new(alice.cell_id.clone())),
        &alice_app_tx,
    )
    .await;
    let expected_error = AppResponse::Error(
        ConductorApiError::ConductorError(ConductorError::CountersigningError(
            CountersigningError::SessionNotFound(alice.cell_id.clone()),
        ))
        .into(),
    );
    assert_eq!(format!("{:?}", response), format!("{:?}", expected_error));

    // Publishing a session of a non-existing cell should return an error.
    let response: AppResponse = request(
        AppRequest::PublishCountersigningSession(Box::new(bob.cell_id.clone())),
        &alice_app_tx,
    )
    .await;
    let expected_error = AppResponse::Error(
        ConductorApiError::ConductorError(ConductorError::CountersigningError(
            CountersigningError::WorkspaceDoesNotExist(bob.cell_id.clone()),
        ))
        .into(),
    );
    assert_eq!(format!("{:?}", response), format!("{:?}", expected_error));

    // Publishing a non-existing session of an existing cell should return an error.
    let response: AppResponse = request(
        AppRequest::PublishCountersigningSession(Box::new(alice.cell_id.clone())),
        &alice_app_tx,
    )
    .await;
    let expected_error = AppResponse::Error(
        ConductorApiError::ConductorError(ConductorError::CountersigningError(
            CountersigningError::SessionNotFound(alice.cell_id.clone()),
        ))
        .into(),
    );
    assert_eq!(format!("{:?}", response), format!("{:?}", expected_error));

    // Set up the session and accept it for both agents.
    let preflight_request: PreflightRequest = alice
        .call_zome(
            &alice_app_tx,
            "generate_countersigning_preflight_request_fast", // 10 sec timeout
            &[
                (alice.cell_id.agent_pubkey().clone(), vec![Role(0)]),
                (bob.cell_id.agent_pubkey().clone(), vec![]),
            ],
        )
        .await;
    let alice_acceptance: PreflightRequestAcceptance = alice
        .call_zome(
            &alice_app_tx,
            "accept_countersigning_preflight_request",
            &preflight_request,
        )
        .await;
    let alice_response =
        if let PreflightRequestAcceptance::Accepted(ref response) = alice_acceptance {
            response
        } else {
            unreachable!();
        };
    let bob_acceptance: PreflightRequestAcceptance = bob
        .call_zome(
            &bob_app_tx,
            "accept_countersigning_preflight_request",
            &preflight_request,
        )
        .await;
    let bob_response = if let PreflightRequestAcceptance::Accepted(ref response) = bob_acceptance {
        response
    } else {
        unreachable!();
    };

    // Countersigning session state should exist for both agents and be in "Accepted" state.
    assert_matches!(
        get_session_state(&alice.cell_id, &alice_app_tx).await,
        Some(CountersigningSessionState::Accepted(_))
    );
    assert_matches!(
        get_session_state(&bob.cell_id, &bob_app_tx).await,
        Some(CountersigningSessionState::Accepted(_))
    );

    // Abandoning a session in a resolvable state should not be possible and return an error.
    let response: AppResponse = request(
        AppRequest::AbandonCountersigningSession(Box::new(alice.cell_id.clone())),
        &alice_app_tx,
    )
    .await;
    let expected_error = AppResponse::Error(
        ConductorApiError::ConductorError(ConductorError::CountersigningError(
            CountersigningError::SessionNotUnresolved(alice.cell_id.clone()),
        ))
        .into(),
    );
    assert_eq!(format!("{:?}", response), format!("{:?}", expected_error));

    // Publishing a session in a resolvable state should not be possible and return an error.
    let response: AppResponse = request(
        AppRequest::PublishCountersigningSession(Box::new(alice.cell_id.clone())),
        &alice_app_tx,
    )
    .await;
    let expected_error = AppResponse::Error(
        ConductorApiError::ConductorError(ConductorError::CountersigningError(
            CountersigningError::SessionNotUnresolved(alice.cell_id.clone()),
        ))
        .into(),
    );
    assert_eq!(format!("{:?}", response), format!("{:?}", expected_error));

    // Session should be unaffected by the failing calls.
    assert_matches!(
        get_session_state(&alice.cell_id, &alice_app_tx).await,
        Some(CountersigningSessionState::Accepted(_))
    );

    // Alice commits the countersigning entry. Up to 5 retries in case Bob's chain head can not be fetched
    // immediately.
    for _ in 0..5 {
        let response = call_zome_fn_fallible(
            &alice_app_tx,
            alice.cell_id.clone(),
            &alice.signing_keypair,
            alice.cap_secret,
            TestWasm::CounterSigning.coordinator_zome_name(),
            "create_a_countersigned_thing_with_entry_hash".into(),
            &[alice_response.clone(), bob_response.clone()],
        )
        .await;

        if let AppResponse::ZomeCalled(_) = response {
            break;
        }
        tokio::time::sleep(Duration::from_millis(100)).await;
    }

    tracing::info!("Alice committed countersigned entry - restarting conductor to provoke unresolved state...\n");

    // Restart Alice's conductor to put countersigning session in unresolved state.
    let mut alice = alice.restart_conductor().await;

    // Attach app interface to Alice's conductor.
    let (alice_app_tx, mut alice_app_rx) = alice.connect_app_interface().await;
    // Spawn task listening to system signal of abandoned session.
    let (alice_session_abandonded_tx, mut alice_session_abandonded_rx) =
        tokio::sync::mpsc::channel(1);
    tokio::spawn(async move {
        while let Ok(ReceiveMessage::Signal(signal)) = alice_app_rx.recv::<AppResponse>().await {
            match Signal::try_from_vec(signal).unwrap() {
                Signal::System(SystemSignal::AbandonedCountersigning(entry_hash)) => {
                    let _ = alice_session_abandonded_tx.send(entry_hash).await;
                }
                _ => unreachable!(),
            }
        }
    });

    // Alice's session should be in state unresolved with 1 attempted resolution.
    tokio::time::timeout(Duration::from_secs(5), async {
        loop {
            let state = get_session_state(&alice.cell_id, &alice_app_tx).await;
            if let Some(CountersigningSessionState::Unknown {
                resolution: summary,
                ..
            }) = state
            {
                if summary.attempts == 1 {
                    break;
                }
            }
            tokio::time::sleep(Duration::from_millis(100)).await;
        }
    })
    .await
    .unwrap();

    // Bob's session should still be in Accepted state.
    assert_matches!(
        get_session_state(&bob.cell_id, &bob_app_tx).await,
        Some(CountersigningSessionState::Accepted(_))
    );

    // Alice abandons the session.
    let response: AppResponse = request(
        AppRequest::AbandonCountersigningSession(Box::new(alice.cell_id.clone())),
        &alice_app_tx,
    )
    .await;
    assert_matches!(response, AppResponse::CountersigningSessionAbandoned);

    // Expect app signal of session abandoned for Alice.
    let force_abandoned_session_entry_hash =
        tokio::time::timeout(Duration::from_secs(30), alice_session_abandonded_rx.recv())
            .await
            .unwrap()
            .unwrap();
    assert_eq!(
        force_abandoned_session_entry_hash,
        preflight_request.app_entry_hash
    );

    // Alice's session should be gone from memory.
    assert_matches!(get_session_state(&alice.cell_id, &alice_app_tx).await, None);

    // Session should be abandoned and can not be abandoned again.
    let response: AppResponse = request(
        AppRequest::AbandonCountersigningSession(Box::new(alice.cell_id.clone())),
        &alice_app_tx,
    )
    .await;
    let expected_error = AppResponse::Error(
        ConductorApiError::ConductorError(ConductorError::CountersigningError(
            CountersigningError::SessionNotFound(alice.cell_id.clone()),
        ))
        .into(),
    );
    assert_eq!(format!("{:?}", response), format!("{:?}", expected_error));
    // Bob's session should still be in Accepted state.
    assert_matches!(
        get_session_state(&bob.cell_id, &bob_app_tx).await,
        Some(CountersigningSessionState::Accepted(_))
    );

    tracing::info!("Alice abandoned session.\n");

    // Await Bob's session to be abandoned due to timeout.
    let abandoned_session_entry_hash =
        tokio::time::timeout(Duration::from_secs(30), bob_session_abandonded_rx.recv())
            .await
            .unwrap()
            .unwrap();
    assert_eq!(
        abandoned_session_entry_hash,
        bob_response.request.app_entry_hash
    );
    // Bob's session should be gone too.
    assert_matches!(get_session_state(&bob.cell_id, &bob_app_tx).await, None);

    // Await DHT sync.
    tokio::time::timeout(Duration::from_secs(30), await_dht_sync(&[&alice, &bob]))
        .await
        .unwrap();

    tracing::info!("Starting over with a new countersigning session.\n");

    // Start over. Alice commits the countersigned entry again.
    // Set up the session and accept it for both agents.
    let preflight_request: PreflightRequest = alice
        .call_zome(
            &alice_app_tx,
            "generate_countersigning_preflight_request_fast", // 10 sec timeout
            &[
                (alice.cell_id.agent_pubkey().clone(), vec![Role(0)]),
                (bob.cell_id.agent_pubkey().clone(), vec![]),
            ],
        )
        .await;
    let alice_acceptance: PreflightRequestAcceptance = alice
        .call_zome(
            &alice_app_tx,
            "accept_countersigning_preflight_request",
            &preflight_request,
        )
        .await;
    let alice_response =
        if let PreflightRequestAcceptance::Accepted(ref response) = alice_acceptance {
            response
        } else {
            unreachable!();
        };
    let bob_acceptance: PreflightRequestAcceptance = bob
        .call_zome(
            &bob_app_tx,
            "accept_countersigning_preflight_request",
            &preflight_request,
        )
        .await;
    let bob_response = if let PreflightRequestAcceptance::Accepted(ref response) = bob_acceptance {
        response
    } else {
        unreachable!();
    };

    // Countersigning session state should exist for both agents and be in "Accepted" state.
    assert_matches!(
        get_session_state(&alice.cell_id, &alice_app_tx).await,
        Some(CountersigningSessionState::Accepted(_))
    );
    assert_matches!(
        get_session_state(&bob.cell_id, &bob_app_tx).await,
        Some(CountersigningSessionState::Accepted(_))
    );

    // Bob commits entry and shuts down.
    for _ in 0..5 {
        let response = call_zome_fn_fallible(
            &bob_app_tx,
            bob.cell_id.clone(),
            &bob.signing_keypair,
            bob.cap_secret,
            TestWasm::CounterSigning.coordinator_zome_name(),
            "create_a_countersigned_thing_with_entry_hash".into(),
            &[alice_response.clone(), bob_response.clone()],
        )
        .await;

        if let AppResponse::ZomeCalled(_) = response {
            break;
        }
        tokio::time::sleep(Duration::from_millis(100)).await;
    }

    tracing::info!("Bob committed countersigned entry - shutting down conductor.\n");

    let bob_config = bob.shutdown();

    // Alice commits countersigned entry.
    for _ in 0..5 {
        let response = call_zome_fn_fallible(
            &alice_app_tx,
            alice.cell_id.clone(),
            &alice.signing_keypair,
            alice.cap_secret,
            TestWasm::CounterSigning.coordinator_zome_name(),
            "create_a_countersigned_thing_with_entry_hash".into(),
            &[alice_response.clone(), bob_response.clone()],
        )
        .await;

        if let AppResponse::ZomeCalled(_) = response {
            break;
        }
        tokio::time::sleep(Duration::from_millis(100)).await;
    }

    tracing::info!("Alice committed countersigned entry - restarting conductor to provoke unresolved state...\n");

    // Restart Alice's conductor to put countersigning session in unresolved state.
    let mut alice = alice.restart_conductor().await;

    // Attach app interface to Alice's conductor.
    let (alice_app_tx, mut alice_app_rx) = alice.connect_app_interface().await;
    // Spawn task listening for countersigning success signal.
    let (alice_successful_session_tx, mut alice_successful_session_rx) =
        tokio::sync::mpsc::channel(1);
    tokio::spawn(async move {
        while let Ok(ReceiveMessage::Signal(signal)) = alice_app_rx.recv::<AppResponse>().await {
            match Signal::try_from_vec(signal).unwrap() {
                Signal::System(SystemSignal::SuccessfulCountersigning(entry)) => {
                    let _ = alice_successful_session_tx.clone().send(entry).await;
                }
                _ => unreachable!(),
            }
        }
    });

    // Bring Bob back up.
    let mut bob = Agent::startup(bob_config).await;

    let (bob_app_tx, mut bob_app_rx) = bob.connect_app_interface().await;
    // Spawn task listening for successful countersigning session signal.
    let (bob_successful_session_tx, mut bob_successful_session_rx) = tokio::sync::mpsc::channel(1);
    tokio::spawn(async move {
        while let Ok(ReceiveMessage::Signal(signal)) = bob_app_rx.recv::<AppResponse>().await {
            match Signal::try_from_vec(signal).unwrap() {
                Signal::System(SystemSignal::SuccessfulCountersigning(entry)) => {
                    let _ = bob_successful_session_tx.clone().send(entry).await;
                }
                _ => unreachable!(),
            }
        }
    });

    // Alice's session should be in state unresolved.
    // Leave some time for the countersigning workflow to attempt to resolve the session.
    tokio::time::timeout(Duration::from_secs(30), async {
        loop {
            if matches!(
                get_session_state(&alice.cell_id, &alice_app_tx).await,
                Some(CountersigningSessionState::Unknown { resolution, .. }) if resolution.attempts >= 1
            ) {
                break;
            }
            tokio::time::sleep(Duration::from_millis(1000)).await;
        }
    })
    .await
    .unwrap();

    // Alice forcefully publishes the session.
    let response: AppResponse = request(
        AppRequest::PublishCountersigningSession(Box::new(alice.cell_id.clone())),
        &alice_app_tx,
    )
    .await;
    assert_matches!(response, AppResponse::PublishCountersigningSessionTriggered);

    // Expect app signal of countersigning success for Alice.
    let force_published_session_entry_hash =
        tokio::time::timeout(Duration::from_secs(30), alice_successful_session_rx.recv())
            .await
            .unwrap()
            .unwrap();
    assert_eq!(
        force_published_session_entry_hash,
        preflight_request.app_entry_hash
    );
    // Alice's session should be gone from memory.
    assert_matches!(get_session_state(&alice.cell_id, &alice_app_tx).await, None);

    tracing::info!("Alice published session.\n");

    // Expect app signal of countersigning success for Bob.
    let bob_session_entry_hash =
        tokio::time::timeout(Duration::from_secs(30), bob_successful_session_rx.recv())
            .await
            .unwrap()
            .unwrap();
    assert_eq!(bob_session_entry_hash, preflight_request.app_entry_hash);
    // Bob's session should be gone from memory.
    assert_matches!(get_session_state(&bob.cell_id, &bob_app_tx).await, None);

    tracing::info!("Sessions resolved successfully. Awaiting DHT sync...");

    // Syncing takes long because Alice's publish loop pauses for a minute.
    tokio::time::timeout(Duration::from_secs(30), await_dht_sync(&[&alice, &bob]))
        .await
        .unwrap();
}

struct Agent {
    admin_tx: WebsocketSender,
    admin_port: u16,
    cell_id: CellId,
    signing_keypair: SigningKey,
    cap_secret: CapSecret,
    config_path: PathBuf,
    _admin_rx: WsPollRecv,
    _holochain: SupervisedChild,
}

impl Agent {
    async fn setup(bootstrap_url: String, signal_url: String, network_seed: String) -> Agent {
        let admin_port = 0;
        let tmp_dir = TempDir::new().unwrap();
        let path = tmp_dir.into_path();
        let environment_path = path.clone();
        let mut config = create_config(admin_port, environment_path.into());
        config.network = KitsuneP2pConfig::default().tune(|mut kc| {
            kc.tx5_implicit_timeout_ms = 3_000;
            kc
        });
        config.keystore = KeystoreConfig::LairServerInProc { lair_root: None };
        config.tuning_params = Some(ConductorTuningParams {
            countersigning_resolution_retry_limit: Some(3),
            countersigning_resolution_retry_delay: Some(Duration::from_secs(5)),
            min_publish_interval: Some(Duration::from_secs(5)),
            ..Default::default()
        });
        config.network.bootstrap_service = Some(Url2::parse(bootstrap_url));
        config.network.transport_pool = vec![TransportConfig::WebRTC {
            signal_url,
            webrtc_config: None,
        }];
        let config_path = write_config(path.clone(), &config);

        let (_holochain, admin_port) = start_holochain_with_lair(config_path.clone(), true).await;
        let admin_port = admin_port.await.unwrap();

        let (mut admin_tx, admin_rx) = websocket_client_by_port(admin_port).await.unwrap();
        let _admin_rx = WsPollRecv::new::<AdminResponse>(admin_rx);

        let dna = fake_dna_zomes(
            &network_seed,
            vec![(
                TestWasm::CounterSigning.into(),
                TestWasm::CounterSigning.into(),
            )],
        );

        // Install Dna.
        let (fake_dna_path, _tmpdir) = write_fake_dna_file(dna.clone()).await.unwrap();
        let cell_id =
            register_and_install_dna(&mut admin_tx, fake_dna_path, None, "".into(), 10000)
                .await
                .unwrap();

        // Activate cells.
        let request = AdminRequest::EnableApp {
            installed_app_id: APP_ID.to_string(),
        };
        let response = admin_tx.request(request);
        let response = check_timeout(response, 3000).await.unwrap();
        assert_matches!(response, AdminResponse::AppEnabled { .. });

        // Generate signing key pair.
        let mut rng = OsRng;
        let signing_keypair = ed25519_dalek::SigningKey::generate(&mut rng);
        let signing_key =
            AgentPubKey::from_raw_32(signing_keypair.verifying_key().as_bytes().to_vec());

        // Grant zome call capability for agent.
        let functions = GrantedFunctions::All;

        let cap_secret = CapSecret::try_from(vec![7; CAP_SECRET_BYTES].as_slice()).unwrap();

        let mut assignees = BTreeSet::new();
        assignees.insert(signing_key.clone());

        let request =
            AdminRequest::GrantZomeCallCapability(Box::new(GrantZomeCallCapabilityPayload {
                cell_id: cell_id.clone(),
                cap_grant: ZomeCallCapGrant {
                    tag: "".into(),
                    access: CapAccess::Assigned {
                        secret: cap_secret,
                        assignees,
                    },
                    functions,
                },
            }));
        let response = admin_tx.request(request);
        let response = check_timeout(response, 3000).await.unwrap();
        assert_matches!(response, AdminResponse::ZomeCallCapabilityGranted);

        Agent {
            admin_tx,
            admin_port,
            cell_id,
            signing_keypair,
            cap_secret,
            config_path,
            _admin_rx,
            _holochain,
        }
    }

    fn shutdown(self) -> (PathBuf, CellId, SigningKey, CapSecret) {
        let Agent {
            config_path,
            cell_id,
            signing_keypair,
            cap_secret,
            admin_tx,
            _admin_rx,
            _holochain,
            ..
        } = self;
        drop(_holochain);
        drop(admin_tx);
        drop(_admin_rx);
        (config_path, cell_id, signing_keypair, cap_secret)
    }

    async fn startup(config: (PathBuf, CellId, SigningKey, CapSecret)) -> Agent {
        let (config_path, cell_id, signing_keypair, cap_secret) = config;

        let (_holochain, admin_port) = start_holochain_with_lair(config_path.clone(), true).await;
        let admin_port = admin_port.await.unwrap();
        let (admin_tx, _admin_rx) = websocket_client_by_port(admin_port).await.unwrap();
        let _admin_rx = WsPollRecv::new::<AdminResponse>(_admin_rx);

        Agent {
            admin_tx,
            admin_port,
            cell_id,
            signing_keypair,
            cap_secret,
            config_path,
            _admin_rx,
            _holochain,
        }
    }

    async fn restart_conductor(self) -> Agent {
        let agent_config = self.shutdown();
        Agent::startup(agent_config).await
    }

    async fn connect_app_interface(&mut self) -> (WebsocketSender, WebsocketReceiver) {
        let app_port = attach_app_interface(&self.admin_tx, None).await;
        let (app_tx, app_rx) = websocket_client_by_port(app_port).await.unwrap();
        authenticate_app_ws_client(app_tx.clone(), self.admin_port, APP_ID.to_string()).await;
        (app_tx, app_rx)
    }

    async fn call_zome<I, O>(
        &self,
        app_tx: &WebsocketSender,
        fn_name: impl Into<FunctionName>,
        input: &I,
    ) -> O
    where
        I: Serialize + std::fmt::Debug,
        O: DeserializeOwned + std::fmt::Debug,
    {
        let zome_name = TestWasm::CounterSigning.coordinator_zome_name();
        call_zome_fn(
            app_tx,
            self.cell_id.clone(),
            &self.signing_keypair,
            self.cap_secret,
            zome_name,
            fn_name.into(),
            input,
        )
        .await
        .decode()
        .unwrap()
    }
}

async fn expect_bootstrapping_completed(agents: &[&Agent]) {
    loop {
        let agent_requests = agents.iter().map(|agent| async {
            match request(AdminRequest::AgentInfo { cell_id: None }, &agent.admin_tx).await {
                AdminResponse::AgentInfo(agent_infos) => agent_infos.len() == agents.len(),
                _ => unreachable!(),
            }
        });
        let all_agents_visible = futures::future::join_all(agent_requests)
            .await
            .into_iter()
            .all(|result| result);
        if all_agents_visible {
            break;
        } else {
            tokio::time::sleep(Duration::from_millis(100)).await;
        }
    }
}

async fn await_dht_sync(agents: &[&Agent]) {
    loop {
        let requests = agents.iter().map(|agent| async {
            match request(
                AdminRequest::DumpFullState {
                    cell_id: Box::new(agent.cell_id.clone()),
                    dht_ops_cursor: None,
                },
                &agent.admin_tx,
            )
            .await
            {
                AdminResponse::FullStateDumped(state) => {
                    let mut dht = state.integration_dump.integrated;
                    sort_dht(&mut dht);
                    dht
                }
                _ => unreachable!(),
            }
        });

        let dhts = futures::future::join_all(requests).await;
        let dhts_synced = dhts[1..].iter().all(|dht| *dht == dhts[0]);
        if dhts_synced {
            break;
        } else {
            tokio::time::sleep(Duration::from_secs(1)).await;
        }
    }
}

fn sort_dht(dht: &mut [DhtOp]) {
    dht.sort_by(|a, b| match a {
        DhtOp::ChainOp(chain_op_a) => {
            if let DhtOp::ChainOp(chain_op_b) = b {
                let type_a = format!(
                    "{}{}{}",
                    chain_op_a.get_type(),
                    chain_op_a.author(),
                    chain_op_a.action().action_seq(),
                );
                let type_b = format!(
                    "{}{}{}",
                    chain_op_b.get_type(),
                    chain_op_b.author(),
                    chain_op_b.action().action_seq(),
                );
                type_a.partial_cmp(&type_b).unwrap()
            } else {
                Ordering::Greater
            }
        }
        _ => unimplemented!(),
    });
}

async fn request<Request, Response>(request: Request, tx: &WebsocketSender) -> Response
where
    Request: std::fmt::Debug,
    SerializedBytes: TryFrom<Request, Error = SerializedBytesError>,
    Response: std::fmt::Debug + DeserializeOwned,
{
    let response = tx.request(request);
    check_timeout::<Response>(response, 6000).await.unwrap()
}

async fn get_session_state(
    cell_id: &CellId,
    app_tx: &WebsocketSender,
) -> Option<CountersigningSessionState> {
    match request(
        AppRequest::GetCountersigningSessionState(Box::new(cell_id.clone())),
        app_tx,
    )
    .await
    {
        AppResponse::CountersigningSessionState(maybe_state) => *maybe_state,
        _ => unreachable!(),
    }
}



================================================
File: crates/holochain/tests/tests/dht_arc/mod.rs
================================================
use holochain::sweettest::SweetAgents;
use holochain::sweettest::SweetConductor;
use holochain_keystore::MetaLairClient;
use holochain_p2p::dht::prelude::Topology;
use holochain_p2p::dht::PeerStrat;
use holochain_p2p::dht_arc::DEFAULT_MIN_PEERS;
use holochain_p2p::dht_arc::DEFAULT_MIN_REDUNDANCY;
use holochain_p2p::dht_arc::MAX_HALF_LENGTH;
use kitsune_p2p::dht::spacetime::SpaceDimension;
use kitsune_p2p::dht::Arq;
use kitsune_p2p::dht::ArqStrat;
use kitsune_p2p::*;
use kitsune_p2p_types::dht_arc::check_redundancy;

async fn get_peers(num: usize, half_lens: &[u32], keystore: MetaLairClient) -> Vec<Arq> {
    let mut half_lens = half_lens.iter().cycle();
    let mut out = Vec::with_capacity(num);

    let agents = SweetAgents::get(keystore, num).await;
    for agent in agents {
        let agent = holochain_p2p::agent_holo_to_kit(agent);
        let arq = Arq::from_start_and_half_len_approximate(
            SpaceDimension::standard(),
            &ArqStrat::default(),
            agent.get_loc(),
            *half_lens.next().unwrap(),
        );
        out.push(arq);
    }
    out
}

// TODO This really looks like it shouldn't be disabled!
#[tokio::test(flavor = "multi_thread")]
#[ignore = "Not using alpha strategy anymore, todo: change to new strategy"]
// This test shows that we can handle maintaining our [`MINIMUM_REDUNDANCY`]
// through 1000 trials. If this test ever fails it's not flakey. Instead that means
// we can't actually maintain the [`MIN_REDUNDANCY`] and will need raise the [`REDUNDANCY_TARGET`].
// Please @freesig if you see this fail.
async fn test_arc_redundancy() {
    let conductor = SweetConductor::from_standard_config().await;
    let keystore = conductor.keystore();
    fn converge(peers: &mut [Arq]) {
        let mut mature = false;
        for _ in 0..40 {
            for i in 0..peers.len() {
                let p = peers.to_owned();
                let arc = peers.get_mut(i).unwrap();
                let view = PeerStrat::default().view(Topology::standard_epoch_full(), p.as_slice());
                view.update_arq(arc);
            }

            let r = check_redundancy(peers.iter().map(|a| a.to_dht_arc_std()).collect());
            if mature {
                assert!(r >= DEFAULT_MIN_REDUNDANCY);
            } else if r >= DEFAULT_MIN_REDUNDANCY {
                mature = true;
            }
        }
        assert!(mature);
    }
    let mut jhs = Vec::with_capacity(1000);
    for _ in 0..1000 {
        let jh = tokio::spawn({
            let keystore = keystore.clone();
            async move {
                let mut peers = get_peers(
                    (DEFAULT_MIN_PEERS as f64 * 1.1) as usize,
                    &[(MAX_HALF_LENGTH as f64 * 0.2) as u32],
                    keystore,
                )
                .await;
                converge(&mut peers);
            }
        });
        jhs.push(jh);
    }
    for jh in jhs {
        jh.await.unwrap();
    }
}

#[tokio::test(flavor = "multi_thread")]
// Can survive 50% of the nodes changing per update without
// dropping below [`MIN_REDUNDANCY`]
async fn test_join_leave() {
    let conductor = SweetConductor::from_standard_config().await;
    let keystore = conductor.keystore();
    let topo = Topology::standard_epoch_full();

    let num_peers = DEFAULT_MIN_PEERS;

    let coverages = vec![MAX_HALF_LENGTH];
    let converge = |peers: &mut Vec<Arq>| {
        for i in 0..peers.len() {
            let p = peers.clone();
            let arq = peers.get_mut(i).unwrap();
            let view = PeerStrat::default().view(topo.clone(), p.as_slice());
            view.update_arq(arq);
        }
    };
    let mut peers = get_peers(num_peers, &coverages, keystore.clone()).await;
    let delta_peers = num_peers / 2;
    let mut mature = false;

    for _ in 0..40 {
        let new_peers = get_peers(delta_peers, &coverages, keystore.clone()).await;
        for (o, n) in peers[..delta_peers].iter_mut().zip(new_peers.into_iter()) {
            *o = n;
        }
        converge(&mut peers);
        let r = check_redundancy(peers.iter().map(|a| a.to_dht_arc(&topo)).collect());

        if mature {
            assert!(r >= DEFAULT_MIN_REDUNDANCY);
        } else if r >= DEFAULT_MIN_REDUNDANCY {
            mature = true;
        }
    }
    assert!(mature);
}



================================================
File: crates/holochain/tests/tests/dna_properties/mod.rs
================================================
use hdk::prelude::*;
use holochain::sweettest::SweetConductor;
use holochain::sweettest::SweetDnaFile;
use holochain_conductor_api::conductor::ConductorConfig;
use holochain_test_wasm_common::MyValidDnaProperties;
use holochain_types::prelude::DnaModifiersOpt;
use holochain_wasm_test_utils::TestWasm;
use serde::{Deserialize, Serialize};

#[tokio::test(flavor = "multi_thread")]
// Can specify dna properties and then read those properties via the #[dna_properties] helper macro
async fn test_dna_properties_macro() {
    let (dna_file, _, _) =
        SweetDnaFile::unique_from_test_wasms(vec![TestWasm::DnaProperties]).await;

    // Set DNA Properties
    let properties = MyValidDnaProperties {
        authority_agent: [0u8; 36].to_vec(),
        max_count: 500,
        contract_address: String::from("0x12345"),
    };
    let properties_sb: SerializedBytes = properties.clone().try_into().unwrap();
    let dnas = &[dna_file.update_modifiers(DnaModifiersOpt {
        network_seed: None,
        properties: Some(properties_sb),
        origin_time: None,
        quantum_time: None,
    })];

    // Create a Conductor
    let mut conductor = SweetConductor::from_config(ConductorConfig::default()).await;
    let app = conductor.setup_app("app", dnas).await.unwrap();
    let alice_zome = app.cells()[0].zome(TestWasm::DnaProperties);

    // Get DNA Properties via helper macro
    let received_properties: MyValidDnaProperties =
        conductor.call(&alice_zome, "get_dna_properties", ()).await;

    assert_eq!(received_properties, properties)
}

#[derive(Serialize, Deserialize, Debug, Eq, PartialEq, SerializedBytes)]
pub struct MyInvalidProperties {
    bad_property: u32,
}

#[tokio::test(flavor = "multi_thread")]
// Can specify dna properties and then read those properties via the #[dna_properties] helper macro
async fn test_dna_properties_fails_with_invalid_properties() {
    let (dna_file, _, _) =
        SweetDnaFile::unique_from_test_wasms(vec![TestWasm::DnaProperties]).await;

    // Set DNA Properties
    let properties = MyInvalidProperties { bad_property: 500 };
    let properties_sb: SerializedBytes = properties.try_into().unwrap();
    let modifiers = DnaModifiersOpt {
        network_seed: None,
        properties: Some(properties_sb),
        origin_time: None,
        quantum_time: None,
    };
    let dnas = &[dna_file.update_modifiers(modifiers)];

    // Create a Conductor
    let mut conductor = SweetConductor::from_config(ConductorConfig::default()).await;
    let app = conductor.setup_app("app", dnas).await.unwrap();
    let alice_zome = app.cells()[0].zome(TestWasm::DnaProperties);

    // Fail to get DNA Properties via helper macro
    let res: Result<MyValidDnaProperties, _> = conductor
        .call_fallible(&alice_zome, "get_dna_properties", ())
        .await;

    assert!(res.is_err())
}



================================================
File: crates/holochain/tests/tests/inline_zome_spec/mod.rs
================================================
#![cfg(feature = "test_utils")]

use hdk::prelude::*;
use holochain::core::ribosome::guest_callback::validate::ValidateResult;
use holochain::test_utils::inline_zomes::{simple_crud_zome, AppString};
use holochain::{conductor::api::error::ConductorApiResult, sweettest::*};
use holochain::{
    conductor::{api::error::ConductorApiError, CellError},
    core::workflow::WorkflowError,
};
use holochain::{core::SourceChainError, test_utils::display_agent_infos};
use holochain_types::{inline_zome::InlineZomeSet, prelude::*};
use holochain_wasm_test_utils::TestWasm;
use holochain_zome_types::{op::Op, record::RecordEntry};
use matches::assert_matches;

/// Simple scenario involving two agents using the same DNA
#[tokio::test(flavor = "multi_thread")]
#[cfg(feature = "test_utils")]
async fn inline_zome_2_agents_1_dna() -> anyhow::Result<()> {
    // Bundle the single zome into a DnaFile
    let (dna_file, _, _) = SweetDnaFile::unique_from_inline_zomes(simple_crud_zome()).await;

    // Create a Conductor
    let mut conductor = SweetConductor::from_standard_config().await;

    // Install DNA and install and enable apps in conductor
    let apps = conductor.setup_apps("app", 2, &[dna_file]).await.unwrap();

    let ((alice,), (bobbo,)) = apps.into_tuples();

    // Call the "create" zome fn on Alice's app
    let hash: ActionHash = conductor
        .call(
            &alice.zome(SweetInlineZomes::COORDINATOR),
            "create_unit",
            (),
        )
        .await;

    await_consistency(10, [&alice, &bobbo]).await.unwrap();

    // Verify that bobbo can run "read" on his cell and get alice's Action
    let records: Option<Record> = conductor
        .call(&bobbo.zome(SweetInlineZomes::COORDINATOR), "read", hash)
        .await;
    let record = records.expect("Record was None: bobbo couldn't `get` it");

    // Assert that the Record bobbo sees matches what alice committed
    assert_eq!(record.action().author(), alice.agent_pubkey());
    assert_eq!(
        *record.entry(),
        RecordEntry::Present(Entry::app(().try_into().unwrap()).unwrap())
    );

    Ok(())
}

/// Simple scenario involving three agents using an app with two DNAs
#[tokio::test(flavor = "multi_thread")]
#[cfg(feature = "test_utils")]
async fn inline_zome_3_agents_2_dnas() -> anyhow::Result<()> {
    holochain_trace::test_run();
    let mut conductor = SweetConductor::from_standard_config().await;

    let (dna_foo, _, _) = SweetDnaFile::unique_from_inline_zomes(simple_crud_zome()).await;
    let (dna_bar, _, _) = SweetDnaFile::unique_from_inline_zomes(simple_crud_zome()).await;

    let apps = conductor
        .setup_apps("app", 3, &[dna_foo, dna_bar])
        .await
        .unwrap();

    let ((alice_foo, alice_bar), (bobbo_foo, bobbo_bar), (carol_foo, carol_bar)) =
        apps.into_tuples();

    assert_eq!(alice_foo.agent_pubkey(), alice_bar.agent_pubkey());
    assert_eq!(bobbo_foo.agent_pubkey(), bobbo_bar.agent_pubkey());
    assert_ne!(alice_foo.agent_pubkey(), bobbo_foo.agent_pubkey());

    //////////////////////
    // END SETUP

    let hash_foo: ActionHash = conductor
        .call(
            &alice_foo.zome(SweetInlineZomes::COORDINATOR),
            "create_unit",
            (),
        )
        .await;
    let hash_bar: ActionHash = conductor
        .call(
            &alice_bar.zome(SweetInlineZomes::COORDINATOR),
            "create_unit",
            (),
        )
        .await;

    // Two different DNAs, so ActionHashes should be different.
    assert_ne!(hash_foo, hash_bar);

    // Wait long enough for others to receive gossip
    await_consistency(10, [&alice_foo, &bobbo_foo, &carol_foo])
        .await
        .unwrap();
    await_consistency(10, [&alice_bar, &bobbo_bar, &carol_bar])
        .await
        .unwrap();

    // Verify that bobbo can run "read" on his cell and get alice's Action
    // on the "foo" DNA
    let record: Option<Record> = conductor
        .call(
            &bobbo_foo.zome(SweetInlineZomes::COORDINATOR),
            "read",
            hash_foo,
        )
        .await;
    let record = record.expect("Record was None: bobbo couldn't `get` it");
    assert_eq!(record.action().author(), alice_foo.agent_pubkey());
    assert_eq!(
        *record.entry(),
        RecordEntry::Present(Entry::app(().try_into().unwrap()).unwrap())
    );

    // Verify that carol can run "read" on her cell and get alice's Action
    // on the "bar" DNA
    // Let's do it with the SweetZome instead of the SweetCell too, for fun
    let record: Option<Record> = conductor
        .call(
            &carol_bar.zome(SweetInlineZomes::COORDINATOR),
            "read",
            hash_bar,
        )
        .await;
    let record = record.expect("Record was None: carol couldn't `get` it");
    assert_eq!(record.action().author(), alice_bar.agent_pubkey());
    assert_eq!(
        *record.entry(),
        RecordEntry::Present(Entry::app(().try_into().unwrap()).unwrap())
    );

    Ok(())
}

#[tokio::test(flavor = "multi_thread")]
#[cfg(feature = "test_utils")]
// I can't remember what this test was for? Should we just delete?
#[ignore = "Needs to be completed when HolochainP2pEvents is accessible"]
async fn invalid_cell() -> anyhow::Result<()> {
    holochain_trace::test_run();
    let mut conductor = SweetConductor::from_standard_config().await;

    let (dna_foo, _, _) = SweetDnaFile::unique_from_inline_zomes(simple_crud_zome()).await;
    let (dna_bar, _, _) = SweetDnaFile::unique_from_inline_zomes(simple_crud_zome()).await;

    let _app_foo = conductor.setup_app("foo", &[dna_foo]).await;

    let _app_bar = conductor.setup_app("bar", &[dna_bar]).await;

    // Give small amount of time for cells to join the network
    tokio::time::sleep(std::time::Duration::from_millis(500)).await;

    tracing::debug!(dnas = ?conductor.list_dnas());
    tracing::debug!(cell_ids = ?conductor.running_cell_ids());
    tracing::debug!(apps = ?conductor.list_running_apps().await.unwrap());

    display_agent_infos(&conductor).await;

    // Can't finish this test because there's no way to construct HolochainP2pEvents
    // and I can't directly call query on the conductor because it's private.

    Ok(())
}

#[tokio::test(flavor = "multi_thread")]
#[cfg(feature = "test_utils")]
async fn get_deleted() -> anyhow::Result<()> {
    holochain_trace::test_run();
    // Bundle the single zome into a DnaFile
    let (dna_file, _, _) = SweetDnaFile::unique_from_inline_zomes(simple_crud_zome()).await;

    // Create a Conductor
    let mut conductor = SweetConductor::from_standard_config().await;

    // Install DNA and install and enable apps in conductor
    let alice = conductor
        .setup_app("app", &[dna_file])
        .await
        .unwrap()
        .into_cells()
        .into_iter()
        .next()
        .unwrap();

    // Call the "create" zome fn on Alice's app
    let hash: ActionHash = conductor
        .call(
            &alice.zome(SweetInlineZomes::COORDINATOR),
            "create_unit",
            (),
        )
        .await;

    await_consistency(10, [&alice]).await.unwrap();

    let records: Option<Record> = conductor
        .call(
            &alice.zome(SweetInlineZomes::COORDINATOR),
            "read",
            hash.clone(),
        )
        .await;
    let record = records.expect("Record was None: bobbo couldn't `get` it");

    assert_eq!(record.action().author(), alice.agent_pubkey());
    assert_eq!(
        *record.entry(),
        RecordEntry::Present(Entry::app(().try_into().unwrap()).unwrap())
    );
    let entry_hash = record.action().entry_hash().unwrap();

    let _: ActionHash = conductor
        .call(
            &alice.zome(SweetInlineZomes::COORDINATOR),
            "delete",
            hash.clone(),
        )
        .await;

    await_consistency(10, [&alice]).await.unwrap();

    let records: Vec<Option<Record>> = conductor
        .call(
            &alice.zome(SweetInlineZomes::COORDINATOR),
            "read_entry",
            entry_hash,
        )
        .await;
    assert!(records.into_iter().next().unwrap().is_none());

    Ok(())
}

#[tokio::test(flavor = "multi_thread")]
#[cfg(feature = "test_utils")]
async fn signal_subscription() {
    holochain_trace::test_run();
    const N: usize = 10;

    let (dna_file, _, _) = SweetDnaFile::unique_from_inline_zomes(simple_crud_zome()).await;
    let mut conductor = SweetConductor::from_standard_config().await;
    let app = conductor.setup_app("app", &[dna_file]).await.unwrap();
    let zome = &app.cells()[0].zome(SweetInlineZomes::COORDINATOR);

    let mut signal_rx = conductor.subscribe_to_app_signals("app".to_string());

    // Emit N signals
    for _ in 0..N {
        let _: () = conductor.call(zome, "emit_signal", ()).await;
    }

    // Ensure that we can receive all signals
    let mut signals: Vec<Signal> = vec![];
    for _ in 0..N {
        let signal = signal_rx.recv().await.unwrap();
        signals.push(signal);
    }

    assert_eq!(signals.len(), N);
}

/// Simple zome which contains a validation rule which can fail
fn simple_validation_zome() -> InlineZomeSet {
    let entry_def = EntryDef::default_from_id("string");

    SweetInlineZomes::new(vec![entry_def.clone()], 0)
        .function("create", move |api, s: AppString| {
            let entry = Entry::app(s.try_into().unwrap()).unwrap();
            let hash = api.create(CreateInput::new(
                InlineZomeSet::get_entry_location(&api, EntryDefIndex(0)),
                EntryVisibility::Public,
                entry,
                ChainTopOrdering::default(),
            ))?;
            Ok(hash)
        })
        .function("read", |api, hash: ActionHash| {
            api.get(vec![GetInput::new(hash.into(), GetOptions::default())])
                .map_err(Into::into)
        })
        .integrity_function("validate", |_api, data: Op| {
            let s = match data {
                Op::StoreEntry(StoreEntry {
                    entry: Entry::App(bytes),
                    ..
                }) => AppString::try_from(bytes.into_sb()).unwrap(),
                _ => return Ok(ValidateResult::Valid),
            };
            if s.0.is_empty() {
                Ok(ValidateResult::Invalid("No empty strings allowed".into()))
            } else {
                Ok(ValidateResult::Valid)
            }
        })
        .0
}

#[tokio::test(flavor = "multi_thread")]
async fn simple_validation() -> anyhow::Result<()> {
    let (dna_file, _, _) = SweetDnaFile::unique_from_inline_zomes(simple_validation_zome()).await;
    let mut conductor = SweetConductor::from_standard_config().await;

    let apps = conductor.setup_apps("app", 2, &[dna_file]).await.unwrap();
    let ((alice,), (_bobbo,)) = apps.into_tuples();

    let alice = alice.zome(SweetInlineZomes::COORDINATOR);

    // This call passes validation
    let h1: ActionHash = conductor.call(&alice, "create", AppString::new("A")).await;
    let e1s: Vec<Option<Record>> = conductor.call(&alice, "read", &h1).await;
    let e1 = e1s.into_iter().next().unwrap();
    let s1: AppString = e1.unwrap().entry().to_app_option().unwrap().unwrap();
    assert_eq!(s1, AppString::new("A"));

    // This call fails validation, and so results in an error
    let err: ConductorApiResult<ActionHash> = conductor
        .call_fallible(&alice, "create", AppString::new(""))
        .await;

    // This is kind of ridiculous, but we can't use assert_matches! because
    // there is a Box in the mix.
    let correct = match err {
        Err(ConductorApiError::CellError(CellError::WorkflowError(ref e))) => match &**e {
            WorkflowError::SourceChainError(SourceChainError::InvalidCommit(reason)) => {
                reason.contains("No empty strings allowed")
            }
            _ => false,
        },
        _ => false,
    };
    assert!(correct, "Error was: {:?}", err);

    Ok(())
}

#[tokio::test(flavor = "multi_thread")]
async fn can_call_real_zomes_too() {
    holochain_trace::test_run();

    let mut conductor = SweetConductor::from_standard_config().await;
    let (mut integrity, mut coordinator) = simple_crud_zome().into_zomes();
    integrity.push(TestWasm::Create.into());
    coordinator.push(TestWasm::Create.into());

    let (dna, _, _) =
        SweetDnaFile::unique_from_zomes(integrity, coordinator, TestWasm::Create.into()).await;

    let app = conductor.setup_app("app1", &[dna.clone()]).await.unwrap();

    let (cell,) = app.into_tuple();

    let hash: ActionHash = conductor
        .call(&cell.zome(SweetInlineZomes::COORDINATOR), "create_unit", ())
        .await;

    let el: Option<Record> = conductor
        .call(&cell.zome("create_entry"), "get_post", hash.clone())
        .await;
    assert_eq!(el.unwrap().action_address(), &hash)
}

/// Simple scenario involving two agents using the same DNA
#[tokio::test(flavor = "multi_thread")]
async fn call_non_existing_zome_fails_gracefully() -> anyhow::Result<()> {
    // Bundle the single zome into a DnaFile
    let (dna_file, _, _) = SweetDnaFile::unique_from_inline_zomes(simple_crud_zome()).await;

    // Create a Conductor
    let mut conductor = SweetConductor::from_standard_config().await;

    // Install DNA and install and enable apps in conductor
    let app = conductor.setup_app("app1", [&dna_file]).await.unwrap();

    let (alice,) = app.into_tuple();

    // Call the a zome fn on a non existing zome on Alice's app
    let result: ConductorApiResult<ActionHash> = conductor
        .call_fallible(&alice.zome("non_existing_zome"), "create_unit", ())
        .await;

    assert_matches!(result, Err(_));

    Ok(())
}



================================================
File: crates/holochain/tests/tests/integrity_zome/mod.rs
================================================
use std::path::PathBuf;

use holo_hash::ActionHash;
use holo_hash::WasmHash;
use holochain::conductor::api::AdminInterfaceApi;
use holochain::sweettest::*;
use holochain_conductor_api::AdminRequest;
use holochain_conductor_api::AdminResponse;
use holochain_types::prelude::*;
use holochain_wasm_test_utils::TestCoordinatorWasm;
use holochain_wasm_test_utils::TestIntegrityWasm;
use holochain_wasm_test_utils::TestWasm;
use mr_bundle::Bundle;
use serde::Serialize;

#[tokio::test(flavor = "multi_thread")]
async fn test_coordinator_zome_update() {
    let mut conductor = SweetConductor::from_standard_config().await;
    let (dna, _, _) = SweetDnaFile::unique_from_zomes(
        vec![TestIntegrityWasm::IntegrityZome],
        vec![TestCoordinatorWasm::CoordinatorZome],
        vec![
            DnaWasm::from(TestIntegrityWasm::IntegrityZome),
            DnaWasm::from(TestCoordinatorWasm::CoordinatorZome),
        ],
    )
    .await;
    let dna_hash = dna.dna_hash().clone();

    println!("Install Dna with integrity and coordinator zomes.");
    let app = conductor.setup_app("app", [&dna]).await.unwrap();
    let cells = app.into_cells();

    println!("Create entry from the coordinator zome into the integrity zome.");
    let hash: ActionHash = conductor
        .call(
            &cells[0].zome(TestCoordinatorWasm::CoordinatorZome),
            "create_entry",
            (),
        )
        .await;
    println!("Success!");

    println!("Try getting the entry from the coordinator zome.");
    let record: Option<Record> = conductor
        .call(
            &cells[0].zome(TestCoordinatorWasm::CoordinatorZome),
            "get_entry",
            (),
        )
        .await;

    assert!(record.is_some());
    println!("Success!");

    println!("Update the coordinator zomes for a totally different coordinator zome (conductor is still running)");
    conductor
        .update_coordinators(
            &dna_hash,
            vec![CoordinatorZome::from(TestCoordinatorWasm::CoordinatorZomeUpdate).into_inner()],
            vec![TestCoordinatorWasm::CoordinatorZomeUpdate.into()],
        )
        .await
        .unwrap();
    println!("Success!");

    println!("Try getting the entry from the new coordinator zome.");
    let record: Option<Record> = conductor
        .call(
            &cells[0].zome(TestCoordinatorWasm::CoordinatorZomeUpdate),
            "get_entry",
            hash,
        )
        .await;

    assert!(record.is_some());
    println!("Success! Success! Success! ");
}

#[tokio::test(flavor = "multi_thread")]
async fn test_coordinator_zome_update_multi_integrity() {
    let mut conductor = SweetConductor::from_standard_config().await;
    let mut second_integrity = IntegrityZome::from(TestIntegrityWasm::IntegrityZome);
    second_integrity.zome_name_mut().0 = "2".into();
    let (_, second_coordinator) =
        CoordinatorZome::from(TestCoordinatorWasm::CoordinatorZome).into_inner();

    let second_coordinator = match second_coordinator.erase_type() {
        ZomeDef::Wasm(WasmZome {
            wasm_hash,
            mut dependencies,
            preserialized_path,
        }) => {
            dependencies.clear();
            dependencies.push("2".into());

            Zome::<CoordinatorZomeDef>::new(
                "2_coord".into(),
                ZomeDef::Wasm(WasmZome {
                    wasm_hash,
                    dependencies,
                    preserialized_path,
                })
                .into(),
            )
        }
        _ => todo!(),
    };

    let (dna, _, _) = SweetDnaFile::unique_from_zomes(
        vec![
            IntegrityZome::from(TestIntegrityWasm::IntegrityZome),
            second_integrity,
        ],
        vec![
            CoordinatorZome::from(TestCoordinatorWasm::CoordinatorZome),
            second_coordinator,
        ],
        vec![
            DnaWasm::from(TestIntegrityWasm::IntegrityZome),
            DnaWasm::from(TestCoordinatorWasm::CoordinatorZome),
        ],
    )
    .await;

    let dna_hash = dna.dna_hash().clone();

    let app = conductor.setup_app("app", [&dna]).await.unwrap();
    let cells = app.into_cells();

    let hash: ActionHash = conductor
        .call(
            &cells[0].zome(TestCoordinatorWasm::CoordinatorZome),
            "create_entry",
            (),
        )
        .await;

    let hash2: ActionHash = conductor
        .call(&cells[0].zome("2_coord"), "create_entry", ())
        .await;

    let record: Option<Record> = conductor
        .call(
            &cells[0].zome(TestCoordinatorWasm::CoordinatorZome),
            "get_entry",
            (),
        )
        .await;

    assert!(record.is_some());
    let record: Option<Record> = conductor
        .call(&cells[0].zome("2_coord"), "get_entry", ())
        .await;

    assert!(record.is_some());

    // Add a completely new coordinator with the same dependency
    conductor
        .update_coordinators(
            &dna_hash,
            vec![CoordinatorZome::from(TestCoordinatorWasm::CoordinatorZomeUpdate).into_inner()],
            vec![TestCoordinatorWasm::CoordinatorZomeUpdate.into()],
        )
        .await
        .unwrap();

    let record: Option<Record> = conductor
        .call(
            &cells[0].zome(TestCoordinatorWasm::CoordinatorZomeUpdate),
            "get_entry",
            hash,
        )
        .await;

    assert!(record.is_some());

    // Replace "2_coord" with different zome but same dependecies.
    let wasm_hash =
        WasmHash::with_data(&DnaWasm::from(TestCoordinatorWasm::CoordinatorZomeUpdate)).await;
    let new_coordinator: CoordinatorZomeDef = ZomeDef::Wasm(WasmZome {
        wasm_hash,
        dependencies: vec!["2".into()],
        preserialized_path: None,
    })
    .into();

    conductor
        .update_coordinators(
            &dna_hash,
            vec![("2_coord".into(), new_coordinator)],
            vec![TestCoordinatorWasm::CoordinatorZomeUpdate.into()],
        )
        .await
        .unwrap();

    let record: Option<Record> = conductor
        .call(&cells[0].zome("2_coord"), "get_entry", hash2)
        .await;

    assert!(record.is_some());
}

#[tokio::test(flavor = "multi_thread")]
async fn test_update_admin_interface() {
    let mut conductor = SweetConductor::from_standard_config().await;
    let (dna, _, _) = SweetDnaFile::unique_from_zomes(
        vec![TestIntegrityWasm::IntegrityZome],
        vec![TestCoordinatorWasm::CoordinatorZome],
        vec![
            DnaWasm::from(TestIntegrityWasm::IntegrityZome),
            DnaWasm::from(TestCoordinatorWasm::CoordinatorZome),
        ],
    )
    .await;

    let dna_hash = dna.dna_hash().clone();

    let app = conductor.setup_app("app", [&dna]).await.unwrap();
    let cells = app.into_cells();

    let hash: ActionHash = conductor
        .call(
            &cells[0].zome(TestCoordinatorWasm::CoordinatorZome),
            "create_entry",
            (),
        )
        .await;

    let admin_api = AdminInterfaceApi::new(conductor.clone());

    let manifest = CoordinatorManifest {
        zomes: vec![ZomeManifest {
            name: TestCoordinatorWasm::CoordinatorZomeUpdate.into(),
            hash: None,
            dylib: None,
            location: ZomeLocation::Bundled(TestCoordinatorWasm::CoordinatorZomeUpdate.into()),
            dependencies: Some(vec![ZomeDependency {
                name: TestIntegrityWasm::IntegrityZome.into(),
            }]),
        }],
    };

    let code = DnaWasm::from(TestCoordinatorWasm::CoordinatorZomeUpdate)
        .code
        .to_vec()
        .into();

    let source: CoordinatorBundle = Bundle::new(
        manifest,
        [(
            PathBuf::from(TestCoordinatorWasm::CoordinatorZomeUpdate),
            code,
        )],
        env!("CARGO_MANIFEST_DIR").into(),
    )
    .unwrap()
    .into();

    let req = UpdateCoordinatorsPayload {
        dna_hash,
        source: holochain_types::prelude::CoordinatorSource::Bundle(Box::new(source)),
    };
    let req = AdminRequest::UpdateCoordinators(Box::new(req));
    let r = admin_api.handle_request(Ok(req)).await.unwrap();
    assert!(matches!(r, AdminResponse::CoordinatorsUpdated));

    let record: Option<Record> = conductor
        .call(
            &cells[0].zome(TestCoordinatorWasm::CoordinatorZomeUpdate),
            "get_entry",
            hash,
        )
        .await;

    assert!(record.is_some());
}

#[tokio::test(flavor = "multi_thread")]
async fn test_wasm_memory() {
    let mut conductor = SweetConductor::from_standard_config().await;
    let (dna, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::Create]).await;

    let app = conductor.setup_app("app", [&dna]).await.unwrap();
    let cells = app.into_cells();

    #[derive(Debug, Serialize)]
    struct Post(String);

    let data = String::from_utf8(vec![0u8; 3_000_000]).unwrap();

    let mut cum = 0;
    for i in 0..100 {
        cum += data.len();
        eprintln!("committing {} {} {:?}", i, cum, Timestamp::now());
        let _hash: ActionHash = conductor
            .call(
                &cells[0].zome(TestWasm::Create),
                "create_post",
                Post(data.clone()),
            )
            .await;
    }
}



================================================
File: crates/holochain/tests/tests/lair_in_proc_restart/mod.rs
================================================
use holochain::sweettest::SweetConductor;
use holochain::sweettest::SweetDnaFile;
use holochain::sweettest::SweetRendezvous;
use holochain_conductor_api::config::conductor::ConductorConfig;
use holochain_conductor_api::config::conductor::KeystoreConfig;
use holochain_keystore::MetaLairClient;
use holochain_wasm_test_utils::TestWasm;
use kitsune_p2p_types::dependencies::lair_keystore_api;
use lair_keystore_api::dependencies::*;
use lair_keystore_api::in_proc_keystore::*;
use lair_keystore_api::prelude::*;
use std::path::PathBuf;
use std::sync::Arc;

/// Written for https://github.com/holochain/lair/issues/120 to verify
/// that InProcKeystore still works after conductor restart
#[tokio::test(flavor = "multi_thread")]
async fn lair_in_proc_sql_pool_factory_restart() {
    // working temp dir
    let tmp = tempfile::tempdir().unwrap();

    // set up new lair keystore config
    let passphrase = sodoken::BufRead::from(&b"passphrase"[..]);
    let config = Arc::new(
        hc_seed_bundle::PwHashLimits::Minimum
            .with_exec(|| LairServerConfigInner::new(tmp.path(), passphrase.clone()))
            .await
            .unwrap(),
    );

    let store_factory = lair_keystore::create_sql_pool_factory(
        tmp.path().join("store_file"),
        &config.database_salt,
    );

    let keystore = InProcKeystore::new(config, store_factory, passphrase)
        .await
        .unwrap();

    // print keystore config
    let keystore_config = keystore.get_config();
    println!("\n## keystore config ##\n{}", keystore_config);

    // set up conductor config to use the started keystore
    let conductor_config = ConductorConfig {
        keystore: KeystoreConfig::LairServerInProc {
            lair_root: Some(PathBuf::from(tmp.path()).into()),
        },
        ..Default::default()
    };

    let lair_client = keystore.new_client().await.unwrap();

    let meta_lair_client = MetaLairClient::from_client(lair_client).await.unwrap();

    let mut conductor = SweetConductor::create_with_defaults(
        conductor_config,
        Some(meta_lair_client),
        None::<Arc<dyn SweetRendezvous>>,
    )
    .await;

    let (dna_file, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::Foo]).await;

    let app = conductor.setup_app("app", [&dna_file]).await.unwrap();

    let cell = app.cells().first().unwrap().clone();

    let _: String = conductor.call(&cell.zome("foo"), "foo", ()).await;

    conductor.shutdown().await;
    conductor.startup().await;

    // Test that zome calls still work after a restart
    let _: String = conductor.call(&cell.zome("foo"), "foo", ()).await;
}



================================================
File: crates/holochain/tests/tests/multi_conductor/mod.rs
================================================
use hdk::prelude::*;
use holochain::conductor::config::{ConductorConfig, DpkiConfig};
use holochain::sweettest::SweetConductorConfig;
use holochain::sweettest::*;
use holochain_conductor_api::conductor::ConductorTuningParams;
use holochain_sqlite::db::{DbKindT, DbWrite};
use holochain_sqlite::prelude::DatabaseResult;
use unwrap_to::unwrap_to;

#[derive(serde::Serialize, serde::Deserialize, Debug, SerializedBytes, derive_more::From)]
#[serde(transparent)]
#[repr(transparent)]
struct AppString(String);

#[cfg(feature = "test_utils")]
#[tokio::test(flavor = "multi_thread")]
async fn dpki_publish() {
    holochain_trace::test_run();

    let config = SweetConductorConfig::standard();
    let conductors = SweetConductorBatch::from_config_rendezvous(2, config).await;

    conductors.exchange_peer_info().await;

    await_consistency(10, conductors.dpki_cells().as_slice())
        .await
        .unwrap();
}

#[cfg(feature = "test_utils")]
#[tokio::test(flavor = "multi_thread")]
async fn dpki_no_publish() {
    holochain_trace::test_run();

    let config = SweetConductorConfig::standard().no_publish();
    let conductors = SweetConductorBatch::from_config_rendezvous(2, config).await;

    conductors.exchange_peer_info().await;

    await_consistency(10, conductors.dpki_cells().as_slice())
        .await
        .unwrap();
}

/// Test that op publishing is sufficient for bobbo to get alice's op
/// even with gossip disabled.
#[cfg(feature = "test_utils")]
#[tokio::test(flavor = "multi_thread")]
async fn test_publish() -> anyhow::Result<()> {
    use std::sync::Arc;

    use holochain::test_utils::inline_zomes::simple_create_read_zome;
    use kitsune_p2p_types::config::KitsuneP2pConfig;

    holochain_trace::test_run();
    const NUM_CONDUCTORS: usize = 3;

    let (signal_url, _signal_srv_handle) = kitsune_p2p::test_util::start_signal_srv().await;

    let mut tuning =
        kitsune_p2p_types::config::tuning_params_struct::KitsuneP2pTuningParams::default();
    tuning.gossip_strategy = "none".to_string();

    let mut network = KitsuneP2pConfig::from_signal_addr(signal_url);
    network.tuning_params = Arc::new(tuning);
    let config = ConductorConfig {
        network,
        tuning_params: Some(ConductorTuningParams {
            sys_validation_retry_delay: Some(std::time::Duration::from_millis(100)),
            countersigning_resolution_retry_delay: None,
            ..Default::default()
        }),
        dpki: DpkiConfig::disabled(),
        ..Default::default()
    };

    let mut conductors = SweetConductorBatch::from_config(NUM_CONDUCTORS, config).await;

    let (dna_file, _, _) =
        SweetDnaFile::unique_from_inline_zomes(("simple", simple_create_read_zome())).await;

    let apps = conductors.setup_app("app", &[dna_file]).await.unwrap();
    conductors.exchange_peer_info().await;

    let ((alice,), (bobbo,), (carol,)) = apps.into_tuples();

    // Call the "create" zome fn on Alice's app
    let hash: ActionHash = conductors[0]
        .call(&alice.zome("simple"), "create", ())
        .await;

    // Wait long enough for Bob to receive gossip
    await_consistency(10, [&alice, &bobbo, &carol])
        .await
        .unwrap();

    // Verify that bobbo can run "read" on his cell and get alice's Action
    let record: Option<Record> = conductors[1]
        .call(&bobbo.zome("simple"), "read", hash)
        .await;
    let record = record.expect("Record was None: bobbo couldn't `get` it");

    // Assert that the Record bobbo sees matches what alice committed
    assert_eq!(record.action().author(), alice.agent_pubkey());
    assert_eq!(
        *record.entry(),
        RecordEntry::Present(Entry::app(().try_into().unwrap()).unwrap())
    );

    Ok(())
}

#[cfg(feature = "test_utils")]
#[tokio::test(flavor = "multi_thread")]
async fn multi_conductor() -> anyhow::Result<()> {
    use holochain::test_utils::inline_zomes::simple_create_read_zome;

    holochain_trace::init_fmt(holochain_trace::Output::Log).unwrap();

    const NUM_CONDUCTORS: usize = 3;

    let config = SweetConductorConfig::rendezvous(true)
        .tune_conductor(|config| {
            // The default is 10s which makes the test very slow in the case that get requests in the sys validation workflow
            // hit a conductor which isn't serving that data yet. Speed up by retrying more quickly.
            config.sys_validation_retry_delay = Some(std::time::Duration::from_millis(100));
        })
        .no_dpki_mustfix();

    let mut conductors = SweetConductorBatch::from_config_rendezvous(NUM_CONDUCTORS, config).await;

    let (dna_file, _, _) =
        SweetDnaFile::unique_from_inline_zomes(("simple", simple_create_read_zome())).await;

    let apps = conductors.setup_app("app", &[dna_file]).await.unwrap();

    let dpki_cells = conductors.dpki_cells();

    await_consistency(20, dpki_cells.as_slice()).await.unwrap();

    let ((alice,), (bobbo,), (carol,)) = apps.into_tuples();

    // Call the "create" zome fn on Alice's app
    let hash: ActionHash = conductors[0]
        .call(&alice.zome("simple"), "create", ())
        .await;

    // Wait long enough for Bob to receive gossip
    await_consistency(20, [&alice, &bobbo, &carol])
        .await
        .unwrap();

    // Verify that bobbo can run "read" on his cell and get alice's Action
    let record: Option<Record> = conductors[1]
        .call(&bobbo.zome("simple"), "read", hash)
        .await;
    let record = record.expect("Record was None: bobbo couldn't `get` it");

    // Assert that the Record bobbo sees matches what alice committed
    assert_eq!(record.action().author(), alice.agent_pubkey());
    assert_eq!(
        *record.entry(),
        RecordEntry::Present(Entry::app(().try_into().unwrap()).unwrap())
    );

    // See if we can fetch metric data from bobbo
    let metrics = conductors[1].dump_network_metrics(None).await?;
    tracing::info!(target: "TEST", "@!@! - metrics: {metrics}");

    // See if we can fetch network stats from bobbo
    let stats = conductors[1].dump_network_stats().await?;
    tracing::info!(target: "TEST", "@!@! - stats: {stats}");

    let stats: tx5::stats::Stats = serde_json::from_str(&stats).unwrap();

    // make sure that, by this point, we have upgraded connections to webrtc
    for con in stats.connection_list {
        assert!(con.is_webrtc);
    }

    Ok(())
}

#[cfg(feature = "test_utils")]
#[tokio::test(flavor = "multi_thread")]
#[cfg_attr(target_os = "macos", ignore = "flaky")]
async fn sharded_consistency() {
    use holochain::test_utils::{
        consistency::local_machine_session, inline_zomes::simple_create_read_zome,
    };

    holochain_trace::test_run();
    const NUM_CONDUCTORS: usize = 3;
    const NUM_CELLS: usize = 5;

    let config = SweetConductorConfig::standard().tune(|tuning| {
        tuning.gossip_strategy = "sharded-gossip".to_string();
        #[cfg(feature = "unstable-sharding")]
        {
            tuning.gossip_dynamic_arcs = true;
        }
    });
    let mut conductors = SweetConductorBatch::from_config(NUM_CONDUCTORS, config).await;

    let (dna_file, _, _) =
        SweetDnaFile::unique_from_inline_zomes(("simple", simple_create_read_zome())).await;
    let dnas = vec![dna_file];

    let apps = conductors.setup_app("app", &dnas).await.unwrap();

    let ((alice,), (bobbo,), (_carol,)) = apps.into_tuples();

    for i in 0..NUM_CELLS {
        conductors.setup_app(&i.to_string(), &dnas).await.unwrap();
    }
    conductors.exchange_peer_info().await;
    conductors.force_all_publish_dht_ops().await;
    // Call the "create" zome fn on Alice's app
    let hash: ActionHash = conductors[0]
        .call(&alice.zome("simple"), "create", ())
        .await;

    let conductor_handles: Vec<_> = conductors.iter().map(|c| c.raw_handle()).collect();
    local_machine_session(&conductor_handles, std::time::Duration::from_secs(60)).await;

    // Verify that bobbo can run "read" on his cell and get alice's Action
    let record: Option<Record> = conductors[1]
        .call(&bobbo.zome("simple"), "read", hash)
        .await;
    let record = record.expect("Record was None: bobbo couldn't `get` it");

    // Assert that the Record bobbo sees matches what alice committed
    assert_eq!(record.action().author(), alice.agent_pubkey());
    assert_eq!(
        *record.entry(),
        RecordEntry::Present(Entry::app(().try_into().unwrap()).unwrap())
    );
}

#[cfg(feature = "test_utils")]
#[tokio::test(flavor = "multi_thread")]
#[cfg_attr(target_os = "windows", ignore = "flaky")]
async fn private_entries_dont_leak() {
    use holochain::sweettest::SweetInlineZomes;
    use holochain_types::inline_zome::InlineZomeSet;

    holochain_trace::test_run();
    let mut entry_def = EntryDef::default_from_id("entrydef");
    entry_def.visibility = EntryVisibility::Private;

    #[derive(Serialize, Deserialize, Debug, SerializedBytes)]
    struct PrivateEntry;

    let zome = SweetInlineZomes::new(vec![entry_def.clone()], 0)
        .function("create", move |api, _: ()| {
            let entry = Entry::app(PrivateEntry {}.try_into().unwrap()).unwrap();
            let hash = api.create(CreateInput::new(
                InlineZomeSet::get_entry_location(&api, EntryDefIndex(0)),
                EntryVisibility::Private,
                entry,
                ChainTopOrdering::default(),
            ))?;
            Ok(hash)
        })
        .function("get", |api, hash: AnyDhtHash| {
            api.get(vec![GetInput::new(hash, GetOptions::default())])
                .map_err(Into::into)
        })
        .function("get_details", |api, hash: AnyDhtHash| {
            api.get_details(vec![GetInput::new(hash, GetOptions::default())])
                .map_err(Into::into)
        });

    let mut conductors = SweetConductorBatch::from_standard_config_rendezvous(2).await;

    let (dna_file, _, _) = SweetDnaFile::unique_from_inline_zomes(zome.0).await;
    let dnas = vec![dna_file];

    let apps = conductors.setup_app("app", &dnas).await.unwrap();
    let ((alice,), (bobbo,)) = apps.into_tuples();

    // Call the "create" zome fn on Alice's app
    let hash: ActionHash = conductors[0]
        .call(&alice.zome(SweetInlineZomes::COORDINATOR), "create", ())
        .await;

    await_consistency(10, [&alice, &bobbo]).await.unwrap();

    let entry_hash =
        EntryHash::with_data_sync(&Entry::app(PrivateEntry {}.try_into().unwrap()).unwrap());

    check_all_gets_for_private_entry(
        &conductors[0],
        &alice.zome(SweetInlineZomes::COORDINATOR),
        hash.clone(),
        entry_hash.clone(),
    )
    .await;
    check_all_gets_for_private_entry(
        &conductors[1],
        &bobbo.zome(SweetInlineZomes::COORDINATOR),
        hash.clone(),
        entry_hash.clone(),
    )
    .await;

    // Bobbo creates the same private entry.
    let bob_hash: ActionHash = conductors[1]
        .call(&bobbo.zome(SweetInlineZomes::COORDINATOR), "create", ())
        .await;
    await_consistency(10, [&alice, &bobbo]).await.unwrap();

    check_all_gets_for_private_entry(
        &conductors[0],
        &alice.zome(SweetInlineZomes::COORDINATOR),
        hash.clone(),
        entry_hash.clone(),
    )
    .await;
    check_all_gets_for_private_entry(
        &conductors[1],
        &bobbo.zome(SweetInlineZomes::COORDINATOR),
        hash.clone(),
        entry_hash.clone(),
    )
    .await;

    check_all_gets_for_private_entry(
        &conductors[0],
        &alice.zome(SweetInlineZomes::COORDINATOR),
        bob_hash.clone(),
        entry_hash.clone(),
    )
    .await;
    check_all_gets_for_private_entry(
        &conductors[1],
        &bobbo.zome(SweetInlineZomes::COORDINATOR),
        bob_hash.clone(),
        entry_hash.clone(),
    )
    .await;

    check_for_private_entries(alice.dht_db().clone()).await;
    check_for_private_entries(conductors[0].get_cache_db(alice.cell_id()).await.unwrap()).await;
    check_for_private_entries(bobbo.dht_db().clone()).await;
    check_for_private_entries(conductors[1].get_cache_db(bobbo.cell_id()).await.unwrap()).await;
}

#[cfg_attr(feature = "instrument", tracing::instrument(skip_all))]
async fn check_for_private_entries<Kind: DbKindT>(env: DbWrite<Kind>) {
    let count: usize = env.read_async(move |txn| -> DatabaseResult<usize> {
        Ok(txn.query_row(
            "select count(action.rowid) from action join entry on action.entry_hash = entry.hash where private_entry = 1",
            [],
            |row| row.get(0),
        )?)
    }).await.unwrap();
    assert_eq!(count, 0);
}

async fn check_all_gets_for_private_entry(
    conductor: &SweetConductor,
    zome: &SweetZome,
    action_hash: ActionHash,
    entry_hash: EntryHash,
) {
    let mut records: Vec<Option<Record>> = conductor
        .call(zome, "get", AnyDhtHash::from(action_hash.clone()))
        .await;
    let e: Vec<Option<Record>> = conductor
        .call(zome, "get", AnyDhtHash::from(entry_hash.clone()))
        .await;
    records.extend(e);
    let details: Vec<Option<Details>> = conductor
        .call(zome, "get_details", AnyDhtHash::from(action_hash.clone()))
        .await;
    records.extend(
        details
            .into_iter()
            .map(|d| d.map(|d| unwrap_to!(d => Details::Record).clone().record)),
    );
    let records = records.into_iter().flatten().collect();
    check_records_for_private_entry(zome.cell_id().agent_pubkey().clone(), records);
    let entries: Vec<Option<Details>> = conductor
        .call(zome, "get_details", AnyDhtHash::from(entry_hash.clone()))
        .await;
    for entry in entries {
        let entry = match entry {
            Some(e) => e,
            None => continue,
        };
        let details = unwrap_to!(entry=> Details::Entry).clone();
        let actions = details.actions;
        for action in actions {
            assert_eq!(action.action().author(), zome.cell_id().agent_pubkey());
        }
    }
}

fn check_records_for_private_entry(caller: AgentPubKey, records: Vec<Record>) {
    for record in records {
        if *record.action().author() == caller {
            assert_ne!(*record.entry(), RecordEntry::Hidden);
        } else {
            assert_eq!(*record.entry(), RecordEntry::Hidden);
        }
    }
}



================================================
File: crates/holochain/tests/tests/new_lair/mod.rs
================================================
use assert_cmd::prelude::*;
use holochain::sweettest::WsPollRecv;
use holochain_conductor_api::config::conductor::ConductorConfig;
use holochain_conductor_api::config::conductor::KeystoreConfig;
use holochain_conductor_api::InterfaceDriver;
use holochain_conductor_api::{AdminInterfaceConfig, AdminResponse};
use holochain_types::websocket::AllowedOrigins;
use kitsune_p2p_types::dependencies::lair_keystore_api;
use lair_keystore_api::dependencies::*;
use lair_keystore_api::ipc_keystore::*;
use lair_keystore_api::mem_store::*;
use lair_keystore_api::prelude::*;
use std::sync::Arc;

use super::test_utils::*;

const ADMIN_PORT: u16 = 12909;

#[tokio::test(flavor = "multi_thread")]
#[cfg_attr(
    target_os = "macos",
    ignore = "processes fail to launch on macos, broken!"
)]
async fn test_new_lair_conductor_integration() {
    // working temp dir
    let tmp = tempfile::tempdir().unwrap();

    // set up new lair keystore config
    let passphrase = sodoken::BufRead::from(&b"passphrase"[..]);
    let config = Arc::new(
        hc_seed_bundle::PwHashLimits::Minimum
            .with_exec(|| LairServerConfigInner::new(tmp.path(), passphrase.clone()))
            .await
            .unwrap(),
    );

    let keystore = IpcKeystoreServer::new(config, create_mem_store_factory(), passphrase)
        .await
        .unwrap();

    // print keystore config
    let keystore_config = keystore.get_config();
    println!("\n## keystore config ##\n{}", keystore_config);

    // set up conductor config to use the started keystore
    let conductor_config = ConductorConfig {
        admin_interfaces: Some(vec![AdminInterfaceConfig {
            driver: InterfaceDriver::Websocket {
                port: ADMIN_PORT,
                allowed_origins: AllowedOrigins::Any,
            },
        }]),
        data_root_path: Some(tmp.path().to_owned().into()),
        keystore: KeystoreConfig::LairServer {
            connection_url: keystore_config.connection_url.clone().into(),
        },
        ..Default::default()
    };

    // write the conductor config
    let conductor_config = serde_yaml::to_string(&conductor_config).unwrap();
    let mut cc_path = tmp.path().to_owned();
    cc_path.push("conductor_config.yml");
    tokio::fs::write(&cc_path, &conductor_config).await.unwrap();
    println!("\n## conductor config ##\n{}", conductor_config);

    // start a conductor using the new config
    let cmd = std::process::Command::cargo_bin("holochain").unwrap();
    let mut cmd = tokio::process::Command::from(cmd);
    cmd.arg("--structured")
        .arg("--config-path")
        .arg(cc_path)
        .arg("--piped")
        .env("RUST_LOG", "trace")
        .stdout(std::process::Stdio::inherit())
        .stderr(std::process::Stdio::inherit())
        .stdin(std::process::Stdio::piped())
        .kill_on_drop(true);

    let mut child = cmd.spawn().unwrap();

    // we asked for the passphrase to be read from stdin pipe
    // provide it now
    let mut stdin = child.stdin.take().unwrap();
    use tokio::io::AsyncWriteExt;
    stdin.write_all(b"passphrase").await.unwrap();
    drop(stdin);

    // cribbed this from test_utils... probably something better would be better
    if let Ok(status) = tokio::time::timeout(std::time::Duration::from_secs(1), child.wait()).await
    {
        panic!("failed to start holochain: {:?}", status);
    }

    let (mut client, rx) = websocket_client_by_port(ADMIN_PORT).await.unwrap();
    let _rx = WsPollRecv::new::<AdminResponse>(rx);

    let agent_key = generate_agent_pub_key(&mut client, 15_000).await.unwrap();
    println!("GENERATED AGENT KEY: {}", agent_key);
    let mut agent_key_bytes = [0; 32];
    agent_key_bytes.copy_from_slice(agent_key.get_raw_32());
    println!("AGENT ED25519 PUBKEY: {:?}", agent_key_bytes);

    let store = keystore.store().await.unwrap();
    let entry = store
        .get_entry_by_ed25519_pub_key(agent_key_bytes.into())
        .await
        .unwrap();
    println!("AGENT_STORE_ENTRY: {:?}", entry);

    match &*entry {
        LairEntryInner::Seed { seed_info, .. } => {
            assert_eq!(*seed_info.ed25519_pub_key, agent_key_bytes);
        }
        oth => panic!("invalid entry type: {:?}", oth),
    }

    child.kill().await.unwrap();
}



================================================
File: crates/holochain/tests/tests/publish/mod.rs
================================================
use holo_hash::ActionHash;
use holochain::core::workflow::publish_dht_ops_workflow::num_still_needing_publish;
use holochain::sweettest::*;
use holochain_wasm_test_utils::TestWasm;
use holochain_zome_types::prelude::GetValidationReceiptsInput;
use holochain_zome_types::validate::ValidationReceiptSet;

/// Verifies that publishing terminates naturally when enough validation receipts are received.
#[cfg(feature = "test_utils")]
#[tokio::test(flavor = "multi_thread")]
#[ignore = "receipt completion is flaky, which has been rechecked since the workflow reviews"]
async fn publish_terminates_after_receiving_required_validation_receipts() {
    holochain_trace::test_run();

    // Need DEFAULT_RECEIPT_BUNDLE_SIZE peers to send validation receipts back
    const NUM_CONDUCTORS: usize =
        holochain::core::workflow::publish_dht_ops_workflow::DEFAULT_RECEIPT_BUNDLE_SIZE as usize
            + 1;

    let mut conductors = SweetConductorBatch::from_config_rendezvous(
        NUM_CONDUCTORS,
        SweetConductorConfig::rendezvous(true),
    )
    .await;

    let (dna_file, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::Create]).await;

    let apps = conductors.setup_app("app", &[dna_file]).await.unwrap();

    let ((alice,), (bobbo,), (carol,), (danny,), (emma,), (fred,)) = apps.into_tuples();

    let action_hash: ActionHash = conductors[0]
        .call(&alice.zome(TestWasm::Create), "create_entry", ())
        .await;

    // Wait until they all see the created entry, at that point validation receipts should be getting sent soon
    await_consistency(60, [&alice, &bobbo, &carol, &danny, &emma, &fred])
        .await
        .unwrap();

    let ops_to_publish = tokio::time::timeout(std::time::Duration::from_secs(60), async {
        let mut ops_to_publish = 1;
        while ops_to_publish > 0 {
            ops_to_publish = alice
                .authored_db()
                .read_async({
                    let alice_pub_key = alice.agent_pubkey().clone();
                    // Note that this test is relying on this being the same check that the publish workflow uses.
                    // If this returns 0 then the publish workflow is expected to suspend. So the test isn't directly
                    // observing that behaviour but it's close enough given that there are unit tests for the actual
                    // behavior.
                    move |txn| num_still_needing_publish(txn, alice_pub_key)
                })
                .await
                .unwrap();
        }

        ops_to_publish
    })
    .await
    .expect("timed out waiting for all receipts to be received");

    assert_eq!(ops_to_publish, 0);

    // Get the validation receipts to check that they are all complete
    let receipt_sets: Vec<ValidationReceiptSet> = conductors[0]
        .call(
            &alice.zome(TestWasm::Create),
            "get_validation_receipts",
            GetValidationReceiptsInput::new(action_hash),
        )
        .await;
    assert_eq!(receipt_sets.len(), 3);
    assert!(receipt_sets.iter().all(|r| r.receipts_complete));

    let agent_activity_receipt_set = receipt_sets
        .into_iter()
        .find(|r| r.op_type == "RegisterAgentActivity")
        .unwrap();
    assert_eq!(
        agent_activity_receipt_set.receipts.len(),
        holochain::core::workflow::publish_dht_ops_workflow::DEFAULT_RECEIPT_BUNDLE_SIZE as usize
    );
}



================================================
File: crates/holochain/tests/tests/regression/mod.rs
================================================
use holo_hash::ActionHash;
#[cfg(not(feature = "wasmer_wamr"))]
use holochain::conductor::conductor::WASM_CACHE;
use holochain::sweettest::*;
use holochain_wasm_test_utils::TestWasm;

// Make sure the wasm cache at least creates files.
// This is not run with the `wasmer_wamr` feature flag,
// as the cache is not used.
#[tokio::test(flavor = "multi_thread")]
#[cfg(not(feature = "wasmer_wamr"))]
async fn wasm_disk_cache() {
    holochain_trace::test_run();
    let mut conductor =
        SweetConductor::from_config(SweetConductorConfig::standard().no_dpki()).await;

    let mut cache_dir = conductor.db_path().to_owned();
    cache_dir.push(WASM_CACHE);

    let mut read = tokio::fs::read_dir(&cache_dir).await.unwrap();
    assert!(read.next_entry().await.unwrap().is_none());

    let (dna_file, _, _) =
        SweetDnaFile::unique_from_test_wasms(vec![TestWasm::ValidateRejectAppTypes, TestWasm::Crd])
            .await;
    let agent = SweetAgents::alice();

    let (cell,) = conductor
        .setup_app_for_agent("app", agent, &[dna_file])
        .await
        .unwrap()
        .into_tuple();

    let _created: ActionHash = conductor
        .call(
            &cell.zome(TestWasm::Crd.coordinator_zome_name()),
            "create",
            (),
        )
        .await;

    let mut read = tokio::fs::read_dir(&cache_dir).await.unwrap();
    assert!(read.next_entry().await.unwrap().is_some());
}

// Intended to keep https://github.com/holochain/holochain/issues/2868 fixed.
#[tokio::test(flavor = "multi_thread")]
async fn zome_with_no_entry_types_does_not_prevent_deletes() {
    holochain_trace::test_run();

    let mut conductor = SweetConductor::from_standard_config().await;

    let (dna_file, _, _) =
        SweetDnaFile::unique_from_test_wasms(vec![TestWasm::ValidateRejectAppTypes, TestWasm::Crd])
            .await;

    let (cell,) = conductor
        .setup_app("app", &[dna_file])
        .await
        .unwrap()
        .into_tuple();

    let created: ActionHash = conductor
        .call(
            &cell.zome(TestWasm::Crd.coordinator_zome_name()),
            "create",
            (),
        )
        .await;

    let _: ActionHash = conductor
        .call(
            &cell.zome(TestWasm::Crd.coordinator_zome_name()),
            "delete_via_hash",
            created,
        )
        .await;
}

// Intended to keep https://github.com/holochain/holochain/issues/2868 fixed.
#[tokio::test(flavor = "multi_thread")]
async fn zome_with_no_link_types_does_not_prevent_delete_links() {
    holochain_trace::test_run();

    let mut conductor = SweetConductor::from_standard_config().await;

    let (dna_file, _, _) = SweetDnaFile::unique_from_test_wasms(vec![
        TestWasm::ValidateRejectAppTypes,
        TestWasm::Link,
    ])
    .await;

    let (cell,) = conductor
        .setup_app("app", &[dna_file])
        .await
        .unwrap()
        .into_tuple();

    let created: ActionHash = conductor
        .call(
            &cell.zome(TestWasm::Link.coordinator_zome_name()),
            "create_link",
            (),
        )
        .await;

    let _: ActionHash = conductor
        .call(
            &cell.zome(TestWasm::Link.coordinator_zome_name()),
            "delete_link",
            created,
        )
        .await;
}

#[tokio::test(flavor = "multi_thread")]
#[cfg_attr(target_os = "windows", ignore = "flaky")]
async fn zero_arc_can_link_to_uncached_base() {
    use hdk::prelude::*;

    holochain_trace::test_run();

    let empty_arc_conductor_config = SweetConductorConfig::rendezvous(false)
        .no_dpki_mustfix()
        .tune(|t| {
            t.gossip_arc_clamping = String::from("empty");
        });

    let mut conductors = SweetConductorBatch::from_configs_rendezvous(vec![
        SweetConductorConfig::rendezvous(false).no_dpki_mustfix(),
        empty_arc_conductor_config,
    ])
    .await;

    let (dna_file, _, _) = SweetDnaFile::unique_from_test_wasms(vec![
        TestWasm::ValidateRejectAppTypes,
        TestWasm::Link,
    ])
    .await;

    let apps = conductors.setup_app("app", &[dna_file]).await.unwrap();
    conductors.exchange_peer_info().await;

    let ((alice,), (bob,)) = apps.into_tuples();

    let alice_pk = alice.cell_id().agent_pubkey().clone();

    println!("@!@!@ alice_pk: {alice_pk:?}");

    let action_hash: ActionHash = conductors[0]
        .call(
            &alice.zome(TestWasm::Link.coordinator_zome_name()),
            "test_entry_create",
            (),
        )
        .await;

    println!("@!@!@ -- must_get_valid_record --");
    println!("@!@!@ action_hash: {action_hash:?}");

    // Bob is linking to Alice's action hash, but doesn't have it locally
    // so the must_get_valid_record in validation will have to do a network get.
    let link_hash: ActionHash = conductors[1]
        .call(
            &bob.zome(TestWasm::Link.coordinator_zome_name()),
            "link_validation_calls_must_get_valid_record",
            (action_hash.clone(), alice_pk.clone()),
        )
        .await;

    println!("@!@!@ link_hash: {link_hash:?}");

    let action_hash: ActionHash = conductors[0]
        .call(
            &alice.zome(TestWasm::Link.coordinator_zome_name()),
            "test_entry_create",
            (),
        )
        .await;

    println!("@!@!@ -- must_get_action / must_get_entry --");
    println!("@!@!@ action_hash: {action_hash:?}");

    // Bob is linking to Alice's action hash, but doesn't have it locally
    // so the must_get_entry/must_get_action in validation will have to do a network get.
    let link_hash: ActionHash = conductors[1]
        .call(
            &bob.zome(TestWasm::Link.coordinator_zome_name()),
            "link_validation_calls_must_get_action_then_entry",
            (action_hash.clone(), alice_pk.clone()),
        )
        .await;

    println!("@!@!@ link_hash: {link_hash:?}");

    let action_hash: ActionHash = conductors[0]
        .call(
            &alice.zome(TestWasm::Link.coordinator_zome_name()),
            "test_entry_create",
            (),
        )
        .await;

    println!("@!@!@ -- must_get_agent_activity --");
    println!("@!@!@ action_hash: {action_hash:?}");

    // Bob is linking to Alice's action hash, but doesn't have it locally
    // so the must_get_agent_activity in validation will have to do a network get.
    let link_hash: ActionHash = conductors[1]
        .call(
            &bob.zome(TestWasm::Link.coordinator_zome_name()),
            "link_validation_calls_must_get_agent_activity",
            (action_hash.clone(), alice_pk.clone()),
        )
        .await;

    println!("@!@!@ link_hash: {link_hash:?}");
}

pub mod must_get_agent_activity_saturation;



================================================
File: crates/holochain/tests/tests/regression/must_get_agent_activity_saturation.rs
================================================
use holo_hash::ActionHash;
use holochain::sweettest::{SweetConductorBatch, SweetConductorConfig, SweetDnaFile};
use holochain_wasm_test_utils::TestWasm;
use holochain_zome_types::prelude::Record;
use rand::{thread_rng, Rng};

// Intended to keep https://github.com/holochain/holochain/issues/3028 fixed.
// ensure that multiple `must_get_agent_activity` calls do not oversaturate the
// fetch pool and bring gossip to a halt
#[tokio::test(flavor = "multi_thread")]
#[cfg(feature = "slow_tests")]
#[cfg_attr(target_os = "windows", ignore = "flaky")]
async fn must_get_agent_activity_saturation() {
    use holochain::sweettest::await_consistency;

    holochain_trace::test_run();

    let mut rng = thread_rng();
    let (dna, _, _) =
        SweetDnaFile::unique_from_test_wasms(vec![TestWasm::MustGetAgentActivity]).await;
    let mut conductors = SweetConductorBatch::from_config_rendezvous(
        2,
        SweetConductorConfig::rendezvous(true).no_dpki_mustfix(),
    )
    .await;
    let apps = conductors
        .setup_app("", [&dna])
        .await
        .unwrap()
        .cells_flattened();
    let alice_cell = &apps[0];
    let bob_cell = &apps[1];

    let mut hash = ActionHash::from_raw_32(vec![0; 32]);
    for _ in 0..100 {
        let content: u32 = rng.gen();
        let record: Record = conductors[0]
            .call(
                &alice_cell.zome(TestWasm::MustGetAgentActivity.coordinator_zome_name()),
                "create_thing",
                content,
            )
            .await;
        hash = record.action_hashed().hash.clone();
    }

    // let conductors catch up
    await_consistency(120, [alice_cell, bob_cell])
        .await
        .unwrap();

    let record: Option<Record> = conductors[1]
        .call(
            &bob_cell.zome(TestWasm::MustGetAgentActivity.coordinator_zome_name()),
            "get_thing",
            hash,
        )
        .await;
    assert!(record.is_some());
}



================================================
File: crates/holochain/tests/tests/ser_regression/mod.rs
================================================
use ::fixt::prelude::*;
use hdk::prelude::*;

use hdk::prelude::fixt::*;
use holochain::conductor::api::AppInterfaceApi;
use holochain::conductor::api::AppRequest;
use holochain::conductor::api::AppResponse;
use holochain::sweettest::*;
use holochain_conductor_api::ZomeCallParamsSigned;
use holochain_nonce::fresh_nonce;
use holochain_types::prelude::*;
use holochain_wasm_test_utils::TestWasm;
use holochain_wasm_test_utils::TestZomes;

#[derive(Serialize, Deserialize, SerializedBytes, Debug)]
struct CreateMessageInput {
    channel_hash: EntryHash,
    content: String,
}

#[derive(Debug, Serialize, Deserialize, SerializedBytes)]
pub struct ChannelName(String);

#[tokio::test(flavor = "multi_thread")]
async fn ser_entry_hash_test() {
    holochain_trace::test_run();
    let eh = fixt!(EntryHash);
    let extern_io: ExternIO = ExternIO::encode(eh).unwrap();
    tracing::debug!(?extern_io);
    let o: EntryHash = extern_io.decode().unwrap();
    let extern_io: ExternIO = ExternIO::encode(o).unwrap();
    tracing::debug!(?extern_io);
    let _eh: EntryHash = extern_io.decode().unwrap();
}

#[tokio::test(flavor = "multi_thread")]
/// we can call a fn on a remote
async fn ser_regression_test() {
    holochain_trace::test_run();
    // ////////////
    // START DNA
    // ////////////

    let dna_file = DnaFile::new(
        DnaDef {
            name: "ser_regression_test".to_string(),
            modifiers: DnaModifiers {
                network_seed: "ba1d046d-ce29-4778-914b-47e6010d2faf".to_string(),
                properties: SerializedBytes::try_from(()).unwrap(),
                origin_time: Timestamp::HOLOCHAIN_EPOCH,
                quantum_time: holochain_p2p::dht::spacetime::STANDARD_QUANTUM_TIME,
            },
            integrity_zomes: vec![TestZomes::from(TestWasm::SerRegression)
                .integrity
                .into_inner()],
            coordinator_zomes: vec![TestZomes::from(TestWasm::SerRegression)
                .coordinator
                .into_inner()],
            lineage: HashSet::new(),
        },
        <Vec<DnaWasm>>::from(TestWasm::SerRegression),
    )
    .await;

    // //////////
    // END DNA
    // //////////

    let mut conductors = SweetConductorBatch::from_standard_config(2).await;
    let ((alice,), (_bob,)) = conductors
        .setup_app("app", vec![&dna_file])
        .await
        .unwrap()
        .into_tuples();

    // ALICE DOING A CALL

    let channel = ChannelName("hello world".into());

    let (nonce, expires_at) = fresh_nonce(Timestamp::now()).unwrap();
    let mut zome_call_params = ZomeCallParams {
        cell_id: alice.cell_id().clone(),
        zome_name: TestWasm::SerRegression.into(),
        cap_secret: Some(CapSecretFixturator::new(Unpredictable).next().unwrap()),
        fn_name: "create_channel".into(),
        payload: ExternIO::encode(channel).unwrap(),
        provenance: alice.agent_pubkey().clone(),
        nonce,
        expires_at,
    };
    let zome_call_params_signed =
        ZomeCallParamsSigned::try_from_params(&conductors[0].keystore(), zome_call_params.clone())
            .await
            .unwrap();

    let app_api = AppInterfaceApi::new(conductors[0].clone());
    let request = Box::new(zome_call_params_signed.clone());
    let request = AppRequest::CallZome(request);
    let response = app_api
        .handle_request("".to_string(), Ok(request))
        .await
        .unwrap();

    let _channel_hash: EntryHash = match response {
        AppResponse::ZomeCalled(r) => r.decode().unwrap(),
        _ => unreachable!(),
    };

    let (nonce, expires_at) = fresh_nonce(Timestamp::now()).unwrap();
    zome_call_params.nonce = nonce;
    zome_call_params.expires_at = expires_at;
    let output = conductors[0]
        .call_zome(zome_call_params)
        .await
        .unwrap()
        .unwrap();

    let channel_hash: EntryHash = match output {
        ZomeCallResponse::Ok(guest_output) => guest_output.decode().unwrap(),
        _ => panic!("{:?}", output),
    };

    let message = CreateMessageInput {
        channel_hash,
        content: "Hello from alice :)".into(),
    };
    let (nonce, expires_at) = fresh_nonce(Timestamp::now()).unwrap();
    let mut zome_call_params = ZomeCallParams {
        cell_id: alice.cell_id().clone(),
        zome_name: TestWasm::SerRegression.into(),
        cap_secret: Some(CapSecretFixturator::new(Unpredictable).next().unwrap()),
        fn_name: "create_message".into(),
        payload: ExternIO::encode(message).unwrap(),
        provenance: alice.agent_pubkey().clone(),
        nonce,
        expires_at,
    };
    let zome_call_params_signed =
        ZomeCallParamsSigned::try_from_params(&conductors[0].keystore(), zome_call_params.clone())
            .await
            .unwrap();

    let request = Box::new(zome_call_params_signed.clone());
    let request = AppRequest::CallZome(request);
    let response = app_api
        .handle_request("".to_string(), Ok(request))
        .await
        .unwrap();

    let _msg_hash: EntryHash = match response {
        AppResponse::ZomeCalled(r) => r.decode().unwrap(),
        _ => unreachable!(),
    };

    let (nonce, expires_at) = fresh_nonce(Timestamp::now()).unwrap();
    zome_call_params.nonce = nonce;
    zome_call_params.expires_at = expires_at;
    let output = conductors[0]
        .call_zome(zome_call_params)
        .await
        .unwrap()
        .unwrap();

    let _msg_hash: EntryHash = match output {
        ZomeCallResponse::Ok(guest_output) => guest_output.decode().unwrap(),
        _ => panic!("{:?}", output),
    };
}



================================================
File: crates/holochain/tests/tests/sharded_gossip/mod.rs
================================================
#![allow(clippy::field_reassign_with_default)]
#![allow(clippy::type_complexity)]
#![allow(clippy::single_match)]

use std::time::{Duration, Instant};

use hdk::prelude::*;
use holochain::sweettest::*;
use holochain::test_utils::inline_zomes::{
    batch_create_zome, simple_create_read_zome, simple_crud_zome,
};
use holochain::test_utils::WaitFor;
use holochain_p2p::*;
use kitsune_p2p_types::config::tuning_params_struct::KitsuneP2pTuningParams;
use kitsune_p2p_types::config::RECENT_THRESHOLD_DEFAULT;

fn make_tuning(
    publish: bool,
    recent: bool,
    historical: bool,
    recent_threshold: Option<u64>,
) -> KitsuneP2pTuningParams {
    let mut tuning = KitsuneP2pTuningParams::default();
    tuning.gossip_strategy = "sharded-gossip".to_string();
    tuning.disable_publish = !publish;
    tuning.disable_recent_gossip = !recent;
    tuning.disable_historical_gossip = !historical;
    tuning.danger_gossip_recent_threshold_secs =
        recent_threshold.unwrap_or(RECENT_THRESHOLD_DEFAULT.as_secs());

    tuning.gossip_inbound_target_mbps = 10000.0;
    tuning.gossip_outbound_target_mbps = 10000.0;
    tuning.gossip_historic_outbound_target_mbps = 10000.0;
    tuning.gossip_historic_inbound_target_mbps = 10000.0;

    // This allows attempting to contact an offline node to timeout quickly,
    // so we can fallback to the next one
    tuning.default_rpc_single_timeout_ms = 3_000;
    tuning.gossip_round_timeout_ms = 10_000;
    tuning.bootstrap_check_delay_backoff_multiplier = 1;

    tuning
}

#[derive(Clone, Debug)]
struct TestConfig {
    publish: bool,
    recent: bool,
    historical: bool,
    bootstrap: bool,
    recent_threshold: Option<u64>,
}

impl From<TestConfig> for SweetConductorConfig {
    fn from(tc: TestConfig) -> Self {
        let TestConfig {
            publish,
            recent,
            historical,
            bootstrap,
            recent_threshold,
        } = tc;
        let tuning = make_tuning(publish, recent, historical, recent_threshold);
        SweetConductorConfig::rendezvous(bootstrap).set_tuning_params(tuning)
    }
}

#[cfg(feature = "test_utils")]
#[tokio::test(flavor = "multi_thread")]
#[cfg_attr(target_os = "macos", ignore = "flaky")]
async fn bad_network_gossip() {
    holochain_trace::test_run();

    let vous = SweetLocalRendezvous::new_raw().await;

    vous.drop_sig().await;

    let v1: DynSweetRendezvous = vous.clone();
    let mut c1 = SweetConductor::from_config_rendezvous(
        SweetConductorConfig::rendezvous(true).no_dpki(),
        v1,
    )
    .await;

    let v2: DynSweetRendezvous = vous.clone();
    let mut c2 = SweetConductor::from_config_rendezvous(
        SweetConductorConfig::rendezvous(true).no_dpki(),
        v2,
    )
    .await;

    let (dna_file, _, _) =
        SweetDnaFile::unique_from_inline_zomes(("simple", simple_create_read_zome())).await;

    let a1 = SweetAgents::one(c1.keystore()).await;
    let a2 = SweetAgents::one(c2.keystore()).await;

    let (app1,) = c1
        .setup_app_for_agent("app", a1.clone(), &[dna_file.clone()])
        .await
        .unwrap()
        .into_tuple();
    let (app2,) = c2
        .setup_app_for_agent("app", a2.clone(), &[dna_file])
        .await
        .unwrap()
        .into_tuple();

    let hash: ActionHash = c1.call(&app1.zome("simple"), "create", ()).await;

    // should not be possible to achieve consistency if the sbd server is down
    // note, the 3 seconds is small because we don't want the test to take
    // a long time, but also, this check isn't as important as the next one
    // that ensures after the server is back up we DO get consistency!
    assert!(await_consistency(3, [&app1, &app2]).await.is_err());

    vous.start_sig().await;

    await_consistency(60, [&app1, &app2]).await.unwrap();

    let record: Option<Record> = c2.call(&app2.zome("simple"), "read", hash).await;
    let record = record.expect("Record was None: bobbo couldn't `get` it");

    assert_eq!(record.action().author(), &a1);
    assert_eq!(
        *record.entry(),
        RecordEntry::Present(Entry::app(().try_into().unwrap()).unwrap())
    );
}

#[cfg(feature = "test_utils")]
#[tokio::test(flavor = "multi_thread")]
#[cfg_attr(target_os = "macos", ignore = "flaky")]
async fn fullsync_sharded_gossip_low_data() -> anyhow::Result<()> {
    holochain_trace::test_run();
    const NUM_CONDUCTORS: usize = 2;

    let mut conductors = SweetConductorBatch::from_config_rendezvous(
        NUM_CONDUCTORS,
        TestConfig {
            publish: false,
            recent: true,
            historical: true,
            bootstrap: true,
            recent_threshold: None,
        },
    )
    .await;

    let (dna_file, _, _) =
        SweetDnaFile::unique_from_inline_zomes(("simple", simple_create_read_zome())).await;

    let apps = conductors.setup_app("app", [&dna_file]).await.unwrap();

    let ((alice,), (bobbo,)) = apps.into_tuples();

    conductors[0]
        .require_initial_gossip_activity_for_cell(
            &alice,
            NUM_CONDUCTORS as u32,
            Duration::from_secs(90),
        )
        .await
        .unwrap();

    // Call the "create" zome fn on Alice's app
    let hash: ActionHash = conductors[0]
        .call(&alice.zome("simple"), "create", ())
        .await;

    // Wait long enough for Bob to receive gossip
    await_consistency(60, [&alice, &bobbo]).await.unwrap();
    // let p2p = conductors[0].envs().p2p().lock().values().next().cloned().unwrap();
    // holochain_state::prelude::dump_tmp(&p2p);
    // holochain_state::prelude::dump_tmp(&alice.env());
    // Verify that bobbo can run "read" on his cell and get alice's Action
    let record: Option<Record> = conductors[1]
        .call(&bobbo.zome("simple"), "read", hash)
        .await;
    let record = record.expect("Record was None: bobbo couldn't `get` it");

    // Assert that the Record bobbo sees matches what alice committed
    assert_eq!(record.action().author(), alice.agent_pubkey());
    assert_eq!(
        *record.entry(),
        RecordEntry::Present(Entry::app(().try_into().unwrap()).unwrap())
    );

    Ok(())
}

#[cfg(feature = "test_utils")]
#[tokio::test(flavor = "multi_thread")]
#[cfg_attr(target_os = "macos", ignore = "flaky")]
async fn fullsync_sharded_gossip_high_data() -> anyhow::Result<()> {
    holochain_trace::test_run();

    const NUM_CONDUCTORS: usize = 3;
    const NUM_OPS: usize = 100;

    let mut conductors = SweetConductorBatch::from_config_rendezvous(
        NUM_CONDUCTORS,
        <TestConfig as Into<SweetConductorConfig>>::into(TestConfig {
            publish: false,
            recent: false,
            historical: true,
            bootstrap: true,
            recent_threshold: Some(0),
        })
        .tune_conductor(|p| {
            // Running too often here seems to not give other things enough time to process these ops. 2s seems to be a good middle ground
            // to make this test pass and be stable.
            p.sys_validation_retry_delay = Some(std::time::Duration::from_secs(2));
        }),
    )
    .await;

    let (dna_file, _, _) =
        SweetDnaFile::unique_from_inline_zomes(("zome", batch_create_zome())).await;

    let apps = conductors.setup_app("app", [&dna_file]).await.unwrap();

    let ((alice,), (bobbo,), (carol,)) = apps.into_tuples();

    conductors[0]
        .require_initial_gossip_activity_for_cell(
            &alice,
            NUM_CONDUCTORS as u32,
            Duration::from_secs(90),
        )
        .await
        .unwrap();

    // Call the "create" zome fn on Alice's app
    let hashes: Vec<ActionHash> = conductors[0]
        .call(&alice.zome("zome"), "create_batch", NUM_OPS)
        .await;

    // Wait long enough for Bob to receive gossip
    await_consistency(20, [&alice, &bobbo, &carol])
        .await
        .unwrap();

    let mut all_op_hashes = vec![];

    for i in 0..NUM_CONDUCTORS {
        let mut hashes: Vec<_> = conductors[i]
            .get_spaces()
            .handle_query_op_hashes(
                dna_file.dna_hash(),
                holochain_p2p::dht_arc::DhtArcSet::Full,
                kitsune_p2p::event::full_time_window(),
                100000000,
                true,
            )
            .await
            .unwrap()
            .unwrap()
            .0;

        hashes.sort();
        all_op_hashes.push(hashes);
    }

    assert_eq!(all_op_hashes[0].len(), all_op_hashes[1].len());
    assert_eq!(all_op_hashes[0], all_op_hashes[1]);
    assert_eq!(all_op_hashes[1].len(), all_op_hashes[2].len());
    assert_eq!(all_op_hashes[1], all_op_hashes[2]);

    // Verify that bobbo can run "read" on his cell and get alice's Action
    let element: Option<Record> = conductors[1]
        .call(&bobbo.zome("zome"), "read", hashes[0].clone())
        .await;
    let element = element.expect("Record was None: bobbo couldn't `get` it");

    // Assert that the Record bobbo sees matches what alice committed
    assert_eq!(element.action().author(), alice.agent_pubkey());
    assert!(matches!(
        *element.entry(),
        RecordEntry::Present(Entry::App(_))
    ));

    Ok(())
}

/// Test that conductors with arcs clamped to zero do not gossip.
#[cfg(feature = "slow_tests")]
#[tokio::test(flavor = "multi_thread")]
async fn test_zero_arc_get_links() {
    holochain_trace::test_run();

    // Standard config with arc clamped to zero
    let mut tuning = make_tuning(true, true, true, None);
    tuning.gossip_arc_clamping = "empty".into();
    let config = SweetConductorConfig::standard().set_tuning_params(tuning);

    let mut conductor0 = SweetConductor::from_config(config).await;
    let mut conductor1 = SweetConductor::from_standard_config().await;

    let tw = holochain_wasm_test_utils::TestWasm::Link;
    let (dna_file, _, _) = SweetDnaFile::unique_from_test_wasms(vec![tw]).await;
    let app0 = conductor0.setup_app("app", [&dna_file]).await.unwrap();
    let _ = conductor1.setup_app("app", [&dna_file]).await.unwrap();
    let (cell0,) = app0.into_tuple();

    // conductors.exchange_peer_info().await;

    let zome0 = cell0.zome(tw);
    let _hash0: ActionHash = conductor0.call(&zome0, "create_link", ()).await;

    let links: Vec<Link> = conductor0.call(&zome0, "get_links", ()).await;
    assert_eq!(links.len(), 1);
}

/// Test that conductors with arcs clamped to zero do not gossip.
#[cfg(feature = "slow_tests")]
#[tokio::test(flavor = "multi_thread")]
#[cfg_attr(target_os = "macos", ignore = "flaky")]
async fn test_zero_arc_no_gossip_2way() {
    holochain_trace::test_run();

    // Standard config

    let config_0: SweetConductorConfig = TestConfig {
        publish: true,
        recent: true,
        historical: true,
        bootstrap: false,
        recent_threshold: None,
    }
    .into();

    // Standard config with arc clamped to zero and publishing off
    // This should result in no publishing or gossip
    let mut tuning_1 = make_tuning(false, true, true, None);
    tuning_1.gossip_arc_clamping = "empty".into();
    let config_0 = config_0.no_dpki_mustfix();
    let config_1 = SweetConductorConfig::rendezvous(false)
        // Zero-arc nodes can't use DPKI in this test,
        // since they can't learn about other peers' keys,
        // since publishing was turned off.
        .no_dpki_mustfix()
        .set_tuning_params(tuning_1);

    let mut conductors = SweetConductorBatch::from_configs_rendezvous([config_0, config_1]).await;

    let (dna_file, _, _) = SweetDnaFile::unique_from_inline_zomes(simple_crud_zome()).await;
    let apps = conductors.setup_app("app", [&dna_file]).await.unwrap();
    let ((cell_0,), (cell_1,)) = apps.into_tuples();

    conductors.exchange_peer_info().await;

    let zome_0 = cell_0.zome(SweetInlineZomes::COORDINATOR);
    let hash_0: ActionHash = conductors[0]
        .call(&zome_0, "create_string", "hi".to_string())
        .await;

    let zome_1 = cell_1.zome(SweetInlineZomes::COORDINATOR);
    let hash_1: ActionHash = conductors[1]
        .call(&zome_1, "create_string", "hi".to_string())
        .await;

    // can't await consistency because one node is neither publishing nor gossiping, and is relying only on `get`

    let record_01: Option<Record> = conductors[0].call(&zome_0, "read", hash_1.clone()).await;
    let record_10: Option<Record> = conductors[1].call(&zome_1, "read", hash_0.clone()).await;

    // 1 is not a valid target for the get, and 0 did not publish, so 0 can't get 1's data.
    assert!(record_01.is_none());

    // 1 can get 0's data, though.
    assert!(record_10.is_some());
}

/// Test that conductors with arcs clamped to zero do not gossip.
#[cfg(feature = "slow_tests")]
#[tokio::test(flavor = "multi_thread")]
async fn test_zero_arc_no_gossip_4way() {
    use futures::future::join_all;
    use maplit::hashset;

    holochain_trace::test_run();

    // XXX: We disable DPKI for this test just because it's so slow for 4 conductors.

    let configs = [
        // Standard config
        <TestConfig as Into<SweetConductorConfig>>::into(TestConfig {
            publish: true,
            recent: true,
            historical: true,
            bootstrap: false,
            recent_threshold: None,
        })
        .no_dpki()
        .tune_conductor(|params| {
            // Speed up sys validation retry when gets hit a conductor that isn't yet serving the requested data
            params.sys_validation_retry_delay = Some(std::time::Duration::from_millis(100));
        }),
        // Publishing turned off
        <TestConfig as Into<SweetConductorConfig>>::into(TestConfig {
            publish: false,
            recent: true,
            historical: true,
            bootstrap: false,
            recent_threshold: None,
        })
        .no_dpki()
        .tune_conductor(|params| {
            // Speed up sys validation retry when gets hit a conductor that isn't yet serving the requested data
            params.sys_validation_retry_delay = Some(std::time::Duration::from_millis(100));
        }),
        {
            // Standard config with arc clamped to zero
            let mut tuning = make_tuning(true, true, true, None);
            tuning.gossip_arc_clamping = "empty".into();
            SweetConductorConfig::rendezvous(true)
                .tune_conductor(|params| {
                    // Speed up sys validation retry when gets hit a conductor that isn't yet serving the requested data
                    params.sys_validation_retry_delay = Some(std::time::Duration::from_millis(100));
                })
                .set_tuning_params(tuning)
                .no_dpki()
        },
        {
            // Publishing turned off, arc clamped to zero
            let mut tuning = make_tuning(false, true, true, None);
            tuning.gossip_arc_clamping = "empty".into();
            SweetConductorConfig::rendezvous(true)
                .tune_conductor(|params| {
                    // Speed up sys validation retry when gets hit a conductor that isn't yet serving the requested data
                    params.sys_validation_retry_delay = Some(std::time::Duration::from_millis(100));
                })
                .set_tuning_params(tuning)
                .no_dpki()
        },
    ];

    let mut conductors = SweetConductorBatch::from_configs_rendezvous(configs).await;

    let (dna_file, _, _) = SweetDnaFile::unique_from_inline_zomes(simple_crud_zome()).await;
    let dna_hash = dna_file.dna_hash().clone();

    let apps = conductors.setup_app("app", [&dna_file]).await.unwrap();
    let cells = apps.cells_flattened();
    let zomes: Vec<_> = cells
        .iter()
        .map(|c| c.zome(SweetInlineZomes::COORDINATOR))
        .collect();

    // Ensure that each node has one agent in its peer store, for the single app installed.
    for (i, cell) in cells.iter().enumerate() {
        let stored_agents: HashSet<_> = holochain::conductor::p2p_agent_store::all_agent_infos(
            conductors[i]
                .get_spaces()
                .p2p_agents_db(&dna_hash)
                .unwrap()
                .into(),
        )
        .await
        .unwrap()
        .into_iter()
        .map(|i| AgentPubKey::from_kitsune(&i.agent()))
        .collect();

        let expected = hashset![
            // conductors[i].dpki_cell().unwrap().agent_pubkey().clone(),
            cell.agent_pubkey().clone()
        ];

        assert_eq!(stored_agents, expected,);
    }

    conductors.exchange_peer_info().await;

    // Ensure that each node has all agents in their local p2p store.
    for c in conductors.iter() {
        let stored_agents = holochain::conductor::p2p_agent_store::all_agent_infos(
            c.get_spaces().p2p_agents_db(&dna_hash).unwrap().into(),
        )
        .await
        .unwrap()
        .len();
        assert_eq!(stored_agents, conductors.len());
    }

    // Have each conductor create an entry
    let hashes: Vec<ActionHash> = join_all(
        conductors
            .iter()
            .enumerate()
            .map(|(i, c)| c.call(&zomes[i], "create_string", format!("{}", i))),
    )
    .await;

    // Have each conductor attempt to get every other conductor's entry,
    // retrying for a certain amount of time until the entry could be successfully retrieved,
    // then testing for success.
    //
    // Nobody should be able to get conductor 3's entry, because it is not publishing
    // and not gossiping due to zero arc.
    let _: Vec<()> = join_all(conductors.iter().enumerate().flat_map(|(i, c)| {
        hashes
            .iter()
            .enumerate()
            .map(|(j, hash)| {
                let zome = zomes[i].clone();
                async move {
                    let assertion = |x: bool| {
                        if j == 3 && i != j {
                            assert!(!x, "Node 3's data should not be accessible by anyone but itself. i={}, j={}", i, j);
                        } else {
                            assert!(x, "All nodes should be able to get all data except for node 3's. i={}, j={}", i, j);
                        }
                    };
                    holochain::wait_for!(
                        WaitFor::new(std::time::Duration::from_secs(5), 10),
                        c.call::<_, Option<Record>>(&zome, "read", hash.clone())
                            .await
                            .is_some(),
                        |x: &bool| {
                            if j == 3 && i != j {
                                !x
                            } else {
                                *x
                            }
                        },
                        assertion
                    );
                }
            })
            .collect::<Vec<_>>()
    }))
    .await;
}

/// Test that when the conductor shuts down, gossip does not continue,
/// and when it restarts, gossip resumes.
#[cfg(feature = "slow_tests")]
#[tokio::test(flavor = "multi_thread")]
#[ignore = "deal with connections closing and banning for 10s"]
async fn test_gossip_shutdown() {
    holochain_trace::test_run();
    let mut conductors = SweetConductorBatch::from_config_rendezvous(
        2,
        TestConfig {
            publish: false,
            recent: true,
            historical: true,
            bootstrap: false,
            recent_threshold: None,
        },
    )
    .await;

    let (dna_file, _, _) = SweetDnaFile::unique_from_inline_zomes(simple_crud_zome()).await;

    let apps = conductors.setup_app("app", [&dna_file]).await.unwrap();
    let ((cell_0,), (cell_1,)) = apps.into_tuples();
    let zome_0 = cell_0.zome(SweetInlineZomes::COORDINATOR);
    let zome_1 = cell_1.zome(SweetInlineZomes::COORDINATOR);

    // Create an entry before the conductors know about each other
    let hash: ActionHash = conductors[0]
        .call(&zome_0, "create_string", "hi".to_string())
        .await;

    // After shutting down conductor 0, test that gossip doesn't happen within 3 seconds
    // of peer discovery (assuming it will never happen)
    conductors[0].shutdown().await;
    conductors.exchange_peer_info().await;
    tokio::time::sleep(std::time::Duration::from_secs(3)).await;

    let record: Option<Record> = conductors[1].call(&zome_1, "read", hash.clone()).await;
    assert!(record.is_none());

    // Ensure that gossip loops resume upon startup
    conductors[0].startup().await;

    await_consistency(60, [&cell_0, &cell_1]).await.unwrap();
    let record: Option<Record> = conductors[1].call(&zome_1, "read", hash.clone()).await;
    assert_eq!(record.unwrap().action_address(), &hash);
}

/// Test that when a new conductor joins, gossip picks up existing data without needing a publish.
#[cfg(feature = "slow_tests")]
#[tokio::test(flavor = "multi_thread")]
#[ignore = "This test is potentially useful but uses sleeps and has never failed.
            Run it again in the future to see if it fails, and if so, rewrite it without sleeps."]
async fn test_gossip_startup() {
    holochain_trace::test_run();
    let config = || async move {
        SweetConductorConfig::standard().tune(|t| {
            t.danger_gossip_recent_threshold_secs = 1;
            t.default_rpc_single_timeout_ms = 3_000;
        })
    };

    let (dna_file, _, _) = SweetDnaFile::unique_from_inline_zomes(simple_crud_zome()).await;
    let mk_conductor = || async {
        let cfg = config().await;
        assert!(cfg.network.is_tx5());
        let mut conductor =
            SweetConductor::from_config_rendezvous(cfg, SweetLocalRendezvous::new().await).await;
        // let mut conductor = SweetConductor::from_config(config()).await;
        let app = conductor.setup_app("app", [&dna_file]).await.unwrap();
        let cell = app.into_cells().pop().unwrap();
        let zome = cell.zome(SweetInlineZomes::COORDINATOR);
        (conductor, cell, zome)
    };
    let (conductor0, cell0, zome0) = mk_conductor().await;

    // Create an entry before the conductors know about each other
    let hash: ActionHash = conductor0
        .call(&zome0, "create_string", "hi".to_string())
        .await;

    // Startup and do peer discovery
    tokio::time::sleep(std::time::Duration::from_secs(5)).await;
    let (conductor1, cell1, zome1) = mk_conductor().await;

    // Wait a bit so that conductor 0 doesn't publish in the next step.
    tokio::time::sleep(std::time::Duration::from_secs(5)).await;

    await_consistency(60, [&cell0, &cell1]).await.unwrap();
    let record: Option<Record> = conductor1.call(&zome1, "read", hash.clone()).await;
    assert_eq!(record.unwrap().action_address(), &hash);
}

#[cfg(feature = "slow_tests")]
#[tokio::test(flavor = "multi_thread")]
#[cfg_attr(target_os = "macos", ignore = "flaky")]
#[cfg_attr(target_os = "windows", ignore = "flaky")]
async fn three_way_gossip_recent() {
    holochain_trace::test_run();

    let config = TestConfig {
        publish: false,
        recent: true,
        historical: false,
        // NOTE: disable bootstrap so we can selectively ignore the shut-down conductor
        bootstrap: false,
        recent_threshold: None,
    };
    three_way_gossip(config.into()).await;
}

#[cfg(feature = "slow_tests")]
#[tokio::test(flavor = "multi_thread")]
#[cfg_attr(target_os = "macos", ignore = "flaky")]
#[cfg_attr(target_os = "windows", ignore = "flaky")]
async fn three_way_gossip_historical() {
    holochain_trace::test_run();

    let config = TestConfig {
        publish: false,
        recent: false,
        historical: true,
        // NOTE: disable bootstrap so we can selectively ignore the shut-down conductor
        bootstrap: false,
        recent_threshold: Some(0),
    };
    three_way_gossip(config.into()).await;
}

/// Test that:
/// - 6MB of data passes from node A to B,
/// - then A shuts down and C starts up,
/// - and then that same data passes from B to C.
async fn three_way_gossip(config: holochain::sweettest::SweetConductorConfig) {
    // TODO: this fails miserably with DPKI enabled. Why?
    let config = config.no_dpki_mustfix();

    let mut conductors = SweetConductorBatch::from_config_rendezvous(2, config.clone()).await;
    let start = Instant::now();

    let (dna_file, _, _) = SweetDnaFile::unique_from_inline_zomes(simple_crud_zome()).await;

    let cells = conductors
        .setup_app("app", [&dna_file])
        .await
        .unwrap()
        .cells_flattened();

    conductors.exchange_peer_info().await;

    println!(
        "Initial agents: {:#?}",
        cells
            .iter()
            .map(|c| c.agent_pubkey().to_kitsune())
            .collect::<Vec<_>>()
    );

    let zomes: Vec<_> = cells
        .iter()
        .map(|c| c.zome(SweetInlineZomes::COORDINATOR))
        .collect();

    let size = 3_000_000;
    let num = 2;

    let mut hashes = vec![];
    for i in 0..num {
        let bytes = vec![42u8 + i as u8; size];
        let hash: ActionHash = conductors[0].call(&zomes[0], "create_bytes", bytes).await;
        hashes.push(hash);
    }

    await_consistency(10, [&cells[0], &cells[1]]).await.unwrap();

    println!(
        "Done waiting for consistency between first two nodes. Elapsed: {:?}",
        start.elapsed()
    );

    let records_0: Vec<Option<Record>> = conductors[0]
        .call(&zomes[0], "read_multi", hashes.clone())
        .await;
    let records_1: Vec<Option<Record>> = conductors[1]
        .call(&zomes[1], "read_multi", hashes.clone())
        .await;
    assert_eq!(
        records_1.iter().filter(|r| r.is_some()).count(),
        num,
        "couldn't get records at positions: {:?}",
        records_1
            .iter()
            .enumerate()
            .filter_map(|(i, r)| r.is_none().then_some(i))
            .collect::<Vec<_>>()
    );
    assert_eq!(records_0, records_1);

    // Forget the first node's peer info before it gets gossiped to the third node.
    // NOTE: this simulates "leave network", which we haven't yet implemented. The test will work without this,
    // but there is a high chance of a 60 second timeout which flakily slows down this test beyond any acceptable duration.
    conductors.forget_peer_info([cells[0].agent_pubkey()]).await;
    conductors[0].shutdown().await;

    // Bring a third conductor online
    conductors.add_conductor_from_config(config).await;

    // conductors.persist_dbs();

    let (cell,) = conductors[2]
        .setup_app("app", [&dna_file])
        .await
        .unwrap()
        .into_tuple();
    let zome = cell.zome(SweetInlineZomes::COORDINATOR);
    SweetConductor::exchange_peer_info([&conductors[1], &conductors[2]]).await;

    println!(
        "Newcomer agent joined: agent={:#?}",
        cell.agent_pubkey().to_kitsune()
    );

    conductors[2]
        .require_initial_gossip_activity_for_cell(&cell, 2, Duration::from_secs(60))
        .await
        .unwrap();

    println!(
        "Initial gossip activity completed. Elapsed: {:?}",
        start.elapsed()
    );

    await_consistency_advanced(
        10,
        (),
        [(&cells[0], false), (&cells[1], true), (&cell, true)],
    )
    .await
    .unwrap();

    println!(
        "Done waiting for consistency between last two nodes. Elapsed: {:?}",
        start.elapsed()
    );

    let records_2: Vec<Option<Record>> = conductors[2].call(&zome, "read_multi", hashes).await;
    assert_eq!(
        records_2.iter().filter(|r| r.is_some()).count(),
        num,
        "couldn't get records at positions: {:?}",
        records_2
            .iter()
            .enumerate()
            .filter_map(|(i, r)| r.is_none().then_some(i))
            .collect::<Vec<_>>()
    );
    assert_eq!(records_2, records_1);
}

#[cfg(feature = "test_utils")]
#[tokio::test(flavor = "multi_thread")]
async fn fullsync_sharded_local_gossip() -> anyhow::Result<()> {
    use holochain::{sweettest::SweetConductor, test_utils::inline_zomes::simple_create_read_zome};

    holochain_trace::test_run();

    let mut conductor = SweetConductor::from_config_rendezvous(
        TestConfig {
            publish: false,
            recent: true,
            historical: true,
            bootstrap: true,
            recent_threshold: None,
        },
        SweetLocalRendezvous::new().await,
    )
    .await;

    let (dna_file, _, _) =
        SweetDnaFile::unique_from_inline_zomes(("simple", simple_create_read_zome())).await;

    let alice = conductor.setup_app("app", [&dna_file]).await.unwrap();

    let (alice,) = alice.into_tuple();
    let bobbo = conductor.setup_app("app2", [&dna_file]).await.unwrap();

    let (bobbo,) = bobbo.into_tuple();

    // Call the "create" zome fn on Alice's app
    let hash: ActionHash = conductor.call(&alice.zome("simple"), "create", ()).await;

    // Wait long enough for Bob to receive gossip
    await_consistency(10, [&alice, &bobbo]).await.unwrap();

    // Verify that bobbo can run "read" on his cell and get alice's Action
    let record: Option<Record> = conductor.call(&bobbo.zome("simple"), "read", hash).await;
    let record = record.expect("Record was None: bobbo couldn't `get` it");

    // Assert that the Record bobbo sees matches what alice committed
    assert_eq!(record.action().author(), alice.agent_pubkey());
    assert_eq!(
        *record.entry(),
        RecordEntry::Present(Entry::app(().try_into().unwrap()).unwrap())
    );

    Ok(())
}



================================================
File: crates/holochain/tests/tests/signals/mod.rs
================================================
//! Tests for local and remote signals using rendezvous config
//!

use hdk::prelude::ExternIO;
use holochain::sweettest::*;
use holochain_types::prelude::*;
use holochain_wasm_test_utils::TestWasm;
use serde::{Deserialize, Serialize};
use std::time::Duration;

#[derive(Serialize, Deserialize, Debug)]
struct SignalMessage {
    value: String,
}

fn to_signal_message(signal: Signal) -> SignalMessage {
    match signal {
        Signal::App { signal, .. } => signal.into_inner().decode().unwrap(),
        _ => {
            panic!("Only expected app signals");
        }
    }
}

#[tokio::test(flavor = "multi_thread")]
#[cfg_attr(target_os = "windows", ignore = "flaky")]
async fn remote_signals_work_after_sbd_restart() {
    holochain_trace::test_run();

    const MAX: u64 = 30;

    let vous = SweetLocalRendezvous::new_raw().await;

    let vous_dyn: DynSweetRendezvous = vous.clone();
    let mut c1 = SweetConductor::from_config_rendezvous(
        SweetConductorConfig::rendezvous(true),
        vous_dyn.clone(),
    )
    .await;

    let mut c2 = SweetConductor::from_config_rendezvous(
        SweetConductorConfig::rendezvous(true),
        vous_dyn.clone(),
    )
    .await;

    let dna_file = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::EmitSignal])
        .await
        .0;

    let (app1,) = c1
        .setup_app("app", &[dna_file.clone()])
        .await
        .unwrap()
        .into_tuple();
    let (app2,) = c2.setup_app("app", &[dna_file]).await.unwrap().into_tuple();
    let a2 = app2.agent_pubkey().clone();

    let mut c2_rx = c2.subscribe_to_app_signals("app".to_string());

    let _: () = c1
        .call(
            &app1.zome(TestWasm::EmitSignal),
            "signal_others",
            RemoteSignal {
                agents: vec![a2.clone()],
                signal: ExternIO::encode(SignalMessage {
                    value: "hello".to_string(),
                })
                .unwrap(),
            },
        )
        .await;

    let msg = tokio::time::timeout(std::time::Duration::from_secs(MAX), c2_rx.recv())
        .await
        .unwrap()
        .map(to_signal_message)
        .unwrap()
        .value;

    assert_eq!("hello", &msg);

    // restart the signal (sbd) server so we get new ids
    vous.start_sig().await;

    // wait for that to propagate in holochain
    tokio::time::sleep(std::time::Duration::from_secs(2)).await;

    let done1 = std::sync::Arc::new(std::sync::atomic::AtomicBool::new(false));
    let done2 = done1.clone();

    tokio::join!(
        async {
            let msg = tokio::time::timeout(std::time::Duration::from_secs(MAX), c2_rx.recv())
                .await
                .unwrap()
                .map(to_signal_message)
                .unwrap()
                .value;

            assert_eq!("world", &msg);

            done1.store(true, std::sync::atomic::Ordering::SeqCst);
        },
        async {
            for _ in 0..MAX {
                let _: () = c1
                    .call(
                        &app1.zome(TestWasm::EmitSignal),
                        "signal_others",
                        RemoteSignal {
                            agents: vec![a2.clone()],
                            signal: ExternIO::encode(SignalMessage {
                                value: "world".to_string(),
                            })
                            .unwrap(),
                        },
                    )
                    .await;

                if done2.load(std::sync::atomic::Ordering::SeqCst) {
                    break;
                }

                tokio::time::sleep(std::time::Duration::from_secs(1)).await;
            }
        },
    );
}

#[tokio::test(flavor = "multi_thread")]
#[cfg(feature = "slow_tests")]
#[ignore = "flaky"]
async fn remote_signals_batch() -> anyhow::Result<()> {
    holochain_trace::test_run();

    let mut conductors =
        SweetConductorBatch::from_config_rendezvous(3, SweetConductorConfig::rendezvous(true))
            .await;

    let dna_file = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::EmitSignal])
        .await
        .0;

    let app_batch = conductors.setup_app("app", &[dna_file]).await.unwrap();

    let ((alice,), (bob,), (carol,)): ((SweetCell,), (SweetCell,), (SweetCell,)) =
        app_batch.into_tuples();

    // Make sure the conductors are talking to each other before sending signals.
    conductors[1]
        .require_initial_gossip_activity_for_cell(&bob, 3, Duration::from_secs(90))
        .await
        .unwrap();

    // Listen for signals on Bob's and Carol's conductors.
    // These are all the signals on that conductor but the only app installed
    // is the one for this test.
    let mut conductor_1_signal_rx = conductors[1].subscribe_to_app_signals("app".to_string());
    let mut conductor_2_signal_rx = conductors[2].subscribe_to_app_signals("app".to_string());

    // Call `signal_others` multiple times as Alice to send signals to Bob.
    for i in 0..6 {
        let _: () = conductors[0]
            .call(
                &alice.zome(TestWasm::EmitSignal),
                "signal_others",
                RemoteSignal {
                    agents: vec![bob.agent_pubkey().clone(), carol.agent_pubkey().clone()],
                    signal: ExternIO::encode(SignalMessage {
                        value: format!("message {}", i),
                    })
                    .unwrap(),
                },
            )
            .await;
    }

    // Check that Bob and Carol receive all the signals.
    tokio::time::timeout(Duration::from_secs(60), async move {
        for i in 0..6 {
            let msg_1 = conductor_1_signal_rx
                .recv()
                .await
                .map(to_signal_message)
                .unwrap()
                .value;
            let msg_2 = conductor_2_signal_rx
                .recv()
                .await
                .map(to_signal_message)
                .unwrap()
                .value;

            assert_eq!(msg_1, format!("message {}", i));
            assert_eq!(msg_1, msg_2);
        }
    })
    .await
    .unwrap();

    Ok(())
}



================================================
File: crates/holochain/tests/tests/test_cli/mod.rs
================================================
#![cfg(test)]

use assert_cmd::prelude::*;
use predicates::prelude::*;
use std::process::Command;

#[test]
fn first_experience_with_holochain_is_a_friendly_one() {
    let tmp = tempfile::tempdir().unwrap();
    let path = tmp.path().join("missing-config.yml");
    let mut cmd = Command::cargo_bin("holochain").unwrap();
    let cmd = cmd.args(["-c", &path.display().to_string()]);
    cmd.assert().failure().code(predicate::eq(42));
    cmd.assert()
        .append_context("reason", "output doesn't contain the word \"please\"")
        .stdout(predicate::str::is_match("[Pp]lease").unwrap());
}

#[test]
fn malformed_toml_error_is_friendly() {
    let tmp = tempfile::tempdir().unwrap();
    let path = tmp.path().join("malformed-config.yml");
    std::fs::write(&path, "{{ totally [ not ( valid yaml").unwrap();
    let mut cmd = Command::cargo_bin("holochain").unwrap();
    let cmd = cmd.args(["-c", &path.display().to_string()]);
    cmd.assert().failure().code(predicate::eq(42));
    cmd.assert()
        .append_context("reason", "output doesn't contain the word \"please\"")
        .stdout(predicate::str::is_match("[Pp]lease").unwrap());
    cmd.assert()
        .append_context("reason", "output contains the wrong reason for error")
        .stdout(predicate::str::contains("invalid type"));
}

#[test]
fn invalid_config_error_is_friendly() {
    let tmp = tempfile::tempdir().unwrap();
    let path = tmp.path().join("malformed-config.yml");
    std::fs::write(&path, "valid:\n  but: wrong").unwrap();
    let mut cmd = Command::cargo_bin("holochain").unwrap();
    let cmd = cmd.args(["-c", &path.display().to_string()]);
    cmd.assert().failure().code(predicate::eq(42));
    cmd.assert()
        .append_context("reason", "output doesn't contain the word \"please\"")
        .stdout(predicate::str::is_match("[Pp]lease").unwrap());
    cmd.assert()
        .append_context("reason", "output contains the wrong reason for error")
        .stdout(predicate::str::is_match("[Mm]issing field").unwrap());
}



================================================
File: crates/holochain/tests/tests/test_utils/mod.rs
================================================
#![allow(dead_code)]

use ::fixt::*;
use anyhow::Result;
use ed25519_dalek::{Signer, SigningKey};
use holochain::conductor::ConductorHandle;
use holochain_conductor_api::conductor::paths::DataRootPath;
use holochain_conductor_api::conductor::DpkiConfig;
use holochain_conductor_api::FullStateDump;
use holochain_websocket::WebsocketSender;
use holochain_websocket::{WebsocketReceiver, WebsocketResult};

pub async fn admin_port(conductor: &ConductorHandle) -> u16 {
    conductor
        .get_arbitrary_admin_websocket_port()
        .expect("No admin port open on conductor")
}

pub async fn websocket_client(
    conductor: &ConductorHandle,
) -> Result<(WebsocketSender, WebsocketReceiver)> {
    let port = admin_port(conductor).await;
    Ok(websocket_client_by_port(port).await?)
}

pub use holochain::sweettest::websocket_client_by_port;

use assert_cmd::prelude::*;
use futures::Future;
use holochain_conductor_api::conductor::ConductorConfig;
use holochain_conductor_api::conductor::KeystoreConfig;
use holochain_conductor_api::AdminInterfaceConfig;
use holochain_conductor_api::InterfaceDriver;
use kitsune_p2p_types::config::KitsuneP2pConfig;
use matches::assert_matches;
use serde::Serialize;
use std::time::Duration;
use std::{path::PathBuf, process::Stdio};
use tokio::io::AsyncBufReadExt;
use tokio::io::AsyncWriteExt;
use tokio::io::BufReader;
use tokio::process::Child;
use tokio::process::Command;

use hdk::prelude::*;
use holochain::{
    conductor::api::ZomeCallParamsSigned,
    conductor::api::{AdminRequest, AdminResponse, AppRequest},
};
use holochain_conductor_api::AppResponse;
use holochain_types::prelude::*;
use holochain_types::websocket::AllowedOrigins;
use holochain_util::tokio_helper;

/// Wrapper that synchronously waits for the Child to terminate on drop.
pub struct SupervisedChild(String, Child);

impl Drop for SupervisedChild {
    fn drop(&mut self) {
        tokio_helper::block_forever_on(async move {
            self.1
                .kill()
                .await
                .unwrap_or_else(|_| panic!("Failed to kill {}", self.0));
        });
    }
}

pub async fn start_local_services() -> (
    SupervisedChild,
    tokio::sync::oneshot::Receiver<String>,
    tokio::sync::oneshot::Receiver<String>,
) {
    tracing::info!("\n----\nstarting local bootstrap server\n----\n");
    let cmd = std::process::Command::cargo_bin("hc-run-local-services").unwrap();
    let mut cmd = Command::from(cmd);
    cmd.stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .kill_on_drop(true);
    let mut child = cmd.spawn().expect("Failed to spawn local services");
    let (tx_bootstrap, rx_bootstrap) = tokio::sync::oneshot::channel();
    let (tx_signal, rx_signal) = tokio::sync::oneshot::channel();
    let stdout = child.stdout.take().unwrap();
    let mut tx_bootstrap = Some(tx_bootstrap);
    let mut tx_signal = Some(tx_signal);
    tokio::spawn(async move {
        let mut reader = BufReader::new(stdout).lines();
        while let Ok(Some(line)) = reader.next_line().await {
            println!("hc local services stdout: {line}");
            if let Some(addr) = line.strip_prefix("# HC BOOTSTRAP - ADDR: ") {
                if let Some(sender) = tx_bootstrap.take() {
                    let _ = sender.send(addr.to_string());
                }
            }
            if let Some(addr) = line.strip_prefix("# HC SIGNAL - ADDR: ") {
                if let Some(sender) = tx_signal.take() {
                    let _ = sender.send(addr.to_string());
                }
            }
        }
    });
    let stderr = child.stderr.take().unwrap();
    tokio::task::spawn(async move {
        let mut reader = BufReader::new(stderr).lines();
        while let Ok(Some(line)) = reader.next_line().await {
            eprintln!("hc local services stderr: {line}");
        }
    });
    (
        SupervisedChild("Local Holochain Services".to_string(), child),
        rx_bootstrap,
        rx_signal,
    )
}

pub async fn start_holochain(
    config_path: PathBuf,
) -> (SupervisedChild, tokio::sync::oneshot::Receiver<u16>) {
    start_holochain_with_lair(config_path, false).await
}

pub async fn start_holochain_with_lair(
    config_path: PathBuf,
    full_keystore: bool,
) -> (SupervisedChild, tokio::sync::oneshot::Receiver<u16>) {
    tracing::info!("\n\n----\nstarting holochain\n----\n\n");
    let cmd = std::process::Command::cargo_bin("holochain").unwrap();
    let mut cmd = Command::from(cmd);
    let rust_log = std::env::var("RUST_LOG").unwrap_or_else(|_| "warn".to_string());
    cmd.arg("--config-path")
        .arg(config_path)
        .env("RUST_LOG", rust_log)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .kill_on_drop(true);
    if full_keystore {
        cmd.arg("--piped").stdin(Stdio::piped());
    }
    let mut child = cmd.spawn().expect("Failed to spawn holochain");
    if full_keystore {
        // Pass in lair keystore password.
        let mut stdin = child.stdin.take().unwrap();
        stdin.write_all("pass".as_bytes()).await.unwrap();
        stdin.flush().await.unwrap();
    }
    // Wait for admin port output.
    let admin_port = spawn_output(&mut child);
    check_started(&mut child).await;
    (SupervisedChild("Holochain".to_string(), child), admin_port)
}

pub async fn grant_zome_call_capability(
    admin_tx: &mut WebsocketSender,
    cell_id: &CellId,
    zome_name: ZomeName,
    fn_name: FunctionName,
    signing_key: AgentPubKey,
) -> WebsocketResult<CapSecret> {
    let mut fns = BTreeSet::new();
    fns.insert((zome_name, fn_name));
    let functions = GrantedFunctions::Listed(fns);

    let mut assignees = BTreeSet::new();
    assignees.insert(signing_key.clone());

    let cap_secret = fixt!(CapSecret);

    let request = AdminRequest::GrantZomeCallCapability(Box::new(GrantZomeCallCapabilityPayload {
        cell_id: cell_id.clone(),
        cap_grant: ZomeCallCapGrant {
            tag: "".into(),
            access: CapAccess::Assigned {
                secret: cap_secret,
                assignees,
            },
            functions,
        },
    }));
    let response = admin_tx.request(request);
    let response = check_timeout(response, 3000).await?;
    assert_matches!(response, AdminResponse::ZomeCallCapabilityGranted);
    Ok(cap_secret)
}

pub async fn call_zome_fn_fallible<I>(
    app_tx: &WebsocketSender,
    cell_id: CellId,
    signing_keypair: &SigningKey,
    cap_secret: CapSecret,
    zome_name: ZomeName,
    fn_name: FunctionName,
    input: &I,
) -> AppResponse
where
    I: Serialize + std::fmt::Debug,
{
    let (nonce, expires_at) = holochain_nonce::fresh_nonce(Timestamp::now()).unwrap();
    let signing_key = AgentPubKey::from_raw_32(signing_keypair.verifying_key().as_bytes().to_vec());
    let zome_call_params = ZomeCallParams {
        cap_secret: Some(cap_secret),
        cell_id: cell_id.clone(),
        zome_name: zome_name.clone(),
        fn_name: fn_name.clone(),
        provenance: signing_key,
        payload: ExternIO::encode(input).unwrap(),
        nonce,
        expires_at,
    };
    let (bytes, bytes_hash) = zome_call_params.serialize_and_hash().unwrap();
    let signature = signing_keypair.sign(&bytes_hash);
    let request = AppRequest::CallZome(Box::new(ZomeCallParamsSigned::new(
        bytes,
        Signature::from(signature.to_bytes()),
    )));
    let response = app_tx.request(request);
    check_timeout(response, 6000).await.unwrap()
}

pub async fn call_zome_fn<I>(
    app_tx: &WebsocketSender,
    cell_id: CellId,
    signing_keypair: &SigningKey,
    cap_secret: CapSecret,
