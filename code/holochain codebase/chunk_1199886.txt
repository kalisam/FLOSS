                            },
                        }
                    }
                    EntryType::CapClaim => OpUpdate::CapClaim {
                        original_action_hash: original_action_hash.clone(),
                        action: update.hashed.content.clone(),
                    },
                    EntryType::CapGrant => OpUpdate::CapGrant {
                        original_action_hash: original_action_hash.clone(),
                        action: update.hashed.content.clone(),
                    },
                };
                Ok(FlatOp::RegisterUpdate(update))
            }
            Op::RegisterAgentActivity(RegisterAgentActivity { action, .. }) => {
                let r = match &action.hashed.content {
                    Action::Dna(action) => {
                        let Dna { hash, .. } = action;
                        OpActivity::Dna {
                            dna_hash: hash.clone(),
                            action: action.clone(),
                        }
                    }
                    Action::AgentValidationPkg(action) => {
                        let AgentValidationPkg { membrane_proof, .. } = action;
                        OpActivity::AgentValidationPkg {
                            membrane_proof: membrane_proof.clone(),
                            action: action.clone(),
                        }
                    }
                    Action::InitZomesComplete(action) => OpActivity::InitZomesComplete {
                        action: action.clone(),
                    },
                    Action::OpenChain(action) => {
                        let OpenChain {
                            prev_target,
                            close_hash,
                            ..
                        } = action;
                        OpActivity::OpenChain {
                            previous_target: prev_target.clone(),
                            close_hash: close_hash.clone(),
                            action: action.clone(),
                        }
                    }
                    Action::CloseChain(action) => {
                        let CloseChain { new_target, .. } = action;
                        OpActivity::CloseChain {
                            new_target: new_target.clone(),
                            action: action.clone(),
                        }
                    }
                    Action::CreateLink(action) => {
                        let CreateLink {
                            base_address,
                            target_address,
                            zome_index,
                            link_type,
                            tag,
                            ..
                        } = action;
                        let link_type = activity_link_type(*zome_index, *link_type)?;
                        OpActivity::CreateLink {
                            base_address: base_address.clone(),
                            target_address: target_address.clone(),
                            tag: tag.clone(),
                            link_type,
                            action: action.clone(),
                        }
                    }
                    Action::DeleteLink(action) => {
                        let DeleteLink {
                            link_add_address,
                            base_address,
                            ..
                        } = action;
                        OpActivity::DeleteLink {
                            original_action_hash: link_add_address.clone(),
                            base_address: base_address.clone(),
                            action: action.clone(),
                        }
                    }
                    Action::Create(action) => {
                        let Create {
                            entry_type,
                            entry_hash,
                            ..
                        } = action;
                        match activity_entry::<ET>(entry_type, entry_hash)? {
                            ActivityEntry::App { entry_type, .. } => OpActivity::CreateEntry {
                                app_entry_type: entry_type,
                                action: action.clone(),
                            },
                            ActivityEntry::PrivateApp { entry_type, .. } => {
                                OpActivity::CreatePrivateEntry {
                                    app_entry_type: entry_type,
                                    action: action.clone(),
                                }
                            }
                            ActivityEntry::Agent(agent) => OpActivity::CreateAgent {
                                agent,
                                action: action.clone(),
                            },
                            ActivityEntry::CapClaim(_hash) => OpActivity::CreateCapClaim {
                                action: action.clone(),
                            },
                            ActivityEntry::CapGrant(_hash) => OpActivity::CreateCapGrant {
                                action: action.clone(),
                            },
                        }
                    }
                    Action::Update(action) => {
                        let Update {
                            original_action_address,
                            original_entry_address,
                            entry_type,
                            entry_hash,
                            ..
                        } = action;
                        match activity_entry::<ET>(entry_type, entry_hash)? {
                            ActivityEntry::App { entry_type, .. } => OpActivity::UpdateEntry {
                                original_action_hash: original_action_address.clone(),
                                original_entry_hash: original_entry_address.clone(),
                                app_entry_type: entry_type,
                                action: action.clone(),
                            },
                            ActivityEntry::PrivateApp { entry_type, .. } => {
                                OpActivity::UpdatePrivateEntry {
                                    original_action_hash: original_action_address.clone(),
                                    original_entry_hash: original_entry_address.clone(),
                                    app_entry_type: entry_type,
                                    action: action.clone(),
                                }
                            }
                            ActivityEntry::Agent(new_key) => OpActivity::UpdateAgent {
                                original_action_hash: original_action_address.clone(),
                                original_key: original_entry_address.clone().into(),
                                new_key,
                                action: action.clone(),
                            },
                            ActivityEntry::CapClaim(_entry_hash) => OpActivity::UpdateCapClaim {
                                original_action_hash: original_action_address.clone(),
                                original_entry_hash: original_entry_address.clone(),
                                action: action.clone(),
                            },
                            ActivityEntry::CapGrant(_entry_hash) => OpActivity::UpdateCapGrant {
                                original_action_hash: original_action_address.clone(),
                                original_entry_hash: original_entry_address.clone(),
                                action: action.clone(),
                            },
                        }
                    }
                    Action::Delete(action) => {
                        let Delete {
                            deletes_address,
                            deletes_entry_address,
                            ..
                        } = action;
                        OpActivity::DeleteEntry {
                            original_action_hash: deletes_address.clone(),
                            original_entry_hash: deletes_entry_address.clone(),
                            action: action.clone(),
                        }
                    }
                };
                Ok(FlatOp::RegisterAgentActivity(r))
            }
            Op::RegisterCreateLink(RegisterCreateLink { create_link }) => {
                let CreateLink {
                    base_address,
                    target_address,
                    zome_index,
                    link_type,
                    tag,
                    ..
                } = &create_link.hashed.content;
                let link_type = in_scope_link_type(*zome_index, *link_type)?;
                Ok(FlatOp::RegisterCreateLink {
                    base_address: base_address.clone(),
                    target_address: target_address.clone(),
                    tag: tag.clone(),
                    link_type,
                    action: create_link.hashed.content.clone(),
                })
            }
            Op::RegisterDeleteLink(RegisterDeleteLink {
                delete_link,
                create_link,
            }) => {
                let CreateLink {
                    base_address,
                    target_address,
                    zome_index,
                    link_type,
                    tag,
                    ..
                } = create_link;
                let link_type = in_scope_link_type(*zome_index, *link_type)?;
                Ok(FlatOp::RegisterDeleteLink {
                    original_action: create_link.clone(),
                    base_address: base_address.clone(),
                    target_address: target_address.clone(),
                    tag: tag.clone(),
                    link_type,
                    action: delete_link.hashed.content.clone(),
                })
            }
            Op::RegisterDelete(RegisterDelete { delete }) => Ok(FlatOp::RegisterDelete(OpDelete {
                action: delete.hashed.content.clone(),
            })),
        }
    }
}

/// Produces the user-defined entry type enum. Even if the entry is private, this will succeed.
/// To be used only in the context of a StoreEntry authority.
fn get_app_entry_type_for_store_entry_authority<ET>(
    entry_def: &AppEntryDef,
    entry: &Entry,
) -> Result<ET, WasmError>
where
    ET: EntryTypesHelper + UnitEnum,
    <ET as UnitEnum>::Unit: Into<ZomeEntryTypesKey>,
    WasmError: From<<ET as EntryTypesHelper>::Error>,
{
    let entry_type = <ET as EntryTypesHelper>::deserialize_from_type(
        entry_def.zome_index,
        entry_def.entry_index,
        entry,
    )?;
    match entry_type {
        Some(entry_type) => Ok(entry_type),
        None => Err(deny_other_zome()),
    }
}

/// Produces the user-defined entry type enum or the unit enum if entry is not present.
/// To be used only in the context of a StoreRecord or AgentActivity authority.
/// If the entry's availability does not match the defined visibility, an error will result.
fn get_app_entry_type_for_record_authority<ET>(
    entry_def: &AppEntryDef,
    entry: Option<&Entry>,
) -> Result<UnitEnumEither<ET>, WasmError>
where
    ET: EntryTypesHelper + UnitEnum,
    <ET as UnitEnum>::Unit: Into<ZomeEntryTypesKey>,
    WasmError: From<<ET as EntryTypesHelper>::Error>,
{
    let AppEntryDef {
        zome_index,
        entry_index: entry_def_index,
        visibility,
        ..
    } = entry_def;
    match (entry, visibility) {
        (Some(entry), EntryVisibility::Public) => {
            get_app_entry_type_for_store_entry_authority(entry_def, entry).map(UnitEnumEither::Enum)
        }

        (None, EntryVisibility::Private) => {
            match get_unit_entry_type::<ET>(*zome_index, *entry_def_index)? {
                Some(unit) => Ok(UnitEnumEither::Unit(unit)),
                None => Err(deny_other_zome()),
            }
        }

        (Some(_), EntryVisibility::Private) => Err(wasm_error!(WasmErrorInner::Guest(format!(
            "Entry visibility is private but an entry was provided! entry_def: {entry_def:?}"
        )))),

        (None, EntryVisibility::Public) => Err(wasm_error!(WasmErrorInner::Guest(format!(
            "Entry visibility is public but no entry is available. entry_def: {entry_def:?}"
        )))),
    }
}

/// Maps [`RegisterAgentActivity`] ops to their
/// entries. The entry type will be [`None`] if
/// the zome id is not a dependency of this zome.
fn activity_entry<ET>(
    entry_type: &EntryType,
    entry_hash: &EntryHash,
) -> Result<ActivityEntry<<ET as UnitEnum>::Unit>, WasmError>
where
    ET: UnitEnum,
    <ET as UnitEnum>::Unit: Into<ZomeEntryTypesKey>,
{
    match entry_type {
        EntryType::App(AppEntryDef {
            zome_index,
            entry_index: entry_def_index,
            visibility,
        }) => {
            let unit = get_unit_entry_type::<ET>(*zome_index, *entry_def_index)?;
            match visibility {
                EntryVisibility::Public => Ok(ActivityEntry::App { entry_type: unit }),
                EntryVisibility::Private => Ok(ActivityEntry::PrivateApp { entry_type: unit }),
            }
        }
        EntryType::AgentPubKey => Ok(ActivityEntry::Agent(entry_hash.clone().into())),
        EntryType::CapClaim => Ok(ActivityEntry::CapClaim(entry_hash.clone())),
        EntryType::CapGrant => Ok(ActivityEntry::CapGrant(entry_hash.clone())),
    }
}

/// Get the app defined link type from a [`ZomeIndex`] and [`LinkType`].
/// If the [`ZomeIndex`] is not a dependency of this zome then return a host error.
fn in_scope_link_type<LT>(zome_index: ZomeIndex, link_type: LinkType) -> Result<LT, WasmError>
where
    LT: LinkTypesHelper,
    WasmError: From<<LT as LinkTypesHelper>::Error>,
{
    match <LT as LinkTypesHelper>::from_type(*zome_index, *link_type)? {
        Some(link_type) => Ok(link_type),
        None => Err(deny_other_zome()),
    }
}

/// Get the app defined link type from a [`ZomeIndex`] and [`LinkType`].
/// If the [`ZomeIndex`] is not a dependency of this zome then return a host error.
fn activity_link_type<LT>(
    zome_index: ZomeIndex,
    link_type: LinkType,
) -> Result<Option<LT>, WasmError>
where
    LT: LinkTypesHelper,
    WasmError: From<<LT as LinkTypesHelper>::Error>,
{
    Ok(<LT as LinkTypesHelper>::from_type(*zome_index, *link_type)?)
}

/// Produce the unit variant given a zome id and entry def index.
/// Returns [`None`] if the zome id is not a dependency of this zome.
/// Returns a [`WasmErrorInner::Guest`] error if the zome id is a
/// dependency but the [`EntryDefIndex`] is out of range.
fn get_unit_entry_type<ET>(
    zome_index: ZomeIndex,
    entry_def_index: EntryDefIndex,
) -> Result<Option<<ET as UnitEnum>::Unit>, WasmError>
where
    ET: UnitEnum,
    <ET as UnitEnum>::Unit: Into<ZomeEntryTypesKey>,
{
    let entries = zome_info()?.zome_types.entries;
    let unit = entries.find(
        <ET as UnitEnum>::unit_iter(),
        ScopedEntryDefIndex {
            zome_index,
            zome_type: entry_def_index,
        },
    );
    let unit = match unit {
        Some(unit) => Some(unit),
        None => {
            if entries.dependencies().any(|z| z == zome_index) {
                return Err(wasm_error!(WasmErrorInner::Guest(format!(
                    "Entry type: {:?} is out of range for this zome.",
                    entry_def_index
                ))));
            } else {
                None
            }
        }
    };
    Ok(unit)
}

/// Produce an error because this zome
/// should never be called with a zome id
/// that is not a dependency.
fn deny_other_zome() -> WasmError {
    wasm_error!(WasmErrorInner::Host(
        "Op called for zome it was not defined in. This is a Holochain bug".to_string()
    ))
}



================================================
File: crates/hdi/src/prelude.rs
================================================
#[cfg(feature = "unstable-functions")]
pub use crate::agent::is_same_agent;
pub use crate::app_entry;
pub use crate::chain::must_get_agent_activity;
pub use crate::ed25519::verify_signature;
pub use crate::ed25519::verify_signature_raw;
pub use crate::entry::must_get_action;
pub use crate::entry::must_get_entry;
pub use crate::entry::must_get_valid_record;
pub use crate::entry_types;
pub use crate::flat_op::*;
pub use crate::hash::*;
pub use crate::hash_path::anchor::Anchor;
pub use crate::hash_path::path::Component;
pub use crate::hash_path::path::Path;
pub use crate::hash_path::path::TypedPath;
pub use crate::hash_path::shard::ShardStrategy;
pub use crate::hdi::*;
pub use crate::info::dna_info;
pub use crate::info::zome_info;
pub use crate::link::LinkTypeFilterExt;
pub use crate::map_extern;
pub use crate::map_extern::ExternResult;
pub use crate::map_extern_infallible;
pub use crate::map_extern_preamble;
pub use crate::op::*;
pub use crate::x_salsa20_poly1305::ed_25519_x_salsa20_poly1305_decrypt;
pub use crate::x_salsa20_poly1305::x_25519_x_salsa20_poly1305_decrypt;
pub use crate::x_salsa20_poly1305::x_salsa20_poly1305_decrypt;
pub use hdk_derive;
pub use hdk_derive::dna_properties;
pub use hdk_derive::hdk_entry_helper;
pub use hdk_derive::hdk_entry_types;
pub use hdk_derive::hdk_entry_types_conversions;
pub use hdk_derive::hdk_extern;
pub use hdk_derive::hdk_link_types;
pub use hdk_derive::hdk_to_coordinates;
pub use hdk_derive::EntryDefRegistration;
pub use hdk_derive::UnitEnum;
pub use holo_hash;
pub use holo_hash::ActionHash;
pub use holo_hash::AgentPubKey;
pub use holo_hash::AnyDhtHash;
pub use holo_hash::AnyLinkableHash;
pub use holo_hash::DnaHash;
pub use holo_hash::EntryHash;
pub use holo_hash::EntryHashes;
pub use holo_hash::ExternalHash;
pub use holo_hash::HasHash;
pub use holo_hash::HoloHash;
pub use holo_hash::HoloHashed;
pub use holochain_integrity_types;
pub use holochain_integrity_types::prelude::*;
pub use holochain_wasmer_guest::*;
pub use std::collections::BTreeSet;
pub use std::collections::HashSet;
pub use std::convert::TryFrom;
#[cfg(feature = "trace")]
pub use tracing;
#[cfg(feature = "trace")]
pub use tracing::{debug, error, info, instrument, trace, warn};

#[cfg(not(feature = "trace"))]
/// Needed as a noop for map_extern! when trace is off.
pub use crate::error;

#[doc(hidden)]
#[cfg(not(feature = "trace"))]
#[macro_export]
/// Needed as a noop for map_extern! when trace is off.
macro_rules! error {
    ($($field:tt)*) => {};
}

#[cfg(feature = "mock")]
pub use mockall;

// This needs to be called at least once _somewhere_ and is idempotent.
#[doc(hidden)]
#[macro_export]
macro_rules! holochain_externs {
    () => {
        holochain_wasmer_guest::host_externs!(
            trace:1,
            hash:1,
            unreachable:1,
            verify_signature:1,
            zome_info:1,
            dna_info:1,
            dna_info:2,
            must_get_entry:1,
            must_get_valid_record:1,
            must_get_action:1,
            must_get_agent_activity:1,
            x_salsa20_poly1305_decrypt:1,
            x_25519_x_salsa20_poly1305_decrypt:1,
            ed_25519_x_salsa20_poly1305_decrypt:1
        );

        #[cfg(feature = "unstable-functions")]
        holochain_wasmer_guest::host_externs!(
            is_same_agent:1
        );
    };
}

#[cfg(not(feature = "mock"))]
holochain_externs!();



================================================
File: crates/hdi/src/test_utils.rs
================================================
use crate::prelude::*;

pub mod short_hand;

pub fn set_zome_types(entries: &[(u8, u8)], links: &[(u8, u8)]) {
    struct TestHdi(ScopedZomeTypesSet);
    #[allow(unused_variables)]
    impl HdiT for TestHdi {
        fn verify_signature(&self, verify_signature: VerifySignature) -> ExternResult<bool> {
            todo!()
        }

        fn hash(&self, hash_input: HashInput) -> ExternResult<HashOutput> {
            todo!()
        }

        fn must_get_entry(
            &self,
            must_get_entry_input: MustGetEntryInput,
        ) -> ExternResult<EntryHashed> {
            todo!()
        }

        fn must_get_action(
            &self,
            must_get_action_input: MustGetActionInput,
        ) -> ExternResult<SignedActionHashed> {
            todo!()
        }

        fn must_get_valid_record(
            &self,
            must_get_valid_record_input: MustGetValidRecordInput,
        ) -> ExternResult<Record> {
            todo!()
        }

        #[cfg(feature = "unstable-functions")]
        fn is_same_agent(&self, key_1: AgentPubKey, key_2: AgentPubKey) -> ExternResult<bool> {
            todo!()
        }

        fn dna_info(&self, dna_info_input: ()) -> ExternResult<DnaInfo> {
            todo!()
        }

        fn zome_info(&self, zome_info_input: ()) -> ExternResult<ZomeInfo> {
            let info = ZomeInfo {
                name: String::default().into(),
                id: u8::default().into(),
                properties: Default::default(),
                entry_defs: EntryDefs(Default::default()),
                extern_fns: Default::default(),
                zome_types: self.0.clone(),
            };
            Ok(info)
        }

        fn x_salsa20_poly1305_decrypt(
            &self,
            x_salsa20_poly1305_decrypt: XSalsa20Poly1305Decrypt,
        ) -> ExternResult<Option<XSalsa20Poly1305Data>> {
            todo!()
        }

        fn x_25519_x_salsa20_poly1305_decrypt(
            &self,
            x_25519_x_salsa20_poly1305_decrypt: X25519XSalsa20Poly1305Decrypt,
        ) -> ExternResult<Option<XSalsa20Poly1305Data>> {
            todo!()
        }

        fn ed_25519_x_salsa20_poly1305_decrypt(
            &self,
            ed_25519_x_salsa20_poly1305_decrypt: Ed25519XSalsa20Poly1305Decrypt,
        ) -> ExternResult<XSalsa20Poly1305Data> {
            todo!()
        }

        fn trace(&self, trace_msg: TraceMsg) -> ExternResult<()> {
            todo!()
        }

        fn must_get_agent_activity(
            &self,
            must_get_agent_activity_input: MustGetAgentActivityInput,
        ) -> ExternResult<Vec<RegisterAgentActivity>> {
            todo!()
        }
    }
    set_hdi(TestHdi(ScopedZomeTypesSet {
        entries: ScopedZomeTypes(
            entries
                .iter()
                .map(|(z, types)| (ZomeIndex(*z), (0..*types).map(EntryDefIndex).collect()))
                .collect(),
        ),
        links: ScopedZomeTypes(
            links
                .iter()
                .map(|(z, types)| (ZomeIndex(*z), (0..*types).map(LinkType).collect()))
                .collect(),
        ),
    }));
}



================================================
File: crates/hdi/src/trace.rs
================================================
use crate::prelude::*;
use std::fmt::Write;
use std::sync::atomic::AtomicUsize;
use std::sync::atomic::Ordering;

#[derive(Default)]
pub struct WasmSubscriber {
    pub ids: AtomicUsize,
}

/// Very basic struct to hold strings that can be written to by the tracing crate and sent to the host when complete.
struct StringVisitor<'a> {
    fields: &'a mut String,
    message: &'a mut String,
}

impl tracing_core::field::Visit for StringVisitor<'_> {
    fn record_debug(&mut self, field: &tracing_core::Field, value: &dyn std::fmt::Debug) {
        // Special case the message field so that it doesn't appear in the key/value format.
        if field.name() == "message" {
            let did_write = write!(self.message, "{:?}", value);
            if did_write.is_err() {
                let _ = write!(self.message, "**failed to write message**");
            }
        // Everything else is a simple key/value debug output.
        } else {
            let did_write = write!(self.fields, "{} = {:?}; ", field.name(), value);
            if did_write.is_err() {
                let _ = write!(self.fields, "**failed to write {}**", field.name());
            }
        }
    }
}

/// By implementing WasmSubscriber we integrate the rust tracing crate with the __trace host_fn without inventing some DIY DSL
///
/// Currently supports all the event macros for tracing such as `trace!`, `info!`, `debug!`, `warn!`, `error!`.
///
/// Does NOT support spans, so attempting to `#[instrument]` a function or similar will panic the wasm.
impl tracing_core::Subscriber for WasmSubscriber {
    fn enabled(&self, _metadata: &tracing::Metadata<'_>) -> bool {
        true
    }
    /// Not really implemented yet.
    /// Placeholder logic only.
    fn new_span(&self, _attributes: &tracing_core::span::Attributes<'_>) -> tracing::Id {
        let next = self.ids.fetch_add(1, Ordering::SeqCst) as u64;
        tracing::Id::from_u64(next)
    }
    fn record(&self, _span: &tracing::Id, _values: &tracing::span::Record<'_>) {
        // unimplemented
    }
    fn record_follows_from(&self, _span: &tracing::Id, _follows: &tracing::Id) {
        // unimplemented
    }
    fn event(&self, event: &tracing::Event<'_>) {
        // New strings for every event.
        let mut visitor = StringVisitor {
            message: &mut String::new(),
            fields: &mut String::new(),
        };

        // This is handled by the Visit implementation above.
        event.record(&mut visitor);

        // The event is pushed to the host to be picked up by the subscriber on that side.
        // The visitor is dropped.
        HDI.with(|h| {
            h.borrow()
                .trace(TraceMsg {
                    level: event.metadata().level().into(),
                    msg: format!(
                        "{}:{}:{} {}{}",
                        event.metadata().module_path().unwrap_or(""),
                        event.metadata().file().unwrap_or(""),
                        event.metadata().line().unwrap_or(0),
                        visitor.fields,
                        visitor.message
                    ),
                })
                .ok()
        });
    }
    fn enter(&self, _span: &tracing::Id) {
        // unimplemented
    }
    fn exit(&self, _span: &tracing::Id) {
        // unimplemented
    }
}



================================================
File: crates/hdi/src/x_salsa20_poly1305.rs
================================================
use crate::prelude::*;

/// Libsodium secret-key authenticated encryption: secretbox_open
///
/// Opens encrypted data created by secretbox.
///
/// If the encrypted data fails authentication and cannot be decrypted this function returns None.
///
/// This means that if any decrypted data is returned by this function it was created by a holder
/// of the shared key and has not been tampered with.
///
/// See [aeads](https://www.imperialviolet.org/2015/05/16/aeads.html)
pub fn x_salsa20_poly1305_decrypt(
    key_ref: XSalsa20Poly1305KeyRef,
    encrypted_data: XSalsa20Poly1305EncryptedData,
) -> ExternResult<Option<XSalsa20Poly1305Data>> {
    HDI.with(|h| {
        h.borrow()
            .x_salsa20_poly1305_decrypt(XSalsa20Poly1305Decrypt::new(key_ref, encrypted_data))
    })
}

/// Libsodium keypair based authenticated encryption: box_open
///
/// Opens encrypted data created by box.
///
/// If the encrypted data fails authentication and cannot be decrypted this function returns [`None`].
///
/// This means that if any decrypted data is returned by this function it was created by _either_
/// keypair and has not been tampered with.
///
/// See <https://www.imperialviolet.org/2015/05/16/aeads.html>
pub fn x_25519_x_salsa20_poly1305_decrypt(
    recipient: X25519PubKey,
    sender: X25519PubKey,
    encrypted_data: XSalsa20Poly1305EncryptedData,
) -> ExternResult<Option<XSalsa20Poly1305Data>> {
    HDI.with(|h| {
        h.borrow()
            .x_25519_x_salsa20_poly1305_decrypt(X25519XSalsa20Poly1305Decrypt::new(
                recipient,
                sender,
                encrypted_data,
            ))
    })
}

/// Libsodium crypto_box decryption, but converts ed25519 *signing*
/// keys into x25519 encryption keys.
/// WARNING: Please first understand the downsides of using this function:
/// <https://doc.libsodium.org/advanced/ed25519-curve25519>
pub fn ed_25519_x_salsa20_poly1305_decrypt(
    recipient: AgentPubKey,
    sender: AgentPubKey,
    encrypted_data: XSalsa20Poly1305EncryptedData,
) -> ExternResult<XSalsa20Poly1305Data> {
    HDI.with(|h| {
        h.borrow()
            .ed_25519_x_salsa20_poly1305_decrypt(Ed25519XSalsa20Poly1305Decrypt::new(
                recipient,
                sender,
                encrypted_data,
            ))
    })
}



================================================
File: crates/hdi/src/entry/examples.rs
================================================
//! # Examples
//!
//! ```
//! use hdi::prelude::*;
//! #[hdk_entry_helper]
//! pub struct Post(pub String);
//! #[hdk_entry_helper]
//! pub struct Msg(pub String);
//!
//! #[hdk_entry_helper]
//! pub struct PrivMsg(pub String);
//!
//! #[hdk_entry_types]
//! #[unit_enum(UnitEntryTypes)]
//! pub enum EntryTypes {
//!     Post(Post),
//!     #[entry_type(required_validations = 5)]
//!     Msg(Msg),
//!     #[entry_type(name = "hidden_msg", required_validations = 5, visibility = "private")]
//!     PrivMsg(PrivMsg),
//! }
//! # fn main() {
//! assert_eq!(__num_entry_types(), 3);
//! # }
//! ```

use self::hdi::prelude::*;
use crate as hdi;

#[hdk_entry_helper]
pub struct Post(pub String);
#[hdk_entry_helper]
pub struct Msg(pub String);

#[hdk_entry_helper]
pub struct PrivMsg(pub String);

#[hdk_entry_types]
#[unit_enum(UnitEntryTypes)]
pub enum EntryTypes {
    Post(Post),
    #[entry_type(required_validations = 5)]
    Msg(Msg),
    #[entry_type(name = "hidden_msg", required_validations = 5, visibility = "private")]
    PrivMsg(PrivMsg),
}



================================================
File: crates/hdi/src/flat_op/flat_op_activity.rs
================================================
use holochain_integrity_types::MigrationTarget;

use super::*;

#[derive(Debug, Clone, PartialEq, Eq)]
/// Data specific to the
/// [`Op::RegisterAgentActivity`](holochain_integrity_types::op::Op::RegisterAgentActivity)
/// operation.
pub enum OpActivity<UnitType, LT> {
    /// This operation registers the [`Action`](holochain_integrity_types::action::Action) for an
    /// app defined entry type to the author's chain.
    CreateEntry {
        /// The unit version of the app defined entry type. If this is [`None`] then the entry type
        /// is defined in a different zome.
        app_entry_type: Option<UnitType>,
        /// The [`Create`] action that creates the entry
        action: Create,
    },
    /// This operation registers the [`Action`](holochain_integrity_types::action::Action) for an
    /// app defined private entry type to the author's chain.
    CreatePrivateEntry {
        /// The unit version of the app defined entry type. If this is [`None`] then the entry type
        /// is defined in a different zome.
        app_entry_type: Option<UnitType>,
        /// The [`Create`] action that creates the entry
        action: Create,
    },
    /// This operation registers the [`Action`](holochain_integrity_types::action::Action) for an
    /// [`AgentPubKey`] to the author's chain.
    CreateAgent {
        /// The agent that was created
        agent: AgentPubKey,
        /// The [`Create`] action that creates the entry
        action: Create,
    },
    /// This operation registers the [`Action`](holochain_integrity_types::action::Action) for a
    /// Capability Claim to the author's chain.
    CreateCapClaim {
        /// The [`Create`] action that creates the
        /// [`CapClaim`](holochain_integrity_types::action::EntryType::CapClaim)
        action: Create,
    },
    /// This operation registers the [`Action`](holochain_integrity_types::action::Action) for a
    /// Capability Grant to the author's chain.
    CreateCapGrant {
        /// The [`Create`] action that creates the
        /// [`CapGrant`](holochain_integrity_types::action::EntryType::CapGrant)
        action: Create,
    },
    /// This operation registers the [`Action`](holochain_integrity_types::action::Action) for an
    /// updated app defined entry type to the author's chain.
    UpdateEntry {
        /// The hash of the [`Action`](holochain_integrity_types::action::Action) that created the
        /// original entry
        original_action_hash: ActionHash,
        /// The hash of the original entry
        original_entry_hash: EntryHash,
        /// The unit version of the app defined entry type. If this is [`None`] then the entry type
        /// is defined in a different zome.
        app_entry_type: Option<UnitType>,
        /// The [`Update`] action that updates the entry
        action: Update,
    },
    /// This operation registers the [`Action`](holochain_integrity_types::action::Action) for an
    /// updated app defined private entry type to the author's chain.
    UpdatePrivateEntry {
        /// The hash of the [`Action`](holochain_integrity_types::action::Action) that created the
        /// original entry
        original_action_hash: ActionHash,
        /// The hash of the original entry
        original_entry_hash: EntryHash,
        /// The unit version of the app defined entry type.
        /// If this is [`None`] then the entry type is defined in a different zome.
        app_entry_type: Option<UnitType>,
        /// The [`Update`] action that updates the entry
        action: Update,
    },
    /// This operation registers the [`Action`](holochain_integrity_types::action::Action) for an
    /// updated [`AgentPubKey`] to the author's chain.
    UpdateAgent {
        /// The new [`AgentPubKey`].
        new_key: AgentPubKey,
        /// The original [`AgentPubKey`].
        original_key: AgentPubKey,
        /// The hash of the [`Action`](holochain_integrity_types::action::Action) that created the
        /// original entry
        original_action_hash: ActionHash,
        /// The [`Update`] action that updates the agent's key
        action: Update,
    },
    /// This operation registers the [`Action`](holochain_integrity_types::action::Action) for an
    /// updated Capability Claim to the author's chain.
    UpdateCapClaim {
        /// The hash of the [`Action`](holochain_integrity_types::action::Action) that created the
        /// original [`CapClaim`](holochain_integrity_types::action::EntryType::CapClaim)
        original_action_hash: ActionHash,
        /// The hash of the original
        /// [`CapClaim`](holochain_integrity_types::action::EntryType::CapClaim)
        original_entry_hash: EntryHash,
        /// The [`Update`] action that updates the
        /// [`CapClaim`](holochain_integrity_types::action::EntryType::CapClaim)
        action: Update,
    },
    /// This operation registers the [`Action`](holochain_integrity_types::action::Action) for an
    /// updated Capability Grant to the author's chain.
    UpdateCapGrant {
        /// The hash of the [`Action`](holochain_integrity_types::action::Action) that created the
        /// original [`CapGrant`](holochain_integrity_types::action::EntryType::CapGrant)
        original_action_hash: ActionHash,
        /// The hash of the original
        /// [`CapGrant`](holochain_integrity_types::action::EntryType::CapGrant)
        original_entry_hash: EntryHash,
        /// The [`Update`] action that updates the
        /// [`CapGrant`](holochain_integrity_types::action::EntryType::CapGrant)
        action: Update,
    },
    /// This operation registers the [`Action`](holochain_integrity_types::action::Action) for a
    /// deleted app defined entry type to the author's chain.
    DeleteEntry {
        /// The hash of the [`Action`](holochain_integrity_types::action::Action) that created the
        /// original entry
        original_action_hash: ActionHash,
        /// The hash of the original entry
        original_entry_hash: EntryHash,
        /// The action that deletes the original entry
        action: Delete,
    },
    /// This operation registers the [`Action`](holochain_integrity_types::action::Action) for a
    /// new link to the author's chain.
    CreateLink {
        /// The base address of the link.
        base_address: AnyLinkableHash,
        /// The target address of the link.
        target_address: AnyLinkableHash,
        /// The link's tag.
        tag: LinkTag,
        /// The app defined link type of this link.
        /// If this is [`None`] then the link type is defined in a different zome.
        link_type: Option<LT>,
        /// The action that creates this link
        action: CreateLink,
    },
    /// This operation registers the [`Action`](holochain_integrity_types::action::Action) for a
    /// deleted link to the author's chain and contains the original link's
    /// [`Action`](holochain_integrity_types::action::Action) hash.
    DeleteLink {
        /// The deleted links [`CreateLink`] [`Action`](holochain_integrity_types::action::Action).
        original_action_hash: ActionHash,
        /// The base address where this link is stored.
        /// This is the base address of the link that is being deleted.
        base_address: AnyLinkableHash,
        /// The [`DeleteLink`] action that deletes the link
        action: DeleteLink,
    },
    /// This operation registers the [`Action`](holochain_integrity_types::action::Action) for an
    /// [`Action::Dna`](holochain_integrity_types::action::Action::Dna) to the author's chain.
    Dna {
        /// The hash of the DNA
        dna_hash: DnaHash,
        /// The [`Dna`] action
        action: Dna,
    },
    /// This operation registers the [`Action`](holochain_integrity_types::action::Action) for an
    /// [`Action::OpenChain`](holochain_integrity_types::action::Action::OpenChain) to the author's
    /// chain and contains the previous chains's [`MigrationTarget`].
    OpenChain {
        /// Target for the previous chain that we are migrating from
        previous_target: MigrationTarget,
        /// Hash of the corresponding CloseChain.
        close_hash: ActionHash,
        /// The [`OpenChain`] action
        action: OpenChain,
    },
    /// This operation registers the [`Action`](holochain_integrity_types::action::Action) for an
    /// [`Action::CloseChain`](holochain_integrity_types::action::Action::CloseChain) to the
    /// author's chain and contains the new chains's [`MigrationTarget`] if applicable.
    CloseChain {
        /// Target for the new chain that we are migrating to
        new_target: Option<MigrationTarget>,
        /// The [`CloseChain`] action
        action: CloseChain,
    },
    /// This operation registers the [`Action`](holochain_integrity_types::action::Action) for an
    /// [`Action::AgentValidationPkg`](holochain_integrity_types::action::Action::AgentValidationPkg)
    /// to the author's chain and contains the membrane proof if there is one.
    AgentValidationPkg {
        /// The membrane proof proving that the agent is allowed to participate in this DNA
        membrane_proof: Option<MembraneProof>,
        /// The [`AgentValidationPkg`] action
        action: AgentValidationPkg,
    },
    /// This operation registers the [`Action`](holochain_integrity_types::action::Action) for an
    /// [`Action::InitZomesComplete`](holochain_integrity_types::action::Action::InitZomesComplete)
    /// to the author's chain.
    InitZomesComplete {
        /// The [`InitZomesComplete`] action
        action: InitZomesComplete,
    },
}

impl<UnitType, LT> OpActivity<UnitType, LT> {
    /// DRY constructor
    pub fn open_chain(action: OpenChain) -> Self {
        Self::OpenChain {
            previous_target: action.prev_target.clone(),
            close_hash: action.close_hash.clone(),
            action,
        }
    }

    /// DRY constructor
    pub fn close_chain(action: CloseChain) -> Self {
        Self::CloseChain {
            new_target: action.new_target.clone(),
            action,
        }
    }
}



================================================
File: crates/hdi/src/flat_op/flat_op_entry.rs
================================================
use holochain_integrity_types::{CapClaimEntry, CapGrantEntry};

use super::*;

#[derive(Debug, Clone, PartialEq, Eq)]
/// Data specific to the [`Op::StoreEntry`](holochain_integrity_types::op::Op::StoreEntry)
/// operation.
pub enum OpEntry<ET>
where
    ET: UnitEnum,
{
    /// This operation stores the [`Entry`](holochain_integrity_types::entry::Entry) for an app
    /// defined entry type.
    CreateEntry {
        /// The app defined entry with the deserialized
        /// [`Entry`](holochain_integrity_types::entry::Entry) data.
        app_entry: ET,
        /// The [`Create`] action that creates this entry
        action: Create,
    },
    /// This operation stores the [`Entry`](holochain_integrity_types::entry::Entry) for an
    /// [`AgentPubKey`].
    CreateAgent {
        /// The agent that was created
        agent: AgentPubKey,
        /// The [`Create`] action that creates this agent's key
        action: Create,
    },
    /// This operation stores the [`Entry`](holochain_integrity_types::entry::Entry) for the newly
    /// created entry in an update.
    UpdateEntry {
        /// The hash of the [`Action`](holochain_integrity_types::action::Action) that created the
        /// original entry
        original_action_hash: ActionHash,
        /// The hash of the original entry
        original_entry_hash: EntryHash,
        /// The app defined entry with the deserialized
        /// [`Entry`](holochain_integrity_types::entry::Entry) data of the new entry.
        app_entry: ET,
        /// The [`Update`] action that updates this entry
        action: Update,
    },
    /// This operation stores the [`Entry`](holochain_integrity_types::entry::Entry) for an updated
    /// [`AgentPubKey`].
    UpdateAgent {
        /// The new [`AgentPubKey`].
        new_key: AgentPubKey,
        /// The original [`AgentPubKey`].
        original_key: AgentPubKey,
        /// The hash of the original keys [`Action`](holochain_integrity_types::action::Action).
        original_action_hash: ActionHash,
        /// The [`Update`] action that updates this entry
        action: Update,
    },
    /// This operation stores the [`Entry`](holochain_integrity_types::entry::Entry) for a CapGrant
    CreateCapGrant {
        /// The cap grant entry data.
        entry: CapGrantEntry,
        /// The [`Create`] action that creates this cap grant
        action: Create,
    },
    /// This operation stores the [`Entry`](holochain_integrity_types::entry::Entry) for a CapClaim
    CreateCapClaim {
        /// The cap claim entry data.
        entry: CapClaimEntry,
        /// The [`Create`] action that creates this cap claim
        action: Create,
    },
    /// This operation updates the [`Entry`](holochain_integrity_types::entry::Entry) for a
    /// CapGrant
    UpdateCapGrant {
        /// The hash of the [`Action`](holochain_integrity_types::action::Action) that created the
        /// original [`CapGrant`](holochain_integrity_types::action::EntryType::CapGrant)
        original_action_hash: ActionHash,
        /// The hash of the original
        /// [`CapGrant`](holochain_integrity_types::action::EntryType::CapGrant)
        original_entry_hash: EntryHash,
        /// The [`Update`] action that updates the
        /// [`CapGrant`](holochain_integrity_types::action::EntryType::CapGrant)
        action: Update,
        /// The new entry to store
        entry: CapGrantEntry,
    },
    /// This operation updates the [`Entry`](holochain_integrity_types::entry::Entry) for a
    /// CapClaim
    UpdateCapClaim {
        /// The hash of the [`Action`](holochain_integrity_types::action::Action) that created the
        /// original [`CapClaim`](holochain_integrity_types::action::EntryType::CapClaim)
        original_action_hash: ActionHash,
        /// The hash of the original
        /// [`CapClaim`](holochain_integrity_types::action::EntryType::CapClaim)
        original_entry_hash: EntryHash,
        /// The [`Update`] action that updates the
        /// [`CapClaim`](holochain_integrity_types::action::EntryType::CapClaim)
        action: Update,
        /// The new entry to store
        entry: CapClaimEntry,
    },
}

#[derive(Debug, Clone, PartialEq, Eq)]
/// Data specific to the [`Op::RegisterUpdate`](holochain_integrity_types::op::Op::RegisterUpdate)
/// operation.
pub enum OpUpdate<ET>
where
    ET: UnitEnum,
{
    /// This operation registers an update from the original
    /// [`Entry`](holochain_integrity_types::entry::Entry).
    Entry {
        /// The app defined entry type with the deserialized
        /// [`Entry`](holochain_integrity_types::entry::Entry) data of the new entry.
        app_entry: ET,
        /// The action that updates this entry
        action: Update,
    },
    /// This operation registers an update from the original private
    /// [`Entry`](holochain_integrity_types::entry::Entry).
    PrivateEntry {
        /// The hash of the original original
        /// [`Action`](holochain_integrity_types::action::Action).
        original_action_hash: ActionHash,
        /// The unit version of the app defined entry type for the new entry.
        app_entry_type: <ET as UnitEnum>::Unit,
        /// The action that updates this entry
        action: Update,
    },
    /// This operation registers an update from the original [`AgentPubKey`].
    Agent {
        /// The new [`AgentPubKey`].
        new_key: AgentPubKey,
        /// The original [`AgentPubKey`].
        original_key: AgentPubKey,
        /// The hash of the original original
        /// [`Action`](holochain_integrity_types::action::Action).
        original_action_hash: ActionHash,
        /// The [`Update`] action that updates the agent's key
        action: Update,
    },
    /// This operation registers an update from a Capability Claim.
    CapClaim {
        /// The hash of the original original
        /// [`Action`](holochain_integrity_types::action::Action).
        original_action_hash: ActionHash,
        /// The [`Update`] action that updates the
        /// [`CapClaim`](holochain_integrity_types::action::EntryType::CapClaim)
        action: Update,
    },
    /// This operation registers an update from a Capability Grant.
    CapGrant {
        /// The hash of the original original
        /// [`Action`](holochain_integrity_types::action::Action).
        original_action_hash: ActionHash,
        /// The [`Update`] action that updates the
        /// [`CapGrant`](holochain_integrity_types::action::EntryType::CapGrant)
        action: Update,
    },
}

#[derive(Debug, Clone, PartialEq, Eq)]
/// Data specific to the [`Op::RegisterDelete`](holochain_integrity_types::op::Op::RegisterDelete)
/// operation.
pub struct OpDelete {
    /// The [`Delete`] action that deletes this entry
    pub action: Delete,
}



================================================
File: crates/hdi/src/flat_op/flat_op_record.rs
================================================
use holochain_integrity_types::MigrationTarget;

use super::*;

#[derive(Debug, Clone, PartialEq, Eq)]
/// Data specific to the [`Op::StoreRecord`](holochain_integrity_types::op::Op::StoreRecord)
/// operation.
pub enum OpRecord<ET: UnitEnum, LT> {
    /// This operation stores the [`Record`](holochain_integrity_types::record::Record) for an app
    /// defined entry type.
    CreateEntry {
        /// The app defined entry type with the deserialized
        /// [`Entry`](holochain_integrity_types::entry::Entry) data.
        app_entry: ET,
        /// The [`Create`] action that creates the entry
        action: Create,
    },
    /// This operation stores the [`Record`](holochain_integrity_types::record::Record) for an app
    /// defined private entry type.
    CreatePrivateEntry {
        /// The unit version of the app defined entry type. Note it is not possible to deserialize
        /// the full entry type here because we don't have the
        /// [`Entry`](holochain_integrity_types::entry::Entry) data.
        app_entry_type: <ET as UnitEnum>::Unit,
        /// The [`Create`] action that creates the entry
        action: Create,
    },
    /// This operation stores the [`Record`](holochain_integrity_types::record::Record) for an
    /// [`AgentPubKey`] that has been created.
    CreateAgent {
        /// The agent that was created
        agent: AgentPubKey,
        /// The [`Create`] action that creates the entry
        action: Create,
    },
    /// This operation stores the [`Record`](holochain_integrity_types::record::Record) for a
    /// Capability Claim that has been created.
    CreateCapClaim {
        /// The [`Create`] action that creates the
        /// [`CapClaim`](holochain_integrity_types::action::EntryType::CapClaim)
        action: Create,
    },
    /// This operation stores the [`Record`](holochain_integrity_types::record::Record) for a
    /// Capability Grant that has been created.
    CreateCapGrant {
        /// The [`Create`] action that creates the
        /// [`CapGrant`](holochain_integrity_types::action::EntryType::CapGrant)
        action: Create,
    },
    /// This operation stores the [`Record`](holochain_integrity_types::record::Record) for an
    /// updated app defined entry type.
    UpdateEntry {
        /// The hash of the [`Action`](holochain_integrity_types::action::Action) that created the
        /// original entry
        original_action_hash: ActionHash,
        /// The hash of the original entry
        original_entry_hash: EntryHash,
        /// The app defined entry type with the deserialized
        /// [`Entry`](holochain_integrity_types::entry::Entry) data from the new entry. Note the
        /// new entry type is always the same as the original entry type however the data may have
        /// changed.
        app_entry: ET,
        /// The [`Update`] action that updates the entry
        action: Update,
    },
    /// This operation stores the [`Record`](holochain_integrity_types::record::Record) for an
    /// updated app defined private entry type.
    UpdatePrivateEntry {
        /// The hash of the [`Action`](holochain_integrity_types::action::Action) that created the
        /// original entry
        original_action_hash: ActionHash,
        /// The hash of the original entry
        original_entry_hash: EntryHash,
        /// The unit version of the app defined entry type. Note the new entry type is always the
        /// same as the original entry type however the data may have changed.
        app_entry_type: <ET as UnitEnum>::Unit,
        /// The [`Update`] action that updates the entry
        action: Update,
    },
    /// This operation stores the [`Record`](holochain_integrity_types::record::Record) for an
    /// updated [`AgentPubKey`].
    UpdateAgent {
        /// The original [`AgentPubKey`].
        original_key: AgentPubKey,
        /// The new [`AgentPubKey`].
        new_key: AgentPubKey,
        /// The hash of the [`Action`](holochain_integrity_types::action::Action) that created the
        /// original key
        original_action_hash: ActionHash,
        /// The [`Update`] action that updates the entry
        action: Update,
    },
    /// This operation stores the [`Record`](holochain_integrity_types::record::Record) for an
    /// updated Capability Claim.
    UpdateCapClaim {
        /// The hash of the [`Action`](holochain_integrity_types::action::Action) that created the
        /// original [`CapClaim`](holochain_integrity_types::action::EntryType::CapClaim)
        original_action_hash: ActionHash,
        /// The hash of the original
        /// [`CapClaim`](holochain_integrity_types::action::EntryType::CapClaim)
        original_entry_hash: EntryHash,
        /// The [`Update`] action that updates the
        /// [`CapClaim`](holochain_integrity_types::action::EntryType::CapClaim)
        action: Update,
    },
    /// This operation stores the [`Record`](holochain_integrity_types::record::Record) for an
    /// updated Capability Grant.
    UpdateCapGrant {
        /// The hash of the [`Action`](holochain_integrity_types::action::Action) that created the
        /// original [`CapGrant`](holochain_integrity_types::action::EntryType::CapGrant)
        original_action_hash: ActionHash,
        /// The hash of the original
        /// [`CapGrant`](holochain_integrity_types::action::EntryType::CapGrant)
        original_entry_hash: EntryHash,
        /// The [`Update`] action that updates the
        /// [`CapGrant`](holochain_integrity_types::action::EntryType::CapGrant)
        action: Update,
    },
    /// This operation stores the [`Record`](holochain_integrity_types::record::Record) for a
    /// deleted app defined entry type.
    DeleteEntry {
        /// The hash of the [`Action`](holochain_integrity_types::action::Action) that created the
        /// original entry
        original_action_hash: ActionHash,
        /// The hash of the original entry
        original_entry_hash: EntryHash,
        /// The [`Delete`] action that creates the entry
        action: Delete,
    },
    /// This operation stores the [`Record`](holochain_integrity_types::record::Record) for a new
    /// link.
    CreateLink {
        /// The base address of the link.
        base_address: AnyLinkableHash,
        /// The target address of the link.
        target_address: AnyLinkableHash,
        /// The link's tag.
        tag: LinkTag,
        /// The app defined link type of this link.
        link_type: LT,
        /// The [`CreateLink`] action that creates this link
        action: CreateLink,
    },
    /// This operation stores the [`Record`](holochain_integrity_types::record::Record) for a
    /// deleted link and contains the original link's
    /// [`Action`](holochain_integrity_types::action::Action) hash.
    DeleteLink {
        /// The deleted links [`CreateLink`] [`Action`](holochain_integrity_types::action::Action).
        original_action_hash: ActionHash,
        /// The base address where this link is stored.
        /// This is the base address of the link that is being deleted.
        base_address: AnyLinkableHash,
        /// The [`DeleteLink`] action that deletes the link
        action: DeleteLink,
    },
    /// This operation stores the [`Record`](holochain_integrity_types::record::Record) for an
    /// [`Action::Dna`](holochain_integrity_types::action::Action::Dna).
    Dna {
        /// The hash of the DNA
        dna_hash: DnaHash,
        /// The [`Dna`] action
        action: Dna,
    },
    /// This operation stores the [`Record`](holochain_integrity_types::record::Record) for an
    /// [`Action::OpenChain`](holochain_integrity_types::action::Action::OpenChain) and contains
    /// the previous chains's [`MigrationTarget`].
    OpenChain {
        /// Specifier for the previous chain that we are migrating from
        previous_target: MigrationTarget,
        /// The hash of the corresponding CloseChain action.
        close_hash: ActionHash,
        /// The [`OpenChain`] action
        action: OpenChain,
    },
    /// This operation stores the [`Record`](holochain_integrity_types::record::Record) for an
    /// [`Action::CloseChain`](holochain_integrity_types::action::Action::CloseChain) and contains
    /// the new chains's [`MigrationTarget`], if applicable.
    CloseChain {
        /// Specifier for the new chain that we are migrating to
        new_target: Option<MigrationTarget>,
        /// The [`CloseChain`] action
        action: CloseChain,
    },
    /// This operation stores the [`Record`](holochain_integrity_types::record::Record) for an
    /// [`Action::AgentValidationPkg`](holochain_integrity_types::action::Action::AgentValidationPkg)
    /// and contains the membrane proof if there is one.
    AgentValidationPkg {
        /// The membrane proof proving that the agent is allowed to participate in this DNA
        membrane_proof: Option<MembraneProof>,
        /// The [`AgentValidationPkg`] action
        action: AgentValidationPkg,
    },
    /// This operation stores the [`Record`](holochain_integrity_types::record::Record) for an
    /// [`Action::InitZomesComplete`](holochain_integrity_types::action::Action::InitZomesComplete).
    InitZomesComplete {
        /// The [`InitZomesComplete`] action
        action: InitZomesComplete,
    },
}

impl<ET: UnitEnum, LT> OpRecord<ET, LT> {
    /// DRY constructor
    pub fn open_chain(action: OpenChain) -> Self {
        Self::OpenChain {
            previous_target: action.prev_target.clone(),
            close_hash: action.close_hash.clone(),
            action,
        }
    }

    /// DRY constructor
    pub fn close_chain(action: CloseChain) -> Self {
        Self::CloseChain {
            new_target: action.new_target.clone(),
            action,
        }
    }
}



================================================
File: crates/hdi/src/hash_path/anchor.rs
================================================
use crate::hash_path::path::Component;
use crate::hash_path::path::Path;
use holochain_wasmer_guest::*;

/// This is the root of the [`Path`] tree.
///
/// Forms the entry point to all anchors so that agents can navigate down the tree from here.
pub const ROOT: &[u8; 2] = &[0x00, 0x00];

#[derive(PartialEq, SerializedBytes, serde::Serialize, serde::Deserialize, Debug, Clone)]
/// An anchor can only be 1 or 2 levels deep as "type" and "text".
///
/// The second level is optional and the Strings use the standard [`TryInto`] for path [`Component`] internally.
///
/// __Anchors are required to be included in an application's [`entry_defs`](crate::prelude::entry_types)__ callback and so implement all the standard methods.
/// Technically the [`Anchor`] entry definition is the [`Path`] definition.
///
/// e.g. `entry_defs![Anchor::entry_def()]`
///
/// The methods implemented on anchor follow the patterns that predate the Path module but `Path::from(&anchor)` is always possible to use the newer APIs.
pub struct Anchor {
    pub anchor_type: String,
    pub anchor_text: Option<String>,
}

/// Anchors are just a special case of path, so we can move from anchor to path losslessly.
/// We simply format the anchor structure into a string that works with the path string handling.
impl From<&Anchor> for Path {
    fn from(anchor: &Anchor) -> Self {
        let mut components = vec![
            Component::new(ROOT.to_vec()),
            Component::from(anchor.anchor_type.as_bytes().to_vec()),
        ];
        if let Some(text) = anchor.anchor_text.as_ref() {
            components.push(Component::from(text.as_bytes().to_vec()));
        }
        components.into()
    }
}

#[cfg(test)]
#[test]
fn hash_path_root() {
    assert_eq!(ROOT, &[0_u8, 0]);
}

#[cfg(test)]
#[test]
fn hash_path_anchor_path() {
    let examples = [
        (
            "foo",
            None,
            Path::from(vec![
                Component::from(vec![0, 0]),
                Component::from(vec![102, 111, 111]),
            ]),
        ),
        (
            "foo",
            Some("bar".to_string()),
            Path::from(vec![
                Component::from(vec![0, 0]),
                Component::from(vec![102, 111, 111]),
                Component::from(vec![98, 97, 114]),
            ]),
        ),
    ];
    for (atype, text, path) in examples {
        assert_eq!(
            path,
            (&Anchor {
                anchor_type: atype.to_string(),
                anchor_text: text,
            })
                .into(),
        );
    }
}



================================================
File: crates/hdi/src/hash_path/path.rs
================================================
use crate::hash_path::shard::ShardStrategy;
use crate::hash_path::shard::SHARDEND;
use crate::prelude::*;
use holochain_integrity_types::link::LinkTag;
use holochain_wasmer_guest::*;
use std::str::FromStr;

/// Root for all paths.
pub const ROOT: &[u8; 2] = &[0x00, 0x01];

pub fn root_hash() -> ExternResult<AnyLinkableHash> {
    hash_entry(Entry::App(
        AppEntryBytes::try_from(SerializedBytes::from(UnsafeBytes::from(ROOT.to_vec())))
            .expect("This cannot fail as it's under the max entry bytes"),
    ))
    .map(Into::into)
}

/// Allows for "foo.bar.baz" to automatically move to/from ["foo", "bar", "baz"] components.
/// Technically it's moving each string component in as bytes.
/// If this is a problem for you simply build the components yourself as a `Vec<Vec<u8>>`.
///
/// See `impl From<String> for Path` below.
pub const DELIMITER: &str = ".";

/// Each path component is arbitrary bytes to be hashed together in a predictable way when the path
/// is hashed to create something that can be linked and discovered by all DHT participants.
#[derive(
    Clone, PartialEq, Debug, Default, serde::Deserialize, serde::Serialize, SerializedBytes,
)]
#[repr(transparent)]
pub struct Component(#[serde(with = "serde_bytes")] Vec<u8>);

impl Component {
    pub fn new(v: Vec<u8>) -> Self {
        Self(v)
    }
}

/// Wrap bytes.
impl From<Vec<u8>> for Component {
    fn from(v: Vec<u8>) -> Self {
        Self(v)
    }
}

/// Access bytes.
impl AsRef<[u8]> for Component {
    fn as_ref(&self) -> &[u8] {
        self.0.as_ref()
    }
}

/// Unwrap bytes.
impl From<Component> for Vec<u8> {
    fn from(component: Component) -> Self {
        component.0
    }
}

/// Build a component from a String.
///
/// For many simple use cases we can construct a path out of a string similar to a URI.
/// We represent this using the utf32 bytes rather than the utf8 bytes for the chars in the string
/// which gives us a fixed width encoding for strings, which gives us a clean/easy way to support
/// sharding based on strings by iterating over u32s rather than deciding what to do with variable
/// width u8 or u16 characters.
///
/// IMPORTANT: if you are not using sharding and make heavy use of [`Path`] then
/// consider building your [`Component`] directly from `my_string.as_bytes()` to
/// achieve much more compact utf8 representations of each [`Component`].
impl From<&str> for Component {
    fn from(s: &str) -> Self {
        let bytes: Vec<u8> = s
            .chars()
            .flat_map(|c| (c as u32).to_le_bytes().to_vec())
            .collect();
        Self::from(bytes)
    }
}

/// Alias From<&str>
impl From<&String> for Component {
    fn from(s: &String) -> Self {
        Self::from(s.as_str())
    }
}

/// Alias From<&str>
impl From<String> for Component {
    fn from(s: String) -> Self {
        Self::from(s.as_str())
    }
}

/// Restoring a [`String`] from a [`Component`] requires [`Vec<u8>`] to [`u32`] to utf8 handling.
impl TryFrom<&Component> for String {
    type Error = SerializedBytesError;
    fn try_from(component: &Component) -> Result<Self, Self::Error> {
        if component.as_ref().len() % 4 != 0 {
            return Err(SerializedBytesError::Deserialize(format!(
                "attempted to create u32s from utf8 bytes of length not a factor of 4: length {}",
                component.as_ref().len()
            )));
        }
        let (chars, _, error) = component
            .as_ref()
            .iter()
            // @todo this algo seems a bit inefficient but also i'm not sure how much that
            // matters in reality, maybe a premature optimisation to do anything else
            .fold(
                (vec![], vec![], None),
                |(mut chars, mut build, mut error), b| {
                    if error.is_none() {
                        build.push(*b);
                        if build.len() == std::mem::size_of::<u32>() {
                            // Convert the build vector into 4 le_bytes for the u32.
                            // This is an unwrap because we already check the total length above.
                            let le_bytes = build[0..std::mem::size_of::<u32>()].try_into().unwrap();
                            let u = u32::from_le_bytes(le_bytes);
                            match std::char::from_u32(u) {
                                Some(c) => {
                                    chars.push(c);
                                    build = vec![];
                                }
                                None => {
                                    error = Some(Err(SerializedBytesError::Deserialize(format!(
                                        "unknown char for u32: {}",
                                        u
                                    ))));
                                }
                            }
                        }
                    }
                    (chars, build, error)
                },
            );
        match error {
            Some(error) => error,
            None => Ok(chars.iter().collect::<String>()),
        }
    }
}

/// A [`Path`] is a vector of [`Component`]s.
///
/// It represents a single traversal of a tree structure down to some arbitrary point.
/// The main intent is that we can recursively walk back up the tree, hashing, committing and
/// linking each sub-path along the way until we reach the root.
///
/// At this point it is possible to follow DHT links from the root back up the path,
/// i.e. the ahead-of-time predictability of the hashes of a given path allows us to travel "up"
/// the tree and the linking functionality of the Holochain DHT allows us to travel "down" the tree
/// after at least one DHT participant has followed the path "up".
#[derive(
    Clone, Debug, PartialEq, Default, serde::Deserialize, serde::Serialize, SerializedBytes,
)]
#[repr(transparent)]
pub struct Path(pub Vec<Component>);

#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize, SerializedBytes)]
/// A [`LinkType`] applied to a [`Path`].
///
/// All links committed from this path will have this link type.
///
/// Get a typed path from a path and a link type:
/// ```ignore
/// let typed_path = path.typed(LinkTypes::MyLink)?;
/// ```
pub struct TypedPath {
    /// The [`LinkType`] within the scope of the zome where it's defined.
    pub link_type: ScopedLinkType,
    /// The [`Path`] that is using this [`LinkType`].
    pub path: Path,
}

/// Wrap components vector.
impl From<Vec<Component>> for Path {
    fn from(components: Vec<Component>) -> Self {
        Self(components)
    }
}

/// Unwrap components vector.
impl From<Path> for Vec<Component> {
    fn from(path: Path) -> Self {
        path.0
    }
}

/// Access components vector.
impl AsRef<Vec<Component>> for Path {
    fn as_ref(&self) -> &Vec<Component> {
        self.0.as_ref()
    }
}

/// Split a string path out into a vector of components.
/// This allows us to construct pseudo-URI-path-things as strings.
/// It is a simpler scheme than URLs and file paths.
/// Leading and trailing slashes are ignored as are duplicate dots and the empty string leads
/// to a path with zero length (no components).
///
/// e.g. all the following result in the same components as `vec!["foo", "bar"]` (as bytes)
/// - foo.bar
/// - foo.bar.
/// - .foo.bar
/// - .foo.bar.
/// - foo..bar
///
/// There is no normalisation of paths, e.g. to guarantee a specific root component exists, at this
/// layer so there is a risk that there are hash collisions with other data on the DHT network if
/// some disambiguation logic is not included in higher level abstractions.
///
/// This supports sharding strategies from a small inline DSL.
/// Start each component with `<width>:<depth>#` to get shards out of the string.
///
/// e.g.
/// - foo.barbaz => normal path as above ["foo", "barbaz"]
/// - foo.1:3#barbazii => width 1, depth 3, ["foo", "b", "a", "r", "barbazii"]
/// - foo.2:3#barbazii => width 2, depth 3, ["foo", "ba", "rb", "az", "barbazii"]
///
/// Note that this all works because the components and sharding for strings maps to fixed-width
/// utf32 bytes under the hood rather than variable width bytes.
impl From<&str> for Path {
    fn from(s: &str) -> Self {
        Self(
            s.split(DELIMITER)
                .filter(|s| !s.is_empty())
                .flat_map(|s| match ShardStrategy::from_str(s) {
                    // Handle a strategy if one is found.
                    Ok(strategy) => {
                        let (_strategy, component) = s.split_at(s.find(SHARDEND).unwrap());
                        let component = component.trim_start_matches(SHARDEND);
                        let shard_path = Path::from((&strategy, component));
                        let mut shard_components: Vec<Component> = shard_path.into();
                        shard_components.push(Component::from(component));
                        shard_components
                    }
                    // No strategy. Use the component directly.
                    Err(_) => vec![Component::from(s)],
                })
                .collect(),
        )
    }
}

/// Alias From<&str>
impl From<&String> for Path {
    fn from(s: &String) -> Self {
        Self::from(s.as_str())
    }
}

/// Alias From<&str>
impl From<String> for Path {
    fn from(s: String) -> Self {
        Self::from(s.as_str())
    }
}

impl TryInto<String> for Path {
    type Error = SerializedBytesError;
    fn try_into(self) -> Result<String, Self::Error> {
        let s = self
            .as_ref()
            .iter()
            .map(String::try_from)
            .collect::<Result<Vec<String>, Self::Error>>()?;

        Ok(s.join(DELIMITER))
    }
}

impl Path {
    /// Attach a [`LinkType`] to this path so its type is known for test utility functions.
    pub fn into_typed(self, link_type: impl Into<ScopedLinkType>) -> TypedPath {
        TypedPath::new(link_type, self)
    }

    /// Try attaching a [`LinkType`] to this path so its type is known for test utility functions.
    pub fn typed<TY, E>(self, link_type: TY) -> Result<TypedPath, WasmError>
    where
        ScopedLinkType: TryFrom<TY, Error = E>,
        WasmError: From<E>,
    {
        Ok(TypedPath::new(ScopedLinkType::try_from(link_type)?, self))
    }
    /// What is the hash for the current [`Path`]?
    pub fn path_entry_hash(&self) -> ExternResult<holo_hash::EntryHash> {
        hash_entry(Entry::App(AppEntryBytes(
            SerializedBytes::try_from(self).map_err(|e| wasm_error!(e))?,
        )))
    }

    /// Mutate this [`Path`] into a child of itself by appending a [`Component`].
    pub fn append_component(&mut self, component: Component) {
        self.0.push(component);
    }

    /// Accessor for the last [`Component`] of this [`Path`].
    /// This can be thought of as the leaf of the implied tree structure of
    /// which this [`Path`] is one branch of.
    pub fn leaf(&self) -> Option<&Component> {
        self.0.last()
    }

    /// Make the [`LinkTag`] for this [`Path`].
    pub fn make_tag(&self) -> ExternResult<LinkTag> {
        Ok(LinkTag::new(match self.leaf() {
            None => <Vec<u8>>::with_capacity(0),
            Some(component) => {
                UnsafeBytes::from(SerializedBytes::try_from(component).map_err(|e| wasm_error!(e))?)
                    .into()
            }
        }))
    }

    /// Check if this [`Path`] is the root.
    pub fn is_root(&self) -> bool {
        self.0.len() == 1
    }
}

impl TypedPath {
    /// Create a new [`TypedPath`] by attaching a [`ZomeIndex`] and [`LinkType`] to a [`Path`].
    pub fn new(link_type: impl Into<ScopedLinkType>, path: Path) -> Self {
        Self {
            link_type: link_type.into(),
            path,
        }
    }

    /// The parent of the current path is simply the path truncated one level.
    pub fn parent(&self) -> Option<Self> {
        if self.path.as_ref().len() > 1 {
            let parent_vec: Vec<Component> =
                self.path.as_ref()[0..self.path.as_ref().len() - 1].to_vec();
            Some(Path::from(parent_vec).into_typed(self.link_type))
        } else {
            None
        }
    }
}

impl std::ops::Deref for TypedPath {
    type Target = Path;

    fn deref(&self) -> &Self::Target {
        &self.path
    }
}

impl From<TypedPath> for Path {
    fn from(p: TypedPath) -> Self {
        p.path
    }
}

impl TryInto<String> for TypedPath {
    type Error = SerializedBytesError;
    fn try_into(self) -> Result<String, Self::Error> {
        self.path.try_into()
    }
}

#[test]
#[cfg(test)]
fn hash_path_delimiter() {
    assert_eq!(".", DELIMITER,);
}

#[test]
#[cfg(test)]
fn hash_path_component() {
    use ::fixt::prelude::*;

    let bytes: Vec<u8> = U8Fixturator::new(Unpredictable).take(5).collect();

    let component = Component::from(bytes.clone());

    assert_eq!(bytes, component.as_ref(),);

    assert_eq!(
        Component::from(vec![102, 0, 0, 0, 111, 0, 0, 0, 111, 0, 0, 0]),
        Component::from("foo"),
    );

    assert_eq!(
        String::try_from(&Component::from(vec![
            102, 0, 0, 0, 111, 0, 0, 0, 111, 0, 0, 0,
        ]))
        .unwrap(),
        String::from("foo"),
    );

    assert_eq!(
        String::try_from(&Component::from(vec![1])),
        Err(SerializedBytesError::Deserialize(
            "attempted to create u32s from utf8 bytes of length not a factor of 4: length 1".into()
        )),
    );
    assert_eq!(
        String::try_from(&Component::from(vec![9, 9, 9, 9])),
        Err(SerializedBytesError::Deserialize(
            "unknown char for u32: 151587081".into()
        )),
    );
}

#[test]
#[cfg(test)]
fn hash_path_path() {
    use ::fixt::prelude::*;

    let components: Vec<Component> = {
        let mut vec = vec![];
        for _ in 0..10 {
            let bytes: Vec<u8> = U8Fixturator::new(Unpredictable).take(10).collect();
            vec.push(Component::from(bytes))
        }
        vec
    };

    assert_eq!(&components, Path::from(components.clone()).as_ref(),);

    for (input, output) in vec![
        ("", vec![]),
        (".", vec![]),
        (".foo", vec![Component::from("foo")]),
        ("foo", vec![Component::from("foo")]),
        ("foo.", vec![Component::from("foo")]),
        (".foo.", vec![Component::from("foo")]),
        (
            ".foo.bar",
            vec![Component::from("foo"), Component::from("bar")],
        ),
        (
            ".foo.bar.",
            vec![Component::from("foo"), Component::from("bar")],
        ),
        (
            "foo.bar",
            vec![Component::from("foo"), Component::from("bar")],
        ),
        (
            "foo.bar.",
            vec![Component::from("foo"), Component::from("bar")],
        ),
        (
            "foo..bar",
            vec![Component::from("foo"), Component::from("bar")],
        ),
        (
            "foo.1:3#abcdef",
            vec![
                Component::from("foo"),
                Component::from("a"),
                Component::from("b"),
                Component::from("c"),
                Component::from("abcdef"),
            ],
        ),
        (
            "foo.2:3#zzzzzzzzzz",
            vec![
                Component::from("foo"),
                Component::from("zz"),
                Component::from("zz"),
                Component::from("zz"),
                Component::from("zzzzzzzzzz"),
            ],
        ),
        (
            "foo.1:3#abcdef.bar",
            vec![
                Component::from("foo"),
                Component::from("a"),
                Component::from("b"),
                Component::from("c"),
                Component::from("abcdef"),
                Component::from("bar"),
            ],
        ),
    ] {
        assert_eq!(Path::from(input), Path::from(output),);
    }

    let path = "foo.a.b.c.abcdef.bar";
    let path_to_string: String = Path::from(path).try_into().unwrap();
    assert_eq!(path.to_string(), path_to_string,);
}



================================================
File: crates/hdi/src/hash_path/shard.rs
================================================
use crate::hash_path::path::Component;
use crate::hash_path::path::Path;
use std::str::FromStr;

/// Separates the shard width and depth.
pub const SHARDSPLIT: &str = ":";
/// Terminates the end of a shard shorthand.
pub const SHARDEND: &str = "#";

/// The width of a shard is how many bytes/characters to use for each path component in sharding.
/// e.g. abcdef with width 1 shards to a.b.c.d.e.f.abcdef and 2 shards to ab.cd.ef.abcdef.
pub type ShardWidth = u32;
/// The depth of a shard is the number of path components to stretch out for shards.
/// e.g. abcdef with a depth of 1 and width 1 shards to a.abcdef and depth 2 shards to a.b.abcdef.
pub type ShardDepth = u32;

#[derive(Debug)]
/// A valid strategy for sharding requires both a width and a depth.
/// At the moment sharding only works well for data that is reliably longer than width/depth.
/// For example, sharding the username foo with width 4 doesn't make sense.
/// There is no magic padding or extending of the provided data to make up undersized shards.
// @todo stretch short shards out in a nice balanced way (append some bytes from the hash?)
pub struct ShardStrategy(ShardWidth, ShardDepth);

/// impl [`ShardStrategy`] as an immutable/read-only thingy.
impl ShardStrategy {
    fn width(&self) -> ShardWidth {
        self.0
    }

    fn depth(&self) -> ShardDepth {
        self.1
    }
}

#[derive(Debug)]
pub enum ParseShardStrategyError {
    /// Could not parse the shard depth.
    BadDepth,
    /// Could not parse the shard width.
    BadWidth,
    /// Failed to find the separator between width and depth.
    ShardSplitNotFound,
    /// Failed to find the end of the sharding definition.
    ShardEndNotFound,
    /// The sharding definition does not start with a number.
    FirstCharNotADigit,
    /// The sharding definition is empty.
    EmptyString,
}

/// Attempt to parse a "width:depth#" shard out of a string.
/// This function looks way scarier than it is.
/// Each level of nesting is just handling a potential parse failure.
impl FromStr for ShardStrategy {
    type Err = ParseShardStrategyError;

    /// A shard strategy is parsed as "width:depth#..." at the start of a string.
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        // The first char needs to be a digit.
        match s.chars().next() {
            Some(first_char) => {
                match u32::from_str(&first_char.to_string()) {
                    Ok(_) => {
                        // There needs to be a #
                        match s.find(SHARDEND) {
                            Some(end_index) => {
                                let (maybe_strategy, _) = s.split_at(end_index);
                                match maybe_strategy.find(SHARDSPLIT) {
                                    Some(split_index) => {
                                        let (maybe_width, maybe_depth) =
                                            maybe_strategy.split_at(split_index);
                                        match u32::from_str(maybe_width) {
                                            Ok(width) => {
                                                match u32::from_str(
                                                    maybe_depth.trim_start_matches(SHARDSPLIT),
                                                ) {
                                                    Ok(depth) => Ok(ShardStrategy(width, depth)),
                                                    Err(_) => {
                                                        Err(ParseShardStrategyError::BadDepth)
                                                    }
                                                }
                                            }
                                            Err(_) => Err(ParseShardStrategyError::BadWidth),
                                        }
                                    }
                                    None => Err(ParseShardStrategyError::ShardSplitNotFound),
                                }
                            }
                            None => Err(ParseShardStrategyError::ShardEndNotFound),
                        }
                    }
                    Err(_) => Err(ParseShardStrategyError::FirstCharNotADigit),
                }
            }
            None => Err(ParseShardStrategyError::EmptyString),
        }
    }
}

/// Builds a path for a shard strategy and some binary bytes.
/// This is the trivial case, we just split the bytes out one by one and make a path from it.
impl From<(&ShardStrategy, &[u8])> for Path {
    fn from((strategy, bytes): (&ShardStrategy, &[u8])) -> Path {
        let full_length = strategy.width() * strategy.depth();
        // Fold a flat slice of bytes into `strategy.depth` number of `strategy.width` length byte
        // [`Component`]s.
        let sharded: Vec<Component> = bytes
            .iter()
            .take(full_length as _)
            .fold((vec![], vec![]), |acc, b| {
                let (mut ret, mut build) = acc;
                build.push(b);
                if build.len() == strategy.width() as usize {
                    ret.push(build.clone());
                    build.clear();
                }
                (ret, build)
            })
            .0
            .iter()
            .map(|bytes| {
                let bytes_vec: Vec<u8> = bytes.iter().map(|b| **b).collect();
                Component::from(bytes_vec)
            })
            .collect();
        Path::from(sharded)
    }
}
/// Wrapper around `&Vec<u8>` to work the same as &[u8].
impl From<(&ShardStrategy, &Vec<u8>)> for Path {
    fn from((strategy, bytes): (&ShardStrategy, &Vec<u8>)) -> Path {
        let bytes: &[u8] = bytes.as_ref();
        Path::from((strategy, bytes))
    }
}
/// Wrapper around `Vec<u8>` to work the same as &[u8].
impl From<(&ShardStrategy, Vec<u8>)> for Path {
    fn from((strategy, bytes): (&ShardStrategy, Vec<u8>)) -> Path {
        let bytes: &[u8] = bytes.as_ref();
        Path::from((strategy, bytes))
    }
}
/// Create [`Path`] from [`String`].
/// To ensure that this works for all utf8, which can have anywhere from 1-4 bytes for a single
/// character, we first represent each character as a utf32 so it gets padded out with 0 bytes.
/// This means the width is 4x what it would be for raw bytes with the same strategy.
impl From<(&ShardStrategy, &str)> for Path {
    fn from((strategy, s): (&ShardStrategy, &str)) -> Path {
        // Truncate the string to only relevant chars.
        let full_length = strategy.width() * strategy.depth();
        let shard_string: String = s.chars().take(full_length as _).collect();

        Path::from((
            &ShardStrategy(
                // Relies on the fact that we're encoding string characters as fixed width u32
                // bytes rather than variable width utf8 bytes.
                strategy.width() * std::mem::size_of::<u32>() as u32,
                strategy.depth(),
            ),
            // Defer to the standard utf32 string handling to get the fixed size byte and endian
            // handling correct.
            Component::from(&shard_string).as_ref(),
        ))
    }
}

/// [`&String`](std::string::String) wrapper mimicking [`&str`] for [`Path`] building.
impl From<(&ShardStrategy, &String)> for Path {
    fn from((strategy, s): (&ShardStrategy, &String)) -> Path {
        Path::from((strategy, s.as_str()))
    }
}
// [`String`] wrapper mimicking [`&str`] for [`Path`] building.
impl From<(&ShardStrategy, String)> for Path {
    fn from((strategy, s): (&ShardStrategy, String)) -> Path {
        Path::from((strategy, s.as_str()))
    }
}

#[test]
#[cfg(test)]
fn hash_path_shard_bytes() {
    for (width, depth, b, output) in vec![
        // Anything with a zero results in an empty path.
        (0, 0, vec![1, 2, 3, 4, 5], Path::from(vec![])),
        (0, 1, vec![1, 2, 3, 4, 5], Path::from(vec![])),
        (1, 0, vec![1, 2, 3, 4, 5], Path::from(vec![])),
        (0, 2, vec![1, 2, 3, 4, 5], Path::from(vec![])),
        (2, 0, vec![1, 2, 3, 4, 5], Path::from(vec![])),
        // Basic sharding behaviour.
        (
            1,
            1,
            vec![1, 2, 3, 4, 5],
            Path::from(vec![Component::from(vec![1_u8])]),
        ),
        (
            2,
            1,
            vec![1, 2, 3, 4, 5],
            Path::from(vec![Component::from(vec![1_u8, 2_u8])]),
        ),
        (
            1,
            2,
            vec![1, 2, 3, 4, 5],
            Path::from(vec![
                Component::from(vec![1_u8]),
                Component::from(vec![2_u8]),
            ]),
        ),
        (
            2,
            2,
            vec![1, 2, 3, 4, 5],
            Path::from(vec![
                Component::from(vec![1_u8, 2_u8]),
                Component::from(vec![3_u8, 4_u8]),
            ]),
        ),
    ] {
        assert_eq!(output, Path::from((&ShardStrategy(width, depth), &b)));
        let bytes: &[u8] = b.as_ref();
        assert_eq!(output, Path::from((&ShardStrategy(width, depth), bytes)));
        assert_eq!(output, Path::from((&ShardStrategy(width, depth), b)));
    }
}

#[test]
#[cfg(test)]
fn hash_path_shard_string() {
    for (width, depth, s, output) in vec![
        // Anything with a zero results in an empty path.
        (0, 0, "foobar", Path::from("")),
        (0, 1, "foobar", Path::from("")),
        (1, 0, "foobar", Path::from("")),
        (0, 2, "foobar", Path::from("")),
        (2, 0, "foobar", Path::from("")),
        // Basic sharding behaviour.
        (1, 1, "foobar", Path::from("f")),
        (2, 1, "foobar", Path::from("fo")),
        (1, 2, "foobar", Path::from("f.o")),
        (2, 2, "foobar", Path::from("fo.ob")),
        // Multibyte characters should be handled the way a naive understanding of strings would
        // expect, i.e. that a 2-byte utf8 character is represented as 1 4-byte utf32 character and
        // so counts as 1 "width" and 1 "depth" for the purpose of sharding.
        (2, 2, "", Path::from(".")),
        // If the string is shorter than the width and depth we go as deep as we can cleanly and
        // truncate the end.
        (4, 4, "foobar", Path::from("foob")),
        (4, 4, "foobarbaz", Path::from("foob.arba")),
        (4, 4, "", Path::from(".")),
    ] {
        assert_eq!(output, Path::from((&ShardStrategy(width, depth), s)));
        assert_eq!(
            output,
            Path::from((&ShardStrategy(width, depth), s.to_string()))
        );
        assert_eq!(
            output,
            Path::from((&ShardStrategy(width, depth), &s.to_string()))
        );
    }
}



================================================
File: crates/hdi/src/link/examples.rs
================================================
//! Example Link Types
//!
//! # Examples
//!
//! ```
//! use hdi::prelude::*;
//! #[hdk_link_types]
//! pub enum SomeLinkTypes {
//!     SomeLinkType,
//!     SomeOtherLinkType,
//! }
//! assert_eq!(__num_link_types(), 2);
//! ```
use crate::prelude::*;

#[hdk_link_types]
/// This is an example of declaring your link types.
pub enum SomeLinkTypes {
    SomeLinkType,
    SomeOtherLinkType,
}



================================================
File: crates/hdi/src/op/test.rs
================================================
use super::*;
use crate as hdi;
use crate::test_utils::set_zome_types;
use crate::test_utils::short_hand::*;
use test_case::test_case;

#[hdk_entry_helper]
#[derive(Clone, PartialEq, Eq)]
pub struct A;
#[hdk_entry_helper]
#[derive(Clone, PartialEq, Eq)]
pub struct B;
#[hdk_entry_helper]
#[derive(Clone, PartialEq, Eq)]
pub struct C;

#[hdk_entry_helper]
#[derive(Clone, PartialEq, Eq, Default)]
pub struct D {
    a: (),
    b: (),
}

#[hdk_entry_types(skip_hdk_extern = true)]
#[unit_enum(UnitEntryTypes)]
#[derive(Clone, PartialEq, Eq)]
pub enum EntryTypes {
    A(A),
    #[entry_type(visibility = "private")]
    B(B),
    C(C),
}
#[hdk_link_types(skip_no_mangle = true)]
pub enum LinkTypes {
    A,
    B,
    C,
}

#[test_case(0, 100 => matches Err(WasmErrorInner::Guest(_)) ; "entry type is out of range")]
#[test_case(100, 0 => matches Ok(None) ; "zome id is out of range")]
#[test_case(0, 0 => matches Ok(Some(UnitEntryTypes::A)) ; "unit a")]
#[test_case(0, 1 => matches Ok(Some(UnitEntryTypes::B)) ; "unit b")]
#[test_case(0, 2 => matches Ok(Some(UnitEntryTypes::C)) ; "unit c")]
fn test_get_unit_entry_type(
    zome_index: u8,
    entry_type: u8,
) -> Result<Option<UnitEntryTypes>, WasmErrorInner> {
    set_zome_types(&[(0, 3)], &[(0, 3)]);
    get_unit_entry_type::<EntryTypes>(zome_index.into(), entry_type.into()).map_err(|e| e.error)
}

#[test_case(
    EntryType::App(public_app_entry_def(0, 0))
    => matches Ok(ActivityEntry::App{entry_type: Some(UnitEntryTypes::A), ..}) ; "unit a")]
#[test_case(
    EntryType::App(public_app_entry_def(0, 1))
    => matches Ok(ActivityEntry::App{entry_type: Some(UnitEntryTypes::B), ..}) ; "unit b")]
#[test_case(
    EntryType::App(public_app_entry_def(0, 2))
    => matches Ok(ActivityEntry::App{entry_type: Some(UnitEntryTypes::C), ..}) ; "unit c")]
#[test_case(
    EntryType::App(private_app_entry_def(0, 0))
    => matches Ok(ActivityEntry::PrivateApp{entry_type: Some(UnitEntryTypes::A), ..}) ; "private unit a")]
#[test_case(
    EntryType::App(private_app_entry_def(0, 1))
    => matches Ok(ActivityEntry::PrivateApp{entry_type: Some(UnitEntryTypes::B), ..}) ; "private unit b")]
#[test_case(
    EntryType::App(private_app_entry_def(0, 2))
    => matches Ok(ActivityEntry::PrivateApp{entry_type: Some(UnitEntryTypes::C), ..}) ; "private unit c")]
#[test_case(EntryType::AgentPubKey => matches Ok(ActivityEntry::Agent(_)); "agent")]
#[test_case(EntryType::CapClaim => matches Ok(ActivityEntry::CapClaim(_)); "cap claim")]
#[test_case(EntryType::CapGrant => matches Ok(ActivityEntry::CapGrant(_)); "cap grant")]
#[test_case(EntryType::App(public_app_entry_def(0, 3)) => matches Err(WasmErrorInner::Guest(_)) ; "entry type out of range")]
#[test_case(EntryType::App(private_app_entry_def(0, 3)) => matches Err(WasmErrorInner::Guest(_)) ; "private entry type out of range")]
#[test_case(
    EntryType::App(public_app_entry_def(1, 0))
    => matches Ok(ActivityEntry::App{entry_type: None, ..}) ; "zome out of range")]
#[test_case(
    EntryType::App(private_app_entry_def(1, 0))
    => matches Ok(ActivityEntry::PrivateApp{entry_type: None, ..}) ; "private entry, zome out of range")]
fn test_activity_entry(
    entry_type: EntryType,
) -> Result<ActivityEntry<UnitEntryTypes>, WasmErrorInner> {
    set_zome_types(&[(0, 3)], &[(0, 3)]);
    activity_entry::<EntryTypes>(&entry_type, &eh(0)).map_err(|e| e.error)
}

#[test_case(
    public_app_entry_def(0, 0), Some(&e(A{}))
    => matches Ok(UnitEnumEither::Enum(EntryTypes::A(A{}))) ; "a")]
#[test_case(
    public_app_entry_def(0, 1), Some(&e(B{}))
    => matches Ok(UnitEnumEither::Enum(EntryTypes::B(B{}))) ; "b")]
#[test_case(
    public_app_entry_def(0, 2), Some(&e(C{}))
    => matches Ok(UnitEnumEither::Enum(EntryTypes::C(C{}))) ; "c")]
#[test_case(
    private_app_entry_def(0, 0), None
    => matches Ok(UnitEnumEither::Unit(UnitEntryTypes::A)) ; "private a")]
#[test_case(
    private_app_entry_def(0, 1), None
    => matches Ok(UnitEnumEither::Unit(UnitEntryTypes::B)) ; "private b")]
#[test_case(
    private_app_entry_def(0, 2), None
    => matches Ok(UnitEnumEither::Unit(UnitEntryTypes::C)) ; "private c")]
#[test_case(
    public_app_entry_def(0, 0), Some(&e(D::default()))
    => matches Err(WasmErrorInner::Serialize(_)) ; "deserialization failure")]
#[test_case(
    public_app_entry_def(0, 3), Some(&e(A{}))
    => matches Err(WasmErrorInner::Guest(_)) ; "entry type out of range")]
#[test_case(
    private_app_entry_def(0, 3), None
    => matches Err(WasmErrorInner::Guest(_)) ; "private entry type out of range")]
#[test_case(
    public_app_entry_def(1, 0), Some(&e(A{}))
    => matches Err(WasmErrorInner::Host(_)) ; "zome id out of range")]
#[test_case(
    private_app_entry_def(1, 0), None
    => matches Err(WasmErrorInner::Host(_)) ; "private entry zome id out of range")]
#[test_case(
    public_app_entry_def(0, 0), None
    => matches Err(WasmErrorInner::Guest(_)) ; "public entry missing")]
#[test_case(
    private_app_entry_def(0, 0), Some(&e(A{}))
    => matches Err(WasmErrorInner::Guest(_)) ; "private entry present")]
fn test_get_app_entry_type_for_record_authority(
    entry_type: AppEntryDef,
    entry: Option<&Entry>,
) -> Result<UnitEnumEither<EntryTypes>, WasmErrorInner> {
    set_zome_types(&[(0, 3)], &[(0, 3)]);
    get_app_entry_type_for_record_authority::<EntryTypes>(&entry_type, entry).map_err(|e| e.error)
}

#[test_case(0, 0 => matches Ok(LinkTypes::A) ; "a")]
#[test_case(0, 1 => matches Ok(LinkTypes::B) ; "b")]
#[test_case(0, 2 => matches Ok(LinkTypes::C) ; "c")]
#[test_case(0, 3 => matches Err(WasmErrorInner::Guest(_)) ; "link type out of scope")]
#[test_case(1, 0 => matches Err(WasmErrorInner::Host(_)) ; "zome out of scope")]
fn test_in_scope_link_type(zome_index: u8, link_type: u8) -> Result<LinkTypes, WasmErrorInner> {
    set_zome_types(&[(0, 3)], &[(0, 3)]);
    in_scope_link_type::<LinkTypes>(zome_index.into(), link_type.into()).map_err(|e| e.error)
}

#[test_case(0, 0 => matches Ok(Some(LinkTypes::A)) ; "a")]
#[test_case(0, 1 => matches Ok(Some(LinkTypes::B)) ; "b")]
#[test_case(0, 2 => matches Ok(Some(LinkTypes::C)) ; "c")]
#[test_case(0, 3 => matches Err(WasmErrorInner::Guest(_)); "link type out of scope")]
#[test_case(1, 0 => matches Ok(None) ; "zome out of scope is none")]
fn test_activity_link_type(
    zome_index: u8,
    link_type: u8,
) -> Result<Option<LinkTypes>, WasmErrorInner> {
    set_zome_types(&[(0, 3)], &[(0, 3)]);
    activity_link_type::<LinkTypes>(zome_index.into(), link_type.into()).map_err(|e| e.error)
}



================================================
File: crates/hdi/src/test_utils/short_hand.rs
================================================
use std::sync::Arc;

use crate::prelude::*;

/// Create [`EntryHash`].
pub fn eh(i: u8) -> EntryHash {
    EntryHash::from_raw_36(vec![i; 36])
}

/// Create [`ActionHash`].
pub fn ah(i: u8) -> ActionHash {
    ActionHash::from_raw_36(vec![i; 36])
}

/// Create [`AgentPubKey`].
pub fn ak(i: u8) -> AgentPubKey {
    AgentPubKey::from_raw_36(vec![i; 36])
}

/// Create [`AnyLinkableHash`].
pub fn lh(i: u8) -> AnyLinkableHash {
    AnyLinkableHash::from(EntryHash::from_raw_36(vec![i; 36]))
}

/// Create [`DnaHash`].
pub fn dh(i: u8) -> DnaHash {
    DnaHash::from_raw_36(vec![i; 36])
}

/// Create [`Op::RegisterAgentActivity`].
pub fn r_activity(action: Action) -> Op {
    Op::RegisterAgentActivity(RegisterAgentActivity {
        action: SignedHashed {
            hashed: HoloHashed {
                content: action,
                hash: ah(0),
            },
            signature: Signature([0u8; 64]),
        },
        cached_entry: None,
    })
}

/// Create [`Op::StoreRecord`].
pub fn s_record(action: Action, entry: RecordEntry) -> Op {
    Op::StoreRecord(StoreRecord {
        record: Record {
            signed_action: SignedHashed {
                hashed: HoloHashed {
                    content: action,
                    hash: ah(0),
                },
                signature: Signature([0u8; 64]),
            },
            entry,
        },
    })
}

/// Create [`Op::StoreEntry`].
pub fn s_entry(action: EntryCreationAction, entry: Entry) -> Op {
    Op::StoreEntry(StoreEntry {
        action: SignedHashed {
            hashed: HoloHashed {
                content: action,
                hash: ah(0),
            },
            signature: Signature([0u8; 64]),
        },
        entry,
    })
}

/// Create [`Op::RegisterUpdate`].
pub fn r_update(update: Update, new_entry: Option<Entry>) -> Op {
    Op::RegisterUpdate(RegisterUpdate {
        update: SignedHashed {
            hashed: HoloHashed {
                content: update,
                hash: ah(0),
            },
            signature: Signature([0u8; 64]),
        },
        new_entry,
    })
}

/// Create [`Op::RegisterDelete`].
pub fn r_delete() -> Op {
    Op::RegisterDelete(RegisterDelete {
        delete: SignedHashed {
            hashed: HoloHashed {
                content: Delete {
                    author: ak(0),
                    timestamp: Timestamp(0),
                    action_seq: 1,
                    prev_action: ah(0),
                    deletes_address: ah(2),
                    deletes_entry_address: eh(1),
                    weight: Default::default(),
                },
                hash: ah(0),
            },
            signature: Signature([0u8; 64]),
        },
    })
}

/// Create [`Op::RegisterCreateLink`].
pub fn r_create_link(zome_index: u8, link_type: u8) -> Op {
    Op::RegisterCreateLink(RegisterCreateLink {
        create_link: SignedHashed {
            hashed: HoloHashed {
                content: cl(zome_index, link_type),
                hash: ah(0),
            },
            signature: Signature([0u8; 64]),
        },
    })
}

/// Create [`Op::RegisterDeleteLink`].
pub fn r_delete_link(zome_index: u8, link_type: u8) -> Op {
    Op::RegisterDeleteLink(RegisterDeleteLink {
        delete_link: SignedHashed {
            hashed: HoloHashed {
                content: DeleteLink {
                    author: ak(0),
                    timestamp: Timestamp(0),
                    action_seq: 1,
                    prev_action: ah(0),
                    base_address: eh(0).into(),
                    link_add_address: ah(2),
                },
                hash: ah(0),
            },
            signature: Signature([0u8; 64]),
        },
        create_link: cl(zome_index, link_type),
    })
}

/// Create [`Create`].
pub fn c(entry_type: EntryType) -> Create {
    Create {
        author: ak(0),
        timestamp: Timestamp(0),
        action_seq: 1,
        prev_action: ah(0),
        entry_hash: eh(0),
        entry_type,
        weight: Default::default(),
    }
}

/// Create [`Update`].
pub fn u(entry_type: EntryType) -> Update {
    Update {
        author: ak(0),
        timestamp: Timestamp(0),
        action_seq: 1,
        prev_action: ah(0),
        entry_hash: eh(0),
        entry_type,
        weight: Default::default(),
        original_action_address: ah(1),
        original_entry_address: eh(1),
    }
}

/// Create [`CreateLink`].
pub fn cl(zome_index: u8, link_type: u8) -> CreateLink {
    CreateLink {
        author: ak(0),
        timestamp: Timestamp(0),
        action_seq: 1,
        prev_action: ah(0),
        zome_index: zome_index.into(),
        link_type: link_type.into(),
        weight: Default::default(),
        base_address: eh(0).into(),
        target_address: eh(1).into(),
        tag: ().into(),
    }
}

/// Create [`CreateLink`].
pub fn dl(link_add_address: ActionHash) -> DeleteLink {
    DeleteLink {
        author: ak(0),
        timestamp: Timestamp(0),
        action_seq: 1,
        prev_action: ah(0),
        base_address: eh(0).into(),
        link_add_address,
    }
}
/// Create [`Delete`].
pub fn d(deletes_address: ActionHash) -> Delete {
    Delete {
        author: ak(0),
        timestamp: Timestamp(0),
        action_seq: 1,
        prev_action: ah(0),
        deletes_address,
        deletes_entry_address: eh(0),
        weight: Default::default(),
    }
}

/// Create [`Dna`].
pub fn dna(dna_hash: DnaHash) -> Dna {
    Dna {
        author: ak(0),
        timestamp: Timestamp(0),
        hash: dna_hash,
    }
}

/// Create [`OpenChain`].
pub fn oc(prev_target: MigrationTarget, close_hash: ActionHash) -> OpenChain {
    OpenChain {
        author: ak(0),
        timestamp: Timestamp(0),
        action_seq: 1,
        prev_action: ah(0),
        prev_target,
        close_hash,
    }
}

/// Create [`CloseChain`].
pub fn cc(new_target: Option<MigrationTarget>) -> CloseChain {
    CloseChain {
        author: ak(0),
        timestamp: Timestamp(0),
        action_seq: 1,
        prev_action: ah(0),
        new_target,
    }
}

pub fn mp() -> MembraneProof {
    Arc::new(SerializedBytes::default())
}

/// Create [`AgentValidationPkg`].
pub fn avp(membrane_proof: Option<MembraneProof>) -> AgentValidationPkg {
    AgentValidationPkg {
        author: ak(0),
        timestamp: Timestamp(0),
        action_seq: 1,
        prev_action: ah(0),
        membrane_proof,
    }
}

/// Create [`InitZomesComplete`].
pub fn izc() -> InitZomesComplete {
    InitZomesComplete {
        author: ak(0),
        timestamp: Timestamp(0),
        action_seq: 1,
        prev_action: ah(0),
    }
}

/// Create public app [`Action::Create`].
pub fn create_entry(zome_index: u8, entry_index: u8) -> Action {
    Action::Create(c(EntryType::App(AppEntryDef {
        entry_index: entry_index.into(),
        zome_index: zome_index.into(),
        visibility: EntryVisibility::Public,
    })))
}

/// Create private app [`Action::Create`].
pub fn create_hidden_entry(zome_index: u8, entry_index: u8) -> Action {
    Action::Create(c(EntryType::App(AppEntryDef {
        entry_index: entry_index.into(),
        zome_index: zome_index.into(),
        visibility: EntryVisibility::Private,
    })))
}

/// Create [`Action::CreateLink`].
pub fn create_link(z: u8, lt: u8) -> Action {
    Action::CreateLink(cl(z, lt))
}

/// Create [`Entry`].
pub fn e(e: impl TryInto<Entry>) -> Entry {
    match e.try_into() {
        Ok(e) => e,
        Err(_) => todo!(),
    }
}

/// Create public [`AppEntryDef`].
pub fn public_app_entry_def(zome_index: u8, entry_index: u8) -> AppEntryDef {
    AppEntryDef {
        entry_index: entry_index.into(),
        zome_index: zome_index.into(),
        visibility: EntryVisibility::Public,
    }
}

/// Create private [`AppEntryDef`].
pub fn private_app_entry_def(zome_index: u8, entry_index: u8) -> AppEntryDef {
    AppEntryDef {
        entry_index: entry_index.into(),
        zome_index: zome_index.into(),
        visibility: EntryVisibility::Private,
    }
}



================================================
File: crates/hdi/tests/integration.rs
================================================
#![cfg(feature = "test_utils")]
//! Tests for the proc macros defined in [`hdk_derive`] that are
//! used at the integrity level.

use hdi::prelude::*;
use hdi::test_utils::set_zome_types;

mod op;

fn to_coords(t: impl Into<ZomeLinkTypesKey>) -> (u8, u8) {
    let t = t.into();
    (t.zome_index.0, t.type_index.0)
}

fn zome_and_link_type<T>(t: T) -> (u8, u8)
where
    T: Copy,
    ScopedLinkType: TryFrom<T, Error = WasmError>,
{
    let t: ScopedLinkType = t.try_into().unwrap();
    (t.zome_index.0, t.zome_type.0)
}

fn scoped_link_type(zome_index: u8, zome_type: u8) -> ScopedLinkType {
    ScopedLinkType {
        zome_index: zome_index.into(),
        zome_type: zome_type.into(),
    }
}

fn zome_and_entry_type<T>(t: T) -> (u8, u8)
where
    ScopedEntryDefIndex: TryFrom<T, Error = WasmError>,
{
    let t: ScopedEntryDefIndex = t.try_into().unwrap();
    (t.zome_index.0, t.zome_type.0)
}

#[test]
fn to_local_types_test_unit() {
    #[hdk_to_coordinates]
    enum Unit {
        A,
        B,
        C,
    }

    assert_eq!(to_coords(Unit::A), (0, 0));
    assert_eq!(to_coords(&Unit::A), (0, 0));
    assert_eq!(to_coords(Unit::B), (0, 1));
    assert_eq!(to_coords(Unit::C), (0, 2));
}

#[test]
/// Setting the discriminant explicitly should have no effect.
fn to_local_types_test_discriminant() {
    #[hdk_to_coordinates]
    enum Unit {
        A = 12,
        B = 3000,
        C = 1,
    }

    assert_eq!(to_coords(Unit::A), (0, 0));
    assert_eq!(to_coords(&Unit::A), (0, 0));
    assert_eq!(to_coords(Unit::B), (0, 1));
    assert_eq!(to_coords(Unit::C), (0, 2));
}

#[test]
fn to_local_types_test_nested() {
    #[hdk_to_coordinates]
    enum Nested1 {
        A,
        B,
    }

    #[hdk_to_coordinates]
    enum Nested2 {
        X,
        Y,
        Z,
    }

    #[hdk_to_coordinates]
    enum NoNesting {
        A,
        #[allow(dead_code)]
        B {
            nested: Nested2,
        },
        C,
    }

    assert_eq!(to_coords(NoNesting::A), (0, 0));
    assert_eq!(to_coords(NoNesting::A), (0, 0));
    assert_eq!(to_coords(&NoNesting::A), (0, 0));
    assert_eq!(to_coords(NoNesting::B { nested: Nested2::X }), (0, 1));
    assert_eq!(to_coords(NoNesting::B { nested: Nested2::Y }), (0, 1));
    assert_eq!(to_coords(NoNesting::B { nested: Nested2::Z }), (0, 1));
    assert_eq!(to_coords(NoNesting::C), (0, 2));

    #[hdk_to_coordinates(nested)]
    enum Nesting {
        A(Nested1),
        #[allow(dead_code)]
        B {
            nested: Nested2,
        },
        C,
        D(Nested2),
    }

    assert_eq!(to_coords(Nesting::A(Nested1::A)), (0, 0));
    assert_eq!(to_coords(Nesting::A(Nested1::B)), (0, 1));
    assert_eq!(to_coords(Nesting::A(Nested1::B)), (0, 1));
    assert_eq!(to_coords(Nesting::B { nested: Nested2::X }), (1, 0));
    assert_eq!(to_coords(Nesting::B { nested: Nested2::Y }), (1, 1));
    assert_eq!(to_coords(Nesting::B { nested: Nested2::Z }), (1, 2));
    assert_eq!(to_coords(Nesting::C), (2, 0));
    assert_eq!(to_coords(Nesting::D(Nested2::X)), (3, 0));
    assert_eq!(to_coords(Nesting::D(Nested2::Y)), (3, 1));
    assert_eq!(to_coords(Nesting::D(Nested2::Z)), (3, 2));

    assert_eq!(Nesting::ENUM_LEN, 9);
}

#[test]
fn to_zome_index_test_unit() {
    mod integrity_a {
        use super::*;
        #[hdk_link_types(skip_no_mangle = true)]
        pub enum Unit {
            A,
            B,
            C,
        }
    }

    mod integrity_b {
        use super::*;
        #[hdk_link_types(skip_no_mangle = true)]
        pub enum Unit {
            A,
            B,
            C,
        }
    }

    set_zome_types(&[], &[(0, 3)]);

    assert_eq!(zome_and_link_type(integrity_a::Unit::A), (0, 0));
    assert_eq!(zome_and_link_type(integrity_a::Unit::A), (0, 0));
    assert_eq!(zome_and_link_type(integrity_a::Unit::B), (0, 1));
    assert_eq!(zome_and_link_type(integrity_a::Unit::C), (0, 2));

    set_zome_types(&[], &[(1, 3)]);

    assert_eq!(zome_and_link_type(integrity_b::Unit::A), (1, 0));
    assert_eq!(zome_and_link_type(integrity_b::Unit::A), (1, 0));
    assert_eq!(zome_and_link_type(integrity_b::Unit::B), (1, 1));
    assert_eq!(zome_and_link_type(integrity_b::Unit::C), (1, 2));
}

mod entry_defs_to_entry_type_index_test {
    use hdi::prelude::*;

    #[derive(PartialEq, Eq)]
    #[hdk_entry_helper]
    pub struct A;
    #[derive(PartialEq, Eq)]
    #[hdk_entry_helper]
    pub struct B;
    #[derive(PartialEq, Eq)]
    #[hdk_entry_helper]
    pub struct C;

    pub mod integrity_a {
        use super::*;

        #[hdk_entry_types(skip_hdk_extern = true)]
        #[unit_enum(UnitFoo)]
        #[derive(PartialEq, Eq)]
        pub enum EntryTypes {
            A(A),
            B(B),
            C(C),
        }
    }

    pub mod integrity_b {
        use super::*;

        #[hdk_entry_types(skip_hdk_extern = true)]
        #[unit_enum(UnitFoo)]
        pub enum EntryTypes {
            A(A),
            B(B),
            C(C),
        }
    }
}
mod entry_defs_overrides_mod {
    use super::*;
    #[hdk_entry_helper]
    pub struct A;
    #[hdk_entry_types(skip_hdk_extern = true)]
    #[unit_enum(UnitFoo)]
    pub enum EntryTypes {
        #[entry_type(name = "hey")]
        A(A),
        #[entry_type(visibility = "private")]
        B(A),
        #[entry_type(required_validations = 10, cache_at_agent_activity = true)]
        C(A),
    }
}

#[test]
fn entry_defs_overrides() {
    assert_eq!(
        entry_defs_overrides_mod::entry_defs(()).unwrap(),
        EntryDefsCallbackResult::Defs(EntryDefs(vec![
            EntryDef {
                id: "hey".into(),
                visibility: Default::default(),
                required_validations: Default::default(),
                ..Default::default()
            },
            EntryDef {
                id: "b".into(),
                visibility: EntryVisibility::Private,
                required_validations: Default::default(),
                ..Default::default()
            },
            EntryDef {
                id: "c".into(),
                visibility: Default::default(),
                required_validations: RequiredValidations(10),
                cache_at_agent_activity: true,
            },
        ]))
    );
}

mod entry_defs_default_mod {
    use super::*;
    #[hdk_entry_helper]
    pub struct A;
    #[hdk_entry_types(skip_hdk_extern = true)]
    #[unit_enum(UnitFoo2)]
    pub enum EntryTypes {
        A(A),
        B(A),
        C(A),
    }
}

#[test]
fn entry_defs_default() {
    assert_eq!(
        entry_defs_default_mod::entry_defs(()).unwrap(),
        EntryDefsCallbackResult::Defs(EntryDefs(vec![
            EntryDef {
                id: "a".into(),
                visibility: Default::default(),
                required_validations: Default::default(),
                ..Default::default()
            },
            EntryDef {
                id: "b".into(),
                visibility: Default::default(),
                required_validations: Default::default(),
                ..Default::default()
            },
            EntryDef {
                id: "c".into(),
                visibility: Default::default(),
                required_validations: Default::default(),
                ..Default::default()
            },
        ]))
    );
}

#[test]
fn entry_defs_to_entry_type_index() {
    use entry_defs_to_entry_type_index_test::*;

    // Set the integrity_a scope.
    set_zome_types(&[(1, 3)], &[]);

    assert_eq!(
        zome_and_entry_type(integrity_a::EntryTypes::A(A {})),
        (1, 0)
    );
    assert_eq!(
        zome_and_entry_type(&integrity_a::EntryTypes::A(A {})),
        (1, 0)
    );
    assert_eq!(
        zome_and_entry_type(integrity_a::EntryTypes::B(B {})),
        (1, 1)
    );
    assert_eq!(
        zome_and_entry_type(integrity_a::EntryTypes::C(C {})),
        (1, 2)
    );

    assert_eq!(
        integrity_a::EntryTypes::deserialize_from_type(1, 0, &Entry::try_from(A {}).unwrap()),
        Ok(Some(integrity_a::EntryTypes::A(A {})))
    );
    assert_eq!(
        integrity_a::EntryTypes::deserialize_from_type(1, 1, &Entry::try_from(A {}).unwrap()),
        Ok(Some(integrity_a::EntryTypes::B(B {})))
    );
    assert_eq!(
        integrity_a::EntryTypes::deserialize_from_type(1, 2, &Entry::try_from(A {}).unwrap()),
        Ok(Some(integrity_a::EntryTypes::C(C {})))
    );

    assert!(
        integrity_a::EntryTypes::deserialize_from_type(1, 20, &Entry::try_from(A {}).unwrap())
            .is_err()
    );
    assert_eq!(
        integrity_a::EntryTypes::deserialize_from_type(0, 0, &Entry::try_from(A {}).unwrap()),
        Ok(None)
    );

    // Set the integrity_b scope.
    set_zome_types(&[(12, 3)], &[]);

    assert_eq!(
        zome_and_entry_type(integrity_b::EntryTypes::A(A {})),
        (12, 0)
    );
    assert_eq!(
        zome_and_entry_type(&integrity_b::EntryTypes::A(A {})),
        (12, 0)
    );
    assert_eq!(
        zome_and_entry_type(integrity_b::EntryTypes::B(B {})),
        (12, 1)
    );
    assert_eq!(
        zome_and_entry_type(integrity_b::EntryTypes::C(C {})),
        (12, 2)
    );

    assert!(matches!(
        integrity_b::EntryTypes::deserialize_from_type(12, 0, &Entry::try_from(A {}).unwrap()),
        Ok(Some(integrity_b::EntryTypes::A(A {})))
    ));
    assert!(matches!(
        integrity_b::EntryTypes::deserialize_from_type(12, 1, &Entry::try_from(A {}).unwrap()),
        Ok(Some(integrity_b::EntryTypes::B(B {})))
    ));
    assert!(matches!(
        integrity_b::EntryTypes::deserialize_from_type(12, 2, &Entry::try_from(A {}).unwrap()),
        Ok(Some(integrity_b::EntryTypes::C(C {})))
    ));

    assert!(matches!(
        integrity_b::EntryTypes::deserialize_from_type(0, 20, &Entry::try_from(A {}).unwrap()),
        Ok(None)
    ));
    assert!(matches!(
        integrity_b::EntryTypes::deserialize_from_type(0, 0, &Entry::try_from(A {}).unwrap()),
        Ok(None)
    ));
}

#[test]
fn link_types_from_action() {
    #[hdk_link_types(skip_no_mangle = true)]
    pub enum LinkTypes {
        A,
        B,
        C,
    }
    set_zome_types(&[], &[(1, 3)]);
    assert_eq!(
        LinkTypes::try_from(scoped_link_type(1, 0)),
        Ok(LinkTypes::A)
    );
    assert_eq!(
        LinkTypes::try_from(scoped_link_type(1, 1)),
        Ok(LinkTypes::B)
    );
    assert_eq!(
        LinkTypes::try_from(scoped_link_type(1, 2)),
        Ok(LinkTypes::C)
    );
    assert!(LinkTypes::try_from(scoped_link_type(1, 50)).is_err());
    assert!(LinkTypes::try_from(scoped_link_type(0, 1)).is_err());
}

#[test]
fn link_types_to_global() {
    #[hdk_link_types(skip_no_mangle = true)]
    pub enum LinkTypes {
        A,
        B,
        C,
    }

    assert_eq!(__num_link_types(), 3);
}



================================================
File: crates/hdi/tests/op/mod.rs
================================================
use super::set_zome_types;
use hdi::prelude::*;
use hdi::test_utils::short_hand::*;
use test_case::test_case;

#[hdk_entry_helper]
#[derive(Clone, PartialEq, Eq)]
pub struct A;
#[hdk_entry_helper]
#[derive(Clone, PartialEq, Eq)]
pub struct B;
#[hdk_entry_helper]
#[derive(Clone, PartialEq, Eq)]
pub struct C;

#[hdk_entry_helper]
#[derive(Clone, PartialEq, Eq, Default)]
pub struct D {
    a: (),
    b: (),
}

#[hdk_entry_types(skip_hdk_extern = true)]
#[unit_enum(UnitEntryTypes)]
#[derive(Clone, PartialEq, Eq)]
pub enum EntryTypes {
    A(A),
    #[entry_type(visibility = "private")]
    B(B),
    C(C),
}
#[hdk_link_types(skip_no_mangle = true)]
pub enum LinkTypes {
    A,
    B,
    C,
}

// Register Agent Activity
#[test_case(r_activity(create_entry(0, 100)) => matches WasmErrorInner::Guest(_))]
#[test_case(r_activity(create_link(0, 100)) => matches WasmErrorInner::Guest(_))]
// Store Record
#[test_case(s_record(create_hidden_entry(0, 100), RecordEntry::Hidden) => matches WasmErrorInner::Guest(_))]
#[test_case(s_record(
    create_hidden_entry(100, 0),
    RecordEntry::Hidden) => matches WasmErrorInner::Host(_) ; "Store Record: with hidden entry and zome out of scope")]
#[test_case(s_record(create_entry(0, 0), RecordEntry::Present(e(D::default()))) => WasmErrorInner::Serialize(SerializedBytesError::Deserialize("invalid type: map, expected unit struct A".to_string())))]
#[test_case(s_record(create_entry(0, 100), RecordEntry::Present(e(A{}))) => matches WasmErrorInner::Guest(_))]
#[test_case(s_record(create_entry(100, 0), RecordEntry::Present(e(A{}))) => matches WasmErrorInner::Host(_))]
// Not quite sure why, but sometimes this is a Guest and sometimes a Host error
#[test_case(s_record(create_entry(0, 0), RecordEntry::Present(Entry::Agent(ak(0)))) => with |_| {})]
#[test_case(s_record(create_hidden_entry(0, 0), RecordEntry::Present(e(A{}))) => matches WasmErrorInner::Guest(_))]
#[test_case(s_record(create_hidden_entry(0, 100), RecordEntry::NA) => matches WasmErrorInner::Guest(_))]
#[test_case(s_record(create_link(0, 100), RecordEntry::NA) => matches WasmErrorInner::Guest(_))]
#[test_case(s_record(create_link(100, 0), RecordEntry::NA) => matches WasmErrorInner::Host(_))]
// Store Entry
#[test_case(s_entry(c(EntryType::App(public_app_entry_def(0, 100))).into(), e(A{})) => matches WasmErrorInner::Guest(_))]
#[test_case(s_entry(c(EntryType::App(public_app_entry_def(100, 0))).into(), e(A{})) => matches WasmErrorInner::Host(_))]
#[test_case(s_entry(c(EntryType::App(public_app_entry_def(0, 0))).into(), e(D::default())) => matches WasmErrorInner::Serialize(_))]
#[test_case(s_entry(c(EntryType::CapClaim).into(), e(A{})) => matches WasmErrorInner::Guest(_))]
#[test_case(s_entry(c(EntryType::CapGrant).into(), e(A{})) => matches WasmErrorInner::Guest(_))]
// RegisterUpdate
#[test_case(r_update(
    u(EntryType::App(public_app_entry_def(0, 0))), Some(e(D::default())))
    => matches WasmErrorInner::Serialize(_) ; "Register Update: new entry fails to deserialize")]
#[test_case(r_update(
    u(EntryType::App(public_app_entry_def(0, 0))), None)
    => matches WasmErrorInner::Guest(_) ; "Register Update: new entry is missing")]
#[test_case(r_update(
    u(EntryType::App(private_app_entry_def(0, 0))), Some(e(A{})))
    => matches WasmErrorInner::Guest(_) ; "Register Update: new entry is private but also present")]
#[test_case(r_update(
    u(EntryType::App(public_app_entry_def(0, 100))), Some(e(A{})))
    => matches WasmErrorInner::Guest(_) ; "Register Update: entry type is out of range")]
#[test_case(r_update(
    u(EntryType::App(public_app_entry_def(100, 0))), Some(e(A{})))
    => matches WasmErrorInner::Host(_) ; "Register Update: zome id is out of range")]
#[test_case(r_create_link(0, 100) => matches WasmErrorInner::Guest(_) ; "Register Create Link: link type out of range")]
#[test_case(r_create_link(100, 0) => matches WasmErrorInner::Host(_) ; "Register Create Link: zome id out of range")]
#[test_case(r_delete_link(0, 100) => matches WasmErrorInner::Guest(_) ; "Register Delete Link: link type out of range")]
#[test_case(r_delete_link(100, 0) => matches WasmErrorInner::Host(_) ; "Register Delete Link: zome id out of range")]
fn op_errors(op: Op) -> WasmErrorInner {
    set_zome_types(&[(0, 3)], &[(0, 3)]);
    op.flattened::<EntryTypes, LinkTypes>().unwrap_err().error
}

// Register Agent Activity
#[test_case(FlatOp::RegisterAgentActivity(OpActivity::CreateEntry { action: c(EntryType::App(public_app_entry_def(0, 0))), app_entry_type: Some(UnitEntryTypes::A) }))]
#[test_case(FlatOp::RegisterAgentActivity(OpActivity::CreateEntry { action: c(EntryType::App(public_app_entry_def(200, 0))), app_entry_type: None }))]
#[test_case(FlatOp::RegisterAgentActivity(OpActivity::CreateCapClaim{ action: c(EntryType::CapClaim)}))]
#[test_case(FlatOp::RegisterAgentActivity(OpActivity::CreateCapGrant{ action: c(EntryType::CapGrant)}))]
#[test_case(FlatOp::RegisterAgentActivity(OpActivity::CreatePrivateEntry { action: c(EntryType::App(private_app_entry_def(0, 0))), app_entry_type: Some(UnitEntryTypes::A) }))]
#[test_case(FlatOp::RegisterAgentActivity(OpActivity::CreatePrivateEntry { action: c(EntryType::App(private_app_entry_def(200, 0))), app_entry_type: None }))]
#[test_case(FlatOp::RegisterAgentActivity(OpActivity::CreateAgent { action: c(EntryType::AgentPubKey), agent: ak(0)}))]
#[test_case(FlatOp::RegisterAgentActivity(OpActivity::UpdateEntry { action: u(EntryType::App(public_app_entry_def(0, 0))), original_action_hash: ah(1), original_entry_hash: eh(1), app_entry_type: Some(UnitEntryTypes::A) }))]
#[test_case(FlatOp::RegisterAgentActivity(OpActivity::UpdateEntry { action: u(EntryType::App(public_app_entry_def(200, 0))), original_action_hash: ah(1), original_entry_hash: eh(1), app_entry_type: None }))]
#[test_case(FlatOp::RegisterAgentActivity(OpActivity::UpdatePrivateEntry { action: u(EntryType::App(private_app_entry_def(0, 0))), original_action_hash: ah(1), original_entry_hash: eh(1), app_entry_type: Some(UnitEntryTypes::A)}))]
#[test_case(FlatOp::RegisterAgentActivity(OpActivity::UpdatePrivateEntry { action: u(EntryType::App(private_app_entry_def(200, 0))), original_action_hash: ah(1), original_entry_hash: eh(1), app_entry_type: None }))]
#[test_case(FlatOp::RegisterAgentActivity(OpActivity::UpdateAgent { action: u(EntryType::AgentPubKey), new_key: ak(0), original_action_hash: ah(1), original_key: ak(1) }))]
#[test_case(FlatOp::RegisterAgentActivity(OpActivity::UpdateCapClaim { action: u(EntryType::CapClaim), original_action_hash: ah(1), original_entry_hash: eh(1) }))]
#[test_case(FlatOp::RegisterAgentActivity(OpActivity::UpdateCapGrant { action: u(EntryType::CapGrant), original_action_hash: ah(1), original_entry_hash: eh(1) }))]
#[test_case(FlatOp::RegisterAgentActivity(OpActivity::DeleteEntry { action: d(ah(0)), original_action_hash: ah(0), original_entry_hash: eh(0) }))]
#[test_case(FlatOp::RegisterAgentActivity(OpActivity::CreateLink { action: cl(0, 0), base_address: lh(0), target_address: lh(1), tag: ().into(), link_type: Some(LinkTypes::A)}))]
#[test_case(FlatOp::RegisterAgentActivity(OpActivity::CreateLink { action: cl(200, 0), base_address: lh(0), target_address: lh(1), tag: ().into(), link_type: None }))]
#[test_case(FlatOp::RegisterAgentActivity(OpActivity::DeleteLink{ action: dl(ah(0)), original_action_hash: ah(0), base_address: eh(0).into()}))]
// Action's without entries
#[test_case(FlatOp::RegisterAgentActivity(OpActivity::Dna { action: dna(dh(0)), dna_hash: dh(0)}))]
#[test_case(FlatOp::RegisterAgentActivity(OpActivity::open_chain(oc(dh(0).into(), ah(0)))))]
#[test_case(FlatOp::RegisterAgentActivity(OpActivity::close_chain(cc(Some(dh(0).into())))))]
#[test_case(FlatOp::RegisterAgentActivity(OpActivity::InitZomesComplete { action: izc()}))]
#[test_case(FlatOp::RegisterAgentActivity(OpActivity::AgentValidationPkg{ membrane_proof: None, action: avp(None) }))]
#[test_case(FlatOp::RegisterAgentActivity(OpActivity::AgentValidationPkg{ membrane_proof: Some(mp()), action: avp(Some(mp())) }))]
// Store Record
// Entries
// App Entries
#[test_case(FlatOp::StoreRecord(OpRecord::CreateEntry { action: c(EntryType::App(public_app_entry_def(0, 0))), app_entry: EntryTypes::A(A{}) }))]
#[test_case(FlatOp::StoreRecord(OpRecord::CreateEntry { action: c(EntryType::App(public_app_entry_def(0, 2))), app_entry: EntryTypes::C(C{}) }))]
#[test_case(FlatOp::StoreRecord(OpRecord::UpdateEntry { original_action_hash: ah(1), original_entry_hash: eh(1), app_entry: EntryTypes::A(A{}), action: u(EntryType::App(public_app_entry_def(0, 0))) }))]
#[test_case(FlatOp::StoreRecord(OpRecord::DeleteEntry { original_action_hash: ah(1), original_entry_hash: eh(0), action: d(ah(1)) }))]
#[test_case(FlatOp::StoreRecord(OpRecord::UpdateEntry { original_action_hash: ah(1), original_entry_hash: eh(1), app_entry: EntryTypes::C(C{}), action: u(EntryType::App(public_app_entry_def(0, 2))) }))]
// Agent Keys
#[test_case(FlatOp::StoreRecord(OpRecord::CreateAgent{ action: c(EntryType::AgentPubKey), agent: ak(0)}))]
#[test_case(FlatOp::StoreRecord(OpRecord::UpdateAgent { action: u(EntryType::AgentPubKey), original_key: ak(1), new_key: ak(0), original_action_hash: ah(1) }))]
// Private Entries
#[test_case(FlatOp::StoreRecord(OpRecord::CreatePrivateEntry { action: c(EntryType::App(private_app_entry_def(0, 0))), app_entry_type: UnitEntryTypes::A }))]
#[test_case(FlatOp::StoreRecord(OpRecord::UpdatePrivateEntry { action: u(EntryType::App(private_app_entry_def(0, 0))), original_action_hash: ah(1), original_entry_hash: eh(1), app_entry_type: UnitEntryTypes::A }))]
// Caps
#[test_case(FlatOp::StoreRecord(OpRecord::CreateCapClaim{ action: c(EntryType::CapClaim)}))]
#[test_case(FlatOp::StoreRecord(OpRecord::CreateCapGrant{ action: c(EntryType::CapGrant)}))]
#[test_case(FlatOp::StoreRecord(OpRecord::UpdateCapClaim{ action: u(EntryType::CapClaim), original_action_hash: ah(1), original_entry_hash: eh(1) }))]
#[test_case(FlatOp::StoreRecord(OpRecord::UpdateCapGrant{ action: u(EntryType::CapGrant), original_action_hash: ah(1), original_entry_hash: eh(1) }))]
// Links
#[test_case(FlatOp::StoreRecord(OpRecord::CreateLink { action: cl(0, 0), base_address: lh(0), target_address: lh(1), tag: ().into(), link_type: LinkTypes::A }))]
#[test_case(FlatOp::StoreRecord(OpRecord::DeleteLink { action: dl(ah(0)), original_action_hash: ah(0), base_address: eh(0).into() }))]
// Action's without entries
#[test_case(FlatOp::StoreRecord(OpRecord::Dna{ action: dna(dh(0)), dna_hash: dh(0)}))]
#[test_case(FlatOp::StoreRecord(OpRecord::open_chain(oc(dh(0).into(), ah(0)))))]
#[test_case(FlatOp::StoreRecord(OpRecord::close_chain(cc(Some(dh(1).into())))))]
#[test_case(FlatOp::StoreRecord(OpRecord::InitZomesComplete { action: izc() }))]
#[test_case(FlatOp::StoreRecord(OpRecord::AgentValidationPkg { action: avp(None), membrane_proof: None}))]
#[test_case(FlatOp::StoreRecord(OpRecord::AgentValidationPkg { action: avp(Some(mp())), membrane_proof: Some(mp())}))]
// Store Entry
#[test_case(FlatOp::StoreEntry(OpEntry::CreateEntry { action: c(EntryType::App(public_app_entry_def(0, 0))), app_entry: EntryTypes::A(A{}) }))]
#[test_case(FlatOp::StoreEntry(OpEntry::UpdateEntry { action: u(EntryType::App(public_app_entry_def(0, 0))), original_action_hash: ah(1), original_entry_hash: eh(1), app_entry: EntryTypes::A(A{}) }))]
#[test_case(FlatOp::StoreEntry(OpEntry::CreateAgent { action: c(EntryType::AgentPubKey), agent: ak(0)}))]
#[test_case(FlatOp::StoreEntry(OpEntry::UpdateAgent { action: u(EntryType::AgentPubKey), original_key: ak(1), new_key: ak(0), original_action_hash: ah(1) }))]
// // Error Cases
// // #[test_case(FlatOp::StoreEntry(OpEntry::CreateEntry {entry_hash: eh(0), entry_type: EntryTypes::B(B{}) }))]
// Register Update
#[test_case(FlatOp::RegisterUpdate(OpUpdate::Entry { action: u(EntryType::App(public_app_entry_def(0, 0))), app_entry: EntryTypes::A(A{}) }))]
#[test_case(FlatOp::RegisterUpdate(OpUpdate::PrivateEntry { action: u(EntryType::App(private_app_entry_def(0, 0))),  original_action_hash: ah(1), app_entry_type: UnitEntryTypes::A }))]
#[test_case(FlatOp::RegisterUpdate(OpUpdate::Agent { action: u(EntryType::AgentPubKey), original_key: ak(1), new_key: ak(0), original_action_hash: ah(1) }))]
#[test_case(FlatOp::RegisterUpdate(OpUpdate::CapClaim { action: u(EntryType::CapClaim), original_action_hash: ah(1) }))]
#[test_case(FlatOp::RegisterUpdate(OpUpdate::CapGrant { action: u(EntryType::CapGrant), original_action_hash: ah(1) }))]
// Register Delete
#[test_case(FlatOp::RegisterDelete(OpDelete { action: d(ah(0)) }))]
// Register Create Link
#[test_case(FlatOp::RegisterCreateLink { action: cl(0, 0), base_address: lh(0), target_address: lh(1), tag: ().into(), link_type: LinkTypes::A })]
#[test_case(FlatOp::RegisterCreateLink { action: cl(0, 1), base_address: lh(0), target_address: lh(1), tag: ().into(), link_type: LinkTypes::B })]
// Register Delete Link
#[test_case(FlatOp::RegisterDeleteLink { action: dl(ah(0)), original_action: cl(0, 0), base_address: eh(0).into(), target_address: eh(1).into(), tag: ().into(), link_type: LinkTypes::A })]
#[test_case(FlatOp::RegisterDeleteLink { action: dl(ah(0)), original_action: cl(0, 2), base_address: eh(0).into(), target_address: eh(1).into(), tag: ().into(), link_type: LinkTypes::C })]
fn op_flattened(op: FlatOp<EntryTypes, LinkTypes>) {
    set_zome_types(&[(0, 3)], &[(0, 3)]);
    let o = match op.clone() {
        FlatOp::StoreRecord(OpRecord::Dna { action, .. }) => {
            let d = Action::Dna(action);
            store_record_entry(d, RecordEntry::NA)
        }
        FlatOp::StoreRecord(OpRecord::AgentValidationPkg { action, .. }) => {
            let d = Action::AgentValidationPkg(action);
            store_record_entry(d, RecordEntry::NA)
        }
        FlatOp::StoreRecord(OpRecord::InitZomesComplete { action }) => {
            let d = Action::InitZomesComplete(action);
            store_record_entry(d, RecordEntry::NA)
        }
        FlatOp::StoreRecord(OpRecord::OpenChain { action, .. }) => {
            let d = Action::OpenChain(action);
            store_record_entry(d, RecordEntry::NA)
        }
        FlatOp::StoreRecord(OpRecord::CloseChain { action, .. }) => {
            let d = Action::CloseChain(action);
            store_record_entry(d, RecordEntry::NA)
        }
        FlatOp::StoreRecord(OpRecord::CreateCapClaim { action }) => {
            let d = Action::Create(action);
            store_record_entry(d, RecordEntry::Hidden)
        }
        FlatOp::StoreRecord(OpRecord::CreateCapGrant { action }) => {
            let d = Action::Create(action);
            store_record_entry(d, RecordEntry::Hidden)
        }
        FlatOp::StoreRecord(OpRecord::UpdateCapClaim { action, .. }) => {
            let u = Action::Update(action);
            store_record_entry(u, RecordEntry::Hidden)
        }
        FlatOp::StoreRecord(OpRecord::UpdateCapGrant { action, .. }) => {
            let u = Action::Update(action);
            store_record_entry(u, RecordEntry::Hidden)
        }
        FlatOp::StoreRecord(OpRecord::CreateEntry {
            app_entry: et,
            action,
        }) => {
            let entry = RecordEntry::Present(Entry::try_from(&et).unwrap());
            let c = Action::Create(action);
            store_record_entry(c, entry)
        }
        FlatOp::StoreRecord(OpRecord::CreatePrivateEntry { action, .. }) => {
            let c = Action::Create(action);
            store_record_entry(c, RecordEntry::Hidden)
        }
        FlatOp::StoreRecord(OpRecord::CreateAgent { action, agent }) => {
            let entry = RecordEntry::Present(Entry::Agent(agent.clone()));
            let c = Action::Create(action);
            store_record_entry(c, entry)
        }
        FlatOp::StoreRecord(OpRecord::CreateLink { action, .. }) => {
            let c = Action::CreateLink(action);
            Op::StoreRecord(StoreRecord {
                record: Record {
                    signed_action: SignedHashed {
                        hashed: ActionHashed::from_content_sync(c),
                        signature: Signature(vec![82; SIGNATURE_BYTES].try_into().unwrap()),
                    },
                    entry: RecordEntry::NA,
                },
            })
        }
        FlatOp::StoreRecord(OpRecord::DeleteLink { action, .. }) => {
            let c = Action::DeleteLink(action);
            Op::StoreRecord(StoreRecord {
                record: Record {
                    signed_action: SignedHashed {
                        hashed: ActionHashed::from_content_sync(c),
                        signature: Signature(vec![82; SIGNATURE_BYTES].try_into().unwrap()),
                    },
                    entry: RecordEntry::NA,
                },
            })
        }
        FlatOp::StoreRecord(OpRecord::UpdateEntry {
            app_entry: et,
            action,
            ..
        }) => {
            let entry = RecordEntry::Present(Entry::try_from(&et).unwrap());
            let u = Action::Update(action);
            store_record_entry(u, entry)
        }
        FlatOp::StoreRecord(OpRecord::UpdatePrivateEntry { action, .. }) => {
            let u = Action::Update(action);
            store_record_entry(u, RecordEntry::Hidden)
        }
        FlatOp::StoreRecord(OpRecord::UpdateAgent {
            new_key, action, ..
        }) => {
            let entry = RecordEntry::Present(Entry::Agent(new_key.clone()));
            let u = Action::Update(action);
            store_record_entry(u, entry)
        }
        FlatOp::StoreRecord(OpRecord::DeleteEntry { action, .. }) => {
            let d = Action::Delete(action);
            store_record_entry(d, RecordEntry::NA)
        }
        FlatOp::StoreEntry(OpEntry::CreateEntry {
            app_entry: et,
            action,
        }) => {
            let entry = Entry::try_from(&et).unwrap();
            store_entry_entry(EntryCreationAction::Create(action), entry)
        }
        FlatOp::StoreEntry(OpEntry::UpdateEntry {
            app_entry: et,
            action,
            ..
        }) => {
            let entry = Entry::try_from(&et).unwrap();
            let u = EntryCreationAction::Update(action);
            store_entry_entry(u, entry)
        }
        FlatOp::StoreEntry(OpEntry::CreateAgent { action, agent }) => {
            let entry = Entry::Agent(agent.clone());
            store_entry_entry(EntryCreationAction::Create(action), entry)
        }
        FlatOp::StoreEntry(OpEntry::UpdateAgent {
            new_key, action, ..
        }) => {
            let entry = Entry::Agent(new_key.clone());
            let u = EntryCreationAction::Update(action);
            store_entry_entry(u, entry)
        }

        FlatOp::StoreEntry(_) => todo!("test these"),

        FlatOp::RegisterCreateLink { action, .. } => Op::RegisterCreateLink(RegisterCreateLink {
            create_link: SignedHashed {
                hashed: HoloHashed::from_content_sync(action),
                signature: Signature(vec![82; SIGNATURE_BYTES].try_into().unwrap()),
            },
        }),
        FlatOp::RegisterDeleteLink {
            original_action,
            action,
            ..
        } => Op::RegisterDeleteLink(RegisterDeleteLink {
            delete_link: SignedHashed {
                hashed: HoloHashed::from_content_sync(action),
                signature: Signature(vec![82; SIGNATURE_BYTES].try_into().unwrap()),
            },
            create_link: original_action,
        }),
        FlatOp::RegisterUpdate(OpUpdate::Entry {
            app_entry: et,
            action,
        }) => {
            let entry = Entry::try_from(&et).unwrap();
            Op::RegisterUpdate(RegisterUpdate {
                update: SignedHashed {
                    hashed: HoloHashed::from_content_sync(action),
                    signature: Signature(vec![82; SIGNATURE_BYTES].try_into().unwrap()),
                },
                new_entry: Some(entry),
            })
        }
        FlatOp::RegisterUpdate(OpUpdate::Agent {
            new_key, action, ..
        }) => {
            let entry = Entry::Agent(new_key.clone());
            Op::RegisterUpdate(RegisterUpdate {
                update: SignedHashed {
                    hashed: HoloHashed::from_content_sync(action),
                    signature: Signature(vec![82; SIGNATURE_BYTES].try_into().unwrap()),
                },
                new_entry: Some(entry),
            })
        }
        FlatOp::RegisterUpdate(OpUpdate::PrivateEntry { action, .. }) => {
            Op::RegisterUpdate(RegisterUpdate {
                update: SignedHashed {
                    hashed: HoloHashed::from_content_sync(action),
                    signature: Signature(vec![82; SIGNATURE_BYTES].try_into().unwrap()),
                },
                new_entry: None,
            })
        }
        FlatOp::RegisterUpdate(OpUpdate::CapClaim {
            original_action_hash: _,
            action,
        }) => Op::RegisterUpdate(RegisterUpdate {
            update: SignedHashed {
                hashed: HoloHashed::from_content_sync(action),
                signature: Signature(vec![82; SIGNATURE_BYTES].try_into().unwrap()),
            },
            new_entry: None,
        }),
        FlatOp::RegisterUpdate(OpUpdate::CapGrant { action, .. }) => {
            Op::RegisterUpdate(RegisterUpdate {
                update: SignedHashed {
                    hashed: HoloHashed::from_content_sync(action),
                    signature: Signature(vec![82; SIGNATURE_BYTES].try_into().unwrap()),
                },
                new_entry: None,
            })
        }
        FlatOp::RegisterDelete(OpDelete { action }) => Op::RegisterDelete(RegisterDelete {
            delete: SignedHashed {
                hashed: HoloHashed::from_content_sync(action),
                signature: Signature(vec![82; SIGNATURE_BYTES].try_into().unwrap()),
            },
        }),
        FlatOp::RegisterAgentActivity(activity) => {
            let r = match activity {
                OpActivity::CreateEntry {
                    action,
                    app_entry_type: _,
                } => Action::Create(action),
                OpActivity::CreatePrivateEntry {
                    action,
                    app_entry_type: _,
                } => Action::Create(action),
                OpActivity::CreateAgent { action, .. } => Action::Create(action),
                OpActivity::UpdateEntry { action, .. } => Action::Update(action),
                OpActivity::UpdatePrivateEntry { action, .. } => Action::Update(action),
                OpActivity::UpdateAgent { action, .. } => Action::Update(action),
                OpActivity::DeleteEntry { action, .. } => Action::Delete(action),
                OpActivity::CreateLink { action, .. } => Action::CreateLink(action),
                OpActivity::DeleteLink { action, .. } => Action::DeleteLink(action),
                OpActivity::CreateCapClaim { action } => Action::Create(action),
                OpActivity::CreateCapGrant { action } => Action::Create(action),
                OpActivity::UpdateCapClaim { action, .. } => Action::Update(action),
                OpActivity::UpdateCapGrant { action, .. } => Action::Update(action),
                OpActivity::Dna { action, .. } => Action::Dna(action),
                OpActivity::OpenChain { action, .. } => Action::OpenChain(action),
                OpActivity::CloseChain { action, .. } => Action::CloseChain(action),
                OpActivity::AgentValidationPkg { action, .. } => Action::AgentValidationPkg(action),
                OpActivity::InitZomesComplete { action } => Action::InitZomesComplete(action),
            };
            let r = RegisterAgentActivity {
                cached_entry: None,
                action: SignedHashed {
                    hashed: HoloHashed::from_content_sync(r),
                    signature: Signature(vec![82; SIGNATURE_BYTES].try_into().unwrap()),
                },
            };
            Op::RegisterAgentActivity(r)
        }
    };
    assert_eq!(o.flattened().unwrap(), op);
}

fn store_record_entry(action: Action, entry: RecordEntry) -> Op {
    Op::StoreRecord(StoreRecord {
        record: Record {
            signed_action: SignedHashed {
                hashed: ActionHashed::from_content_sync(action),
                signature: Signature([0u8; 64]),
            },
            entry,
        },
    })
}
fn store_entry_entry(action: EntryCreationAction, entry: Entry) -> Op {
    Op::StoreEntry(StoreEntry {
        action: SignedHashed {
            hashed: HoloHashed::from_content_sync(action),
            signature: Signature([0u8; 64]),
        },
        entry,
    })
}

#[test]
fn op_match_sanity() {
    fn empty_create() -> Create {
        Create {
            author: AgentPubKey::from_raw_36(vec![0u8; 36]),
            timestamp: Timestamp(0),
            action_seq: 1,
            prev_action: ActionHash::from_raw_36(vec![0u8; 36]),
            entry_type: EntryType::App(AppEntryDef {
                entry_index: 0.into(),
                zome_index: 0.into(),
                visibility: EntryVisibility::Public,
            }),
            entry_hash: EntryHash::from_raw_36(vec![0u8; 36]),
            weight: Default::default(),
        }
    }
    let op = Op::StoreRecord(StoreRecord {
        record: Record {
            signed_action: SignedHashed {
                hashed: ActionHashed {
                    content: Action::Create(Create {
                        entry_type: EntryType::App(AppEntryDef {
                            entry_index: 0.into(),
                            zome_index: 0.into(),
                            visibility: EntryVisibility::Public,
                        }),
                        ..empty_create()
                    }),
                    hash: ActionHash::from_raw_36(vec![1u8; 36]),
                },
                signature: Signature([0u8; 64]),
            },
            entry: RecordEntry::Present(EntryTypes::A(A {}).try_into().unwrap()),
        },
    });
    set_zome_types(&[(0, 3)], &[(0, 3)]);
    match op.flattened().unwrap() {
        FlatOp::StoreRecord(r) => match r {
            OpRecord::CreateEntry {
                app_entry: EntryTypes::A(_),
                action: _,
            } => (),
            OpRecord::CreateEntry {
                app_entry: EntryTypes::B(_),
                action: _,
            } => unreachable!(),
            OpRecord::CreateEntry {
                app_entry: EntryTypes::C(_),
                action: _,
            } => (),
            OpRecord::CreatePrivateEntry {
                app_entry_type: UnitEntryTypes::B,
                action: _,
            } => (),
            OpRecord::CreatePrivateEntry {
                app_entry_type: _, ..
            } => unreachable!(),
            OpRecord::CreateAgent { .. } => (),
            OpRecord::CreateCapClaim { .. } => (),
            OpRecord::CreateCapGrant { .. } => (),
            OpRecord::UpdateEntry {
                action: _,
                original_action_hash: _,
                original_entry_hash: _,
                app_entry: EntryTypes::A(_),
            } => (),
            OpRecord::UpdateEntry {
                action: _,
                original_action_hash: _,
                original_entry_hash: _,
                app_entry: EntryTypes::B(_),
            } => unreachable!(),
            OpRecord::UpdateEntry {
                action: _,
                original_action_hash: _,
                original_entry_hash: _,
                app_entry: EntryTypes::C(_),
            } => (),
            OpRecord::UpdatePrivateEntry {
                action: _,
                original_action_hash: _,
                original_entry_hash: _,
                app_entry_type: UnitEntryTypes::B,
            } => (),
            OpRecord::UpdatePrivateEntry { .. } => unreachable!(),
            OpRecord::UpdateAgent {
                action: _,
                original_action_hash: _,
                original_key: _,
                new_key: _,
            } => (),
            OpRecord::UpdateCapClaim {
                action: _,
                original_action_hash: _,
                original_entry_hash: _,
            } => (),
            OpRecord::UpdateCapGrant {
                action: _,
                original_action_hash: _,
                original_entry_hash: _,
            } => (),
            OpRecord::DeleteEntry {
                action: _,
                original_action_hash: _,
                original_entry_hash: _,
            } => (),
            OpRecord::CreateLink {
                base_address: _,
                target_address: _,
                tag: _,
                link_type: LinkTypes::A,
                action: _,
            } => (),
            OpRecord::CreateLink {
                base_address: _,
                target_address: _,
                tag: _,
                link_type: LinkTypes::B,
                action: _,
            } => (),
            OpRecord::CreateLink {
                base_address: _,
                target_address: _,
                tag: _,
                link_type: LinkTypes::C,
                action: _,
            } => (),
            OpRecord::DeleteLink { .. } => (),
            OpRecord::Dna { .. } => (),
            OpRecord::OpenChain { .. } => (),
            OpRecord::CloseChain { .. } => (),
            OpRecord::AgentValidationPkg { .. } => (),
            OpRecord::InitZomesComplete { .. } => (),
        },
        FlatOp::StoreEntry(_) => (),
        FlatOp::RegisterAgentActivity(_) => (),
        FlatOp::RegisterCreateLink {
            action: _,
            base_address: _,
            target_address: _,
            tag: _,
            link_type,
        } => match link_type {
            LinkTypes::A => (),
            LinkTypes::B => (),
            LinkTypes::C => (),
        },
        FlatOp::RegisterDeleteLink {
            original_action: _,
            base_address: _,
            target_address: _,
            tag: _,
            link_type,
            action: _,
        } => match link_type {
            LinkTypes::A => (),
            LinkTypes::B => (),
            LinkTypes::C => (),
        },
        FlatOp::RegisterUpdate(_) => (),
        FlatOp::RegisterDelete(_) => (),
    }
    if let FlatOp::StoreRecord(OpRecord::CreateEntry {
        action: _,
        app_entry: EntryTypes::A(_),
    }) = op.flattened::<_, ()>().unwrap()
    {}
    if let FlatOp::StoreRecord(OpRecord::CreateLink {
        link_type: LinkTypes::A,
        ..
    }) = op.flattened::<(), _>().unwrap()
    {}
    op.flattened::<(), ()>().unwrap();
}



================================================
File: crates/hdk/README.md
================================================
# hdk

<!-- cargo-rdme start -->

The Holochain Development Kit (HDK) provides high and low level functions for writing Holochain applications.

Holochain is built as a client-server architecture. The Conductor, Holochain's runtime, acts as the server.
Its [Conductor API](https://docs.rs/holochain_conductor_api/latest/holochain_conductor_api) can be queried
by a client to manage hApps and send requests to hApp functions.
[Read more on Holochain's architecture.](https://developer.holochain.org/concepts/2_application_architecture)

Functions of a hApp are organized into reusable components. In Holochain terminology these components are called "zomes".
One or multiple zomes are compiled into WebAssembly (WASM) binaries and bundled into a file referred to as a DNA. All of the DNAs of an application are bundled to a hApp.
In short, the structure is __hApp -> DNA -> zome -> function__.

hApps can be developed using the HDK. See the [Holochain Quick Start Guide](https://developer.holochain.org/quick-start)
to get started with hApp development.

## Example zomes 

There are numerous example/test WASMs on many aspects of hApp development that can be browsed
[on Github](https://github.com/holochain/holochain/tree/develop/crates/test_utils/wasm/wasm_workspace).

Each example WASM is a minimal demonstration of specific HDK functionality, such as generating random data, creating entries or defining validation callbacks.
Some of the examples are very contrived, none are intended as production grade hApp examples, but do highlight key functionality.

## Zomes are separated into data model and domain logic

hApps are required to produce and validate data deterministically. There's a data model and a domain logic part to each hApp. In Holochain, the
data model is defined in integrity zomes and the domain logic is written in coordinator zomes.

### Integrity zomes 

Integrity zomes describe a hApp's domain model by defining a set of entry and link types and providing a validation callback
function that checks the integrity of any operations that manipulate data of those types.
Additionally, a genesis self-check callback can be implemented for basic verification
of the data that allows an agent to join a network before they attempt to join it.

The wasm workspace contains examples of integrity zomes like this:
<https://github.com/holochain/holochain/blob/develop/crates/test_utils/wasm/wasm_workspace/integrity_zome/src/lib.rs>

Refer to the HDI crate for more information on the integrity layer.

### Coordinator zomes 

Coordinator zomes are the counterpart of integrity zomes in a DNA. They contain the domain logic of how data is read and written.
Whereas data is defined and validated in integrity zomes, functions to manipulate data are implemented in coordinator zomes.

An example coordinator zome can be found in the wasm workspace of the Holochain repository:
<https://github.com/holochain/holochain/blob/develop/crates/test_utils/wasm/wasm_workspace/coordinator_zome/src/lib.rs>.

## HDK structure 

HDK implements several key features:

- Base HDKT trait for standardisation, mocking, unit testing support: [`hdk`] module
- Capabilities and function level access control: [`capability`] module
- [Holochain Deterministic Integrity (HDI)]
- Application data and entry definitions for the source chain and DHT: [`entry`]
  module and [entry_types] callback
- Referencing/linking entries on the DHT together into a graph structure: [`link`] module
- Defining tree-like structures out of links and entries for discoverability and scalability: [`hash_path`] module
- Create, read, update, delete (CRUD) operations on the above
- Libsodium compatible symmetric/secret (secretbox) and asymmetric/keypair (box) encryption: [`x_salsa20_poly1305`] module
- Ed25519 signing and verification of data: [`ed25519`] module
- Exposing information about the current execution context such as zome name: [`info`] module
- Other utility functions provided by the host such as generating randomness and timestamps that are impossible in WASM: utility module
- Exposing functions to external processes and callbacks to the host: [`hdk_extern!`](macro@crate::prelude::hdk_extern) and [`map_extern!`](macro@crate::prelude::map_extern) macros
- Integration with the Rust [tracing](https://docs.rs/tracing/0.1.23/tracing/) crate
- Exposing a [`prelude`] of common types and functions for convenience

Generally these features are structured logically into modules but there are some affordances to the layering of abstractions.


## HDK is based on callbacks 

The only way to execute logic inside WASM is by having the conductor (host) call a function that is marked as an `extern` by the zome (guest).

> Note: From the perspective of hApp development in WASM, the "guest" is the WASM and the "host" is the running Holochain conductor.
> The host is _not_ the "host operating system" in this context.

Similarly, the only way for the guest to do anything other than process data and calculations is to call functions the host provides to it at runtime.

Host functions are all defined by the Holochain conductor and implemented by HDK for you, but the guest functions need to all be defined by your application.

> Any WASM that does _not_ use the HDK will need to define placeholders for and the interface to the host functions.

All host functions can be called directly as:

```rust
use crate::prelude::*;
let _output: HDK.with(|h| h.borrow().host_fn(input));
```

And every host function defined by Holochain has a convenience wrapper in HDK that does the type juggling for you.

Low-level communication between the conductor and WASM binaries, like typing and serialization of data, is abstracted by the HDK.
Using the HDK, hApp developers can focus on their application's logic. [Learn more about WASM in Holochain.](https://github.com/holochain/holochain/blob/develop/crates/hdk/ON-WASM.md)

### External callbacks = Zome functions

To extend a Rust function so that it can be called by the host, add the [`hdk_extern!`](macro@crate::prelude::hdk_extern) attribute.

- The function may take _none_ or _one_ argument that, if provided, must implement `serde::Serialize + std::fmt::Debug`.
- The function must return an `ExternResult` where the success value implements `serde::Serialize + std::fmt::Debug`
- The function must have a unique name across all externs as they share a global namespace in WASM
- Everything inside the function is Rust-as-usual including `?` to interact with `ExternResult` that fails as `WasmError`
- Use the `wasm_error!` macro along with the
  `WasmErrorInner::Guest` variant for failure conditions that the host or
  external processes need to be aware of
- Externed functions can be called as normal by other functions inside the same WASM

For example:

```rust
use crate::prelude::*;

// This function can be called by any external process that can provide and accept messagepack serialized u32 integers.
#[hdk_extern]
pub fn increment(u: u32) -> ExternResult<u32> {
  Ok(u + 1)
}

// Extern functions can be called as normal by other rust code.
assert_eq!(2, increment(1));
```

Most externs are simply available to external processes and must be called explicitly e.g. via RPC over websockets.
The external process only needs to ensure the input and output data is handled correctly as messagepack.

### Internal callbacks

Some externs act as callbacks the host will call at key points in Holochain internal system workflows.
These callbacks allow the guest to define how the host proceeds at those decision points. They are defined in zomes like
extern callbacks above, but have reserved names listed below.

Callbacks are simply called by name and they are "sparse" in that they are matched incrementally from the most specific
name to the least specific name. For example, the `validate_{{ create|update|delete }}_{{ agent|entry }}` callbacks will
all match and all run during validation. All function components with multiple options are optional, e.g. `validate` will execute and so will `validate_create`.

Holochain will merge multiple callback results for the same callback in a context sensitive manner. For example, the host will consider initialization failed if _any_ init callback fails.

The callbacks are (see above for examples):

- `fn entry_defs() -> ExternResult<EntryDefsCallbackResult>`:
  - Typically implemented automatically by macros in the HDK so does NOT
    require writing the extern for it manually.
  - `EntryDefs` is a vector defining all entries used by this app.
  - All zomes in a DNA define all their entries at the same time for the host.
  - All entry defs are combined into a single ordered list per zome and exposed to tooling such as DNA generation.
  - Entry defs are referenced by `u8` numerical position externally and in DHT actions, and by id/name e.g. "post" in sparse callbacks.
- `fn genesis_self_check(_: GenesisSelfCheckData) -> ExternResult<ValidateCallbackResult>`:
  - Allows each agent to validate itself before attempting to join the
    network.
  - Receives `GenesisSelfCheckData` that includes DNA information, the agent
    key for the candidate source chain and the membrane proof.
  - Runs _before the agent exists on the network_ so has no ability to use
    the network and generally only has access to deterministic HDK functions.
- `fn init() -> ExternResult<InitCallbackResult>`:
  - Allows the guest to pass/fail/retry initialization with `InitCallbackResult`.
  - Lazy execution - only runs when any zome of the DNA is first called.
  - All zomes in a DNA init at the same time.
  - Any zome failure fails initialization for the DNA, any zome retry (missing dependencies) causes the DNA to retry.
  - Failure overrides retry.
  - See `create_cap_grant` for an explanation of how to set up capabilities in `init`.
- `fn migrate_agent_{{ open|close }} -> ExternResult<MigrateAgentCallbackResult>`:
  - Allows the guest to pass/fail a migration attempt to/from another DNA.
  - Open runs when an agent is starting a new source chain from an old one.
  - Close runs when an agent is deprecating an old source chain in favour of a new one.
  - All zomes in a DNA migrate at the same time.
  - Any failure fails the migration.
- `fn post_commit(actions: Vec<SignedActionHashed>)`:
  - Executes after the WASM call that originated the commits so not bound by the original atomic transaction.
  - Input is all the action hashes that were committed.
  - The zome that originated the commits is called.
- `fn validate(op: Op) -> ExternResult<ValidateCallbackResult>`:
  - Allows the guest to pass/fail/retry any operation.
  - Only the originating zome is called.
  - Failure overrides retry.

## HDK has layers 

HDK is designed in layers so that there is some kind of 80/20 rule.
The code is not strictly organised this way but you'll get a feel for it as you write your own hApps.

Roughly speaking, 80% of your apps can be production ready using just 20% of the HDK features and code.
These are the 'high level' functions such as [`crate::entry::create_entry`] and macros like [`hdk_extern!`](macro@crate::prelude::hdk_extern).
Every Holochain function is available with a typed and documented wrapper and there is a set of macros for exposing functions and defining entries.

The 20% of the time that you need to go deeper there is another layer followng its own 80/20 rule.
80% of the time you can fill the gaps from the layer above with `host_call` or by writing your own entry definition logic.
For example you may want to implement generic type interfaces or combinations of structs and enums for entries that isn't handled out of the box.

If you need to go deeper still, the next layer is the `holochain_wasmer_guest`, `holochain_zome_types` and `holochain_serialization` crates.
Here you can customise exactly how your externally facing functions are called and how they serialize data and memory.
Ideally you never need to go this far but there are rare situations that may require it.
For example, you may need to accept data from an external source that cannot be messagepack serialized (e.g. json), or you may want to customise the tracing tooling and error handling.

The lowest layer is the structs and serialization that define how the host and the guest communicate.
You cannot change this but you can reimplement it in your language of choice (e.g. Haskell?) by referencing the Rust zome types and extern function signatures.


## HDK is atomic on the source chain 

[Read up on what the source chain is in Holochain.](https://developer.holochain.org/concepts/3_source_chain)

All writes to the source chain are atomic within a single extern/callback call.

This means __all data will validate and be written together or nothing will__.

There are no such guarantees for other side effects. Notably we cannot control anything over the network or outside the Holochain database.

Remote calls will be atomic on the recipients device but could complete successfully while the local agent subsequently errors and rolls back their chain.
This means you should not rely on data existing _between_ agents unless you have another source of integrity such as cryptographic countersignatures.

Use a post commit hook and signals or remote calls if you need to notify other agents about completed commits.


## HDK should be pinned 

The basic functionality of the HDK is to communicate with the Holochain conductor using a specific typed interface.

If any of the following change relative to the conductor your WASM _will_ have bugs:

- Shared types used by the host and guest to communicate
- Serialization logic that generates bytes used by cryptographic algorithms
- Negotiating shared memory between the host and guest
- Functions available to be called by the guest on the host
- Callbacks the guest needs to provide to the host

For this reason we have dedicated crates for serialization and memory handling that rarely change.
HDK references these crates with `=x.y.z` syntax in Cargo.toml to be explicit about this.

HDK itself has a slower release cycle than the Holochain conductor by design to make it easier to pin and track changes.

You should pin your dependency on HDK using the `=x.y.z` syntax too!

You do _not_ need to pin _all_ your Rust dependencies, just those that take part in defining the host/guest interface.


## HDK is integrated with rust tracing for better debugging 

Every extern defined with the [`hdk_extern!`](macro@crate::prelude::hdk_extern) attribute registers a [tracing subscriber](https://crates.io/crates/tracing-subscriber) that works in WASM.

All the basic tracing macros `trace!`, `debug!`, `warn!`, `error!` are implemented.

However, tracing spans currently do _not_ work, if you attempt to `#[instrument]`, you will likely panic your WASM.

WASM tracing can be filtered at runtime using the `WASM_LOG` environment variable that works exactly as `RUST_LOG` does for the Holochain conductor and other Rust binaries.

The most common internal errors, such as invalid deserialization between WASM and external processes, are traced as `error!` by default.


## HDK requires explicit error handling between the guest and host 

All calls to functions provided by the host can fail to execute cleanly, at the least serialization could always fail.

There are many other possibilities for failure, such as a corrupt database or attempting cryptographic operations without a key.

When the host encounters a failure `Result`, it will __serialize the error and pass it back to the WASM guest__.
The __guest must handle this error__ and either return it back to the host which _then_ rolls back writes (see above), or implement some kind of graceful failure or retry logic.

The `Result` from the host in the case of host calls indicates whether the execution _completed_ successfully and is _in addition to_ other Result-like enums.
For example, a remote call can be `Ok` from the host's perspective but contain an
`ZomeCallResponse::Unauthorized` "failure" enum variant from the remote agent.
Both need to be handled in context.

<!-- cargo-rdme end -->

License: CAL-1.0



================================================
File: crates/hdk/Cargo.toml
================================================
[package]
name = "hdk"
version = "0.5.0-dev.19"
description = "The Holochain HDK"
license = "CAL-1.0"
homepage = "https://github.com/holochain/holochain/tree/develop/crates/hdk"
documentation = "https://docs.rs/hdk"
authors = ["Holochain Core Dev Team <devcore@holochain.org>"]
keywords = ["holochain", "holo", "hdk"]
categories = ["cryptography"]
edition = "2021"

# reminder - do not use workspace deps
[dependencies]
hdi = { version = "=0.6.0-dev.15", path = "../hdi", features = ["trace"] }
hdk_derive = { version = "^0.5.0-dev.14", path = "../hdk_derive" }
holo_hash = { version = "^0.5.0-dev.7", path = "../holo_hash" }
holochain_wasmer_guest = "=0.0.99"
# it's important that we depend on holochain_zome_types with no default
# features, both here AND in hdk_derive, to reduce code bloat
holochain_zome_types = { version = "^0.5.0-dev.17", path = "../holochain_zome_types", default-features = false }
paste = "1.0"
serde = "1.0"
serde_bytes = "0.11"
thiserror = "1.0.22"
tracing = "0.1"
tracing-core = "0.1"
mockall = { version = "0.11.3", optional = true }

# When building for the WASM target, we need to configure getrandom
# to use the host system for the source of crypto-secure randomness.
# NOTE: This needs to be kept in sync with what is actually being pulled in via holo_hash and holochain_wasmer_guest
[target.'cfg(all(target_arch = "wasm32", target_os = "unknown"))'.dependencies]
getrandom = { version = "0.2", features = ["custom"] }

[dev-dependencies]
fixt = { path = "../fixt" }
trybuild = "1.0"

[lints]
workspace = true

[features]
default = ["encoding"]

mock = ["hdk_derive/mock", "mockall"]
encoding = ["holo_hash/encoding"]
fixturators = ["holochain_zome_types/fixturators", "holo_hash/fixturators"]
fuzzing = ["holochain_zome_types/fuzzing", "holo_hash/fuzzing"]
test_utils = ["fixturators", "hdi/test_utils", "holo_hash/test_utils"]
properties = ["holochain_zome_types/properties"]

unstable-functions = [
  "holochain_zome_types/unstable-functions",
  "hdi/unstable-functions",
]

unstable-countersigning = ["holochain_zome_types/unstable-countersigning"]



================================================
File: crates/hdk/CHANGELOG.md
================================================
---
default_semver_increment_mode: !pre_minor dev
---
# Changelog

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/). This project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## Unreleased

## 0.5.0-dev.19

## 0.5.0-dev.18

## 0.5.0-dev.17

- Prevent TODO comments from being rendered in cargo docs.

- Add `hdk_extern` tests

## 0.5.0-dev.16

## 0.5.0-dev.15

## 0.5.0-dev.14

- Update `holochain_wasmer_guest`.

## 0.5.0-dev.13

- Update `holochain_wasmer_guest`.

## 0.5.0-dev.12

## 0.5.0-dev.11

## 0.5.0-dev.10

## 0.5.0-dev.9

## 0.5.0-dev.8

## 0.5.0-dev.7

## 0.5.0-dev.6

## 0.5.0-dev.5

## 0.5.0-dev.4

## 0.5.0-dev.3

## 0.5.0-dev.2

## 0.5.0-dev.1

## 0.5.0-dev.0

## 0.4.0

## 0.4.0-dev.19

## 0.4.0-dev.18

## 0.4.0-dev.17

## 0.4.0-dev.16

## 0.4.0-dev.15

## 0.4.0-dev.14

## 0.4.0-dev.13

## 0.4.0-dev.12

## 0.4.0-dev.11

- Added a new HDK function `get_validation_receipts` which can be used to look up validation receipts for an action that you have authored.

## 0.4.0-dev.10

## 0.4.0-dev.9

## 0.4.0-dev.8

## 0.4.0-dev.7

## 0.4.0-dev.6

## 0.4.0-dev.5

## 0.4.0-dev.4

## 0.4.0-dev.3

## 0.4.0-dev.2

- Adds two new HDK functions `close_chain` and `open_chain` that allow `Action::CloseChain` and `Action::OpenChain` respectively, to be created. These are intended to be used for DNA migrations. There is an example in the Holochain functions tests in migration.rs \#3804

## 0.4.0-dev.1

## 0.4.0-dev.0

## 0.3.0

## 0.3.0-beta-dev.41

## 0.3.0-beta-dev.40

## 0.3.0-beta-dev.39

## 0.3.0-beta-dev.38

## 0.3.0-beta-dev.37

## 0.3.0-beta-dev.36

## 0.3.0-beta-dev.35

## 0.3.0-beta-dev.34

## 0.3.0-beta-dev.33

## 0.3.0-beta-dev.32

- Added `create_clone_cell`, `disable_clone_cell`, `enable_clone_cell` and `delete_clone_cell` functionality to the HDK. This was previously only available on the admin interface of Holochain which shouldnt be used by apps. Exposing this functionality through the HDK allows happ developers to manage clones from their backend code without having to worry about their apps breaking when more security is added to the admin interface. The only restriction on the use of these methods is that they will not permit you to create clones in another app. You can create clones of any cell within the app you make the host function calls from.
- **BREAKING**: Added parameter `GetOptions` to calls `get_links` and `get_link_details`, to allow for fetching only local data. With the default setting of this option - `Latest`, links and link details are fetched from the network. When specifically set to `Content`, the network call is skipped and the calls only consider locally available data.

## 0.3.0-beta-dev.31

## 0.3.0-beta-dev.30

## 0.3.0-beta-dev.29

## 0.3.0-beta-dev.28

## 0.3.0-beta-dev.27

## 0.3.0-beta-dev.26

## 0.3.0-beta-dev.25

## 0.3.0-beta-dev.24

## 0.3.0-beta-dev.23

- **BREAKING CHANGE** Rename `remote_signal` to `send_remote_signal` to match the grammar of other HDK functions. [\#3113](https://github.com/holochain/holochain/pull/3113)

- Remove access to `Timestamp::now()` which comes from `kitsune_p2p_timestamp` and was not supposed to be available in WASM. It would always panic in WASM calls so it should be safe to assume that nobody was actually using this in real apps. If you were trying to and this breaks your hApp then please consider using `sys_time` from the HDK instead which is safe to use for getting the current time.

## 0.3.0-beta-dev.22

## 0.3.0-beta-dev.21

- Remove types for hash paths (migrated to hdi crate). Add HdkPathExt trait to implement TypedPath functionality that requires hdk. Add TryFromPath trait to implement conversion of Path into Anchor. [\#2980](https://github.com/holochain/holochain/pull/2980)

## 0.3.0-beta-dev.20

## 0.3.0-beta-dev.19

## 0.3.0-beta-dev.18

## 0.3.0-beta-dev.17

## 0.3.0-beta-dev.16

## 0.3.0-beta-dev.15

## 0.3.0-beta-dev.14

## 0.3.0-beta-dev.13

## 0.3.0-beta-dev.12

## 0.3.0-beta-dev.11

## 0.3.0-beta-dev.10

- **BREAKING CHANGE** `get_links` no longer takes `base`, `link_type` and `link_tag` as separate inputs and now takes `GetLinksInput` instead. This can be built using a `GetLinksInputBuilder`. Links can then be filtered by `author` and created timestamp `after` and `before`. This change has been made both to make the `get_links` function consistent with what you see if you use `HDK.with`, which is always supposed to be the case, and also to increase the options for filtering getting links.

## 0.3.0-beta-dev.9

## 0.3.0-beta-dev.8

## 0.3.0-beta-dev.7

- Add String<TryInto> for Path for easy conversion of Path to string representation

## 0.3.0-beta-dev.6

## 0.3.0-beta-dev.5

- New v2 of dna info returns full modifiers not just properties. Removed from genesis self check in favour of hdk call. [\#2366](https://github.com/holochain/holochain/pull/2366).

## 0.3.0-beta-dev.4

## 0.3.0-beta-dev.3

## 0.3.0-beta-dev.2

- Add new HDK function `count_links` which accepts a filter that can be applied remotely. This is a more optimal alternative to requesting all links and counting them within a zome function.

## 0.3.0-beta-dev.1

## 0.3.0-beta-dev.0

## 0.2.0

## 0.2.0-beta-rc.6

## 0.2.0-beta-rc.5

## 0.2.0-beta-rc.4

## 0.2.0-beta-rc.3

## 0.2.0-beta-rc.2

## 0.2.0-beta-rc.1

## 0.2.0-beta-rc.0

- Add block/unblock agent functions to HDK [\#1828](https://github.com/holochain/holochain/pull/1828)
- Rewrite hdk documentation and add links to conductor API docs.

## 0.1.0

- Add note in HDK documentation about links not deduplicating. ([\#1791](https://github.com/holochain/holochain/pull/1791))

## 0.1.0-beta-rc.3

- Fix typos and links in docs and add links to wasm examples.

## 0.1.0-beta-rc.2

## 0.1.0-beta-rc.1

## 0.1.0-beta-rc.0

## 0.0.163

## 0.0.162

## 0.0.161

## 0.0.160

## 0.0.159

## 0.0.158

## 0.0.157

- Pin the *hdi* dependency version. [\#1605](https://github.com/holochain/holochain/pull/1605)

## 0.0.156

## 0.0.155

## 0.0.154

## 0.0.153

## 0.0.152

## 0.0.151

## 0.0.150

## 0.0.149

## 0.0.148

## 0.0.147

## 0.0.146

## 0.0.145

## 0.0.144

- Docs: Add example how to get a typed path from a path to `path` module [\#1505](https://github.com/holochain/holochain/pull/1505)
- Exposed `TypedPath` type in the hdk prelude for easy access from zomes.

## 0.0.143

- Docs: Add documentation on `get_links` argument `link_type`. [\#1486](https://github.com/holochain/holochain/pull/1486)
- Docs: Intra-link to `wasm_error` and `WasmErrorInner`. [\#1486](https://github.com/holochain/holochain/pull/1486)

## 0.0.142

## 0.0.141

- Docs: Add section on coordinator zomes and link to HDI crate.

## 0.0.140

## 0.0.139

- **BREAKING CHANGE:** Anchor functions, `TypedPath` and `create_link` take `ScopedLinkType: TryFrom<T>` instead of `LinkType: From<T>`.
- **BREAKING CHANGE:** `create_entry` takes `ScopedEntryDefIndex: TryFrom<T>` instead of `EntryDefIndex: TryFrom<T>`.
- **BREAKING CHANGE:** `get_links` and `get_link_details` take `impl LinkTypeFilterExt` instead of `TryInto<LinkTypeRanges>`.
- hdk: **BREAKING CHANGE** `x_salsa20_poly1305_*` functions have been properly implemented. Any previous `KeyRef`s will no longer work. These new functions DO NOT work with legacy lair `v0.0.z`, you must use NEW lair `v0.y.z` (v0.2.0 as of this PR). [\#1446](https://github.com/holochain/holochain/pull/1446)
- Fixed `hdk::query`, which was showing some incorrect behavior [\#1402](https://github.com/holochain/holochain/pull/1402):
  - When using `ChainQueryFilterRange::ActionHashRange`, extraneous elements from other authors could be returned.
  - Certain combinations of filters, like hash-bounded ranges and header type filters, are currently implemented incorrectly and lead to undefined behavior. Filter combinations which are unsupported now result in `SourceChainError::UnsupportedQuery`.

## 0.0.138

- hdk: Bump rand version + fix getrandom (used by rand\_core and rand) to fetch randomness from host system when compiled to WebAssembly. [\#1445](https://github.com/holochain/holochain/pull/1445)

## 0.0.137

- hdk: Use newest wasmer and introduces `wasm_error!` macro to capture line numbers for wasm errors [\#1380](https://github.com/holochain/holochain/pull/1380)
- Docs: Restructure main page sections and add several intra-doc lnks [\#1418](https://github.com/holochain/holochain/pull/1418)
- hdk: Add functional stub for `x_salsa20_poly1305_shared_secret_create_random` [\#1410](https://github.com/holochain/holochain/pull/1410)
- hdk: Add functional stub for `x_salsa20_poly1305_shared_secret_export` [\#1410](https://github.com/holochain/holochain/pull/1410)
- hdk: Add functional stub for `x_salsa20_poly1305_shared_secret_ingest` [\#1410](https://github.com/holochain/holochain/pull/1410)
- Bump wasmer to 0.0.80 [\#1386](https://github.com/holochain/holochain/pull/1386)

### Integrity / Coordinator Changes [\#1325](https://github.com/holochain/holochain/pull/1325)

### Added

- `get_links` and `get_link_details` take a `TryInto<LinkTypesRages>`. See the link test wasm for examples.

### Removed

- `entry_def_index` and `entry_type` macros are no longer needed.

### Changed

- `call` and `call_remote` now take an `Into<ZomeName>` instead of a `ZomeName`.
- `create_link` takes a `TryInto<LinkType>` instead of an `Into<LinkType>`.
- `update` takes `UpdateInput` instead of a `HeaderHash` and `CreateInput`.
- `create_entry` takes a type that can try into an `EntryDefIndex` and `EntryVisibility` instead of implementing `EntryDefRegistration`.
- `update_entry` takes the previous header hash and a try into `Entry` instead of a `EntryDefRegistration`.
- `Path` now must be `typed(LinkType)` to use any functionality that creates or gets links.

## 0.0.136

- Docs: Crate README generated from crate level doc comments [\#1392](https://github.com/holochain/holochain/pull/1392).

## 0.0.135

## 0.0.134

## 0.0.133

## 0.0.132

- hdk: Provide `Into<AnyLinkableHash>` impl for `EntryHash` and `HeaderHash`. This allows `create_link` and `get_links` to be used directly with EntryHash and HeaderHash arguments, rather than needing to construct an `AnyLinkableHash` explicitly.

## 0.0.131

- Docs: Fix intra-doc links in all crates [\#1323](https://github.com/holochain/holochain/pull/1323)

## 0.0.130

## 0.0.129

## 0.0.128

*NOTE: this release has not been published to crates.io*

- hdk: Adds external hash type for data that has a DHT location but does not exist on the DHT [\#1298](https://github.com/holochain/holochain/pull/1298)
- hdk: Adds compound hash type for linkable hashes [\#1308](https://github.com/holochain/holochain/pull/1308)
- hdk: Missing dependencies are fetched async for validation [\#1268](https://github.com/holochain/holochain/pull/1268)

## 0.0.127

## 0.0.126

- Docs: Explain how hashes in Holochain are composed and its components on the module page for `hdk::hash` [\#1299](https://github.com/holochain/holochain/pull/1299).

## 0.0.125

- hdk: link base and target are no longer required to exist on the current DHT and arent made available via. validation ops (use must\_get\_entry instead) [\#1266](https://github.com/holochain/holochain/pull/1266)

## 0.0.124

## 0.0.123

## 0.0.122

- hdk: `delete`, `delete_entry`, and `delete_cap_grant` can all now take a `DeleteInput` as an argument to be able specify `ChainTopOrdering`, congruent with `create` and `update`. This change is backward compatible: a plain `HeaderHash` can still be used as input to `delete`.

## 0.0.121

## 0.0.120

- docs: Add introduction to front-page and move example section up [1172](https://github.com/holochain/holochain/pull/1172)

## 0.0.119

- hdk: `encoding` from `holo_hash` re-exported as hdk feature [1177](https://github.com/holochain/holochain/pull/1177)

## 0.0.118

- hdk: `Path` now split into `Path` and `PathEntry` [1156](https://github.com/holochain/holochain/pull/1156)
- hdk: Minor changes and additions to `Path` methods [1156](https://github.com/holochain/holochain/pull/1156)
- hdk: `call` and `call_remote` are the same thing under the hood [1180](https://github.com/holochain/holochain/pull/1180)

## 0.0.117

## 0.0.116

## 0.0.115

## 0.0.114

## 0.0.113

## 0.0.112

## 0.0.111

## 0.0.110

## 0.0.109

## 0.0.108

## 0.0.107

### Changed

- hdk: `scheduled` fn signature updated to a string

### Added

- hdk: `map_extern_infallible` added to map infallible externs
- hdk: `schedule` function now takes a String giving a function name to schedule, rather than a Duration

## 0.0.106

## 0.0.105

## 0.0.104

## 0.0.103

### Changed

- hdk: `sys_time` returns `Timestamp` instead of `Duration`

### Added

- hdk: Added `accept_countersigning_preflight_request`

- hdk: Added `session_times_from_millis`

- hdk: Now supports creating and updating countersigned entries

- hdk: Now supports deserializing countersigned entries in app entry `try_from`

- hdk: implements multi-call for:
  
  - `remote_call`
  - `call`
  - `get`
  - `get_details`
  - `get_links`
  - `get_link_details`
  
  We strictly only needed `remote_call` for countersigning, but feedback from the community was that having to sequentially loop over these common HDK functions is a pain point, so we enabled all of them to be async over a vector of inputs.

## 0.0.102

### Changed

- hdk: fixed wrong order of recipient and sender in `x_25519_x_salsa20_poly1305_decrypt`

## 0.0.101

### Changed

- Added `HdkT` trait to support mocking the host and native rust unit tests

### Added

- Added `sign_ephemeral` and `sign_ephemeral_raw`

## [0.0.100](https://github.com/holochain/holochain/compare/hdk-v0.0.100-alpha1..hdk-v0.0.100)

### Changed

- hdk: fixup the autogenerated hdk documentation.

## 0.0.100-alpha.1

### Added

- holochain 0.0.100 (RSM) compatibility
- Extensive doc comments



================================================
File: crates/hdk/ON-WASM.md
================================================

## Wasm overview

The first thing to understand is what wasm is and how it works.

Wasm code is "web assembly" https://webassembly.org/.

It is designed to be embedded in other systems and to execute efficiently and
predictably across every environment it is embedded in.

To achieve this wasm makes almost no assuptions about the environment and is
very low level (i.e. it is "assembly code").

We will start with an overview of the limitations of wasm because it is
important to understand the constraints of the system. It may seem overwhelming
but we have created conventions and macros that makes working with holochain as
straightforward as any other Rust code.

### Hosted execution environment

Wasm runs inside some kind of host as a guest execution environment.

Wasm can perform pure mathematical calculations only. Anything that requires
a side effect like reading/writing to a database, file system, network,
terminal, browser, etc. requires the host to provide that functionality.

For example, a wasm game engine running in a web browser may want to render
pixels to an HTML canvas element. The wasm code has no access to anything in the
host so it will need to precalculate all the pixels and hand them off to the
host somehow.

The wasm host has full read/write access to the wasm's memory but the guest can
only access its own memory and return values from `extern` functions that the
host calls.

This means that the portability of wasm code is only as good as the host's
ability to drive the guest `extern` functions with the right data and execution
logic, and to provide all the functionality the guest is expecting.

For example, if a wasm guest is written to expect file system style system calls
to be possible it will fail to execute in a web browser.

Conversely, if the host expects the guest to expose certain functions and accept
certain data structures, then the wasm behaviour will be undefined or simply
crash if the guest does not meet these requirements.

__In short, wasm code is fundamentally driven through bidirectional callbacks.__

### No types or rich data

There are no types other than integers, floats and functions.

Wasm is missing even basic collections like lists or sets.  
There are no strings or utf-8 characters.  
Integers don't even define whether they are signed or unsigned!  
An "integer" is just a 32 or 64 bit block of binary data that signed and
unsigned operators like "addition" can do something with at runtime.

Some float operations, specifically those that involve the sign of operations
against `NaN` are non-deterministic in wasm, so it is often recommended to avoid
their usage entirely in p2p applications where determinism is important.

This effectively leaves us with just 3 types of data:

- functions
- 32 bit chunks of binary data called `i32`
- 64 bit chunks of binary data called `i64`

__Which is pragmatically just one type of data: "several bits of binary".__

### Bleeding edge technology

The wasm spec is still being developed.

Most language support is "coming soon".

__Rust is the only language with mature and official support for wasm.__

## How holochain uses wasm

The holochain binary acts as both a wasm host and a websockets server that
accepts incoming RPC style function calls and forwards them through to the wasm
guest. Any `extern` functions inside the guest wasm can be called this way via.
websockets and the holochain host can call `extern` functions itself to
provide "hook" style extension points for developers.

For example, when a holochain "DNA" is first installed it will reference one or
several wasm files. If any of these wasm files defines a function called `init`
then holochain will call each of the `init` functions one after the other in the
order they are referenced in the DNA config files.

Defining an extern function for holochain in Rust is straightforward:

- define a function as usual;
- with the `extern "C"` keywords to expose it to the host;
- the `#[no_mangle]` attribute to stop the compiler from renaming it;
- and `RemotePointer` arg/return values from the `holochain-wasmer-guest` crate.

Since we will want to accept and return more complex data than small chunks of
binary, there are a few macros such as `host_args!()` and `ret!()` that import
and export anything that can be serialized with `serde` from and to `GuestPtr`
values.

It's probably not clear how it is possible to "serialize" arbitrary data into a
single `u64` so these macros will be explained in more detail below.

Rather than diving into technical details, let's start with some illustrative
examples that demonstrates working with holochain-friendly wasm _without_ a HDK.

### Example: Minimal wasm that will run

All the core externs required for holochain to interact with this wasm are
defined by the `holochain_externs!()` macro.

Every callback is optional so defining the core externs is enough to compile
the wasm and have holochain install and run it.

```rust
holochain_wasmer_guest::holochain_externs!();
```

### Example: Minimal `init` callback

To implement an `init` callback we need a few things:

- the `holochain_externs!()` macro as above
- to define an `extern` called `init` as described above
- to use the `ret!()` macro with the `ExternOutput` type to return an
  `InitCallbackResult` enum, serialized into a `GuestPtr`

That last point is a little complex so I'll break it down.

The `ExternOutput` struct wraps `SerializedBytes` from the
`holochain_serialized_bytes` crate. Anything that can be serialized can be
sent back to the host through this struct and the `ret!` macro.

Internally `ret!()` serializes any compatible data to messagepack, puts it in
the wasm guest memory, tells the rust memory allocator _not_ to drop it
automatically and returns the location of it back to the host so the host can
copy it out of wasm memory into its own memory and work with it from there.

In the case of a known callback like `init` the host will attempt to deserialize
the inner value of `ExternOutput` because it is expecting the guest to return a
meaningful value from the callback.

All the callback return values have a simple naming convention
`FooCallbackResult` so `init` must return an `InitCallbackResult` enum.

In the case of a function called due to an external RPC request, the host will
simply send back whatever is inside `ExternOutput` as raw binary bytes.

All the callback input and output values are defined in `holochain_zome_types`.

```rust
use holochain_wasmer_guest::*;
use holochain_zome_types::init::InitCallbackResult;

holochain_externs!();

// tell the compiler not to "mangle" (rename) the function
#[no_mangle]
// note the `extern "C"` keywords
pub extern "C" fn init(_: GuestPtr) -> GuestPtr {

 // `ret!` will `return` anything `TryInto<SerializedBytes>` as a `GuestPtr`
 ret!(
  ExternOutput::new(
   // the host will allow this wasm to be installed if it returns `Pass`
   InitCallbackResult::Pass.try_into().unwrap()
  )
 );

}
```

### Example: Minimal "hello world" extern

A minimal functional wasm that implements a `hello_world` function that can be
called by the outside world, e.g. via. websockets RPC calls.

Our function won't take any inputs or do any real work, it will simply return
a `GuestPtr` to an empty placeholder `HelloWorld` struct.

The holochain host would return a messagepack-serialized representation of this
`HelloWorld` struct back to the guest via. websockets RPC.

In a real application this struct can be anything that round-trips through
`SerializedBytes` from the `holochain_serialized_bytes` crate. This means
anything compatible with the messagepack implementation for `serde`.

The easiest way to make a struct do this is by deriving the traits:

```rust
#[derive(serde::Serialize, serde::Deserialize, SerializedBytes)]
struct Foo;
```

Note in the example the usage of `ret!()` and `ExternOutput` exactly as in the
`init` example.

In this case the custom `HelloWorld` struct will be ignored by the holochain
host and forwarded as messagepack serialized data back to the websockets RPC
caller. It is up to the developers of the wasm and the websockets client to
make sure the data in the structs is handled correctly. For example, a web-based
SDK for JavaScript would likely convert the messagepack data into JSON data and
maybe massage the raw data to be more idiomatic in its naming conventions for a
JavaScript context before exposing it to some GUI framework.

```rust
use holochain_wasmer_guest::*;

holochain_externs!();

#[derive(serde::Serialize, serde::Deserialize, SerializedBytes)]
// a real application would put meaningful data in this struct
struct HelloWorld;

// the same #[no_mangle] attribute and `extern "C"` keywords are used to expose
// functions to the external world as to implement callback functions
#[no_mangle]
pub extern "C" hello_world(_: GuestPtr) -> GuestPtr {
 ret!(
  ExternOutput(
   // the derived serialization traits make this work
   HelloWorld.try_into().unwrap()
  )
 );
}
```

### Example: Slightly less minimal - install, RPC, commit & validate

A typical wasm for a real application will expose `extern` functions to be RPC
called by websockets, which will internally call host functions, that in turn
trigger guest callbacks, before a final result is returned back over websockets.

The most obvious example of this is an `extern` function that commits an entry.

Entries must be validated by both the holochain host and the guest wasm before
they are finalized on the local source chain or broadcast to the DHT network.

In addition to the patterns we demonstrated above for externs and callbacks, we
also need to introduce the `host_call()!` and `host_args!()` macros.

The `host_call()` function works very similarly to the `ret!()` macro in that it
takes serializable data on the guest and sends it to the host as a `GuestPtr`.
The difference is that instead of causing the guest to `return`, this data is
the argument to a function that _executes and blocks immediately on the host_
and the result is deserialized back into the guest wasm automatically, inline
from a returned `GuestPtr`.

The `host_args!()` macro can be used _immediately at the start of a guest
function execution_ to attempt to deserialize the `GuestPtr` argument from the
host to a guest function. Internally the host is writing bytes directly to the
guest wasm memory and telling the guest memory allocator to leak these bytes.
The `host_args!()` macro relies on and cleans up this temporary memory leak so
always call it before anything else. Note that `host_args!()` will short circuit
and return early with an error similar to the `?` operator if deserialization
fails on the guest.

Note that both the `host_call()` function and the `host_args!()` macros rely on the guest to
correctly deserialize the values that the host is copying to the guest's memory.

So, before looking at the code, here is a diagram of how our example wasm would
interact with holochain and the outside world, from `init` through to an extern
function call, an entry commit and successful validation callback.

The `validation` callback is an example of specificity in callbacks.
The base callback is called `validate` so we can implement that and it will be
triggered for every entry that needs validation.
We can also define a more specific `validate_entry` callback that will only be
triggered for entries defined and committed by the current wasm - i.e. only
"app entries" and not system entries like agent keys.

![holochain wasm flow](https://thedavidmeister.keybase.pub/holochain/docs/hdk/images/wasm-flow.jpg)

So here is the wasm code for all that.

It consists of a few components, some new and some already demonstrated above:

- `holochain_externs!()` to enable the holochain host to run the wasm
- A `Png` struct to hold binary PNG data as `u8` bytes
- An `extern` function `save_image` that will be callable over websockets RPC
- A `host_call` to `__create` inside `save_image` to commit the image
- A `validate_entry` callback function implementation to validate the PNG
- Some basic validation logic to ensure the PNG is under 10mb
- Calling `host_args!()` in both externs to accept input
- Calling `ret!()` to return the validation callback result

`init` is optional, we can ignore it and that is the same as it always passing.

```rust
use holochain_wasmer_guest::*;

holochain_externs!();

#[derive(serde::Serialize, serde::Deserialize, SerializedBytes)]
// a simple new type to hold binary PNG data
struct Png([u8]);

// the websockets client can send raw binary bytes as the payload to this
// save_image function and the `remote_ptr` arg will point to the image data
#[no_mangle]
pub extern "C" fn save_image(remote_ptr: GuestPtr) -> GuestPtr {

 // the deserialization pattern mimics serde
 // we tell the compiler that we expect a `Png` type and `host_args!()` will
 // attempt to create one from the guest memory starting at `remote_ptr`
 let png: Png = host_args!(remote_ptr);

 // for this example we don't care about the result of commit entry
 // a real application should handle it
 //
 // the important bit for this example is that we use host_call() and that the
 // __create function on the host will enqueue a validation callback
 let _: CreateOutput = host_call(
  // note that all host functions from holochain start with prefix `__`
  __create,
  CreateInput::new(
   Entry::App(
    // this serializes the image into an Entry enum that the holochain host
    // knows what to do with
    png.try_into().unwrap()
   )
  )
 ).unwrap();
}

#[no_mangle]
// the validate_entry is a more specific variant of the base validate hook
// all the input and output values and behaviour are the same as the base hook
// but it will only be triggered for Entry::App variants rather than any Entry
// this is optional, the same logic can be implemented with the base `validate`
pub extern "C" fn validate_entry(remote_ptr: GuestPtr) -> GuestPtr {

 // ExternInput is the mirror of ExternOutput
 let input: ExternInput = host_args!(remote_ptr);

 // we ret! a GuestInput containing SerializedBytes of ValidateCallbackResult
 ret!(ExternOutput::new(
  // attempt to deserialize an Entry from the inner
  // SerializedBytes of the ExternInput struct
  match Entry::try_from(input.into_inner()) {
   Ok(Entry::App(serialized_bytes)) => {
    // we only have one entry type in this wasm so we can deserialize it
    // directly into a Png type
    // more complex apps should implement an enum with variants for the data
    // types needed
    let png: Png = serialized_bytes.try_into().unwrap();

    // let's cap the png size at 10mb
    // if this was a real app we might want to use an image processing crate to
    // attempt to validate that the image data is not corrupt
    if png.len() > 10_000_000 {
     ValidateCallbackResult::Invalid("The image is too big".to_string())
    } else {
     ValidateCallbackResult::Valid
    }
   },
   // technically this is reachable as the deserialization could fail for an
   // entry we are asked to validate incoming from the dht
   // for a local-only to example this _is_ unreachable because we
   // control the serialization locally and the specific `validate_entry`
   // callback has already pre-filtered inputs to the Entry::App variant only
   _ => unreachable!(),
 }));

}
```

### Example: Don't panic!

Panicking inside wasm is generally really bad. Even worse than panicking inside
vanilla Rust.

There are several reasons for this:

- The tooling for backtraces etc. is worse than native rust
- It opens the potential for malicious actors on the DHT to force your wasm to
  crash with bad data (the last example above would hit `unreachable!()` if
  undeserializable garbage data was received from the network)
- The type of errors handled in wasm callbacks should typically be able to be
  handled gracefully because we can simply hand errors back to the host

But so far all the examples have been littered with `unwrap()` and similar.

This is because all the extern functions can only accept and receive `GuestPtr`
data and we had no tools to handle `Result` or `?` type logic that is idiomatic
to Rust.

If you read the `holochain_serialized_bytes` documentation linked above, or have
worked with the crate before, you would know that we cannot simply serialize a
`Result` value directly into `SerializedBytes`. It needs to be wrapped in a
newtype struct first.

Even if we rewrote `SerializedBytes` to be compatible with `Result` it would not
help much because wasm doesn't allow us to return `Result` values from wasm
`extern` functions. This breaks the most common and useful Rust idiom for error
handling, the `?` operator.

To fill the `Result`/`?` gap we have two macros in `holochain_wasmer_guest`.

- `ret_err!()`: works like `ret!()` but accepts a failure string and is
  interpreted as an error value by the host
- `try_result!()`: works like `?` but uses `ret_err!()` under the hood

These macros are only needed inside `extern` functions and nothing requires that
all the app logic is limited to `extern` functions. Regular rust functions that
work with `Result` values directly can be written as normal, just not at the
point where callbacks cross the host/guest wasm boundary.

Note also that `host_args!()` does something _similar_ to `ret_err!()`
internally when it short-circuits in the case of failing to deserialize args.

The two most obvious cases for using `try_result!()` are:

- coupled with `host_call()` inside simple extern functions/callbacks
- to wrap vanilla rust code that returns a result to avoid logic-in-externs

This example will show a simple `host_call()` error handling but the next
example will show how to use all the macros together to collapse all the extern
logic into some generic, standalone boilerplate.

```rust
use holochain_wasmer_guest::*;

holochain_externs!();

#[derive(serde::Serialize, serde::Deserialize, SerializedBytes)]
struct Message(String);

#[no_mangle]
// an extern that allows websockets to commit some utf-8 message string
pub extern "C" fn commit_message(remote_ptr: GuestPtr) -> GuestPtr {
 let message: Message = host_args!(remote_ptr);
 // try_result! works exactly like `?`
 // it evalutes to v from Ok(v) or short circuits with Err(e)
 // because this is inside an extern function the short circuit logic also
 // handles memory and serialization logic for the holochain host
 let commit_entry_output: CreateOutput = try_result!(
  host_call(
   __create,
   CreateInput::new(
    Entry::App(
     try_result!(
      message.try_into(),
      "failed to serialize message to be committed"
     )
    )
   )
  ),
  "commit entry call failed"
 );
 ret!(
  ExternOutput(
   try_result!(
    commit_entry_output.try_into(),
    "failed to deserialize commit entry output"
   )
  )
 );
}
```

### Example: Quarantine extern boilerplate

While the wasmer macros do a lot of heavy lifting, they are still not as
ergonomic or idiomatic as vanilla rust would be.

Defining the externs and handling serialization, errors and memory correctly is
required but it only needs to be done once per extern.

Here is a combination of the last two examples, with less commentary but error
handling for the `Png` committing with minimal `try_result!()` calls.

At this point you should start to have a clear understanding of what the HDK is
doing under the hood and to decide for yourself whether you really need or want
the sugar that it provides.

The HDK macros simply expand to this extern boilerplate, saving you from typing
out a few macros to input/output data for the host. They also offer some
convenience wrappers around `host_call()` that do exactly what you'd expect,
e.g. `create_entry( ... )` vs. `host_call(__create, ... )`.

Think of the HDK as a tool and safety net but also don't feel you can't peek
under the hood to see what is there.

```rust
use holochain_wasmer_guest::*;

///////////////////////////////
// WASM BOILERPLATE STARTS HERE
///////////////////////////////

holochain_externs!();

#[no_mangle]
// note the generic structure of this extern...
pub extern "C" fn save_image(remote_ptr: GuestPtr) -> GuestPtr {
 ret!(try_result!(_save_image(host_args!(remote_ptr)), "save_image error"));
}

#[no_mangle]
// the generic structure of this extern matches save_image
pub extern "C" fn validate_entry(remote_ptr: GuestPtr) -> GuestPtr {
 ret!(try_result!(_validate_entry(host_args!(remote_ptr)), "validate entry error"));
}

/////////////////////////////
// WASM BOILERPLATE ENDS HERE
/////////////////////////////

#[derive(serde::Serialize, serde::Deserialize, SerializedBytes)]
struct Png([u8]);

// everything in here is "normal" rust
// no need for special keywords on the function
// the input args and return values are all native Rust types, not pointers
// we can use `Result` and `?`
// the only wasm-ey thing here is the `host_call()` macro
fn _save_image(png: Png) -> Result<CreateOutput, String> {
 Ok(host_call(
  __create,
  &CreateInput::new(
   Entry::App(
    png.try_into()?
   )
  )
 )?)
}

// absolutely nothing wasm specific here at all
// only need to know to return a ExternOutput with inner ValidateCallbackResult
fn _validate_entry(input: ExternInput) -> Result<ExternOutput, String> {
 Ok(ExternOutput(match Entry::try_from(input.into_inner())? {
  Entry::App(serialized_bytes) => {
   let png: Png = serialized_bytes.try_into()?;

   if png.len() > 10_000_000 {
    ValidateCallbackResult::Invalid("The image is too big".to_string())
   } else {
    ValiateCallbackResult::Valid
   }
  },
  // this really _is_ unreachable now
  // the specific validate_entry callback guards against other entry variants
  // all the fallible logic is guarded by `?`
  _ => unreachable!(),
 }.try_into()?))
}
```



================================================
File: crates/hdk/release.toml
================================================
[[pre-release-replacements]]
file = "Cargo.toml"
search = "/develop/"
replace = "/{{crate_name}}-v{{version}}/"
prerelease = true

[[post-release-replacements]]
file = "Cargo.toml"
search = '/[A-Za-z0-9-_]+-v(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?/'
replace = "/develop/"
prerelease = true



================================================
File: crates/hdk/src/agent.rs
================================================
//! Calls related to agent keys.
//!
//! An agent can update their key. This is helpful in cases where a the private key of their key pair
//! has been leaked or becomes unusable in some other way. The agent key can be updated, which
//! invalidates the current key and generates a new key. Both the invalidated key and the new key
//! belong to the same agent. A sequence of keys belonging to the same agent form a key lineage.

// Tests are located under conductor::conductor::tests::agent_lineage and core::ribosome::host_fn::get_agent_key_lineage::test.

/// Queries a complete lineage of agent keys.
///
/// Returns a list of agent keys that are of the same lineage as the provided key, sorted in ascending
/// order by timestamp. A key lineage includes all keys of an agent that have been generated by creating
