        title: "update source '${{ inputs.update_source }}' on branch '${{ inputs.branch }}'"
        branch: auto-update/${{ inputs.branch }}/${{ inputs.update_source }}
        labels: |
          autorebase:opt-in
        draft: false
        delete-branch: true
    - name: Enable Pull Request Automerge
      if: steps.cpr1.outputs.pull-request-operation == 'created' || steps.cpr1.outputs.pull-request-operation == 'updated'
      uses: peter-evans/enable-pull-request-automerge@v3
      with:
        token: ${{ inputs.HRA_GITHUB_TOKEN}}
        pull-request-number: ${{ steps.cpr1.outputs.pull-request-number }}
        merge-method: squash
    - name: Auto approve Pull Request
      if: steps.cpr1.outputs.pull-request-operation == 'created' || steps.cpr1.outputs.pull-request-operation == 'updated'
      uses: juliangruber/approve-pull-request-action@v2
      with:
        github-token: ${{ inputs.GITHUB_TOKEN }}
        number: ${{ steps.cpr1.outputs.pull-request-number }}



================================================
File: .github/ISSUE_TEMPLATE/bug_report.md
================================================
---
name: Bug report
about: Create a report to help us improve
title: "[BUG]"
labels: ''
assignees: ''

---

**Describe the bug**
A clear and concise description of what the bug is, how you encountered it, and
the text of any error you received.

**Expected behavior**
A clear and concise description of what you expected to happen.

**System information:**
 - OS: [e.g. iOS]
 - Browser [e.g. chrome, safari]
 - Holochain and HDK Version (run `hn-introspect` as well as `holochain --build-info`
 from the nix shell and paste output)

**Steps to reproduce**
Detailed, specific steps which will reliably reproduce this bug.

If you have the means to do so, it would be extremely helpful to create a minimal reproduction of the problem.
The most helpful form of reproduction is to add a test directly to our existing codebase via a pull request,
so that we have a regression test for that bug. Please read the section in our 
[CONTRIBUTING.md](https://github.com/holochain/holochain/blob/develop/CONTRIBUTING.md) guide titled "Bug fixes and minimal reproductions"
for instructions on the best way to create a PR with a failing test.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Additional context**
Add any other context about the problem here.



================================================
File: .github/ISSUE_TEMPLATE/holonix_bug_report.md
================================================
---
name: Holonix bug report
about: Create a report to help us improve the Holonix dev shell
title: "[BUG - HOLONIX]"
labels: ["bug", "nix"]
assignees: ''

---

**Describe the bug**
A description of what the bug is, which dependency it is to do with,
how you encountered it, and the text of any error you received.

**Expected behavior**
A description of what you expected to happen.

**System information:**
 - OS: [e.g. macOS 13, Ubuntu Linux 22.04]
 - Nix version: (`nix --version`)

**Steps to reproduce**
Steps which will reliably reproduce this bug.

If you have the means to do so, it would be extremely helpful to create a minimal reproduction of the problem.

**Screenshots**
If applicable, add screenshots to help explain your problem.



================================================
File: .github/ISSUE_TEMPLATE/release_checklist.md
================================================
---
name: Release Checklist
about: Release preparation checklist
title: "[RELEASE]"
labels: ''
assignees: ''

---

- [ ] check for regressions or unexpected behavior by testing with an app that's in active use, in the field: @
- [ ] confirm launcher build: @
- [ ] confirm with manual runs of a test app: @
- [ ] confirm scaffolding works: @
- [ ] confirm holonix branch `main-0.x`: @
- [ ] migration guide written to help users move to the new release: @
- [ ] confirm any docs/updates ready to publish after release lands: @ 

**Assignment**

Assign and add responsible party for each checklist item.

**Sub-tasks**

If any items in the checklist need subtasks for the specific release, add them!


================================================
File: .github/manifest/vcpkg-configuration.json
================================================
{
  "default-registry": {
    "kind": "git",
    "baseline": "9760ce6194ef51aa4faf77b6321e1280daa4545c",
    "repository": "https://github.com/microsoft/vcpkg"
  },
  "registries": []
}



================================================
File: .github/manifest/vcpkg.json
================================================
{
  "dependencies": [
    {
      "name": "libsodium",
      "version>=": "1.0.20"
    },
    "openssl"
  ],
  "builtin-baseline": "9760ce6194ef51aa4faf77b6321e1280daa4545c"
}



================================================
File: .github/workflows/autorebase.yml
================================================
# Operates on open PRs and automatically rebases the PR branch onto the target branch.
# Like autoupdate.yml, but with rebasing instead of merging.
# Is triggered on a PR if labeled `autorebase:opt-in`.

name: autorebase

on:
    # Run on every push on develop
    push:
        branches:
            - "develop"
    # Run when pull requests get labeled
    pull_request:
        types: [labeled, opened, ready_for_review, reopened]
        branches:
            - "develop"

jobs:
    auto-rebase:
        name: AutoRebase
        runs-on: ubuntu-latest
        steps:
            - uses: Label305/AutoRebase@v0.1
              with:
                  # We can't use the built-in secrets.GITHUB_TOKEN yet because of this limitation:
                  # https://github.community/t5/GitHub-Actions/Triggering-a-new-workflow-from-another-workflow/td-p/31676
                  # In the meantime, use a token granting write access on the repo:
                  # - a GitHub App token
                  #   See https://github.com/marketplace/actions/github-app-token.
                  # - a personal access token
                  #   See https://help.github.com/en/articles/creating-a-personal-access-token-for-the-command-line.
                  github_token: ${{ secrets.HRA_GITHUB_TOKEN }}



================================================
File: .github/workflows/autoupdate.yaml
================================================
# Operates on open PRs and automatically merges updates on the target branch into the PR branch.
# Like autorebase.yml, but with merging instead of rebasing.
# Is triggered on a PR if labeled `autoupdate:opt-in`.

name: autoupdate

on:
    # Run on every push on develop
    push:
        branches:
            - "develop"
    # Run when pull requests get labeled
    pull_request:
        types: [labeled, opened, ready_for_review, reopened]
        branches:
            - "develop"

jobs:
    autoupdate:
        name: autoupdate
        runs-on: ubuntu-latest
        steps:
            - uses: docker://chinthakagodawita/autoupdate-action:v1
              env:
                  GITHUB_TOKEN: "${{ secrets.HRA_GITHUB_TOKEN }}"
                  PR_FILTER: "labelled"
                  PR_LABELS: "autoupdate:opt-in"
                  MERGE_CONFLICT_ACTION: "fail"
                  MERGE_MSG: "Branch was auto-updated."



================================================
File: .github/workflows/command-listener.yml
================================================
name: command-listener

on:
  issue_comment:
    types: ["created"]

jobs:
  action_pr_comment:
    name: Action PR comment
    if: ${{ github.event.issue.pull_request }}
    runs-on: ubuntu-latest
    steps:
      - name: Dispatch
        id: dispatch
        env:
          USER: ${{ github.event.sender.login }}
          ALLOWED_USERS: ${{ join(fromJson('["ThetaSinner", "jost-s", "maackle", "thedavidmeister", "steveej", "neonphog", "matthme", "c12i"]'), '\n') }}
          COMMENT: ${{ github.event.comment.body }}
        run: |
          set -euo pipefail
          
          COMMAND=""
          if [[ "$COMMENT" == @hra* ]]; then
            echo "Comment is a command"
            COMMAND=$(echo "$COMMENT" | cut -b 6- | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
          else
            echo "Comment is not a command"
            exit 0
          fi
          
          if echo "$ALLOWED_USERS" | grep -q "${USER}"; then
            echo "User $USER is allowed to run commands"
          else
            echo "User $USER is not allowed to run commands"
            exit 1
          fi

          echo "Setting command '$COMMAND'"  
          echo "action=${COMMAND}" >> "$GITHUB_OUTPUT"
    outputs:
      action: ${{ steps.dispatch.outputs.action }}
  holonix_update:
    name: Holonix update
    runs-on: ubuntu-latest
    needs: [action_pr_comment]
    if: ${{ startsWith(needs.action_pr_comment.outputs.action, 'holonix_update') }}
    steps:
      - name: Configure
        id: configure
        env:
          ACTION: ${{ needs.action_pr_comment.outputs.action }}
          PR_NUMBER: ${{ github.event.issue.number }}
          RUN_ID: ${{ github.run_id }}
          GH_TOKEN: ${{ secrets.HRA_GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          
          HOLONIX_VERSION=$(echo $ACTION | cut -b 16- | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
          gh pr comment $PR_NUMBER --repo holochain/holochain --body "Got it, will try to update inputs for Holonix version \`$HOLONIX_VERSION\` - [Workflow](https://github.com/holochain/holochain/actions/runs/$RUN_ID)"
          
          echo "holonix_version=${HOLONIX_VERSION}" >> "$GITHUB_OUTPUT"
      - uses: actions/checkout@v4
      - uses: cachix/install-nix-action@v26
      - uses: cachix/cachix-action@v14
        with:
          name: holochain-ci
      - name: set up git config
        run: |
          ./scripts/ci-git-config.sh
      - name: Flake update
        env:
          PR_NUMBER: ${{ github.event.issue.number }}
          HOLONIX_VERSION: ${{ steps.configure.outputs.holonix_version }}
          GH_TOKEN: ${{ secrets.HRA_GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          
          gh pr checkout $PR_NUMBER --repo holochain/holochain
          nix run .#scripts-repo-flake-update $HOLONIX_VERSION  
          git pull --rebase
          git push



================================================
File: .github/workflows/holochain-build-and-test.yml
================================================
name: "holochain build and test"

on:
  workflow_call:
    inputs:
      repo_path:
        description: "a path to the holochain repository"
        required: false
        type: string
        default: "."
      fail_fast:
        description: "whether all tests will be stopped on first failure occurrence or run to completion"
        required: false
        type: boolean
        default: false
    secrets:
      GITHUB_ACCESS_TOKEN:
        description: "A GitHub access token which can be used for cloning the project"
        required: true
      CACHIX_AUTH_TOKEN_HOLOCHAIN_CI_INTERNAL:
        description: "The Cachix token for `holochain-ci-internal` to be used for caching Holochain CI runs"
        required: true

jobs:
  test:
    strategy:
      fail-fast: ${{ inputs.fail_fast }}
      matrix:
        cmd:
          # ensure functionality on multiple platforms
          - pkgs:
              - build-holonix-tests-integration
            extra_arg: "--override-input versions ./versions/weekly --override-input holochain ${{ inputs.repo_path }}"

          # ensure that any Nix changes on this branch don't cause problems for maintenance versions
          - pkgs:
              - build-holonix-tests-integration
            extra_arg: "--override-input versions ./versions/0_2"
          - pkgs:
              - build-holonix-tests-integration
            extra_arg: "--override-input versions ./versions/0_3"
          - pkgs:
              - build-holonix-tests-integration
            extra_arg: "--override-input versions ./versions/weekly"
        platform:
          - system: aarch64-darwin
          - system: x86_64-linux

        include:
          # we only run repo consistency checks on x86_64-linux
          - cmd:
              pkgs:
                - build-release-automation-tests-unit
              extra_arg: "--override-input versions './versions/weekly' --override-input holochain ${{ inputs.repo_path }}"
            platform:
              system: x86_64-linux

          # TODO: can this be skipped during a release run because it duplicates the release-prepare job?
          - cmd:
              pkgs:
                - build-release-automation-tests-repo
              extra_arg: "--override-input versions ./versions/weekly --override-input repo-git 'path:.git'"
            platform:
              system: x86_64-linux

    # runs-on: ${{ matrix.platform.runs-on }}
    runs-on: [self-hosted, multi-arch]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          lfs: false

      - name: Print matrix
        env:
          MATRIX: ${{ toJSON(matrix) }}
        run: echo ${MATRIX}

      - name: "Test command ${{ join(matrix.cmd.pkgs, ',') }}"
        env:
          system: ${{ matrix.platform.system }}
          NIX_CONFIG: "access-tokens = github.com=${{ secrets.GITHUB_TOKEN }}"
          # TODO Want to be able to choose between internal/external when building external PRs
          CACHIX_AUTH_TOKEN: ${{ secrets.CACHIX_AUTH_TOKEN_HOLOCHAIN_CI_INTERNAL }}
        run: |
          set -xe

          git status

          # If a nix store path was passed, ensure it exists locally. This will fetch the path from cachix.
          if [[ ${{ inputs.repo_path }} == "/nix/"* ]]; then
            nix-store --realise ${{inputs.repo_path }}

            # Temporary workaround for https://github.com/NixOS/nix/issues/10202
            git config --global --add safe.directory ${{ inputs.repo_path }}
          fi

          # first build all derivations. this could be enough for test derivations.
          nix build -L --show-trace \
            ${{ matrix.cmd.extra_arg }} \
            .#packages.${system}.${{ join(matrix.cmd.pkgs, ' .#packages.${system}.')}}

          # Temporary workaround for https://github.com/NixOS/nix/issues/10202
          if [[ ${{ inputs.repo_path }} == "/nix/"* ]]; then
            git config --global --unset safe.directory ${{ inputs.repo_path }}
          fi

          # Don't exit if this fails so we can clean up the profile
          for i in result*; do
            cachix push holochain-ci-internal $i || true
          done

          rm result*



================================================
File: .github/workflows/holonix-cache.yml
================================================
name: "Holonix cache"

on:
  push:
    branches:
      - develop
  workflow_dispatch:
    inputs: {}

jobs:
  # ensures the cache is regularly updated for the supported versions on multiple platforms
  cache-update:
    strategy:
      fail-fast: false
      matrix:
        target:
          - "github:holochain/holochain#packages.{0}.build-holonix-tests-integration"
          - "github:holochain/holochain#devShells.{0}.holonix"
        extra_args:
          - ""
          - "--refresh --override-input versions github:holochain/holochain?dir=versions/0_3"
          - "--refresh --override-input versions github:holochain/holochain?dir=versions/0_3_rc"
          - "--refresh --override-input versions github:holochain/holochain?dir=versions/0_4_rc"
          - "--refresh --override-input versions github:holochain/holochain?dir=versions/weekly"
        platform:
          - aarch64-darwin
          - x86_64-linux

    runs-on: [self-hosted, multi-arch]
    steps:
      - name: Print matrix
        env:
          MATRIX: ${{ toJSON(matrix) }}
        run: echo ${MATRIX}

      - name: "Cache packages ${{ matrix.extra_args }}"
        env:
          NIX_CONFIG: "access-tokens = github.com=${{ secrets.GITHUB_TOKEN }}"
          CACHIX_AUTH_TOKEN: "${{ secrets.CACHIX_AUTH_TOKEN_HOLOCHAIN_CI }}"
        run: |
          set -xe

          target=${{ matrix.target }}

          # See https://docs.cachix.org/pushing#id1
          nix develop --build -L --profile result-develop \
            ${{ matrix.extra_args }} \
            ${{ format(matrix.target, matrix.platform) }}

          nix build -L --profile result-build \
            ${{ matrix.extra_args }} \
            ${{ format(matrix.target, matrix.platform) }}

          # Don't exit if this fails so we can clean up the profile
          total_status=0
          for i in result-*; do
            if ! cachix push holochain-ci $i; then
              total_status=$((total_status+1))
            fi
          done

          rm result*
          
          exit $total_status
  cache-check:
    needs:
      - cache-update
    strategy:
      fail-fast: false
      matrix:
        target:
          - "github:holochain/holochain#devShells.{0}.holonix"
          - "github:holochain/holochain#packages.{0}.hc-scaffold"
        extra_args:
          - ""
          - "--refresh --override-input versions github:holochain/holochain?dir=versions/0_3"
          - "--refresh --override-input versions github:holochain/holochain?dir=versions/0_3_rc"
          - "--refresh --override-input versions github:holochain/holochain?dir=versions/weekly"
        platform:
          - aarch64-darwin
          - x86_64-linux
    runs-on: ubuntu-latest
    steps:
      - uses: cachix/install-nix-action@v26
      - uses: cachix/cachix-action@v14
        with:
          name: holochain-ci
      - name: Check the Holonix cache
        uses: holochain/nix-cache-check@v1
        env:
          NIX_CONFIG: "access-tokens = github.com=${{ secrets.GITHUB_TOKEN }}"
        with:
          derivation: ${{ format(matrix.target, matrix.platform) }}
          extra_build_args: ${{ matrix.extra_args }}



================================================
File: .github/workflows/pr-tests.yml
================================================
# Builds all components and runs their tests

name: pr_tests

on:
  workflow_dispatch: {}
  pull_request: {}

concurrency:
  group: build-${{ github.ref_name }}-${{ github.event_name }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

jobs:
  test:
    uses: ./.github/workflows/holochain-build-and-test.yml
    secrets:
      GITHUB_ACCESS_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      CACHIX_AUTH_TOKEN_HOLOCHAIN_CI_INTERNAL: ${{ secrets.CACHIX_AUTH_TOKEN_HOLOCHAIN_CI_INTERNAL }}

  github-actions-ci-jobs-succeed:
    if: ${{ always() }}
    runs-on: "ubuntu-latest"
    needs: [test]
    steps:
      - name: Check status
        id: check-status
        env:
          RESULTS: "${{ toJSON(needs.*.result) }}"
        run: |
          [[ $(jq -n 'env.RESULTS | fromjson | unique == ["success"]') == 'true' ]]


================================================
File: .github/workflows/release-dispatch.yml
================================================
name: "Holochain release dispatch"

on:
  push:
    tags:
      # Expect tags to be `holochain-<semver-version>`
      - holochain-*

jobs:
  holochain-tag-created:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        # Add repositories here to trigger their `workflow_dispatch` event when Holochain releases.
        target: ["holochain/holonix"]
    steps:
      - name: dispatch
        env:
          GH_TOKEN: ${{ secrets.HRA_GITHUB_TOKEN }}
        # See https://github.com/holochain/holonix/blob/main/.github/workflows/dispatch-listener.yaml
        # For an example of how to handle this event.
        run: |
          gh api \
            --method POST \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            /repos/${{ matrix.target }}/dispatches \
            -f "event_type=holochain-released" -F "client_payload[tag]=${{ github.ref_name }}"



================================================
File: .github/workflows/release-prepare.yml
================================================
# Loaded as part for `release.yml`
# Contains a single job called `prepare`.
#
# As input it receives a branch to be released (aka. source branch).
# It then merges the source branch into the release branch (usually `release`).
#
# The merged state of the repo is then serialized and cached to use in the subsequent `release.yml` workflow.
#
# This workflow also caches cargo related state and build files between runs.
#
#
# Relevant Steps:
# - Merge the source branch into the release branch
# - Restore holochain cargo related state and build files
# - (Checks files) Detect missing release headings
# - (Changes files) Generate crate READMEs from doc comments
# - (Changes files) Bump the crate versions for the release
# - Cache the repo and set outputs

on:
  workflow_call:
    inputs:
      dry_run:
        type: string
        required: true
      debug:
        type: string
        required: true
      skip_prepare_logic:
        type: string
        required: true

      HOLOCHAIN_SOURCE_BRANCH:
        type: string
        required: true
      HOLOCHAIN_TARGET_BRANCH:
        type: string
        required: true
      HOLOCHAIN_URL:
        type: string
        required: false
        default: "https://github.com/holochain/holochain"
      HOLOCHAIN_REPO:
        type: string
        required: false
        default: "/var/tmp/holochain_repo"
      CACHIX_REV:
        type: string
        required: true
    secrets:
      HRA_GITHUB_TOKEN:
        required: true
      CACHIX_SIGNING_KEY:
        required: true
      CACHIX_AUTH_TOKEN:
        required: true

    outputs:
      latest_holochain_release_tag:
        description: "which holochain tag, if one, will be released"
        value: ${{ jobs.prepare.outputs.latest_holochain_release_tag }}
      latest_holochain_release_version:
        description: "which holochain version, if one, will be released"
        value: ${{ jobs.prepare.outputs.latest_holochain_release_version }}
      release_branch:
        description: "the branch that contains the changes made during this action"
        value: ${{ jobs.prepare.outputs.release_branch }}
      repo_nix_store_path:
        description: "the nix-store path for the release repo that is a result of the preparation"
        value: ${{ jobs.prepare.outputs.repo_nix_store_path }}
      releasable_crates:
        description: "whether there are any releaseable crates"
        value: ${{ jobs.prepare.outputs.releasable_crates }}

jobs:
  prepare:
    env:
      HOLOCHAIN_REPO: ${{ inputs.HOLOCHAIN_REPO }}
      CACHIX_REV: ${{ inputs.CACHIX_REV }}
    runs-on: ubuntu-latest
    outputs:
      latest_holochain_release_tag: ${{ steps.write-env-and-tag.outputs.latest_holochain_release_tag }}
      latest_holochain_release_version: ${{ steps.write-env-and-tag.outputs.latest_holochain_release_version }}
      release_branch: ${{ steps.write-env-and-tag.outputs.release_branch }}
      repo_nix_store_path: ${{ steps.write-env-and-tag.outputs.repo_nix_store_path }}
      releasable_crates: ${{ steps.bump-versions.outputs.releasable_crates }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Install nix
        uses: cachix/install-nix-action@v26
      - name: Setup cachix
        uses: cachix/cachix-action@v14
        with:
          name: holochain-ci
          authToken: "${{ secrets.CACHIX_AUTH_TOKEN }}"
          installCommand: |
            nix-env -if https://github.com/cachix/cachix/tarball/${CACHIX_REV:?} \
              --substituters 'https://cache.nixos.org https://cachix.cachix.org' \
              --trusted-public-keys 'cachix.cachix.org-1:eWNHQldwUO7G2VkjpnjDbWwy4KQ/HNxht7H4SSoMckM= cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY='
      # - name: Set NIX_PATH (FIXME)
      #   run: echo NIX_PATH=nixpkgs=$(./scripts/nix_path.sh) >> $GITHUB_ENV

      - name: Merge source branch (${{ inputs.HOLOCHAIN_SOURCE_BRANCH }}) into target branch (${{ inputs.HOLOCHAIN_TARGET_BRANCH }})
        env:
          HRA_GITHUB_TOKEN: ${{ secrets.HRA_GITHUB_TOKEN }}
          HOLOCHAIN_REPO: ${{ inputs.HOLOCHAIN_REPO }}
          HOLOCHAIN_SOURCE_BRANCH: ${{ inputs.HOLOCHAIN_SOURCE_BRANCH }}
          HOLOCHAIN_TARGET_BRANCH: ${{ inputs.HOLOCHAIN_TARGET_BRANCH }}
          HOLOCHAIN_URL: ${{ inputs.HOLOCHAIN_URL }}
        run: |
          set -exuE -o pipefail

          if [[ -d "${HOLOCHAIN_REPO}" ]]; then
            echo repository at ${HOLOCHAIN_REPO} unexpectedly exists
            exit 1
          fi
          mkdir -p "${HOLOCHAIN_REPO}"

          cd "${HOLOCHAIN_REPO}"

          if ! git status; then
            git init
            git remote add origin "${HOLOCHAIN_URL}"
          else
            echo unexpectedly got a git repo at $PWD
            exit 1
          fi

          cp -v $HOME/work/holochain/holochain/.git/config .git/config

          git fetch --all --tags --prune --prune-tags --force
          git branch --list --all
          git checkout --force -B ${HOLOCHAIN_SOURCE_BRANCH} remotes/origin/${HOLOCHAIN_SOURCE_BRANCH}

          # .gitignore might've changed
          git reset --hard
          git clean -fd

          obsolete_branches="$(git branch --list | sed -E 's/^ +//' | (grep -oE '^release-[0-9\.]+' || :))"
          if [[ -n "${obsolete_branches}" ]]; then
            git branch -D ${obsolete_branches}
          fi

          # Merge source branch into the target branch
          if ! (git branch --list --all | grep origin/${HOLOCHAIN_TARGET_BRANCH}); then
            git checkout -B ${HOLOCHAIN_TARGET_BRANCH}
          else
            git checkout --force -B ${HOLOCHAIN_TARGET_BRANCH} origin/${HOLOCHAIN_TARGET_BRANCH}
          fi
          git merge --ff-only "${HOLOCHAIN_SOURCE_BRANCH}"

      - name: Restore Cargo cache
        if: ${{ inputs.skip_prepare_logic != 'true' }}
        uses:  actions/cache@v4
        with:
          # See https://doc.rust-lang.org/cargo/guide/cargo-home.html#caching-the-cargo-home-in-ci
          # See https://github.com/actions/cache/blob/main/examples.md#rust---cargo
          path: |
            ~/.cargo/.crates.toml
            ~/.cargo/.crates2.json
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            ${{ inputs.HOLOCHAIN_REPO }}/target/
          key: "${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}"

      - name: Generate READMEs and bump the crate versions
        id: bump-versions
        if: ${{ inputs.skip_prepare_logic != 'true' }}
        env:
          HOLOCHAIN_REPO: ${{ inputs.HOLOCHAIN_REPO }}
          HOLOCHAIN_SOURCE_BRANCH: ${{ inputs.HOLOCHAIN_SOURCE_BRANCH }}
        run: |
          set -exu

          cd ${HOLOCHAIN_REPO}

          nix run .#cargo-sweep -- sweep -s
          nix run .#scripts-release-automation-check-and-bump -- $PWD
          
          ./scripts/format-toml.sh
          ./scripts/ci-git-config.sh
          git add **/*.toml
          git commit -m "Format toml files"
          
          nix run .#scripts-ci-generate-readmes
          nix run .#cargo-sweep -- sweep -f

          if ! git diff --exit-code --quiet ${HOLOCHAIN_SOURCE_BRANCH}; then
            echo "releasable_crates=true" >> $GITHUB_OUTPUT
          else
            echo "releasable_crates=false" >> $GITHUB_OUTPUT
          fi

      - name: Run dmesg on error
        if: ${{ failure() }}
        run: sudo dmesg

      - name: cache the repo and set outputs
        id: write-env-and-tag
        env:
          HOLOCHAIN_REPO: ${{ inputs.HOLOCHAIN_REPO }}
        run: |
          set -exu

          cd "${HOLOCHAIN_REPO}"

          export RELEASE_BRANCH=$(git branch --show-current)

          git tag --sort=-taggerdate --merged "${RELEASE_BRANCH}" | grep holochain-

          export LATEST_HOLOCHAIN_RELEASE_TAG=$(git tag --sort=-taggerdate --merged "${RELEASE_BRANCH}" | grep holochain- | head -n1)
          export LATEST_HOLOCHAIN_RELEASE_VERSION=${LATEST_HOLOCHAIN_RELEASE_TAG/holochain-/}

          # clean the repo before adding it to the store. Adding the directory to the store will cause the content to be pushed to cachix.
          git clean -ffdx
          export STORE_PATH=$(nix store add --name holochain_repo .)

          echo "latest_holochain_release_tag=${LATEST_HOLOCHAIN_RELEASE_TAG}" >> $GITHUB_OUTPUT
          echo "latest_holochain_release_version=${LATEST_HOLOCHAIN_RELEASE_VERSION}" >> $GITHUB_OUTPUT
          echo "release_branch=${RELEASE_BRANCH}" >> $GITHUB_OUTPUT
          echo "repo_nix_store_path=${STORE_PATH}" >> $GITHUB_OUTPUT

      - name: Setup SSH session
        uses: steveeJ-forks/action-upterm@main
        if: ${{ failure() && inputs.debug == 'true' }}
        env:
          HRA_GITHUB_TOKEN: ${{ secrets.HRA_GITHUB_TOKEN }}
        with:
          ## limits ssh access and adds the ssh public key for the user which triggered the workflow
          limit-access-to-actor: true
          ## limits ssh access and adds the ssh public keys of the listed GitHub users
          limit-access-to-users: steveeJ,jost-s,neonphog,maackle,ThetaSinner,cdunster



================================================
File: .github/workflows/release.yml
================================================
# Contained Jobs
# - vars: processes the input
# - prepare: imported from ./release-prepare.yml
# - test: calls ./holochain-build-and-test.yml
# - finalize:
#   - restore repo from cache
#   - push to the target branch
#   - push to the release branch (TODO: What is the difference)
#   - publish crates
#   - push tags
#   - merge release branch into source branch
#   - push updated source branch
#   - create a pull-request towards the source branch
#   - create a github release
#
# involved branches:
# - the target branch is expected to never change outside of the release workflow, hence the usage of `git merge --ff-only`.
# - the source branch is the one that developers create changes to; we do use pull-requests for that but that's not part of the release workflow's concern.
# - the release branch is a temporary branch that is created ad-hoc by the release workflow that contains the version bumps before merging them into the target branch and back into the source branch.

name: release holochain

on:
# TODO re-enabled after K2 integration
#  schedule:
#    - cron: "0 0 * * 3" # At 12:00am on Wednesday
  workflow_dispatch:
    inputs:
      # holochain_url:
      #   description: "holochain git repo url"
      #   required: false
      #   default: ""
      #   type: string
      holochain_source_branch:
        description: "holochain source branch for the release"
        required: false
        default: ""
        type: string
      holochain_target_branch:
        description: "holochain target branch for the release"
        required: false
        default: ""
        type: string
      dry_run:
        description: "dry-run: prevent crate.io publishing and pushing the git tags, target and source branches"
        required: false
        default: "true"
        type: string
      debug:
        description: "start an ssh session on failure"
        required: false
        default: "true"
        type: string
      skip_test:
        description: "skip the integration test suite"
        required: false
        default: "false"
        type: string
      skip_prepare_logic:
        description: "skip the version bump step"
        type: string
        default: "false"
        required: true
      force_cancel_in_progress:
        description: "force cancelling a running action"
        required: false
        default: "false"
        type: string

concurrency:
  group: release-${{ github.ref_name }}-${{ github.event_name }}
  cancel-in-progress: ${{ github.event.inputs.force_cancel_in_progress == 'true' || github.event_name == 'pull_request' }}

env:
  HOLOCHAIN_REPO: "/var/tmp/holochain_repo"
  CACHIX_REV: "v1.2"

jobs:
  vars:
    runs-on: ubuntu-latest
    outputs:
      HOLOCHAIN_REPO: ${{ steps.eval.outputs.HOLOCHAIN_REPO }}
      CACHIX_REV: ${{ steps.eval.outputs.CACHIX_REV}}
      # holochain_url: ${{ steps.eval.outputs.holochain_url }}
      holochain_source_branch: ${{ steps.eval.outputs.holochain_source_branch }}
      holochain_target_branch: ${{ steps.eval.outputs.holochain_target_branch }}
      dry_run: ${{ steps.eval.outputs.dry_run }}
      debug: ${{ steps.eval.outputs.debug }}
      skip_test: ${{ steps.eval.outputs.skip_test }}
      skip_prepare_logic: ${{ steps.eval.outputs.skip_prepare_logic }}
    steps:
      - name: evaluate variables
        id: eval
        env:
          # input_holochain_url: ${{ github.event.inputs.holochain_url }}
          input_holochain_source_branch: ${{ github.event.inputs.holochain_source_branch }}
          input_holochain_target_branch: ${{ github.event.inputs.holochain_target_branch }}
          input_dry_run: ${{ github.event.inputs.dry_run}}
          input_debug: ${{ github.event.inputs.debug }}
          input_skip_test: ${{ github.event.inputs.skip_test }}
          input_skip_prepare_logic: ${{ github.event.inputs.skip_prepare_logic }}

        run: |
          set -xeu

          # if [[ ${input_holochain_url} != "" ]]; then
          #   echo "holochain_url=${input_holochain_url}" >> $GITHUB_OUTPUT
          # else
          #   echo "holochain_url=https://github.com/holochain/holochain" >> $GITHUB_OUTPUT
          # fi

          if [[ ${input_holochain_source_branch} != "" ]]; then
            export holochain_source_branch="${input_holochain_source_branch}"
          else
            export holochain_source_branch="${GITHUB_HEAD_REF:-${GITHUB_REF_NAME}}"
          fi
          echo "holochain_source_branch=${holochain_source_branch}" >> $GITHUB_OUTPUT

          if [[ ${input_holochain_target_branch} != "" ]]; then
            echo "holochain_target_branch=${input_holochain_target_branch}" >> $GITHUB_OUTPUT
          else
            case "${holochain_source_branch}" in
              develop*)
                echo "holochain_target_branch=$(echo ${holochain_source_branch} | sed 's/^develop/main/')" >> $GITHUB_OUTPUT
                ;;
              *)
                echo "holochain_target_branch=release-target-${holochain_source_branch}" >> $GITHUB_OUTPUT
                export enforce_dry_run="true"
                ;;
            esac
          fi

          if [[ "${enforce_dry_run:-false}" == "true" ]]; then
            echo dry-run enforced
            echo "dry_run=true" >> $GITHUB_OUTPUT
          elif [[ ${input_dry_run} != "" ]]; then
            echo "dry_run=${input_dry_run}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "schedule" ]]; then
            echo "dry_run=false" >> $GITHUB_OUTPUT
          else
            echo "dry_run=true" >> $GITHUB_OUTPUT
          fi

          if [[ ${input_debug} != "" ]]; then
            echo "debug=${input_debug}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "schedule" ]]; then
            echo "debug=false" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "debug=false" >> $GITHUB_OUTPUT
          else
            echo "debug=true" >> $GITHUB_OUTPUT
          fi

          if [[ ${input_skip_test} != "" ]]; then
            echo "skip_test=${input_skip_test}" >> $GITHUB_OUTPUT
          else
            echo "skip_test=false" >> $GITHUB_OUTPUT
          fi

          if [[ ${input_skip_prepare_logic} != "" ]]; then
            echo "skip_prepare_logic=${input_skip_prepare_logic}" >> $GITHUB_OUTPUT
          else
            echo "skip_prepare_logic=false" >> $GITHUB_OUTPUT
          fi

          echo "HOLOCHAIN_REPO=${{ env.HOLOCHAIN_REPO }}" >> $GITHUB_OUTPUT
          echo "CACHIX_REV=${{ env.CACHIX_REV }}" >> $GITHUB_OUTPUT
  prepare:
    needs: [vars]
    uses: ./.github/workflows/release-prepare.yml
    with:
      dry_run: ${{ needs.vars.outputs.dry_run }}
      debug: ${{ needs.vars.outputs.debug }}
      skip_prepare_logic: ${{ needs.vars.outputs.skip_prepare_logic }}
      HOLOCHAIN_SOURCE_BRANCH: ${{ needs.vars.outputs.holochain_source_branch }}
      HOLOCHAIN_TARGET_BRANCH: ${{ needs.vars.outputs.holochain_target_branch }}
      HOLOCHAIN_REPO: ${{ needs.vars.outputs.HOLOCHAIN_REPO }}
      CACHIX_REV: ${{ needs.vars.outputs.CACHIX_REV }}
    secrets:
      CACHIX_SIGNING_KEY: ${{ secrets.CACHIX_AUTH_TOKEN }}
      CACHIX_AUTH_TOKEN: ${{ secrets.CACHIX_AUTH_TOKEN }}
      HRA_GITHUB_TOKEN: ${{ secrets.HRA_GITHUB_TOKEN}}

  test:
    needs: [vars, prepare]
    if: ${{ needs.vars.outputs.skip_test != 'true' }}
    uses: ./.github/workflows/holochain-build-and-test.yml
    with:
      repo_path: ${{ needs.prepare.outputs.repo_nix_store_path }}
    secrets:
      GITHUB_ACCESS_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      CACHIX_AUTH_TOKEN_HOLOCHAIN_CI_INTERNAL: ${{ secrets.CACHIX_AUTH_TOKEN_HOLOCHAIN_CI_INTERNAL }}

  finalize:
    if: ${{ always() && needs.prepare.result == 'success' && (needs.test.result == 'success' || needs.test.result == 'skipped') && github.event_name != 'pull_request' && (needs.prepare.outputs.releasable_crates == 'true' || needs.vars.outputs.skip_prepare_logic == 'true') }}
    needs: [vars, prepare, test]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Install nix
        uses: cachix/install-nix-action@v26
      - name: Setup cachix
        uses: cachix/cachix-action@v14
        if: ${{ ! contains(matrix.platform.runs-on, 'self-hosted') }}
        with:
          name: holochain-ci
          authToken: "${{ secrets.CACHIX_AUTH_TOKEN }}"
          installCommand: |
            nix-env -if https://github.com/cachix/cachix/tarball/${CACHIX_REV} \
              --substituters 'https://cache.nixos.org https://cachix.cachix.org' \
              --trusted-public-keys 'cachix.cachix.org-1:eWNHQldwUO7G2VkjpnjDbWwy4KQ/HNxht7H4SSoMckM= cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY='

      - name: Restore the holochain release repository
        env:
          HOLOCHAIN_REPO_NIX_STORE_PATH: ${{ needs.prepare.outputs.repo_nix_store_path }}
        run: |
          set -exu

          if [[ -d "${HOLOCHAIN_REPO}" ]]; then
            echo repository at ${HOLOCHAIN_REPO} unexpectedly exists
            exit 1
          fi

          # this fetches the repo from the nix cache
          nix-store --realise ${HOLOCHAIN_REPO_NIX_STORE_PATH}

          mkdir -p $(dirname ${HOLOCHAIN_REPO})
          cp -rv --no-preserve=ownership ${HOLOCHAIN_REPO_NIX_STORE_PATH} ${HOLOCHAIN_REPO}
          chmod --recursive u+w ${HOLOCHAIN_REPO}
          cp -v $HOME/work/holochain/holochain/.git/config ${HOLOCHAIN_REPO}/.git/config

      - name: Restore Cargo cache
        uses: actions/cache@v4
        with:
          # See https://doc.rust-lang.org/cargo/guide/cargo-home.html#caching-the-cargo-home-in-ci
          # See https://github.com/actions/cache/blob/main/examples.md#rust---cargo
          path: |
            ~/.cargo/.crates.toml
            ~/.cargo/.crates2.json
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            ${{ env.HOLOCHAIN_REPO }}/target/
          key: "${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}"

      - name: Ensure the git credentials are set
        env:
          HRA_GITHUB_TOKEN: ${{ secrets.HRA_GITHUB_TOKEN }}
        run: |
          set -xeu
          cd "${HOLOCHAIN_REPO}"

          ./scripts/ci-git-config.sh
          # use our custom token for more permissions, e.g. "workflow" which is needed to push workflow files
          git config --local "http.https://github.com/.extraheader" "AUTHORIZATION: basic $(echo -n pat:${HRA_GITHUB_TOKEN} | base64)"

      - name: Merge release branch (${{ needs.prepare.outputs.release_branch }}) into target branch (${{ needs.vars.outputs.holochain_target_branch }}) and push it
        env:
          RELEASE_BRANCH: ${{ needs.prepare.outputs.release_branch }}
          HOLOCHAIN_TARGET_BRANCH: ${{ needs.vars.outputs.holochain_target_branch }}
          DRY_RUN: "${{ needs.vars.outputs.dry_run }}"
        run: |
          set -xeu
          cd "${HOLOCHAIN_REPO}"

          git status

          git checkout ${HOLOCHAIN_TARGET_BRANCH}
          git merge --ff-only ${RELEASE_BRANCH}

          if [[ "${DRY_RUN}" == "false" ]]; then
            git push origin ${HOLOCHAIN_TARGET_BRANCH}
          fi

      - name: Push the release branch
        id: push-release-branch
        env:
          RELEASE_BRANCH: ${{ needs.prepare.outputs.release_branch }}
          HOLOCHAIN_REPO_NIX_STORE_PATH: ${{ needs.prepare.outputs.repo_nix_store_path }}
        run: |
          set -xeu
          cd "${HOLOCHAIN_REPO}"

          git checkout ${RELEASE_BRANCH}
          git push origin ${RELEASE_BRANCH}

      - name: Publish crates
        if: ${{ needs.vars.outputs.dry_run == 'false' }}
        id: publish
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
        run: |
          cd "${HOLOCHAIN_REPO}"

          nix develop .#release \
            --ignore-environment \
            --keep CARGO_REGISTRY_TOKEN \
            --command release-automation \
                --workspace-path=$PWD \
                --log-level=trace \
                release \
                  --no-verify \
                  --steps=PublishToCratesIo,AddOwnersToCratesIo

      - name: Push the tags
        if: ${{ needs.vars.outputs.dry_run == 'false' }}
        id: push-tags
        env:
          HOLOCHAIN_TARGET_BRANCH: ${{ needs.vars.outputs.holochain_target_branch }}
        run: |
          set -eu
          cd "${HOLOCHAIN_REPO}"

          git status

          # Push just the Holochain tag initially, so that GitHub Actions will create an event based on it.
          # Pushing a batch larger than 3 tags will cause the event to be ignored -> https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#push
          # TODO Once this has been tested, removed the `set +eu` and `set -eu` lines. That is just to prevent this from making the workflow fail.
          set +eu
          SEARCH_PATTERN="^holochain-[0-9]"
          ALL_HOLOCHAIN_TAGS=$(git -c 'versionsort.suffix=-beta-dev' -c 'versionsort.suffix=-dev' -c 'versionsort.suffix=-rc' tag --sort='v:refname' | cut --delimiter='/' --fields=3)
          LATEST_MATCHING_TAG=$(echo "$ALL_HOLOCHAIN_TAGS" | grep -E "$SEARCH_PATTERN" | tail -n 1)
          git push origin ${LATEST_MATCHING_TAG}
          set -eu

          git push origin ${HOLOCHAIN_TARGET_BRANCH} --tags

      - name: Merge release branch into source branch
        continue-on-error: true
        id: merge-into-source
        env:
          RELEASE_BRANCH: ${{ needs.prepare.outputs.release_branch }}
          HOLOCHAIN_SOURCE_BRANCH: ${{ needs.vars.outputs.holochain_source_branch }}
        run: |
          set -xeu
          cd "${HOLOCHAIN_REPO}"

          git fetch origin ${HOLOCHAIN_SOURCE_BRANCH}
          git checkout -B ${HOLOCHAIN_SOURCE_BRANCH} origin/${HOLOCHAIN_SOURCE_BRANCH}
          git merge ${RELEASE_BRANCH}

      - name: Push the updated source branch
        if: ${{ needs.vars.outputs.dry_run == 'false' }}
        continue-on-error: true
        env:
          HOLOCHAIN_SOURCE_BRANCH: ${{ needs.vars.outputs.holochain_source_branch }}
        run: |
          set -xeu
          cd "${HOLOCHAIN_REPO}"
          git status
          git pull origin ${HOLOCHAIN_SOURCE_BRANCH}
          git push origin ${HOLOCHAIN_SOURCE_BRANCH}

      - name: Create a pull-request towards the source branch
        id: cpr
        if: ${{ always() && steps.push-release-branch.outcome == 'success' && (needs.vars.outputs.dry_run == 'true' || (steps.publish.outcome == 'failed' || steps.push-tags.outcome == 'failed' || steps.merge-into-source.outcome == 'failed')) }}
        continue-on-error: ${{ needs.prepare.outputs.releasable_crates != 'true' }}
        env:
          RELEASE_BRANCH: ${{ needs.prepare.outputs.release_branch }}
          HOLOCHAIN_SOURCE_BRANCH: ${{ needs.vars.outputs.holochain_source_branch }}
          GITHUB_TOKEN: ${{ secrets.HRA_GITHUB_TOKEN }}
        run: |
          set -xeuE -o pipefail

          cd "${HOLOCHAIN_REPO}"

          gh pr create \
            --title "Merge ${RELEASE_BRANCH} back into ${HOLOCHAIN_SOURCE_BRANCH}" \
            --label release \
            --label "autoupdate:opt-in" \
            --base ${HOLOCHAIN_SOURCE_BRANCH} --head "${RELEASE_BRANCH}" \
            --body 'Please double-check the consistency of the CHANGELOG.md files' 2>&1 | tee gh-pr-create.log
            # --reviewer "holochain/core-dev" \

          pull_request_number="$(tail -n1 gh-pr-create.log | grep -oE '[0-9]+$')"
          echo "pull-request-number=${pull_request_number}" >> $GITHUB_OUTPUT

      - name: Create a github release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HOLOCHAIN_TARGET_BRANCH: ${{ needs.vars.outputs.holochain_target_branch }}
          RELEASE_BRANCH: ${{ needs.prepare.outputs.release_branch }}
          LATEST_HOLOCHAIN_RELEASE_TAG: ${{ needs.prepare.outputs.latest_holochain_release_tag }}
          LATEST_HOLOCHAIN_RELEASE_VERSION: ${{ needs.prepare.outputs.latest_holochain_release_version }}
          DRY_RUN: "${{ needs.vars.outputs.dry_run }}"
        run: |
          set -eux
          cd "${GITHUB_WORKSPACE}"
          ./scripts/ci-gh-release.sh

      - name: Setup SSH session
        uses: steveeJ-forks/action-upterm@main
        if: ${{ failure() && needs.vars.outputs.debug == 'true' }}
        env:
          GITHUB_ACTION_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_HRA_ACTION_TOKEN: ${{ secrets.HRA_GITHUB_TOKEN }}
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
        with:
          ## limits ssh access and adds the ssh public key for the user which triggered the workflow
          limit-access-to-actor: true
          ## limits ssh access and adds the ssh public keys of the listed GitHub users
          limit-access-to-users: steveeJ,jost-s,neonphog,maackle,ThetaSinner,cdunster

  github-actions-ci-jobs-succeed:
    if: ${{ always() && github.event_name == 'pull_request' }}
    runs-on: "ubuntu-latest"
    needs: [vars, test, prepare]
    steps:
      - name: Check status
        id: check-status
        env:
          RESULTS: "${{ toJSON(needs.*.result) }}"
          DRY_RUN: "${{ needs.vars.outputs.dry_run }}"
          SKIP_TEST: "${{ needs.vars.outputs.skip_test }}"
        run: |
          [[ $(jq -n 'env.RESULTS | fromjson | unique == ["success"]') == 'true' ]] || \
          [[ (${DRY_RUN} == 'true' || ${SKIP_TEST} == 'true') && $(jq -n 'env.RESULTS | fromjson | unique | sort == ["skipped", "success"]') == 'true' ]]

      - name: Post mattermost message
        if: always()
        shell: bash
        continue-on-error: true
        env:
          STATUS: ${{ steps.check-status.outcome }}
          VERSION: ${{ needs.prepare.outputs.latest_holochain_release_version }}
          TAG: ${{ needs.prepare.outputs.latest_holochain_release_tag }}
          WORKFLOW_RUN_URL: "https://github.com/holochain/holochain/actions/runs/${{ github.run_id }}"
          HRA_MATTERMOST_TOKEN: ${{ secrets.HRA_MATTERMOST_TOKEN }}

          # dev/holochain-rsm/CI
          MM_CHANNEL_ID: "uzjosy5d3fdcxe35oyw9naihfw"
        run: |
          set -xeEu

          if [[ "${STATUS}" == "success" ]]; then
            holochain_status=":white_check_mark:"
          else
            holochain_status=":x:"
          fi

          holochain_status="${holochain_status} [log](${WORKFLOW_RUN_URL})"

          message=$(cat <<-EOF
          #### Holochain release run (ci-mode)

          Version | ${VERSION}
          --- | ---
          holochain | ${holochain_status}
          EOF
          )
          export message

          data=$(jq -n --compact-output '{"channel_id":env.MM_CHANNEL_ID, "message":env.message, "props":{"version":env.VERSION}}')
          curl -X POST -H "Authorization: Bearer ${HRA_MATTERMOST_TOKEN}" -d "$data" https://chat.holochain.org/api/v4/posts

      - name: Trigger status event
        if: always()
        shell: bash
        continue-on-error: true
        env:
          STATUS: ${{ steps.check-status.outcome }}
          WORKFLOW_RUN_URL: "https://github.com/holochain/holochain/actions/runs/${{ github.run_id }}"
        run: |
          set -x

          data=$(jq -n --compact-output '{
            "state":env.STATUS,
            "target_url":env.WORKFLOW_RUN_URL,
            "description":"release workflow completed",
            "context":"github-actions/relelase-holochain"
          }')
          curl -L -X POST \
            -H "Content-Type: application/json" \
            -H "Authorization: token ${{ secrets.HRA_GITHUB_TOKEN}}" \
            -d "$data" \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/statuses/${{ github.sha }}"

  all-jobs-succeed:
    if: ${{ always() && github.event_name != 'pull_request' }}
    runs-on: "ubuntu-latest"
    needs: [vars, prepare, test, finalize]
    steps:
      - name: Check status
        id: check-status
        env:
          RESULTS: "${{ toJSON(needs.*.result) }}"
          DRY_RUN: "${{ needs.vars.outputs.dry_run }}"
          SKIP_TEST: "${{ needs.vars.outputs.skip_test }}"
        run: |
          [[ $(jq -n 'env.RESULTS | fromjson | unique == ["success"]') == 'true' ]] || \
          [[ (${DRY_RUN} == 'true' || ${SKIP_TEST} == 'true') && $(jq -n 'env.RESULTS | fromjson | unique | sort == ["skipped", "success"]') == 'true' ]]

      - name: Post mattermost message
        if: always()
        continue-on-error: true
        env:
          STATUS: ${{ steps.check-status.outcome }}
          VERSION: ${{ needs.prepare.outputs.latest_holochain_release_version }}
          TAG: ${{ needs.prepare.outputs.latest_holochain_release_tag }}
          WORKFLOW_RUN_URL: "https://github.com/holochain/holochain/actions/runs/${{ github.run_id }}"
          HRA_MATTERMOST_TOKEN: ${{ secrets.HRA_MATTERMOST_TOKEN }}
          DRY_RUN: "${{ needs.vars.outputs.dry_run }}"
          RELEASABLE_CRATES: ${{ needs.prepare.outputs.releasable_crates }}

          # dev/HC-releases
          MM_CHANNEL_ID: "cdxeytdc97ff3e1jbdzgyfcduo"
        run: |
          if [[ "${STATUS}" == "success" ]]; then
            # TODO: adapt tag to case where holochain isn't released
            holochain_status="success :white_check_mark: [log](${WORKFLOW_RUN_URL}), [tag](https://github.com/holochain/holochain/releases/tag/${TAG})"
          elif [[ "${RELEASABLE_CRATES}" == "false" ]]; then
            holochain_status="no changes to release :ballot_box_with_check: [log](${WORKFLOW_RUN_URL})"
          else
            holochain_status="failure :x: [log](${WORKFLOW_RUN_URL})"
          fi

          mode="release-mode"
          if [[ "${DRY_RUN}" == "true" ]]; then
            mode="${mode}, dry-run"
          fi

          message=$(cat <<-EOF
          #### Holochain release run (${mode})

          Version | ${VERSION}
          --- | ---
          holochain | ${holochain_status}
          holonix | _undetermined_
          EOF
          )
          export message

          data=$(jq -n --compact-output '{"channel_id":env.MM_CHANNEL_ID, "message":env.message, "props":{"version":env.VERSION}}')
          curl -X POST -H "Authorization: Bearer ${HRA_MATTERMOST_TOKEN}" -d "$data" https://chat.holochain.org/api/v4/posts



================================================
File: .github/workflows/ssh-session.yml
================================================
# An action triggered manually to debug the cached state for `release.yml` and `release-prepare.yml`

name: SSH session

on:
  workflow_dispatch:
    inputs:
      runs-on:
        description: "value passed to 'runs-on'"
        required: false
        default: "ubuntu-latest"
        type: string
      extend-space:
        description: "extend the runner's space"
        required: false
        default: "false"
        type: string

jobs:
  ssh-session:
    runs-on: ${{ github.event.inputs.runs-on }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Extend space
        uses: ./.github/actions/extend-space
        if: ${{ github.event.inputs.runs-on == 'ubuntu-latest'  && github.event.inputs.extend-space == 'true' }}

      - name: Install nix
        uses: cachix/install-nix-action@v26
        if: ${{ github.event.inputs.runs-on != 'multi-arch' }}
        with:
          extra_nix_config: |
            experimental-features = flakes nix-command

      - name: Setup cachix
        uses: cachix/cachix-action@v14
        if: ${{ matrix.platform.runs-on != 'multi-arch' }}
        with:
          name: holochain-ci
          authToken: "${{ secrets.CACHIX_AUTH_TOKEN }}"

      - name: Restart nix-daemon
        if: ${{ github.event.inputs.runs-on == 'ubuntu-latest' }}
        run: |
          sudo bash -c 'echo extra-experimental-features = impure-derivations >> /etc/nix/nix.conf'
          sudo systemctl stop nix-daemon

      - name: debug
        run: |
          set -x
          env
          nix-shell --version
          nix --version
          pwd

      - name: Setup SSH session
        uses: lhotari/action-upterm@v1
        env:
          ORIG_GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HRA_GITHUB_TOKEN: ${{ secrets.HRA_GITHUB_TOKEN }}
        if: ${{ always() }}
        with:
          ## limits ssh access and adds the ssh public key for the user which triggered the workflow
          limit-access-to-actor: true
          ## limits ssh access and adds the ssh public keys of the listed GitHub users
          limit-access-to-users: steveeJ,jost-s,neonphog,maackle,ThetaSinner,cdunster



================================================
File: .github/workflows/stale.yml
================================================
name: Stale
on:
  workflow_dispatch:
  schedule:
    - cron: "37 2 * * *"

jobs:
  close-issues:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
    steps:
      - uses: actions/stale@v9
        with:
          days-before-issue-stale: -1 # Disabled
          days-before-issue-close: -1 # Disabled
          stale-issue-label: "stale"
          stale-issue-message: "This item has been open for 30 days with no activity."
          close-issue-message: "This item has been inactive for 14 days since being marked as stale."
          exempt-issue-labels: "permanent"
          days-before-pr-stale: 30
          days-before-pr-close: 14
          stale-pr-label: "stale"
          stale-pr-message: "This item has been open for 30 days with no activity."
          close-pr-message: "This item has been inactive for 14 days since being marked as stale."
          exempt-pr-labels: "permanent"
          operations-per-run: 330
          repo-token: ${{ secrets.GITHUB_TOKEN }}



================================================
File: .github/workflows/test.yml
================================================
name: test

on:
  pull_request:
    branches:
      - develop
      - develop-*

concurrency:
  group: test-${{ github.workflow }}-${{ github.ref || github.run_id }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

env:
  CARGO_INCREMENTAL: 0
  RUSTFLAGS: "-Dwarnings"
  RUST_BACKTRACE: 1

jobs:
  static-job-id:
    name: static
    runs-on: ubuntu-latest
    steps:
      - name: checkout
        uses: actions/checkout@v4

      - name: "Common Test Setup Actions"
        uses: ./.github/actions/common-pre

      - name: static-fmt
        run: make static-fmt

      - name: static-toml
        run: make static-toml

      - name: static-clippy
        run: make static-clippy

      - name: static-clippy-unstable
        run: make static-clippy-unstable

      - name: static-doc
        run: make static-doc

      - name: "Common Test Teardown Actions"
        uses: ./.github/actions/common-post

  test-job-id:
    name: test
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            target: wasmer_sys
          - os: macos-latest
            target: wasmer_sys
          - os: macos-13
            target: wasmer_sys
          - os: windows-latest
            target: wasmer_sys
          - os: ubuntu-latest
            target: wasmer_sys-unstable

          # Our intended target for wasmer_wamr feature is iOS and Android.
          # For now, wasmer_wamr tests are only run on macos-latest
          - os: macos-latest
            target: wasmer_wamr
    steps:
      - name: checkout
        uses: actions/checkout@v4

      - name: "Common Test Setup Actions"
        uses: ./.github/actions/common-pre

      - name: install build dependencies (macos-latest, wasmer_wamr)
        if: matrix.os == 'macos-latest' && matrix.target == 'wasmer_wamr'
        shell: bash
        run: brew install cmake ninja

      - name: build (windows-latest)
        if: matrix.os == 'windows-latest'
        run: |-
          $env:OPENSSL_NO_VENDOR="1"
          $env:OPENSSL_DIR="$(pwd)\vcpkg\packages\openssl_x64-windows-release"
          $env:SODIUM_LIB_DIR="$(pwd)\vcpkg\packages\libsodium_x64-windows-release\lib"
          make build-workspace-${{ matrix.target }}

      - name: build
        if: matrix.os != 'windows-latest'
        run: make build-workspace-${{ matrix.target }}

      - name: test (windows-latest)
        if: matrix.os == 'windows-latest'
        run: |-
          $env:OPENSSL_NO_VENDOR="1"
          $env:OPENSSL_DIR="$(pwd)\vcpkg\packages\openssl_x64-windows-release"
          $env:SODIUM_LIB_DIR="$(pwd)\vcpkg\packages\libsodium_x64-windows-release\lib"
          make test-workspace-${{ matrix.target }}

      - name: test
        if: matrix.os != 'windows-latest'
        run: make test-workspace-${{ matrix.target }}

      - name: "Common Test Teardown Actions"
        uses: ./.github/actions/common-post

  ci-pass:
    if: ${{ always() }}
    name: "All Jobs Pass"
    runs-on: "ubuntu-latest"
    needs:
      - static-job-id
      - test-job-id
    steps:
      - name: check status
        uses: re-actors/alls-green@release/v1
        with:
          jobs: ${{ toJSON(needs) }}



================================================
File: .github/workflows/update-dispatch.yml
================================================
# Scheduled action to update:
# - flake inputs of ./versions/
# - rust-overlay flake input
# - nixpkgs flake input

name: "trigger source updates"
on:
  # push:
  #   branches: [pr-periodic-updates]
  # TODO Disabled during K2 integration, re-enable once done
  #schedule:
  #  - cron: "0 0 * * 1" # run once a week, at 12:00am on Monday
  workflow_dispatch:
    inputs:
      only-base-ref:
        description: |
          when this is set to 'true', the branches main and develop
          will not be automatically included in the update
        required: true
        default: "false"
        type: string

concurrency:
  group: ${{ github.ref_name }}

jobs:
  call-update:
    strategy:
      fail-fast: false
      matrix:
        branch:
          - name: develop
            skip: false
          - name: ${{ github.ref_name }}
            skip: true
        update:
          - source: "versions/weekly"
            cmd: "nix run .#scripts-repo-flake-update weekly"
          - source: "rust-overlay"
            cmd: "nix flake lock --update-input rust-overlay"
          - source: "nixpkgs"
            cmd: "nix flake lock --update-input nixpkgs"
          - source: "crates-io"
            cmd: "nix develop .#coreDev --command scripts-cargo-update"

    runs-on: "ubuntu-latest"
    steps:
      - name: Evaluate skip
        id: skip
        if: ${{
          !(
          (github.event.inputs.only-base-ref == 'true' && !endsWith(github.ref_name, matrix.branch.name))
          || (github.event.inputs.only-base-ref != 'true' && endsWith(github.ref_name, matrix.branch.name) && matrix.branch.skip == true)
          )
          }}
        run: echo
      - name: Checkout repository
        if: ${{ steps.skip.outcome != 'skipped' }}
        uses: actions/checkout@v4
      - name: Call the update action
        if: ${{ steps.skip.outcome != 'skipped' }}
        uses: ./.github/actions/update
        with:
          branch: ${{ matrix.branch.name }}
          update_source: ${{ matrix.update.source }}
          update_cmd: ${{ matrix.update.cmd }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HRA_GITHUB_TOKEN: ${{ secrets.HRA_GITHUB_TOKEN }}
          CACHIX_SIGNING_KEY: ${{ secrets.CACHIX_SIGNING_KEY }}
          CACHIX_AUTH_TOKEN: ${{ secrets.CACHIX_AUTH_TOKEN }}
  all-jobs-succeed:
    runs-on: "ubuntu-latest"
    needs: [call-update]
    if: always()
    steps:
      - name: Check status
        env:
          RESULTS: "${{ toJSON(needs.*.result) }}"
        run: "[[ $(jq -n 'env.RESULTS | fromjson | unique == [\"success\"]') == \"true\" ]]\n"



================================================
File: .github/workflows/update-holonix-version.yml
================================================
name: "Update Holonix versions"
on:
  workflow_dispatch:
    inputs:
      version:
        description: |
          One of the directory names under ./versions
        required: true
        default: "false"
        type: choice
        options:
          - "0_2"
          - "0_2_rc"
          - "0_3"
          - "0_3_rc"
          - "0_4"
          - "0_4_rc"
          - "weekly"

concurrency:
  group: ${{ github.ref_name }}

jobs:
  update-holonix-version:
    runs-on: "ubuntu-latest"
    steps:
      - uses: actions/checkout@v4
        with:
          ref: develop
      - uses: cachix/install-nix-action@v26
      - name: Get tags
        run: git fetch --quiet --tags origin
      - name: Configure Git
        shell: bash
        run: |
          ./scripts/ci-git-config.sh
      - name: Run the update script
        run: |
          ./scripts/update-holonix-version.sh ${{ github.event.inputs.version }}

          echo "Completed source update. Now updating the flake locks"

          nix run .#scripts-repo-flake-update ${{ github.event.inputs.version }}
      - name: Create Pull Request
        id: cpr
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.HRA_GITHUB_TOKEN }}
          committer: "Holochain Release Automation <hra+gh@holochain.org>"
          title: "Update Holochain version in Holonix for ${{ github.event.inputs.version }}"
          branch: holonix-update/${{ github.event.inputs.version }}
          labels: |
            autorebase:opt-in
          draft: false
          delete-branch: true
      - name: Enable auto-merge
        if: steps.cpr.outputs.pull-request-operation == 'created'
        run: gh pr merge --squash --auto "${{ steps.cpr.outputs.pull-request-number }}"
        env:
          GH_TOKEN: ${{ secrets.HRA_GITHUB_TOKEN }}


