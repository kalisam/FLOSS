                "#
                },
            ),
        ];

        let release_name = "2021.mock";
        ws_changelog
            .add_release(release_name.to_string(), &crate_releases)
            .unwrap();

        let result = std::fs::read_to_string(ws_changelog.path()).unwrap();
        let expected = indoc::formatdoc!(
            r#"
            # Changelog
            This file conveniently consolidates all of the crates individual CHANGELOG.md files and groups them by timestamps at which crates were released.
            The file is updated every time one or more crates are released.

            The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).
            This project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

            # [Unreleased]

            ## Something outdated maybe
            This will be removed by aggregation.


            ## [crate\_a](crates/crate_a/CHANGELOG.md#unreleased)
            ### Added
            - `InstallAppBundle`

            ## [crate\_f](crates/crate_f/CHANGELOG.md#unreleased)

            This will be released in the future.

            # {}
            The text beneath this heading will be retained which allows adding overarching release notes.

            ## [crate_e-0.0.1](crates/crate_e/CHANGELOG.md#0.0.1)
            Awesome changes!

            ## [crate_c-0.0.1](crates/crate_c/CHANGELOG.md#0.0.1)
            Awesome changes!

            ### Breaking
            Breaking changes, be careful.

            # [20210304.120604]
            This will include the hdk-0.0.100 release.

            ## [hdk-0.0.100](crates/hdk/CHANGELOG.md#0.0.100)

            ### Changed
            - hdk: fixup the autogenerated hdk documentation.
            "#,
            release_name
        );

        let expected = sanitize(expected);
        assert_eq!(
            result,
            expected,
            "\ndiff:\n{}",
            prettydiff::text::diff_lines(&result, &expected).format()
        );
    }

    #[test]
    fn find_crate_changes() {
        let workspace_mocker = example_workspace_1().unwrap();

        let inputs: &[(&str, PathBuf, Vec<ChangeT>)] = &[
            (
                "crate_a",
                workspace_mocker.root().join("crates/crate_a/CHANGELOG.md"),
                vec![
                    ChangeT::Unreleased,
                    ChangeT::Release(ReleaseChange::CrateReleaseChange("0.0.1".to_string())),
                ],
            ),
            (
                "crate_b",
                workspace_mocker.root().join("crates/crate_b/CHANGELOG.md"),
                vec![ChangeT::Unreleased],
            ),
            (
                "crate_c",
                workspace_mocker.root().join("crates/crate_c/CHANGELOG.md"),
                vec![ChangeT::Unreleased],
            ),
        ];

        for (name, changelog_path, expected_changes) in inputs {
            let changelog = ChangelogT::<CrateChangelog>::at_path(changelog_path);

            let changes = changelog.changes().unwrap();

            assert_eq!(expected_changes, &changes, "{}", name);
        }
    }

    #[test]
    fn find_workspace_changes() {
        let workspace_mocker = example_workspace_1().unwrap();

        let changelog_path = workspace_mocker.root().join("CHANGELOG.md");
        let changelog = ChangelogT::<WorkspaceChangelog>::at_path(&changelog_path);
        let changes = changelog.changes().unwrap();

        assert_eq!(
            vec![
                ChangeT::Changelog,
                ChangeT::Unreleased,
                ChangeT::Release(ReleaseChange::WorkspaceReleaseChange(
                    "[20210304.120604]".to_string(),
                    vec!["hdk-0.0.100".to_string()]
                )),
            ],
            changes
        );
    }

    use test_case::test_case;

    #[test_case(Frontmatter::default(), SemverIncrementMode::default())]
    #[test_case(Frontmatter{ semver_increment_mode: None, ..Default::default()}, SemverIncrementMode::default())]
    #[test_case(Frontmatter{ semver_increment_mode: Some(SemverIncrementMode::Minor), ..Default::default()}, SemverIncrementMode::Minor)]
    #[test_case(Frontmatter{ default_semver_increment_mode: Some(SemverIncrementMode::Minor), ..Default::default()}, SemverIncrementMode::Minor)]
    fn semver_increment_mode_getter(fm: Frontmatter, expected: SemverIncrementMode) {
        assert_eq!(fm.semver_increment_mode(), expected)
    }

    #[test]
    fn crate_changelog_reset_front_matter() {
        let workspace_mocker = example_workspace_1().unwrap();

        let read_changelog = move || -> ChangelogT<CrateChangelog> {
            ChangelogT::<CrateChangelog>::at_path(
                &workspace_mocker.root().join("crates/crate_a/CHANGELOG.md"),
            )
        };

        let cl = read_changelog();
        let fm_orig = cl.front_matter().unwrap().expect("expected fm initially");

        assert!(
            fm_orig.semver_increment_mode.is_some(),
            "expect semver_increment_mode initially"
        );

        cl.reset_front_matter_to_defaults().unwrap();

        let cl = read_changelog();
        let fm_new_readback = cl.front_matter().unwrap().unwrap();

        let fm_new_expected = Frontmatter {
            semver_increment_mode: None,

            ..fm_orig
        };
        assert_eq!(fm_new_expected, fm_new_readback);
    }

    #[test]
    fn changelog_set_frontmatter() {
        let workspace_mocker = example_workspace_1().unwrap();

        const FRONTMATTER_VALUE: &str = "default_semver_increment_mode: !pre_minor a-release-test";

        {
            let workspace = ReleaseWorkspace::try_new(workspace_mocker.root()).unwrap();

            let mut frontmatter_file = tempfile::NamedTempFile::new().unwrap();
            frontmatter_file
                .write_all(format!("\n{}\n", FRONTMATTER_VALUE).as_bytes())
                .unwrap();

            let mut cmd = crate::tests::cli::command_pure(
                "release-automation",
                Some(&workspace_mocker.root()),
            )
            .unwrap();
            let cmd = cmd.args(&[
                &format!("--workspace-path={}", workspace.root().display()),
                "--log-level=trace",
                "changelog",
                "set-frontmatter",
                &frontmatter_file.path().to_string_lossy(),
            ]);

            let (stderr, stdout) = crate::assert_cmd_success!(cmd);
            println!("stderr:\n{}\n\nstdout:\n{}", stderr, stdout);
        }

        // re-read the workspace after changing it
        let workspace = ReleaseWorkspace::try_new(workspace_mocker.root()).unwrap();

        for member in workspace.members().unwrap() {
            let changelog_path = member.changelog().unwrap().path();
            let changelog = ChangelogT::<CrateChangelog>::at_path(changelog_path);
            let result = sanitize(std::fs::read_to_string(changelog.path()).unwrap());
            assert!(
                result.contains(FRONTMATTER_VALUE),
                "expected {:?} frontmatter to contain {:?}, got: {}",
                changelog_path,
                FRONTMATTER_VALUE,
                result
            );
        }
    }
}



================================================
File: crates/release-automation/src/lib/check.rs
================================================
//! Check command functionality.

use super::*;

/// Parses the workspace for release candidates and checks for blocking conditions.
pub fn cmd(args: &cli::Args, cmd_args: &cli::CheckArgs) -> CommandResult {
    let ws = crate_selection::ReleaseWorkspace::try_new_with_criteria(
        args.workspace_path.clone(),
        cmd_args.to_selection_criteria(&args),
    )?;

    let release_candidates = common::selection_check(cmd_args, &ws)?;

    println!(
        "{}",
        crate_selection::CrateState::format_crates_states(
            &release_candidates
                .iter()
                .map(|member| (member.name(), member.state()))
                .collect::<Vec<_>>(),
            "The following crates would have been selected for the release process.",
            false,
            true,
            false,
        )
    );

    Ok(())
}



================================================
File: crates/release-automation/src/lib/common.rs
================================================
use std::{
    io::{Read, Write},
    path::Path,
};

use cargo::util::VersionExt;
use semver::{Comparator, VersionReq};
use serde::{Deserialize, Serialize};

use super::*;

pub fn selection_check<'a>(
    cmd_args: &'a crate::cli::CheckArgs,
    ws: &'a crate::crate_selection::ReleaseWorkspace<'a>,
) -> Fallible<Vec<&'a crate_selection::Crate<'a>>> {
    debug!("cmd_args: {:#?}", cmd_args);

    let release_selection = ws.release_selection()?;

    info!(
        "crates selected for the release process: {:#?}",
        release_selection
            .iter()
            .map(|crt| format!("{}-{}", crt.name(), crt.version()))
            .collect::<Vec<_>>()
    );

    Ok(release_selection)
}

#[cfg(test)]
pub fn get_dependency_version(manifest_path: &Path, name: &str) -> Fallible<String> {
    let manifest_path = manifest_path
        .parent()
        .ok_or_else(|| anyhow::anyhow!("couldn't get parent of path {}", manifest_path.display()))?
        .join("Cargo.toml");

    {
        let manifest: toml_edit::Document = load_from_file(&manifest_path)?.parse()?;
        for key in &["dependencies", "dev-dependencies", "build-dependencies"] {
            if manifest.as_table().contains_key(key)
                && manifest[key]
                    .as_table()
                    .expect("manifest is already verified")
                    .contains_key(name)
            {
                return Ok(manifest[key][name]["version"]
                    .as_value()
                    .ok_or_else(|| anyhow::anyhow!("expected a value"))?
                    .to_string());
            }
        }
    }

    bail!("version not found")
}

/// Load a file into a String
pub fn load_from_file(path: &Path) -> Fallible<String> {
    let mut file = std::fs::File::open(path)?;
    let mut s = String::new();
    file.read_to_string(&mut s)?;
    Ok(s)
}

#[derive(Clone, Debug, PartialEq, Deserialize, Serialize, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum SemverIncrementMode {
    Major,
    Minor,
    Patch,
    Pre(String),
    PreMajor(String),
    PreMinor(String),
    PrePatch(String),
}

impl Default for SemverIncrementMode {
    fn default() -> Self {
        Self::Patch
    }
}

#[derive(thiserror::Error, Debug, PartialEq)]
pub enum SemverIncrementError {
    #[error("resulting version ({result}) is lower than on entry ({entry})")]
    ResultingVersionLower {
        result: semver::Version,
        entry: semver::Version,
    },

    #[error("pre-release increment requested but none found on entry ({entry})")]
    MissingPreRelease { entry: semver::Version },
}

fn evaluate_suffix<'a>(suffix_requested: &'a str, pre: &'a semver::Prerelease) -> (&'a str, usize) {
    let (suffix, counter) = match pre.rsplit_once('.') {
        Some((suffix, maybe_number)) => {
            if let Ok(number) = maybe_number.parse::<usize>() {
                (suffix, number + 1)
            } else {
                (pre.as_str(), 0)
            }
        }

        None => (pre.as_str(), 0),
    };

    if suffix != suffix_requested {
        (suffix_requested, 0)
    } else {
        (suffix, counter)
    }
}

/// Implements version incrementation as specified in [SemVer 2.0.0](https://semver.org/spec/v2.0.0.html)
/// Currently resets [Build metadata](https://semver.org/spec/v2.0.0.html#spec-item-10).
pub fn increment_semver<'a>(v: &'a mut semver::Version, mode: SemverIncrementMode) -> Fallible<()> {
    use SemverIncrementMode::*;

    v.build = semver::BuildMetadata::EMPTY;

    let entry_version = v.clone();

    match mode {
        Major => {
            if !v.pre.is_empty() && v.patch == 0 && v.minor == 0 {
                v.pre = semver::Prerelease::EMPTY;
            } else {
                v.major += 1;
                v.minor = 0;
                v.patch = 0;
                v.pre = semver::Prerelease::EMPTY;
            }
        }
        Minor => {
            if !v.pre.is_empty() && v.patch == 0 {
                v.pre = semver::Prerelease::EMPTY;
            } else {
                v.minor += 1;
                v.patch = 0;
                v.pre = semver::Prerelease::EMPTY;
            }
        }
        Patch => {
            if !v.pre.is_empty() {
                v.pre = semver::Prerelease::EMPTY;
            } else {
                v.patch += 1;
                v.pre = semver::Prerelease::EMPTY;
            }
        }

        pre_modes => {
            let (suffix, counter) = match &pre_modes {
                Major | Minor | Patch => unreachable!(
                    r"
                        this arm is already fully covered in the surrounding match statement.
                        i'm surprised the compiler doesn't understand this ¯\_(ツ)_/¯
                    "
                ),

                Pre(suffix_requested) => {
                    if !v.is_prerelease() {
                        bail!(SemverIncrementError::MissingPreRelease { entry: v.clone() });
                    }

                    evaluate_suffix(&suffix_requested, &v.pre)
                }

                PreMajor(suffix_requested) => {
                    if v.minor == 0 && v.patch == 0 && v.is_prerelease() {
                        evaluate_suffix(suffix_requested.as_str(), &v.pre)
                    } else {
                        increment_semver(v, SemverIncrementMode::Major)?;
                        (suffix_requested.as_str(), 0)
                    }
                }

                PreMinor(suffix_requested) => {
                    if v.patch == 0 && v.is_prerelease() {
                        evaluate_suffix(suffix_requested.as_str(), &v.pre)
                    } else {
                        increment_semver(v, SemverIncrementMode::Minor)?;
                        (suffix_requested.as_str(), 0)
                    }
                }

                PrePatch(suffix_requested) => {
                    if v.is_prerelease() {
                        evaluate_suffix(suffix_requested.as_str(), &v.pre)
                    } else {
                        increment_semver(v, SemverIncrementMode::Patch)?;
                        (suffix_requested.as_str(), 0)
                    }
                }
            };

            let final_pre = format!("{}.{}", suffix, counter);
            v.pre = semver::Prerelease::new(&final_pre)?;
        }
    }

    if &entry_version >= &v {
        bail!(SemverIncrementError::ResultingVersionLower {
            result: v.clone(),
            entry: entry_version,
        });
    }

    Ok(())
}

#[cfg(test)]
mod test {
    use test_case::test_case;

    use crate::common::{
        increment_semver,
        SemverIncrementMode::{self, *},
    };

    use super::SemverIncrementError;

    //
    // Major
    //
    #[test_case(Major, "0.0.0-dev.0", "0.0.0")]
    #[test_case(Major, "0.0.1-dev.0", "1.0.0")]
    #[test_case(Major, "0.0.1", "1.0.0")]
    #[test_case(Major, "1.0.0-dev.0", "1.0.0")]
    #[test_case(Major, "1.0.0", "2.0.0")]
    #[test_case(Major, "1.0.1-dev.0", "2.0.0")]
    #[test_case(Major, "1.1.1-dev.0", "2.0.0")]
    #[test_case(Major, "1.1.1", "2.0.0")]
    //
    // Minor
    //
    #[test_case(Minor, "0.0.1", "0.1.0")]
    #[test_case(Minor, "0.0.1-dev.0", "0.1.0")]
    #[test_case(Minor, "0.1.1-dev.0", "0.2.0")]
    #[test_case(Minor, "0.1.0-beta-rc.1", "0.1.0")]
    //
    // Patch
    //
    #[test_case(Patch, "0.0.0-dev.0", "0.0.0")]
    #[test_case(Patch, "0.0.1-dev.0", "0.0.1")]
    #[test_case(Patch, "0.0.1", "0.0.2")]
    #[test_case(Patch, "0.1.1", "0.1.2")]
    #[test_case(Patch, "1.1.1", "1.1.2")]
    //
    // Pre
    //
    #[test_case(Pre("rc".to_string()), "0.0.1-dev.0", "0.0.1-rc.0")]
    #[test_case(Pre("rc".to_string()), "0.0.1-rc.0", "0.0.1-rc.1")]
    //
    // PreMajor
    //
    #[test_case(PreMajor("rc".to_string()), "0.0.0", "1.0.0-rc.0")]
    #[test_case(PreMajor("rc".to_string()), "0.0.1", "1.0.0-rc.0")]
    #[test_case(PreMajor("rc".to_string()), "0.1.0", "1.0.0-rc.0")]
    #[test_case(PreMajor("rc".to_string()), "0.1.1", "1.0.0-rc.0")]
    // TODO: check with someone else if this seems counter-intuitive
    #[test_case(PreMajor("rc".to_string()), "1.0.0-rc", "1.0.0-rc.0")]
    // TODO: check with someone else if this seems counter-intuitive
    #[test_case(PreMajor("rc".to_string()), "1.0.0-rc.0", "1.0.0-rc.1")]
    //
    // PreMinor
    //
    #[test_case(PreMinor("rc".to_string()), "0.0.0", "0.1.0-rc.0")]
    #[test_case(PreMinor("rc".to_string()), "0.0.1-rc.0", "0.1.0-rc.0")]
    // TODO: check with someone else if this seems counter-intuitive
    #[test_case(PreMinor("rc".to_string()), "0.1.0-rc", "0.1.0-rc.0")]
    // TODO: check with someone else if this seems counter-intuitive
    #[test_case(PreMinor("rc".to_string()), "0.1.0-rc.0", "0.1.0-rc.1")]
    #[test_case(PreMinor("beta-rc".to_string()), "0.0.170", "0.1.0-beta-rc.0")]
    #[test_case(PreMinor("beta-rc".to_string()), "0.1.0-beta-rc.0", "0.1.0-beta-rc.1")]
    //
    // PrePatch
    //
    #[test_case(PrePatch("rc".to_string()), "0.0.0", "0.0.1-rc.0")]
    #[test_case(PrePatch("rc".to_string()), "0.0.1", "0.0.2-rc.0")]
    #[test_case(PrePatch("rc".to_string()), "0.1.1", "0.1.2-rc.0")]
    #[test_case(PrePatch("rc".to_string()), "1.1.0", "1.1.1-rc.0")]
    #[test_case(PrePatch("rc".to_string()), "1.1.1-rc", "1.1.1-rc.0")]
    #[test_case(PrePatch("rc".to_string()), "1.1.1-rc.0", "1.1.1-rc.1")]
    #[test_case(PrePatch("rc".to_string()), "1.0.0", "1.0.1-rc.0")]
    // TODO: check with someone else if this seems counter-intuitive
    #[test_case(PrePatch("rc".to_string()), "0.0.0-rc", "0.0.0-rc.0")]
    // TODO: check with someone else if this seems counter-intuitive
    #[test_case(PrePatch("rc".to_string()), "0.0.0-rc.0", "0.0.0-rc.1")]
    fn increment_semver_consistency(
        increment_mode: SemverIncrementMode,
        input_version: &str,
        expected_version: &str,
    ) {
        let mut working_version = semver::Version::parse(input_version).unwrap();
        increment_semver(&mut working_version, increment_mode).unwrap();

        let expected_version = semver::Version::parse(expected_version).unwrap();
        assert_eq!(expected_version, working_version);
    }

    //
    // errors
    //
    #[test_case(Pre("rc".to_string()), "0.0.1", SemverIncrementError::MissingPreRelease { entry:  semver::Version::new(0,0,1)})]
    #[test_case(Pre("a".to_string()), "0.0.1-b", SemverIncrementError::ResultingVersionLower { result: semver::Version::parse("0.0.1-a.0").unwrap(), entry:  semver::Version::parse("0.0.1-b").unwrap()})]
    fn increment_semver_consistency_failure(
        increment_mode: SemverIncrementMode,
        input_version: &str,
        expected_error: SemverIncrementError,
    ) {
        let mut working_version = semver::Version::parse(input_version).unwrap();
        let err: SemverIncrementError = increment_semver(&mut working_version, increment_mode)
            .unwrap_err()
            .downcast()
            .unwrap();

        assert_eq!(expected_error, err, "{:?}", err)
    }
}



================================================
File: crates/release-automation/src/lib/crate_.rs
================================================
use anyhow::{bail, Context};
use bstr::ByteSlice;
use cargo::util::VersionExt;
use linked_hash_map::LinkedHashMap;
use linked_hash_set::LinkedHashSet;
use log::{debug, info, trace, warn};
use semver::{Comparator, Version, VersionReq};
use std::collections::{HashMap, HashSet};
use structopt::StructOpt;

use crate::{
    common::{increment_semver, SemverIncrementMode},
    crate_selection::Crate,
    release::ReleaseWorkspace,
    CommandResult, Fallible,
};

#[derive(StructOpt, Debug)]
pub struct CrateArgs {
    #[structopt(subcommand)]
    pub command: CrateCommands,
}

#[derive(Debug, StructOpt)]
pub struct CrateSetVersionArgs {
    #[structopt(long)]
    pub crate_name: String,

    #[structopt(long)]
    pub new_version: Version,
}

pub static DEFAULT_DEV_SUFFIX: &str = "dev.0";

#[derive(Debug, StructOpt)]
pub struct CrateApplyDevVersionsArgs {
    #[structopt(long, default_value = DEFAULT_DEV_SUFFIX)]
    pub dev_suffix: String,

    #[structopt(long)]
    pub dry_run: bool,

    #[structopt(long)]
    pub commit: bool,

    #[structopt(long)]
    pub no_verify: bool,
}

#[derive(Debug)]
pub enum FixupReleases {
    Latest,
    All,
    Selected(Vec<String>),
}

/// Parses an input string to an ordered set of release steps.
pub fn parse_fixup_releases(input: &str) -> Fallible<FixupReleases> {
    use std::str::FromStr;

    let words = input
        .split(',')
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .collect::<Vec<String>>();

    if let Some(first) = words.first() {
        match first.as_str() {
            "latest" => return Ok(FixupReleases::Latest),
            "all" => return Ok(FixupReleases::All),
            _ => {}
        }
    }

    Ok(FixupReleases::Selected(words))
}

#[derive(Debug, StructOpt)]
pub struct CrateFixupUnpublishedReleases {
    #[structopt(long, default_value = DEFAULT_DEV_SUFFIX)]
    pub dev_suffix: String,

    #[structopt(long)]
    pub dry_run: bool,

    #[structopt(long, default_value = "latest", parse(try_from_str = parse_fixup_releases))]
    pub fixup_releases: FixupReleases,

    #[structopt(long)]
    pub commit: bool,

    #[structopt(long)]
    pub no_verify: bool,
}

#[derive(Debug, StructOpt)]
pub struct CrateDetectMissingReleaseheadings {}

#[derive(Debug, StructOpt)]
pub struct CrateCheckArgs {
    #[structopt(long)]
    offline: bool,
}

/// These crate.io handles are used as the default minimum crate owners for all published crates.
pub const MINIMUM_CRATE_OWNERS: &str =
    "github:holochain:core-dev,holochain-release-automation,holochain-release-automation2,zippy,steveeJ";

#[derive(Debug, StructOpt)]
pub struct EnsureCrateOwnersArgs {
    #[structopt(long)]
    dry_run: bool,

    /// Assumes the default crate owners that are ensured to be set for each crate in the workspace.
    #[structopt(
        long,
        default_value = MINIMUM_CRATE_OWNERS,
        use_delimiter = true,
        multiple = false,

    )]
    minimum_crate_owners: Vec<String>,
}

#[derive(Debug, StructOpt)]
pub struct CratePinDepsArgs {
    #[structopt(long)]
    dry_run: bool,

    #[structopt(long, default_value = "=")]
    version_prefix: String,

    crt: String,
}

#[derive(Debug, StructOpt)]
pub struct CrateMakePinnedArgs {
    #[structopt(long)]
    dry_run: bool,

    #[structopt(long, default_value = "=")]
    version_prefix: String,

    crt: String,
}

#[derive(Debug, StructOpt)]
pub enum CrateCommands {
    SetVersion(CrateSetVersionArgs),
    ApplyDevVersions(CrateApplyDevVersionsArgs),

    /// check the latest (or given) release for crates that aren't published, remove their tags, and bump their version.
    FixupUnpublishedReleases(CrateFixupUnpublishedReleases),

    /// verify that all published crates have a heading in their changelog
    DetectMissingReleaseheadings(CrateDetectMissingReleaseheadings),

    Check(CrateCheckArgs),
    EnsureCrateOwners(EnsureCrateOwnersArgs),

    /// Pins all dependencies of a given crate and its path dependencies recursively
    PinDeps(CratePinDepsArgs),

    /// Makes a given crate a pinned dependency in the entire workspace
    MakePinnedDep(CrateMakePinnedArgs),
}

pub fn cmd(args: &crate::cli::Args, cmd_args: &CrateArgs) -> CommandResult {
    let ws = ReleaseWorkspace::try_new(args.workspace_path.clone())?;

    match &cmd_args.command {
        CrateCommands::SetVersion(subcmd_args) => {
            let crt = *ws
                .members()?
                .iter()
                .find(|crt| crt.name() == subcmd_args.crate_name)
                .ok_or_else(|| anyhow::anyhow!("crate {} not found", subcmd_args.crate_name))?;

            crt.set_version(false, &subcmd_args.new_version)?;

            Ok(())
        }

        CrateCommands::ApplyDevVersions(subcmd_args) => apply_dev_versions(
            &ws,
            &subcmd_args.dev_suffix,
            subcmd_args.dry_run,
            subcmd_args.commit,
            subcmd_args.no_verify,
        ),

        CrateCommands::FixupUnpublishedReleases(subcmd_args) => fixup_unpublished_releases(
            &ws,
            &subcmd_args.dev_suffix,
            &subcmd_args.fixup_releases,
            subcmd_args.dry_run,
            subcmd_args.commit,
            subcmd_args.no_verify,
        ),

        CrateCommands::Check(subcmd_args) => {
            ws.cargo_check(subcmd_args.offline, std::iter::empty::<&str>())?;

            Ok(())
        }
        CrateCommands::EnsureCrateOwners(subcmd_args) => {
            ensure_crate_io_owners(
                &ws,
                subcmd_args.dry_run,
                ws.members()?,
                subcmd_args.minimum_crate_owners.as_slice(),
            )?;

            Ok(())
        }
        CrateCommands::DetectMissingReleaseheadings(subcmd_args) => {
            cmd_detect_missing_releaseheadings(&ws, subcmd_args)
        }
        CrateCommands::PinDeps(subcmd_args) => pin_deps(&ws, subcmd_args),
        CrateCommands::MakePinnedDep(subcmd_args) => make_pinned_dep(&ws, subcmd_args),
    }
}

fn pin_deps<'a>(
    _ws: &'a ReleaseWorkspace<'a>,
    _subcmd_args: &CratePinDepsArgs,
) -> Result<(), anyhow::Error> {
    todo!()
}

fn make_pinned_dep<'a>(
    ws: &'a ReleaseWorkspace<'a>,
    subcmd_args: &CrateMakePinnedArgs,
) -> Result<(), anyhow::Error> {
    let crt = ws
        .members()?
        .into_iter()
        .find(|member| member.name() == subcmd_args.crt)
        .ok_or(anyhow::anyhow!(
            "looking for crate {} in workspace",
            subcmd_args.crt
        ))?;

    for dependant in crt.dependants_in_workspace()? {
        dependant.set_dependency_version(
            &crt.name(),
            &crt.version(),
            Some(&semver::VersionReq::parse(&format!(
                "{}{}",
                subcmd_args.version_prefix,
                crt.version()
            ))?),
            subcmd_args.dry_run,
        )?;
    }

    Ok(())
}

fn cmd_detect_missing_releaseheadings<'a>(
    ws: &'a ReleaseWorkspace<'a>,
    _subcmd_args: &CrateDetectMissingReleaseheadings,
) -> Fallible<()> {
    let missing_headings = detect_missing_releaseheadings(ws)?;

    if !missing_headings.is_empty() {
        bail!("missing crate release headings: {:#?}", missing_headings);
    }

    Ok(())
}

/// if there are any crate release headings present in the workspace changelog but missing from the crate changelogs an error is returned.
///
/// uses the workspace changelog as a source of truth for existing crate releases.
/// this reasonable because the workspace changelog it's only changed on releases it's not prone to manual mistakes.
pub fn detect_missing_releaseheadings<'a>(
    ws: &'a ReleaseWorkspace<'a>,
) -> Fallible<LinkedHashMap<String, LinkedHashSet<String>>> {
    use itertools::Itertools;

    let crate_headings_toplevel = {
        let cl = ws
            .changelog()
            // .map(|cl| cl.topmost_release())
            .ok_or_else(|| {
                anyhow::anyhow!("no changelog found in workspace at '{:?}'", ws.root())
            })?;

        cl.changes()?
            .iter()
            .map(|change| match change {
                crate::changelog::ChangeT::Release(rc) => match rc {
                    crate::changelog::ReleaseChange::WorkspaceReleaseChange(_title, releases) => {
                        Ok(releases.clone())
                    }
                    unexpected => bail!("expected a WorkspaceReleaseChange here: {:?}", unexpected),
                },
                _ => Ok(vec![]),
            })
            // TODO: what happens with errors here?
            .flatten_ok()
            .collect::<Fallible<Vec<_>>>()?
    };

    let crate_headings_toplevel_by_crate = crate_headings_toplevel.into_iter().try_fold(
        LinkedHashMap::<String, LinkedHashSet<String>>::new(),
        |mut acc, cur| -> Fallible<_> {
            // TODO: use crate names to detect the split instead of the delimiter
            let (crt, version) = cur.split_once('-').ok_or(anyhow::anyhow!(
                "could not split '{}' by
                '-'",
                cur
            ))?;

            acc.entry(crt.to_string())
                .or_insert_with(|| Default::default())
                .insert(version.to_string());

            Ok(acc)
        },
    )?;

    trace!(
        "toplevel crate headings: {:#?}",
        crate_headings_toplevel_by_crate
    );

    let crate_headings_cratedirs = ws.members()?.into_iter().try_fold(
        LinkedHashMap::<String, LinkedHashSet<String>>::new(),
        |mut acc, crt| -> Fallible<_> {
            let name = crt.name();

            let crt_released_versions = if let Some(cl) = crt.changelog() {
                cl.changes()?
                    .iter()
                    .map(|change| match change {
                        crate::changelog::ChangeT::Release(rc) => match rc {
                            crate::changelog::ReleaseChange::CrateReleaseChange(version) => {
                                Ok(Some(version.clone()))
                            }
                            unexpected => {
                                bail!("expected a CrateReleaseChange here: {:?}", unexpected)
                            }
                        },
                        _ => Ok(None),
                    })
                    // TODO: what happens with errors here?
                    .flatten_ok()
                    .collect::<Fallible<Vec<_>>>()?
            } else {
                // don't change the result if the crate has no changelog
                return Ok(acc);
            };

            acc.entry(name)
                .or_insert_with(|| Default::default())
                .extend(crt_released_versions);

            Ok(acc)
        },
    )?;

    let missing_headings: LinkedHashMap<String, LinkedHashSet<String>> =
        crate_headings_toplevel_by_crate
            .iter()
            .filter_map(|(crt, headings)| {
                // only consider crates that still exist as they could have been deleted entirely at some point
                if let Some(headings_crate) = crate_headings_cratedirs.get(crt) {
                    let diff = headings
                        .difference(headings_crate)
                        .cloned()
                        .collect::<LinkedHashSet<_>>();

                    if !diff.is_empty() {
                        Some((crt.to_owned(), diff))
                    } else {
                        None
                    }
                } else {
                    None
                }
            })
            .collect();

    Ok(missing_headings)
}

/// Scans the workspace for crates that have changed since their previous release and bumps their version to a dev version.
///
/// This is a crucial part of the release flow to prevent inconsistencies in publishing dependents of these changed crates.
/// For example:
/// crate A is being published and depends on crate B and its changes since its last release.
/// crate B however hasn't increased its version number since the last release, so it looks as if the most recent version is already published.
/// This causes crate A to be published with a dependency on version of crate B that doesn't contain the changes that crate A depends upon.
/// Hence the newly published version of crate A is broken.
/// To prevent this, we increase crate B's version to a develop version that hasn't been published yet.
/// This will detect a missing dependency in an attempt to publish crate A, as the dev version of crate B is not found on the registry.
/// Note that we wouldn't publish the develop version of crate B, as the regular workspace release flow also increases its version according to the configured scheme.
pub fn apply_dev_versions<'a>(
    ws: &'a ReleaseWorkspace<'a>,
    dev_suffix: &str,
    dry_run: bool,
    commit: bool,
    no_verify: bool,
) -> Fallible<()> {
    let applicable_crates = ws
        .members()?
        .iter()
        .filter(|crt| crt.state().changed_since_previous_release())
        .cloned()
        .collect::<Vec<_>>();

    let msg = apply_dev_vesrions_to_selection(applicable_crates, dev_suffix, dry_run)?;

    if !msg.is_empty() {
        let commit_msg = indoc::formatdoc! {r#"
            apply develop versions to changed crates

            the following crates changed since their most recent release
            and are therefore increased to a develop version:
            {}
        "#, msg,
        };

        info!("creating commit with message '{}' ", commit_msg);

        if !dry_run {
            // this checks consistency and also updates the Cargo.lock file(s)
            if !no_verify {
                ws.cargo_check(false, std::iter::empty::<&str>())?;
            }

            if commit {
                ws.git_add_all_and_commit(&commit_msg, None)?;
            }
        }
    }

    Ok(())
}

pub fn apply_dev_vesrions_to_selection<'a>(
    applicable_crates: Vec<&'a Crate<'a>>,
    dev_suffix: &str,
    dry_run: bool,
) -> Fallible<String> {
    let mut applicable_crates = applicable_crates
        .iter()
        .map(|crt| (crt.name(), *crt))
        .collect::<HashMap<_, _>>();

    let mut queue = applicable_crates.values().copied().collect::<Vec<_>>();
    let mut msg = String::new();

    while let Some(crt) = queue.pop() {
        let mut version = crt.version();

        if version.is_prerelease() {
            debug!(
                "[{}] ignoring due to prerelease version '{}' after supposed release",
                crt.name(),
                version,
            );

            continue;
        }

        increment_semver(&mut version, SemverIncrementMode::Patch)?;
        version = semver::Version::parse(&format!("{}-{}", version, dev_suffix))?;

        debug!(
            "[{}] rewriting version {} -> {}",
            crt.name(),
            crt.version(),
            version,
        );

        for changed_dependant in crt.set_version(dry_run, &version)? {
            if applicable_crates
                .insert(changed_dependant.name(), changed_dependant)
                .is_none()
                && changed_dependant.state().has_previous_release()
            {
                queue.push(changed_dependant);
            }
        }

        // todo: can we mutate crt and use crt.name_version() here instead?
        msg += format!("\n- {}-{}", crt.name(), version).as_str();
    }

    Ok(msg)
}

pub fn fixup_unpublished_releases<'a>(
    ws: &'a ReleaseWorkspace<'a>,
    dev_suffix: &str,
    fixup: &FixupReleases,
    dry_run: bool,
    commit: bool,
    no_verify: bool,
) -> Fallible<()> {
    let mut unpublished_crates: std::collections::BTreeMap<
        String,
        Vec<&'a crate::crate_selection::Crate>,
    > = Default::default();

    match fixup {
        FixupReleases::Latest => {
            let (release_title, crate_release_titles) = match ws
                .changelog()
                .map(|cl| cl.topmost_release())
                .transpose()?
                .flatten()
                .ok_or_else(|| {
                    anyhow::anyhow!(
                        "no topmost release found in changelog '{:?}'. nothing to publish",
                        ws.changelog()
                    )
                })? {
                crate::changelog::ReleaseChange::WorkspaceReleaseChange(title, releases) => (
                    title,
                    releases
                        .into_iter()
                        .collect::<std::collections::BTreeSet<_>>(),
                ),
                unexpected => bail!("unexpected topmost release: {:?}", unexpected),
            };

            debug!("{}: {:#?}", release_title, crate_release_titles);

            let crates = ws
                .members()?
                .iter()
                .filter(|crt| crate_release_titles.contains(&crt.name_version()))
                .cloned()
                .collect::<Vec<_>>();

            for crt in crates {
                if !crates_index_helper::is_version_published(&crt.name(), &crt.version(), false)? {
                    unpublished_crates
                        .entry(release_title.clone())
                        .or_default()
                        .push(crt);
                }
            }
        }
        other => bail!("{:?} not implemented", other),
    }

    info!(
        "the following crates are unpublished: {:#?}",
        unpublished_crates
            .iter()
            .map(|(release, crts)| (
                release,
                crts.iter()
                    .map(|crt| crt.name_version())
                    .collect::<Vec<_>>()
            ))
            .collect::<Vec<_>>()
    );

    // bump their versions to dev versions
    let msg = apply_dev_vesrions_to_selection(
        // TOOD: change this once more than "latest" is supported above
        unpublished_crates.into_iter().next().unwrap_or_default().1,
        dev_suffix,
        dry_run,
    )?;

    if !msg.is_empty() {
        let commit_msg = indoc::formatdoc! {r#"
            applying develop versions to unpublished crates

            bumping the following crates to their dev versions to retrigger the release process for the failed crates
            {}
        "#, msg,
        };

        info!("creating commit with message '{}' ", commit_msg);

        if !dry_run {
            // this checks consistency and also updates the Cargo.lock file(s)
            if !no_verify {
                ws.cargo_check(false, std::iter::empty::<&str>())?;
            };

            if commit {
                ws.git_add_all_and_commit(&commit_msg, None)?;
            }
        }
    }

    Ok(())
}

/// Ensures that the given crates have at least sent an invite to the given crate.io usernames.
pub fn ensure_crate_io_owners<'a>(
    _ws: &'a ReleaseWorkspace<'a>,
    dry_run: bool,
    crates: &[&Crate],
    minimum_crate_owners: &[String],
) -> Fallible<()> {
    let desired_owners = minimum_crate_owners
        .into_iter()
        .cloned()
        .collect::<HashSet<String>>();

    for crt in crates {
        if !crates_index_helper::is_version_published(&crt.name(), &crt.version(), false)? {
            warn!("{} is not published, skipping..", crt.name());
            continue;
        }

        let mut cmd = std::process::Command::new("cargo");
        cmd.args(&["owner", "--list", &crt.name()]);

        debug!("[{}] running command: {:?}", crt.name(), cmd);
        let output = cmd.output().context("process exitted unsuccessfully")?;
        if !output.status.success() {
            warn!(
                "[{}] failed list owners: {}",
                crt.name(),
                String::from_utf8_lossy(&output.stderr)
            );

            continue;
        }

        let current_owners = output
            .stdout
            .lines()
            .map(|line| {
                line.words_with_breaks()
                    .take_while(|item| *item != " ")
                    .collect::<String>()
            })
            .collect::<HashSet<_>>();
        let diff = desired_owners.difference(&current_owners);
        info!(
            "[{}] current owners {:?}, missing owners: {:?}",
            crt.name(),
            current_owners,
            diff
        );

        for owner in diff {
            let mut cmd = std::process::Command::new("cargo");
            cmd.args(&["owner", "--add", owner, &crt.name()]);

            debug!("[{}] running command: {:?}", crt.name(), cmd);
            if !dry_run {
                let output = cmd.output().context("process exitted unsuccessfully")?;
                if !output.status.success() {
                    warn!(
                        "[{}] failed to add owner '{}': {}",
                        crt.name(),
                        owner,
                        String::from_utf8_lossy(&output.stderr)
                    );
                }
            }
        }
    }

    Ok(())
}



================================================
File: crates/release-automation/src/lib/mod.rs
================================================
#![allow(unused_imports)]
#![allow(dead_code)]

use anyhow::bail;
use anyhow::Context;
use comrak::{format_commonmark, parse_document, Arena, ComrakOptions};
use enumflags2::{bitflags, BitFlags};
use log::{debug, error, info, trace, warn};
use std::collections::{BTreeSet, HashSet};
use structopt::StructOpt;

use crate_selection::{aliases::CargoDepKind, CrateState, CrateStateFlags};
use release::ReleaseSteps;

pub mod changelog;
pub mod check;
pub mod common;
pub mod crate_;
pub mod crate_selection;
pub mod release;

#[cfg(test)]
mod tests;

pub type Fallible<T> = anyhow::Result<T>;
pub type CommandResult = Fallible<()>;

pub mod cli {
    use crate::common::SemverIncrementMode;
    use crate::crate_::CrateArgs;

    use super::*;
    use crate_selection::SelectionCriteria;
    use semver::Version;
    use std::ffi::OsStr;
    use std::path::PathBuf;

    #[derive(Debug, StructOpt)]
    #[structopt(name = "release-automation")]
    pub struct Args {
        #[structopt(long)]
        pub workspace_path: PathBuf,

        #[structopt(subcommand)]
        pub cmd: Commands,

        #[structopt(long, default_value = "warn")]
        pub log_level: log::Level,

        #[structopt(long, default_value = "")]
        pub log_filters: String,

        /// Allows filtering to a subset of crates that will be processed for the given command.
        /// This string will be used as a regex to filter the package names.
        /// By default, all crates will be considered.
        #[structopt(long, default_value = ".*")]
        pub match_filter: fancy_regex::Regex,
    }

    #[derive(Debug, StructOpt)]
    #[structopt(name = "ra")]
    pub enum Commands {
        Changelog(ChangelogArgs),
        Release(ReleaseArgs),
        Check(CheckArgs),
        Crate(CrateArgs),
    }

    #[derive(Debug, StructOpt)]
    pub struct ChangelogAggregateArgs {
        /// Output path, relative to the workspace root.
        #[structopt(long, default_value = "CHANGELOG.md")]
        pub output_path: PathBuf,
    }

    #[derive(Debug, StructOpt)]
    pub struct ChangelogSetFrontmatterArgs {
        /// Activate dry-run mode which avoid changing any files
        #[structopt(long)]
        pub dry_run: bool,

        /// YAML file that defines the new frontmatter content. (will be validated by parsing)
        pub frontmatter_yaml_path: PathBuf,
    }

    #[derive(Debug, StructOpt)]
    pub enum ChangelogCommands {
        Aggregate(ChangelogAggregateArgs),
        SetFrontmatter(ChangelogSetFrontmatterArgs),
    }

    #[derive(StructOpt, Debug)]
    pub struct ChangelogArgs {
        #[structopt(subcommand)]
        pub command: ChangelogCommands,
    }

    /// Determine whether there are any release blockers by analyzing the state of the workspace.
    #[derive(StructOpt, Debug)]
    pub struct CheckArgs {
        /// All existing versions must match these requirements.
        /// Can be passed more than once to specify multiple.
        /// See https://docs.rs/semver/0.11.0/semver/?search=#requirements
        #[structopt(long)]
        pub enforced_version_reqs: Vec<semver::VersionReq>,

        /// None of the existing versions are allowed to match these requirements.
        /// Can be passed more than once to specify multiple.
        /// See https://docs.rs/semver/0.11.0/semver/?search=#requirements
        #[structopt(long)]
        pub disallowed_version_reqs: Vec<semver::VersionReq>,

        /// Allow these blocking states for dev dependency crates.
        /// Comma separated.
        /// Valid values are: MissingReadme, UnreleasableViaChangelogFrontmatter, DisallowedVersionReqViolated, EnforcedVersionReqViolated
        #[structopt(long, default_value = "", parse(try_from_str = parse_cratestateflags))]
        pub allowed_dev_dependency_blockers: BitFlags<CrateStateFlags>,

        /// Allow these blocking states for crates via the packages filter.
        /// Comma separated.
        /// Valid values are: MissingReadme, UnreleasableViaChangelogFrontmatter, DisallowedVersionReqViolated, EnforcedVersionReqViolated
        #[structopt(long, default_value = "", parse(try_from_str = parse_cratestateflags))]
        pub allowed_matched_blockers: BitFlags<CrateStateFlags>,

        /// Exclude optional dependencies.
        #[structopt(long)]
        pub exclude_optional_deps: bool,

        /// If given, only these SemverIncrementMode values will be allowed.
        /// Comma separated.
        /// The values shall be given as YAML strings, matching the way they are configured in the CHANGELOG.md front matters.
        /// For a list of values and examples please see [this document](https://github.com/holochain/holochain/blob/develop/docs/release/release.md#permanently-marking-a-crate-for-majorminorpatchpre-version-bumps).
        #[structopt(long, parse(try_from_str = parse_semverincrementmode))]
        allowed_semver_increment_modes: Option<HashSet<SemverIncrementMode>>,
    }

    fn parse_depkind(input: &str) -> Fallible<HashSet<CargoDepKind>> {
        let mut set = HashSet::new();

        for word in input.split(',') {
            set.insert(match word.to_lowercase().as_str() {
                "" => continue,
                "normal" => CargoDepKind::Normal,
                "development" => CargoDepKind::Development,
                "build" => CargoDepKind::Build,

                invalid => bail!("invalid dependency kind: {}", invalid),
            });
        }

        Ok(set)
    }

    fn parse_cratestateflags(input: &str) -> Fallible<BitFlags<CrateStateFlags>> {
        use std::str::FromStr;

        input
            .split(',')
            .filter(|s| !s.is_empty())
            .map(|csf| {
                CrateStateFlags::from_str(csf)
                    .map_err(|_| anyhow::anyhow!("could not parse '{}' as CrateStateFlags", input))
            })
            .try_fold(
                Default::default(),
                |mut acc, elem| -> Fallible<BitFlags<_>> {
                    acc.insert(elem?);
                    Ok(acc)
                },
            )
    }

    fn parse_semverincrementmode(input: &str) -> Fallible<HashSet<SemverIncrementMode>> {
        input
            .split(',')
            .filter(|s| !s.is_empty())
            .map(|sim| {
                serde_yaml::from_str(sim).map_err(|_| {
                    anyhow::anyhow!("could not parse '{}' as SemverIncrementMode", input)
                })
            })
            .try_fold(
                Default::default(),
                |mut acc, elem| -> Fallible<HashSet<SemverIncrementMode>> {
                    acc.insert(elem?);
                    Ok(acc)
                },
            )
    }

    impl CheckArgs {
        /// Boilerplate to instantiate `SelectionCriteria` from `CheckArgs`
        pub fn to_selection_criteria(&self, args: &Args) -> SelectionCriteria {
            SelectionCriteria {
                match_filter: args.match_filter.clone(),
                disallowed_version_reqs: self.disallowed_version_reqs.clone(),
                enforced_version_reqs: self.enforced_version_reqs.clone(),
                allowed_dev_dependency_blockers: self.allowed_dev_dependency_blockers,
                allowed_selection_blockers: self.allowed_matched_blockers,
                exclude_optional_deps: self.exclude_optional_deps,
                allowed_semver_increment_modes: self.allowed_semver_increment_modes.clone(),
            }
        }
    }

    /// Initiate a release process with the given arguments.
    ///
    /// See https://docs.rs/semver/0.11.0/semver/?search=#requirements for details on the requirements arguments.
    #[derive(StructOpt, Debug)]
    pub struct ReleaseArgs {
        #[structopt(flatten)]
        pub check_args: CheckArgs,

        #[structopt(long)]
        pub dry_run: bool,

        /// Will be inferred from the current name if not given.
        #[structopt(long)]
        pub release_branch_name: Option<String>,

        /// The release steps to perform.
        /// These will be reordered to their defined ordering.
        ///
        /// See `ReleaseSteps` for the list of steps.
        #[structopt(long, default_value="", parse(try_from_str = parse_releasesteps))]
        pub steps: BTreeSet<ReleaseSteps>,

        /// Force creation of the branch regardless of source branch.
        #[structopt(long)]
        pub force_branch_creation: bool,

        /// Force creation of the git tags.
        #[structopt(long)]
        pub force_tag_creation: bool,

        /// Force creation of the git tags.
        #[structopt(long)]
        pub no_tag_creation: bool,

        /// The dependencies that are allowed to be missing at the search location despite not being released.
        #[structopt(long, default_value="", parse(from_str = parse_string_set))]
        pub allowed_missing_dependencies: HashSet<String>,

        /// Set a custom CARGO_TARGET_DIR when shelling out to `cargo`.
        /// Currently only used for `cargo publish`.
        #[structopt(long)]
        pub cargo_target_dir: Option<PathBuf>,

        /// Don't run consistency verification checks.
        #[structopt(long)]
        pub no_verify: bool,

        /// Don't run consistency verification pre-change.
        #[structopt(long)]
        pub no_verify_pre: bool,

        /// Don't run consistency verification post-change.
        #[structopt(long)]
        pub no_verify_post: bool,

        /// Paths to manifest that will also be considered when updating the Cargo.lock files
        #[structopt(long)]
        pub additional_manifests: Vec<String>,

        #[structopt(
            long,
            default_value = crate_::MINIMUM_CRATE_OWNERS,
            use_delimiter = true,
            multiple = false,
        )]
        pub minimum_crate_owners: Vec<String>,
    }

    /// Parses a commad separated input string to a set of strings.
    pub fn parse_string_set(input: &str) -> HashSet<String> {
        use std::str::FromStr;

        input.split(',').filter(|s| !s.is_empty()).fold(
            Default::default(),
            |mut acc, elem| -> HashSet<_> {
                acc.insert(elem.to_string());
                acc
            },
        )
    }

    /// Parses an input string to an ordered set of release steps.
    pub fn parse_releasesteps(input: &str) -> Fallible<BTreeSet<ReleaseSteps>> {
        use std::str::FromStr;

        input
            .split(',')
            .map(str::trim)
            .filter(|s| !s.is_empty())
            .map(|csf| {
                ReleaseSteps::from_str(csf).map_err(|_| {
                    anyhow::anyhow!("could not parse '{}' in '{}' as ReleaseSteps:", csf, input)
                })
            })
            .try_fold(
                Default::default(),
                |mut acc, elem| -> Fallible<BTreeSet<_>> {
                    acc.insert(elem?);
                    Ok(acc)
                },
            )
    }
}



================================================
File: crates/release-automation/src/lib/release.rs
================================================
//! Release command functionality.

use super::*;

use anyhow::bail;
use anyhow::Context;
use bstr::ByteSlice;
use cargo::util::VersionExt;
use chrono::TimeZone;
use chrono::Utc;
use cli::ReleaseArgs;
use comrak::{format_commonmark, parse_document, Arena, ComrakOptions};
use enumflags2::{bitflags, BitFlags};
use log::{debug, error, info, trace, warn};
use once_cell::sync::OnceCell;
use std::convert::TryInto;
use std::iter::FromIterator;
use std::path::Path;
use std::sync::Arc;
use std::sync::Mutex;
use std::{
    collections::HashMap,
    io::{Read, Write},
};
use std::{
    collections::{BTreeSet, HashSet},
    path::PathBuf,
};
use structopt::StructOpt;

use crate::crate_selection::flatten_forest;
use crate::{
    changelog::{Changelog, WorkspaceCrateReleaseHeading},
    common::{increment_semver, SemverIncrementMode},
    crate_::ensure_crate_io_owners,
    crate_selection::{ensure_release_order_consistency, Crate},
};
pub use crate_selection::{ReleaseWorkspace, SelectionCriteria};

const TARGET_DIR_SUFFIX: &str = "target/release_automation";

/// These steps make up the release workflow
#[bitflags]
#[repr(u64)]
#[derive(enum_utils::FromStr, Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub enum ReleaseSteps {
    /// create a new release branch based on develop
    CreateReleaseBranch,
    /// substeps: get crate selection, bump cargo toml versions, rotate
    /// changelog, commit changes
    BumpReleaseVersions,
    /// verify that the release tag exists on the main branch and is the
    /// second commit on it, directly after the merge commit
    PublishToCratesIo,
    AddOwnersToCratesIo,
}

// todo(backlog): what if at any point during the release process we have to merge a hotfix to main?
// todo: don't forget to adhere to dry-run into all of the following
/// This function handles the release process from start to finish.
/// Eventually this will be idempotent by understanding the state of the repository and
/// derive from it the steps that required to proceed with the release.
///
/// For now it is manual and the release phases need to be given as an instruction.
pub fn cmd(args: &crate::cli::Args, cmd_args: &crate::cli::ReleaseArgs) -> CommandResult {
    for step in &cmd_args.steps {
        trace!("Processing step '{:?}'", step);

        // read the workspace after every step in case it was mutated
        let ws = ReleaseWorkspace::try_new_with_criteria(
            args.workspace_path.clone(),
            cmd_args.check_args.to_selection_criteria(args),
        )?;

        macro_rules! _skip_on_empty_selection {
            ($step:expr, $body:expr) => {
                if ws.release_selection()?.len() == 0 {
                    warn!("empty release selection. skipping {:?}", $step);
                } else {
                    $body
                }
            };
        }

        match step {
            ReleaseSteps::CreateReleaseBranch => create_release_branch(&ws, cmd_args)?,
            ReleaseSteps::BumpReleaseVersions => bump_release_versions(&ws, cmd_args)?,
            ReleaseSteps::PublishToCratesIo => publish_to_crates_io(&ws, cmd_args)?,
            ReleaseSteps::AddOwnersToCratesIo => ensure_crate_io_owners(
                &ws,
                cmd_args.dry_run,
                &latest_release_crates(&ws)?,
                &cmd_args.minimum_crate_owners,
            )?,
        }
    }

    Ok(())
}

pub const RELEASE_BRANCH_PREFIX: &str = "release-";

/// Generate a time-derived name for a new release branch.
pub fn generate_release_branch_name() -> String {
    format!(
        "{}{}",
        RELEASE_BRANCH_PREFIX,
        chrono::Utc::now().format("%Y%m%d.%H%M%S")
    )
}

/// Create a new git release branch.
pub fn create_release_branch<'a>(
    ws: &'a ReleaseWorkspace<'a>,
    cmd_args: &ReleaseArgs,
) -> Fallible<()> {
    match ws.git_head_branch_name()?.as_str() {
        "develop" => {
            // we're good to continue!
        }
        _ if cmd_args.force_branch_creation => {}
        other => bail!(
            "only support releasing from the 'develop' branch, but found '{}'",
            other
        ),
    };

    let statuses = ws
        .git_repo()
        .statuses(Some(git2::StatusOptions::new().include_untracked(true)))
        .context("querying repository status")?;
    if !statuses.is_empty() && !cmd_args.force_branch_creation {
        bail!(
            "repository is not clean. {} change(s): \n{}",
            statuses.len(),
            statuses
                .iter()
                .map(|statusentry| format!(
                    "{:?}: {}\n",
                    statusentry.status(),
                    statusentry.path().unwrap_or_default()
                ))
                .collect::<String>()
        )
    };

    let release_branch_name = cmd_args
        .release_branch_name
        .to_owned()
        .unwrap_or_else(generate_release_branch_name);

    if cmd_args.dry_run {
        info!("[dry-run] would create branch '{}'", release_branch_name);
    } else {
        ws.git_checkout_new_branch(&release_branch_name)?;

        ensure_release_branch(ws)?;
    }

    Ok(())
}

fn bump_release_versions<'a>(
    ws: &'a ReleaseWorkspace<'a>,
    cmd_args: &'a ReleaseArgs,
) -> Fallible<()> {
    let branch_name = match ensure_release_branch(ws) {
        Ok(branch_name) => branch_name,
        Err(_) if cmd_args.dry_run => generate_release_branch_name(),
        Err(e) => bail!(e),
    };

    // check the workspace and determine the release selection
    let selection = crate::common::selection_check(&cmd_args.check_args, ws)?;

    if selection.is_empty() {
        debug!("no crates to release, exiting.");
        return Ok(());
    }

    // run the checks to ensure the repo is in a consistent state to begin with
    if !cmd_args.no_verify && !cmd_args.no_verify_pre {
        info!("running consistency checks before changing the versions...");
        do_publish_to_crates_io(
            &selection,
            true,
            true,
            false,
            // If dependencies (especially pinned) have changed in source control but mismatch with dependencies that are already published to crates.io at the same version
            // then cargo will correctly complain about mismatched dependencies when attempting a publish before bumping versions.
            true,
            &cmd_args.allowed_missing_dependencies,
            &cmd_args.cargo_target_dir,
        )
        .context("consistency checks failed")?;
    }

    let mut changed_crate_changelogs = vec![];

    for crt in &selection {
        let current_version = crt.version();
        let changelog = crt
            .changelog()
            .ok_or_else(|| anyhow::anyhow!("[{}] missing changelog", crt.name()))?;

        let maybe_previous_release_version = changelog
            .topmost_release()?
            .map(|change| semver::Version::parse(change.title()))
            .transpose()
            .context(format!(
                "parsing {:#?} in {:#?} as a semantic version",
                changelog.topmost_release(),
                changelog.path(),
            ))?;

        let maybe_semver_increment_mode = changelog
            .front_matter()?
            .map(|fm| fm.semver_increment_mode());
        let semver_increment_mode = maybe_semver_increment_mode.unwrap_or_default();

        let incremented_version = {
            let mut v = current_version.clone();
            increment_semver(&mut v, semver_increment_mode)?;
            v
        };

        let release_version = match &maybe_previous_release_version {
            Some(previous_release_version) => {
                if &current_version > previous_release_version {
                    current_version.clone()
                } else if &incremented_version > previous_release_version {
                    crt.set_version(cmd_args.dry_run, &incremented_version)?;
                    incremented_version.clone()
                } else {
                    bail!("[{}] neither current version '{}' nor incremented version '{}' exceed previously released version '{}'", crt.name(), &current_version, &incremented_version, previous_release_version);
                }
            }

            None => {
                // default to incremented version if we don't have information on a previous release
                crt.set_version(cmd_args.dry_run, &incremented_version.clone())?;
                incremented_version.clone()
            }
        };

        debug!(
            "[{}] previous release version: '{:?}', current version: '{}', incremented version: '{}'",
            crt.name(),
            maybe_previous_release_version,
            current_version,
            incremented_version,
        );

        let crate_release_heading_name = format!("{}", release_version);

        // create a new release entry in the crate's changelog and move all items from the unreleased heading if there are any
        debug!(
            "[{}] creating crate release heading '{}' in '{:?}'",
            crt.name(),
            crate_release_heading_name,
            changelog.path(),
        );

        if !cmd_args.dry_run {
            changelog
                .add_release(crate_release_heading_name.clone())
                .context(format!("adding release to changelog for '{}'", crt.name()))?;

            // FIXME: now we should reread the whole thing?

            // rewrite frontmatter to reset it to its defaults
            changelog.reset_front_matter_to_defaults()?;
        }

        changed_crate_changelogs.push(WorkspaceCrateReleaseHeading {
            prefix: crt.name(),
            suffix: crate_release_heading_name,
            changelog,
        });
    }

    ws.update_lockfile(
        cmd_args.dry_run,
        cmd_args.additional_manifests.iter().map(|mp| mp.as_str()),
    )?;

    /* TODO: the workspace probably needs to be re-read here because otherwise the publish dry-run will assume the previous crate versions
     * either this or something else is leading to this issue where the verify_post checks aren't effective
     *
     * > [INFO  release_automation::lib::common] crates selected for the release process: [
     * >         "holochain_cli-0.1.0-a-minor-release-test.2",
     * >     ]
     * > [DEBUG release_automation::lib::crate_selection] setting version to 0.1.0-a-minor-release-test.3 in manifest at "/home/steveej/src/holo/holochain/crates/hc/Cargo.toml"
     * > [DEBUG release_automation::lib::release] [holochain_cli] creating crate release heading '0.1.0-a-minor-release-test.3' in '"/home/steveej/src/holo/holochain/crates/hc/CHANGELOG.md"'
     * > [DEBUG release_automation::lib::crate_selection] running command: "cargo" "fetch" "--verbose" "--manifest-path" "Cargo.toml"
     * > [DEBUG release_automation::lib::crate_selection] running command: "cargo" "update" "--workspace" "--offline" "--verbose"
     * > [DEBUG release_automation::lib::crate_selection] running command: "cargo" "fetch" "--verbose" "--manifest-path" "crates/test_utils/wasm/wasm_workspace/Cargo.toml"
     * >     Blocking waiting for file lock on package cache
     * >     Blocking waiting for file lock on package cache
     * > [DEBUG release_automation::lib::crate_selection] running command: "cargo" "update" "--workspace" "--offline" "--verbose" "--manifest-path" "crates/test_utils/wasm/wasm_workspace/Cargo.toml"
     * >     Blocking waiting for file lock on package cache
     * > [INFO  release_automation::lib::release] running consistency checks after changing the versions...
     * > [DEBUG release_automation::lib::release] attempting to publish {"holochain_cli"}
     * > [DEBUG release_automation::lib::release] holochain_cli-0.1.0-a-minor-release-test.2 is unchanged and already published, skipping..
     * > [DEBUG release_automation::lib::release] Running command: "cargo" "check" "--locked" "--verbose" "--release" "--manifest-path=/home/steveej/src/holo/holochain/crates/hc/Cargo.toml"
     * > [DEBUG release_automation::lib::release] Running command: "cargo" "publish" "--locked" "--verbose" "--no-verify" "--manifest-path=/home/steveej/src/holo/holochain/crates/hc/Cargo.toml" "--dry-run" "--allow-dirty"
     * > [INFO  release_automation::lib::release] successfully published holochain_cli-0.1.0-a-minor-release-test.2
     * > [INFO  release_automation::lib::release] crates processed: 1, consistent: 1, published: 1, skipped: 1, tolerated: 0
     *
     * the above shouldn't have looked up .2 but rather .3, which it wouldn't have found
     */

    if !cmd_args.no_verify && !cmd_args.no_verify_post {
        info!("running consistency checks after changing the versions...");
        do_publish_to_crates_io(
            &selection,
            true,
            true,
            false,
            false,
            &cmd_args.allowed_missing_dependencies,
            &cmd_args.cargo_target_dir,
        )
        .context("cargo publish dry-run failed")?;
    }

    // ## for the workspace release:
    let workspace_release_name = branch_name
        .strip_prefix(RELEASE_BRANCH_PREFIX)
        .ok_or_else(|| {
            anyhow::anyhow!(
                "expected branch name to start with prefix '{}'. got instead: {}",
                RELEASE_BRANCH_PREFIX,
                branch_name,
            )
        })?
        .to_string();

    let ws_changelog = ws
        .changelog()
        .ok_or_else(|| anyhow::anyhow!("workspace has no changelog"))?;

    info!(
        "adding release {} to changelog at {:?} with the following crate releases: {}",
        workspace_release_name,
        ws_changelog.path(),
        changed_crate_changelogs
            .iter()
            .map(|cr| format!("\n- {}", cr.title()))
            .collect::<String>()
    );

    if !cmd_args.dry_run {
        ws_changelog.add_release(workspace_release_name, &changed_crate_changelogs)?;
    }

    // create a release commit with an overview of which crates are included
    let commit_msg = indoc::formatdoc!(
        r#"
        create a release from branch {}

        the following crates are part of this release:
        {}
        "#,
        branch_name,
        changed_crate_changelogs
            .iter()
            .map(|wcrh| format!("\n- {}", wcrh.title()))
            .collect::<String>()
    );

    info!("creating the following commit: {}", commit_msg);
    if !cmd_args.dry_run {
        ws.git_add_all_and_commit(&commit_msg, None)?;
    };

    if !cmd_args.no_tag_creation {
        // create tags for all released crates
        let tags_to_create = changed_crate_changelogs
            .iter()
            .map(|wcrh| wcrh.title())
            .collect::<Vec<String>>();
        create_crate_tags(ws, tags_to_create, cmd_args)?;
    }

    Ok(())
}

pub fn publish_to_crates_io<'a>(
    ws: &'a ReleaseWorkspace<'a>,
    cmd_args: &'a ReleaseArgs,
) -> Fallible<()> {
    let crates = latest_release_crates(ws)?;

    do_publish_to_crates_io(
        &crates,
        cmd_args.dry_run,
        false,
        cmd_args.no_verify,
        false,
        &Default::default(),
        &cmd_args.cargo_target_dir,
    )?;

    Ok(())
}

fn latest_release_crates<'a>(ws: &'a ReleaseWorkspace<'a>) -> Fallible<Vec<&Crate>> {
    let (release_title, crate_release_titles) = match ws
        .changelog()
        .map(|cl| cl.topmost_release())
        .transpose()?
        .flatten()
        .ok_or_else(|| {
            anyhow::anyhow!(
                "no topmost release found in changelog '{:?}'. nothing to publish",
                ws.changelog()
            )
        })? {
        changelog::ReleaseChange::WorkspaceReleaseChange(title, releases) => {
            (title, releases.into_iter().collect::<BTreeSet<_>>())
        }
        unexpected => bail!("unexpected topmost release: {:?}", unexpected),
    };
    debug!("{}: {:#?}", release_title, crate_release_titles);

    let crates = ws
        .members()?
        .iter()
        .filter_map(|member| {
            if crate_release_titles.contains(&member.name_version()) {
                Some(*member)
            } else {
                None
            }
        })
        .collect::<Vec<_>>();

    Ok(crates)
}

/// This models the information in the failure output of `cargo publish --dry-run`.
#[derive(thiserror::Error, Debug, PartialEq, Eq)]
pub enum PublishError {
    #[error(
        "{package}@{path}: '{dependency}' dependency by {package_found} not found at {location}"
    )]
    PackageNotFound {
        package: String,
        version: String,
        path: String,
        dependency: String,
        package_found: String,
        location: String,
    },
    #[error(
        "{package}@{path}: '{dependency} = \"{version_req}\"' dependency by {package_found}-{version_found} not found at {location}"
    )]
    PackageVersionNotFound {
        package: String,
        version: String,
        path: String,
        dependency: String,
        version_req: String,
        location: String,
        package_found: String,
        version_found: String,
    },
    #[error("{package}@{path}: {version} already uploaded at {location}")]
    AlreadyUploaded {
        package: String,
        version: String,
        path: String,
        location: String,
        version_found: String,
    },

    #[error("{package}: publish rate limit exceeded. retry after '{retry_after}'")]
    PublishLimitExceeded {
        package: String,
        version: String,
        location: String,
        retry_after: chrono::DateTime<Utc>,
    },

    #[error("{package}: check failed: {log}")]
    CheckFailure {
        package: String,
        version: String,
        log: String,
    },

    #[error("{}: {}", _0, _1)]
    Other(String, String),
}

impl PublishError {
    pub fn with_str(package: String, version: String, input: String) -> Self {
        static PACKAGE_NOT_FOUND_RE: OnceCell<regex::Regex> = OnceCell::new();
        static PACKAGE_VERSION_NOT_FOUND_RE: OnceCell<regex::Regex> = OnceCell::new();
        static ALREADY_UPLOADED_RE: OnceCell<regex::Regex> = OnceCell::new();
        static PUBLISH_LIMIT_EXCEEDED_RE: OnceCell<regex::Regex> = OnceCell::new();

        if let Some(captures) = PACKAGE_NOT_FOUND_RE
            .get_or_init(|| {
                regex::Regex::new(indoc::indoc!(
                    r#"
                    (.*"(?P<path>.*)":)?
                    (.|\n)*
                    .*no matching package named `(?P<dependency>.*)` found
                    .*location searched: (?P<location>.*)
                    .*required by package `(?P<package>\S+) v(?P<version>\S+).*`
                    "#
                ))
                .expect("regex should compile")
            })
            .captures(&input)
        {
            if let (path, Some(dependency), Some(location), Some(package_found), Some(version_found)) = (
                captures.name("path"),
                captures.name("dependency"),
                captures.name("location"),
                captures.name("package"),
                captures.name("version"),
            ) {
                    let package_found= package_found.as_str().to_string();
                    if package_found != package {
                        warn!("package mismatch. got '{}' expected '{}'", package_found, package);
                    }
                    let version_found= version_found.as_str().to_string();
                    if version_found != version {
                        warn!("version mismatch. got '{}' expected '{}'", version_found, version);
                    }
                    return PublishError::PackageNotFound {
                        package,
                        version,
                        path: path.map(|path| path.as_str().to_string()).unwrap_or_default(),
                        dependency: dependency.as_str().to_string(),
                        location: location.as_str().to_string(),
                        package_found,
                    }
                }
        } else if let Some(captures) = PACKAGE_VERSION_NOT_FOUND_RE
            .get_or_init(|| {
                regex::Regex::new(indoc::indoc!(
                    r#"
                        (.*"(?P<path>.*)":)?
                        (.|\n)*
                        .*failed to select a version for the requirement `(?P<dependency>.*) = "(?P<version_req>.*)"`
                        .*
                        .*location searched: (?P<location>.*)
                        .*required by package `(?P<package>\S+) v(?P<version>\S+).*`
                    "#
                ))
                .expect("regex should compile")
            })
            .captures(&input)
        {
            if let                 (path, Some(dependency), Some(version_req), Some(location), Some(package_found), Some(version_found))
            = (
                captures.name("path"),
                captures.name("dependency"),
                captures.name("version_req"),
                captures.name("location"),
                captures.name("package"),
                captures.name("version"),
            ) {
                let package_found= package_found.as_str().to_string();
                if package_found != package {
                    warn!("package mismatch. got '{}' expected '{}'", package_found, package);
                }

                let version_found= version_found.as_str().to_string();
                if version_found != version {
                    warn!("version mismatch. got '{}' expected '{}'", version_found, version);
                }
                return PublishError::PackageVersionNotFound {
                    package,
                    version,
                    path: path.map(|path| path.as_str().to_string()).unwrap_or_default(),
                    dependency: dependency.as_str().to_string(),
                    version_req: version_req.as_str().to_string(),
                    location: location.as_str().to_string(),
                    package_found,
                    version_found,
                }
            }

        } else if let Some(captures) = ALREADY_UPLOADED_RE
            .get_or_init(|| {
                regex::Regex::new(indoc::indoc!(
                    r#"
                    error: failed to publish to (?P<location>.*)
                    (.|\n)*
                    .*crate version `(?P<version>.*)` is already uploaded
                    "#
                ))
                .expect("regex should compile")
            })
            .captures(&input)
        {
            if let (path, Some(location), Some(version_found)) = (
                captures.name("path"),
                captures.name("location"),
                captures.name("version"),
            ) {
                let version_found= version_found.as_str().to_string();
                if version_found != version {
                    warn!("version mismatch. got '{}' expected '{}'", version_found, version);
                }
                return PublishError::AlreadyUploaded {
                    package,
                    version,
                    path: path.map(|path| path.as_str().to_string()).unwrap_or_default(),
                    location: location.as_str().to_string(),
                    version_found,
                }
            }
        } else if let Some(captures) = PUBLISH_LIMIT_EXCEEDED_RE
            .get_or_init(|| {
                regex::Regex::new(indoc::indoc!(
                    r#"
                    error: failed to publish to (?P<location>.*)
                    (.|\n)*
                    .*try again after (?P<retry_after>.*) or.*
                    "#
                ))
                .expect("regex should compile")
            })
            .captures(&input)
        {
            if let (Some(location), Some(retry_after_string)) = (
                captures.name("location"),
                captures.name("retry_after"),
            ) {
                // TODO FIXME
                #[allow(deprecated)]
                let retry_after =
                chrono::Utc.timestamp(
                    chrono::DateTime::parse_from_rfc2822(retry_after_string.as_str())
                    .expect("time to parse").timestamp(), 0);
                return PublishError::PublishLimitExceeded{
                    package,
                    version,
                    location: location.as_str().to_string(),
                    retry_after,
                }
            }
        }

        PublishError::Other(package, input)
    }
}

/// Try to publish the given crates to crates.io.
///
/// If dry-run is given, the following error conditions are tolerated:
/// - a dependency is not found but is part of the release
/// - a version of a dependency is not found bu the dependency is part of the release
///
/// For this to work properly all changed crates need to have their dev versions applied.
/// If they don't, `cargo publish` will prefer a published crates to the local ones.
pub fn do_publish_to_crates_io<'a>(
    crates: &[&'a Crate<'a>],
    dry_run: bool,
    allow_dirty: bool,
    no_verify: bool,
    no_publish: bool,
    allowed_missing_dependencies: &HashSet<String>,
    cargo_target_dir: &Option<PathBuf>,
) -> Fallible<()> {
    ensure_release_order_consistency(&crates).context("release ordering is broken")?;

    let crate_names: Vec<String> = crates.iter().map(|crt| crt.name()).collect();
    if !no_publish {
        debug!("attempting to publish {:?}", crate_names);
    } else {
        debug!("check but not publishing {:?}", crate_names);
    }

    let mut queue = crates.iter().collect::<std::collections::LinkedList<_>>();
    let mut errors: Vec<PublishError> = vec![];

    let mut check_cntr = 0;
    let mut publish_cntr = 0;
    let mut tolerated_cntr = 0;
    let mut skip_cntr = 0;
    let do_return =
        |errors: Vec<PublishError>, check_cntr, publish_cntr, skip_cntr, tolerated_cntr| {
            let msg = format!(
                "crates processed: {}, consistent: {}, published: {}, skipped: {}, tolerated: {}",
                crates.len(),
                check_cntr,
                publish_cntr,
                skip_cntr,
                tolerated_cntr,
            );

            info!("{}", msg);

            if !errors.is_empty() {
                let mut root = anyhow::anyhow!(msg);
                for error in errors.into_iter().rev() {
                    root = root.context(error);
                }
                Err(root)
            } else {
                Ok(())
            }
        };

    let mut published_or_tolerated = linked_hash_set::LinkedHashSet::new();

    let mut publish_cntr_inc = |name: &str| {
        info!("successfully published {}", name);
        publish_cntr += 1;
    };

    while let Some(crt) = queue.pop_front() {
        let state_changed = crt.state().changed();

        let name = crt.name().to_owned();
        let ver = crt.version().to_owned();

        let is_version_published = crates_index_helper::is_version_published(&name, &ver, false)
            .context(format!("looking up {name}-{ver} on local crate index"))?;

        if !state_changed && is_version_published {
            debug!(
                "{} is unchanged and already published, skipping..",
                crt.name_version()
            );
            skip_cntr += 1;
        }

        let manifest_path = crt.manifest_path();
        let cargo_target_dir_string = cargo_target_dir
            .as_ref()
            .map(|target_dir| format!("--target-dir={}", target_dir.to_string_lossy()));

        if !no_verify {
            let mut cmd = std::process::Command::new("cargo");
            cmd.args(
                [
                    vec![
                        "check",
                        "--locked",
                        "--verbose",
                        "--release",
                        &format!("--manifest-path={}", manifest_path.to_string_lossy()),
                    ],
                    if let Some(target_dir) = cargo_target_dir_string.as_ref() {
                        vec![target_dir]
                    } else {
                        vec![]
                    },
                ]
                .concat(),
            );
            debug!("Running command: {:?}", cmd);
            let output = cmd.output().context("process exitted unsuccessfully")?;
            if !output.status.success() {
                let mut details = String::new();
                for line in output.stderr.lines_with_terminator() {
                    let line = line.to_str_lossy();
                    details += &line;
                }

                let error = PublishError::CheckFailure {
                    package: crt.name(),
                    version: crt.version().to_string(),
                    log: details,
                };
                errors.push(error);
            } else {
                check_cntr += 1;
            }
        }

        if !no_publish {
            let mut cmd = std::process::Command::new("cargo");
            cmd.args(
                [
                    vec![
                        "publish",
                        "--locked",
                        "--verbose",
                        "--no-verify",
                        "--registry",
                        "crates-io",
                        &format!("--manifest-path={}", manifest_path.to_string_lossy()),
                    ],
                    if dry_run { vec!["--dry-run"] } else { vec![] },
                    if allow_dirty {
                        vec!["--allow-dirty"]
                    } else {
                        vec![]
                    },
                    if let Some(target_dir) = cargo_target_dir_string.as_ref() {
                        vec![target_dir]
                    } else {
                        vec![]
                    },
                ]
                .concat(),
            );
    
            debug!("Running command: {:?}", cmd);
    
            let output = cmd.output().context("process exitted unsuccessfully")?;
            if !output.status.success() {
                let mut details = String::new();
                for line in output.stderr.lines_with_terminator() {
                    let line = line.to_str_lossy();
                    details += &line;
                }
    
                let error = PublishError::with_str(crt.name(), crt.version().to_string(), details);
    
                if match &error {
                    PublishError::Other(..) => true,
                    PublishError::PackageNotFound { dependency, .. }
                    | PublishError::PackageVersionNotFound { dependency, .. } => {
                        !((dry_run
                            && crate_names.contains(dependency)
                            && published_or_tolerated.contains(dependency))
                            || allowed_missing_dependencies.contains(dependency))
                    }
                    PublishError::AlreadyUploaded { version, .. } => {
                        crt.version().to_string() != *version
                    }
                    PublishError::PublishLimitExceeded { retry_after, .. } => {
                        let wait = *retry_after - chrono::offset::Utc::now();
                        warn!("waiting for {:?} to adhere to the rate limit...", wait);
                        std::thread::sleep(wait.to_std()?);
                        queue.push_front(crt);
                        continue;
                    }
                    PublishError::CheckFailure { .. } => true,
                } {
                    error!("{}", error);
                    errors.push(error);
                } else {
                    tolerated_cntr += 1;
                    debug!("tolerating error: '{:#?}'", &error);
    
                    published_or_tolerated.insert(crt.name());
                }
            } else if dry_run {
                publish_cntr_inc(&crt.name_version());
                published_or_tolerated.insert(crt.name());
            } else {
                // wait until the published version is live
    
                let mut found = false;
    
                for delay_secs in &[56, 28, 14, 7, 14, 28, 56] {
                    let duration = std::time::Duration::from_secs(*delay_secs);
                    std::thread::sleep(duration);
    
                    if crates_index_helper::is_version_published(&crt.name(), &crt.version(), true)? {
                        debug!(
                            "Found recently published {} on crates.io!",
                            crt.name_version()
                        );
                        found = true;
                        break;
                    }
    
                    warn!(
                        "Did not find {} on crates.io, retrying in {:?}...",
                        crt.name_version(),
                        duration
                    );
                }
    
                if !found {
                    errors.push(PublishError::Other(
                        crt.name_version(),
                        "recently published version not found in time on the crates_io index"
                            .to_string(),
                    ));
    
                    return do_return(errors, check_cntr, publish_cntr, skip_cntr, tolerated_cntr);
                }
    
                publish_cntr_inc(&crt.name_version());
                published_or_tolerated.insert(crt.name());
            }
        }
    }

    do_return(errors, check_cntr, publish_cntr, skip_cntr, tolerated_cntr)
}

/// create a tag for each crate which will be used to identify its latest release
fn create_crate_tags<'a>(
    ws: &'a ReleaseWorkspace<'a>,
    tags_to_create: Vec<String>,
    cmd_args: &'a ReleaseArgs,
) -> Fallible<()> {
    let existing_tags = tags_to_create
        .iter()
        .filter_map(|git_tag| crate::crate_selection::git_lookup_tag(ws.git_repo(), git_tag))
        .collect::<Vec<_>>();

    if !cmd_args.force_tag_creation && !existing_tags.is_empty() {
        error!(
            "the following tags already exist: {}",
            existing_tags
                .iter()
                .map(|tag| format!("\n- {}", tag))
                .collect::<String>()
        )
    }

    for git_tag in tags_to_create {
        debug!("creating tag '{}'", git_tag);
        if !cmd_args.dry_run {
            ws.git_tag(&git_tag, cmd_args.force_tag_creation)?;
        }
    }

    Ok(())
}

/// Ensure we're on a branch that starts with `Self::RELEASE_BRANCH_PREFIX`
pub fn ensure_release_branch<'a>(ws: &'a ReleaseWorkspace<'a>) -> Fallible<String> {
    let branch_name = ws.git_head_branch_name()?;
    if !branch_name.starts_with(RELEASE_BRANCH_PREFIX) {
        bail!(
            "expected branch name with prefix '{}', got '{}'",
            RELEASE_BRANCH_PREFIX,
            branch_name
        );
    }

    Ok(branch_name)
}



================================================
File: crates/release-automation/src/lib/crate_selection/forest.rs
================================================
use std::collections::{HashMap, HashSet};

use anyhow::bail;
use itertools::Itertools;

use crate::Fallible;

use super::{Crate, DependenciesT};

#[derive(Debug)]
struct Node<'a> {
    c: &'a Crate<'a>,
    direct_ws_deps: HashSet<cargo::core::Dependency>,
    in_degree: usize,
    out_degree: usize,
}

// Based on Kahn’s algorithm for topological sorting of a graph and does not assume that the graph is connected
pub fn flatten_forest<'a>(crates: &'a Vec<Crate<'a>>) -> Fallible<Vec<&'a Crate<'a>>> {
    // A set of nodes which track the degree of each node
    let mut forest = build_forest(crates);

    let mut order = Vec::<&'a Crate<'a>>::new();

    loop {
        let mut working_order = Vec::<(&'a Crate<'a>, HashSet<cargo::core::Dependency>)>::new();
        for node in forest.values() {
            if node.in_degree == 0 {
                working_order.push((node.c, node.direct_ws_deps.clone()));
            }
        }

        if working_order.is_empty() {
            break;
        }

        // Remove all the nodes from the forest which had no references to them in this pass
        for (c, deps) in &working_order {
            for d in deps {
                if let Some(n) = forest.get_mut(&d.package_name().to_string()) {
                    n.in_degree -= 1
                }
            }

            forest.remove(&c.name());
        }

        // Push those same nodes to the final list
        order.extend(
            working_order
                .into_iter()
                .map(|(c, _)| c)
                .sorted_by(|a, b| a.name().cmp(&b.name())),
        );
    }

    let num_crates = crates.len();
    let num_order = order.len();
    if num_crates != num_order {
        let crates: HashSet<_> = crates.iter().map(|c| c.name()).collect();
        let order = order.iter().map(|c| c.name()).collect::<Vec<_>>();
        let order_set: HashSet<String> = order.iter().cloned().collect();
        let diff = crates.difference(&order_set);
        bail!("While attempting to order crates, managed to order {num_order} of {num_crates} crates. This likely means there is a cyclic dependency.\n\nOrdered crates: {order:#?}\nMissing crates: {diff:#?}");
    }

    Ok(order.into_iter().rev().collect())
}

fn build_forest<'a>(crates: &'a Vec<Crate<'a>>) -> HashMap<String, Node> {
    let mut forest = HashMap::<String, Node>::new();
    for c in crates {
        let node = Node {
            c: &c,
            direct_ws_deps: HashSet::new(),
            in_degree: 0,
            out_degree: 0,
        };

        forest.insert(c.name(), node);
    }

    let workspace_packages: HashSet<String> = forest.iter().map(|(name, _)| name.clone()).collect();

    let mut in_degrees = HashMap::<String, usize>::new();

    for node in forest.values_mut() {
        let deps = node.c.direct_workspace_dependencies(&workspace_packages);
        node.direct_ws_deps = deps.iter().cloned().collect();
        node.out_degree = deps.len();
        for d in deps {
            let degree = in_degrees.entry(d.package_name().to_string()).or_insert(0);
            *degree += 1;
        }
    }

    for node in forest.values_mut() {
        if let Some(degree) = in_degrees.get(&node.c.name()) {
            node.in_degree = *degree;
        }
    }

    forest
}



================================================
File: crates/release-automation/src/lib/crate_selection/mod.rs
================================================
//! Select which crates to include in the release process.

use crate::changelog::{
    self, ChangeT, ChangelogT, ChangelogType, CrateChangelog, WorkspaceChangelog,
};
use crate::common::SemverIncrementMode;
use crate::Fallible;
use cargo::core::Dependency;
use log::{debug, info, trace, warn};

use anyhow::Context;
use anyhow::{anyhow, bail};
use educe::{self, Educe};
use enumflags2::{bitflags, BitFlags};
use linked_hash_map::LinkedHashMap;
use linked_hash_set::LinkedHashSet;
use once_cell::unsync::{Lazy, OnceCell};
use regex::Regex;
use semver::{Comparator, Op, Version, VersionReq};
use std::cell::Cell;
use std::collections::{BTreeSet, HashMap, HashSet};
use std::fmt;
use std::io::Write;
use std::iter::FromIterator;
use std::path::{Path, PathBuf};
use std::process::Command;

mod forest;
pub use forest::flatten_forest;

pub mod aliases {
    pub use cargo::core::dependency::DepKind as CargoDepKind;
    pub use cargo::core::package::Package as CargoPackage;
    pub use cargo::core::Workspace as CargoWorkspace;
}
use aliases::*;

fn releaseworkspace_path_only_fmt(
    ws: &&ReleaseWorkspace<'_>,
    f: &mut fmt::Formatter,
) -> fmt::Result {
    write!(f, "{:?}", &ws.root_path)
}

type DependenciesT = LinkedHashMap<String, Vec<cargo::core::Dependency>>;

#[derive(custom_debug::Debug)]
pub struct Crate<'a> {
    package: CargoPackage,
    changelog: Option<ChangelogT<'a, CrateChangelog>>,
    #[debug(with = "releaseworkspace_path_only_fmt")]
    workspace: &'a ReleaseWorkspace<'a>,
    #[debug(skip)]
    dependencies_in_workspace: OnceCell<DependenciesT>,
    #[debug(skip)]
    dependants_in_workspace: OnceCell<Vec<&'a Crate<'a>>>,
}

#[cfg(test)]
impl PartialEq for Crate<'_> {
    fn eq(&self, other: &Self) -> bool {
        self.package == other.package
            && self.dependencies_in_workspace == other.dependencies_in_workspace
            && self.dependants_in_workspace == other.dependants_in_workspace
    }
}

impl<'a> Crate<'a> {
    /// Instantiate a new Crate with the given CargoPackage.
    pub fn with_cargo_package(
        package: CargoPackage,
        workspace: &'a ReleaseWorkspace<'a>,
    ) -> Fallible<Self> {
        let changelog = {
            let changelog_path = package.root().join("CHANGELOG.md");
            if changelog_path.exists() {
                Some(ChangelogT::<CrateChangelog>::at_path(&changelog_path))
            } else {
                None
            }
        };

        Ok(Self {
            package,
            changelog,
            workspace,
            dependencies_in_workspace: Default::default(),
            dependants_in_workspace: Default::default(),
        })
    }

    /// Return the path of the package's manifest.
    pub fn manifest_path(&self) -> &Path {
        self.package.manifest_path()
    }

    /// Sets the new version for the given crate, updates all workspace dependants,
    /// and returns a refrence to them for post-processing.
    pub fn set_version(
        &'a self,
        dry_run: bool,
        release_version: &semver::Version,
    ) -> Fallible<Vec<&'a Crate<'a>>> {
        debug!(
            "setting version to {} in manifest at {:?}",
            release_version,
            self.manifest_path(),
        );

        let release_version_str = release_version.to_string();

        if !dry_run {
            cargo_next::set_version(self.manifest_path(), release_version_str.as_str())?;
        }

        let dependants = self
            .dependants_in_workspace_filtered(|(_dep_name, deps)| {
                deps.iter().any(|dep| {
                    dep.version_req() != &cargo::util::OptVersionReq::from(VersionReq::STAR)
                })
            })?
            .to_owned();

        for dependant in dependants.iter() {
            dependant.set_dependency_version(&self.name(), &release_version, None, dry_run)?;
        }

        Ok(dependants)
    }

    /// Set a dependency to a specific version
    // Adapted from https://github.com/sunng87/cargo-release/blob/f94938c3f20ef20bc8f971d59de75574a0b18931/src/cargo.rs#L122-L154
    pub fn set_dependency_version(
        &self,
        name: &str,
        version: &Version,
        version_req_override: Option<&VersionReq>,
        dry_run: bool,
    ) -> Fallible<()> {
        debug!(
            "[{}] updating dependency version from dependant {} to version {} in manifest {:?}",
            &self.name(),
            &name,
            &version,
            self.manifest_path(),
        );

        let temp_manifest_path = self
            .manifest_path()
            .parent()
            .ok_or_else(|| {
                anyhow::anyhow!(
                    "couldn't get parent of path {}",
                    self.manifest_path().display()
                )
            })?
            .join("Cargo.toml.work");

        {
            let manifest = crate::common::load_from_file(self.manifest_path())?;
            let mut manifest: toml_edit::Document = manifest.parse()?;
            for key in &["dependencies", "dev-dependencies", "build-dependencies"] {
                if manifest.as_table().contains_key(key)
                    && manifest[key]
                        .as_table()
                        .expect("manifest is already verified")
                        .contains_key(name)
                {
                    let extracted_version_req = match &manifest[key][name] {
                        toml_edit::Item::Value(toml_edit::Value::String(_)) => {
                            bail!("{} has a dependency on {} with a version req that is simple but must be detailed and include a path.", self.name(), name);
                        }
                        toml_edit::Item::Value(toml_edit::Value::InlineTable(t)) => {
                            if t.get("path").is_none() {
                                bail!("{} has a dependency on {} that doesn't include a path.", self.name(), name);
                            }

                            t.get("version").and_then(|v| v.as_str()).map(|version| {
                                VersionReq::parse(version).context(anyhow::anyhow!(
                                    "parsing version {:?} for dependency {} ",
                                    version,
                                    self.name()
                                ))
                            })
                        }
                        _ => {
                            bail!("{} has a dependency on {} with a version req that is in a format that wasn't recognised.", self.name(), name);
                        }
                    };

                    let existing_version_req = if let Some(Ok(existing_version_req)) = extracted_version_req {
                        existing_version_req
                    } else {
                        // TODO We've already checked the key and name are present so hitting this is actually serious and shouldn't just log and continue
                        debug!(
                            "could not parse {}'s {} version req to string: {:?}",
                            name, key, manifest[key][name]["version"]
                        );

                        continue;
                    };

                    trace!(
                        "version: {:?}, existing version req {:?} in {}",
                        version,
                        existing_version_req,
                        key,
                    );

                    // only set the version if necessary
                    if *key == "dependencies" || existing_version_req != VersionReq::STAR {
                        let final_version_req = if let Some(vr) = version_req_override {
                            vr.clone()
                        } else {
                            let mut version_req = VersionReq::parse(&version.to_string())?;

                            // if the Op of the first Comparator we'll inherit that, the rest will be discarded
                            if let Some(op) = existing_version_req
                                .comparators
                                .first()
                                .map(|comp| {
                                    if comp.op != semver::Op::Wildcard {
                                        Some(comp.op)
                                    } else {
                                        None
                                    }
                                })
                                .flatten()
                            {
                                trace!("overriding first op of {:?} with {:?}", version_req, op);
                                let version_req_clone = version_req.clone();

                                version_req
                                    .comparators
                                    .first_mut()
                                    .ok_or_else(|| anyhow::anyhow!{
                                        "first comparator of version_req {:?} should be accessible",
                                        version_req_clone
                                    })?
                                    .op = op;
                            };

                            version_req
                        };

                        manifest[key][name]["version"] =
                            toml_edit::value(final_version_req.to_string());
                    }
                }
            }

            let mut file_out = std::fs::File::create(&temp_manifest_path)?;
            file_out.write_all(manifest.to_string_in_original_order().as_bytes())?;
        }
        if !dry_run {
            std::fs::rename(temp_manifest_path, self.manifest_path())?;
        }

        Ok(())
    }

    /// Return a reference to the package.
    pub fn package(&self) -> &CargoPackage {
        &self.package
    }

    pub fn state(&self) -> CrateState {
        self.workspace
            .members_states()
            .expect("should be initialised")
            .get(&self.name())
            .expect("should be found")
            .clone()
    }

    /// This crate's name as given in the Cargo.toml file
    pub fn name(&self) -> String {
        self.package.name().to_string()
    }

    /// This crate's current version as given in the Cargo.toml file
    pub fn version(&self) -> Version {
        self.package.version().to_owned()
    }

    /// Return a string in the from of '{package_name}-{package_version}'
    pub fn name_version(&self) -> String {
        format!("{}-{}", self.name(), self.version())
    }

    /// This crate's changelog.
    pub fn changelog(&'a self) -> Option<&ChangelogT<'a, CrateChangelog>> {
        self.changelog.as_ref()
    }

    /// Returns the crates in the same workspace that this crate depends on.
    pub fn dependencies_in_workspace(&'a self) -> Fallible<&'a DependenciesT> {
        self.dependencies_in_workspace.get_or_try_init(|| {
            // LinkedHashSet automatically deduplicates while maintaining the insertion order.
            let mut dependencies = LinkedHashMap::new();
            let ws_members: std::collections::HashMap<_, _> = self
                .workspace
                .members_unsorted()?
                .iter()
                .map(|m| (m.name(), &m.package))
                .collect();

            // This vector is used to implement a depth-first-search to capture all transitive dependencies.
            // Starting with the package in self and traversing down from it.
            let mut queue = vec![&self.package];
            let mut seen = HashSet::new();

            while let Some(package) = queue.pop() {
                for dep in package.dependencies() {
                    let dep_name = dep.package_name().to_string();

                    // todo: write a test-case for this
                    if dep.is_optional() && self.workspace.criteria.exclude_optional_deps {
                        trace!(
                            "[{}] excluding optional dependency '{}'",
                            package.name(),
                            dep_name,
                        );

                        continue;
                    }

                    // only consider workspace members
                    if let Some(dep_package) = ws_members.get(&dep.package_name().to_string()) {
                        // only consider non-star version requirements
                        if dep.specified_req() && dep.version_req().to_string() != "*" {
                            // don't add this package to its own dependencies
                            if dep_package.name() != package.name() {
                                dependencies
                                    .entry(dep_name.clone())
                                    .or_insert_with(|| vec![])
                                    .push(dep.to_owned());

                                if !seen.contains(&dep_name) {
                                    queue.push(dep_package);
                                }
                            } else {
                                warn!(
                                    "encountered dependency cycle: {:?} <-> {:?}",
                                    self.name(),
                                    package.name()
                                );
                            }
                        }
                    }
                }
                seen.insert(package.name().to_string());
            }
            Ok(dependencies)
        })
    }

    fn direct_workspace_dependencies(
        &'a self,
        workspace_packages: &HashSet<String>,
    ) -> Vec<cargo::core::Dependency> {
        self.package()
            .dependencies()
            .iter()
            .filter_map(|dep| {
                let dep_name = dep.package_name().to_string();
                if self.name() == dep_name {
                    None // Ignore self
                } else if !workspace_packages.contains(&dep_name) {
                    None // Ignore deps that aren't part of the workspace
                } else if !dep.specified_req() || dep.version_req().to_string() == "*" {
                    None // Ignore deps without a version or with a "*" version
                } else {
                    Some(dep.clone())
                }
            })
            .collect()
    }

    /// Returns a reference to all workspace crates that depend on this crate.
    pub fn dependants_in_workspace(&'a self) -> Fallible<&'a Vec<&'a Crate<'a>>> {
        self.dependants_in_workspace
            .get_or_try_init(|| -> Fallible<_> { self.dependants_in_workspace_filtered(|_| true) })
    }

    /// Returns a reference to all workspace crates that depend on this crate.
    /// Features filtering by applying a filter function to the dependant's dependencies.
    pub fn dependants_in_workspace_filtered<F>(
        &'a self,
        filter_fn: F,
    ) -> Fallible<Vec<&'a Crate<'a>>>
    where
        F: Fn(&(&String, &Vec<Dependency>)) -> bool,
        F: Copy,
    {
        let members_dependants = self.workspace.members()?.iter().try_fold(
            LinkedHashMap::<String, &'a Crate<'a>>::new(),
            |mut acc, member| -> Fallible<_> {
                if member
                    .dependencies_in_workspace()?
                    .iter()
                    .filter(filter_fn)
                    .any(|(dep_name, _)| dep_name == &self.name())
                {
                    acc.insert(member.name(), *member);
                };

                Ok(acc)
            },
        )?;

        Ok(members_dependants.values().cloned().collect())
    }

    pub fn root(&self) -> &Path {
        self.package.root()
    }

    pub fn workspace(&self) -> &'a ReleaseWorkspace<'a> {
        self.workspace
    }
}

type MemberStates = LinkedHashMap<String, CrateState>;

#[derive(custom_debug::Debug)]
pub struct ReleaseWorkspace<'a> {
    root_path: PathBuf,
    criteria: SelectionCriteria,
    git_config_name: String,
    git_config_email: String,

    changelog: Option<ChangelogT<'a, WorkspaceChangelog>>,

    #[debug(skip)]
    cargo_config: cargo::util::config::Config,
    cargo_workspace: OnceCell<CargoWorkspace<'a>>,
    members_unsorted: OnceCell<Vec<Crate<'a>>>,
    members_sorted: OnceCell<Vec<&'a Crate<'a>>>,
    members_matched: OnceCell<Vec<&'a Crate<'a>>>,
    members_states: OnceCell<MemberStates>,
    #[debug(skip)]
    git_repo: git2::Repository,
}

/// Configuration criteria for the crate selection.
#[derive(Educe, Debug)]
#[educe(Default)]
pub struct SelectionCriteria {
    #[educe(Default(expression = r#"fancy_regex::Regex::new(".*").expect("matching anything is valid")"#r))]
    pub match_filter: fancy_regex::Regex,
    pub enforced_version_reqs: Vec<semver::VersionReq>,
    pub disallowed_version_reqs: Vec<semver::VersionReq>,
    pub allowed_dev_dependency_blockers: BitFlags<CrateStateFlags>,
    pub allowed_selection_blockers: BitFlags<CrateStateFlags>,
    pub allowed_semver_increment_modes: Option<HashSet<SemverIncrementMode>>,
    pub exclude_optional_deps: bool,
}

/// Defines detailed crate's state in terms of the release process.
#[bitflags]
#[repr(u32)]
#[derive(enum_utils::FromStr, Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum CrateStateFlags {
    /// matches a package filter
    Matched,
    /// in the dependency tree of a matched package
    IsWorkspaceDependency,
    /// in the dev-dependency tree of a matched package
    IsWorkspaceDevDependency,
    /// has changed since previous release if any
    HasPreviousRelease,
    /// Has no previous release
    NoPreviousRelease,
    /// Has a previous release but its tag is missing
    MissingReleaseTag,
    /// has changed since previous release
    ChangedSincePreviousRelease,
    /// At least one dependency is marked as changed.
    DependencyChanged,

    /// has `unreleasable: true` set in changelog
    MissingChangelog,
    MissingReadme,
    UnreleasableViaChangelogFrontmatter,
    EnforcedVersionReqViolated,
    DisallowedVersionReqViolated,
    /// Has no description in the Cargo.toml
    MissingDescription,
    /// Has no license in the Cargo.toml
    MissingLicense,
    /// Has a dependency that contains '*'
    HasWildcardDependency,
    /// Has a dev-dependency that contains '*'
    HasWildcardDevDependency,
    /// One of the manifest keywords is too long
    ManifestKeywordExceeds20Chars,
    ManifestKeywordContainsInvalidChar,
    ManifestKeywordsMoreThan5,
    AllowedSemverIncrementModeViolated,
}

/// Defines the meta states that can be derived from the more detailed `CrateStateFlags`.
#[bitflags]
#[repr(u16)]
#[derive(enum_utils::FromStr, Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum MetaCrateStateFlags {
    Allowed,
    Blocked,
    Changed,
    Selected,
}

impl CrateStateFlags {
    pub fn empty_set() -> BitFlags<Self> {
        BitFlags::empty()
    }
}

/// Implements the logic for determining a crate's starte in terms of the release process.
#[derive(Default, Clone, Debug, PartialEq, Eq, Hash)]
pub struct CrateState {
    flags: BitFlags<CrateStateFlags>,
    meta_flags: BitFlags<MetaCrateStateFlags>,

    allowed_dev_dependency_blockers: BitFlags<CrateStateFlags>,
    allowed_selection_blockers: BitFlags<CrateStateFlags>,
}

impl CrateState {
    pub const BLOCKING_STATES: BitFlags<CrateStateFlags> = enumflags2::make_bitflags!(
        CrateStateFlags::{MissingChangelog
            | MissingReadme
            | UnreleasableViaChangelogFrontmatter
            | DisallowedVersionReqViolated
            | EnforcedVersionReqViolated
            | MissingDescription
            | MissingLicense
            | HasWildcardDependency
            | ManifestKeywordExceeds20Chars
            | ManifestKeywordContainsInvalidChar
            | ManifestKeywordsMoreThan5
            | AllowedSemverIncrementModeViolated
    });

    pub fn new(
        flags: BitFlags<CrateStateFlags>,
        allowed_dev_dependency_blockers: BitFlags<CrateStateFlags>,
        allowed_selection_blockers: BitFlags<CrateStateFlags>,
    ) -> Self {
        let mut new = Self {
            flags,
            meta_flags: Default::default(),
            allowed_dev_dependency_blockers,
            allowed_selection_blockers,
        };
        new.update_meta_flags();
        new
    }

    pub fn contains(&self, flag: CrateStateFlags) -> bool {
        self.flags.contains(flag)
    }

    pub fn merge(&mut self, other: Self) {
        self.flags.extend(other.flags.iter());
        self.update_meta_flags();
    }

    pub fn insert(&mut self, flag: CrateStateFlags) {
        self.flags.insert(flag);
        self.update_meta_flags();
    }

    pub fn is_matched(&self) -> bool {
        self.flags.contains(CrateStateFlags::Matched)
    }

    pub fn is_dependency(&self) -> bool {
        self.flags.contains(CrateStateFlags::IsWorkspaceDependency)
    }

    pub fn is_dev_dependency(&self) -> bool {
        self.flags
            .contains(CrateStateFlags::IsWorkspaceDevDependency)
    }

    fn update_meta_flags(&mut self) {
        if self.changed() {
            self.meta_flags.insert(MetaCrateStateFlags::Changed);
        } else {
            self.meta_flags.remove(MetaCrateStateFlags::Changed);
        }

        if !self.blocked_by().is_empty() {
            self.meta_flags.insert(MetaCrateStateFlags::Blocked);
        } else {
            self.meta_flags.remove(MetaCrateStateFlags::Blocked);
        }

        if self.allowed() {
            self.meta_flags.insert(MetaCrateStateFlags::Allowed);
        } else {
            self.meta_flags.remove(MetaCrateStateFlags::Allowed);
        }

        if self.selected() {
            self.meta_flags.insert(MetaCrateStateFlags::Selected);
        } else {
            self.meta_flags.remove(MetaCrateStateFlags::Selected);
        }
    }

    fn blocked_by(&self) -> BitFlags<CrateStateFlags> {
        Self::BLOCKING_STATES.intersection_c(self.flags)
    }

    fn disallowed_blockers(&self) -> BitFlags<CrateStateFlags> {
        let mut blocking_flags = self.blocked_by();

        match (self.is_matched(), self.is_dev_dependency()) {
            (true, _) => blocking_flags.remove(self.allowed_selection_blockers),
            (_, true) => blocking_flags.remove(self.allowed_dev_dependency_blockers),
            _ => {}
        }

        blocking_flags
    }

    fn blocked(&self) -> bool {
        !self.blocked_by().is_empty()
    }

    fn allowed(&self) -> bool {
        self.disallowed_blockers().is_empty()
    }

    /// There are changes to be released.
    pub fn changed(&self) -> bool {
        self.flags.contains(CrateStateFlags::NoPreviousRelease)
            || self.flags.contains(CrateStateFlags::MissingReleaseTag)
            || self
                .flags
                .contains(CrateStateFlags::ChangedSincePreviousRelease)
    }

    /// At least one dependency is marked as changed.
    pub fn dependency_changed(&self) -> bool {
        self.flags.contains(CrateStateFlags::DependencyChanged)
    }

    /// There are changes to be released since the previous release
    pub fn changed_since_previous_release(&self) -> bool {
        self.flags
            .contains(CrateStateFlags::ChangedSincePreviousRelease)
    }

    /// Has a prevoius release.
    pub fn has_previous_release(&self) -> bool {
        self.flags.contains(CrateStateFlags::HasPreviousRelease)
    }

    /// Has been matched explicitly or as a consequence of a dependency.
    pub fn selected(&self) -> bool {
        self.is_matched() || self.is_dependency() || self.is_dev_dependency()
    }

    /// Will be included in the release
    pub fn release_selection(&self) -> bool {
        !self.blocked() && (self.changed() || self.dependency_changed()) && self.selected()
    }

    /// Returns a formatted string with an overview of crates and their states.
    pub fn format_crates_states<'cs, CS>(
        states: CS,
        title: &str,
        show_blocking: bool,
        show_flags: bool,
        show_meta: bool,
    ) -> String
    where
        CS: std::iter::IntoIterator<Item = &'cs (String, CrateState)>,
    {
        let mut states_shown = if show_blocking || show_flags || show_meta {
            "Showing states: "
        } else {
            ""
        }
        .to_string();
        if show_blocking {
            states_shown += "* Disallowed Blocking "
        }
        if show_flags {
            states_shown += "* Flags "
        }
        if show_meta {
            states_shown += "* Meta"
        }
        if !states_shown.is_empty() {
            states_shown += "\n";
        }

        let mut msg = format!("\n{0:-<80}\n{1}\n{2}", "", title.to_owned(), states_shown,);
        for (name, state) in states {
            msg += &format!("{empty:-<80}\n{name:<30}", empty = "", name = name);
            if show_blocking {
                msg += &format!(
                    "{blocking_flags:?}\n{empty:<30}",
                    empty = "",
                    blocking_flags = state.disallowed_blockers().iter().collect::<Vec<_>>(),
                );
            }

            if show_flags {
                msg += &format!(
                    "{flags:?}\n{empty:<30}",
                    empty = "",
                    flags = state.flags.iter().collect::<Vec<_>>(),
                );
            };

            if show_meta {
                msg += &format!(
                    "{meta_flags:?}",
                    meta_flags = state.meta_flags.iter().collect::<Vec<_>>(),
                );
            };

            msg += &"\n".to_string();
        }

        msg
    }
}

impl<'a> ReleaseWorkspace<'a> {
    const README_FILENAME: &'a str = "README.md";
    const GIT_CONFIG_NAME: &'a str = "Holochain Core Dev Team";
    const GIT_CONFIG_EMAIL: &'a str = "devcore@holochain.org";

    pub fn try_new_with_criteria(
        root_path: PathBuf,
        criteria: SelectionCriteria,
    ) -> Fallible<ReleaseWorkspace<'a>> {
        Ok(Self {
            criteria,
            ..Self::try_new(root_path)?
        })
    }

    /// Reset all cached state which will cause a reload the next time any method is called.
    pub fn reset_state(&mut self) {
        self.cargo_workspace = Default::default();
        self.cargo_workspace = Default::default();
        self.members_unsorted = Default::default();
        self.members_sorted = Default::default();
        self.members_states = Default::default();
    }

    pub fn try_new(root_path: PathBuf) -> Fallible<ReleaseWorkspace<'a>> {
        let changelog = {
            let changelog_path = root_path.join("CHANGELOG.md");
            if changelog_path.exists() {
                Some(ChangelogT::<WorkspaceChangelog>::at_path(&changelog_path))
            } else {
                None
            }
        };

        let new = Self {
            // initialised: false,
            git_repo: git2::Repository::open(&root_path)?,

            git_config_name: Self::GIT_CONFIG_NAME.to_string(),
            git_config_email: Self::GIT_CONFIG_EMAIL.to_string(),

            root_path,
            criteria: Default::default(),
            changelog,
            cargo_config: cargo::util::config::Config::default()?,

            cargo_workspace: Default::default(),
            members_unsorted: Default::default(),
            members_sorted: Default::default(),
            members_matched: Default::default(),
            members_states: Default::default(),
        };

        // todo(optimization): eagerly ensure that the workspace is valid, but the following fails lifetime checks
        // let _ = new.cargo_workspace()?;

        Ok(new)
    }

    fn members_states(&'a self) -> Fallible<&MemberStates> {
        self.members_states.get_or_try_init(|| {
            let mut members_states = MemberStates::new();

            let criteria = &self.criteria;
            let initial_state = CrateState {
                allowed_dev_dependency_blockers: criteria.allowed_dev_dependency_blockers,
                allowed_selection_blockers: criteria.allowed_selection_blockers,

                ..Default::default()
            };

            let keyword_validation_re = Regex::new("^[a-zA-Z][a-zA-Z_\\-0-9]+$").unwrap();

            for member in self.members()? {

                // helper macros to access the desired state
                macro_rules! get_state {
                    ( $i:expr ) => {
                        members_states.entry($i).or_insert(initial_state.clone())
                    };
                }
                macro_rules! insert_state {
                    ( $flag:expr ) => {
                        insert_state!($flag, member.name())
                    };
                    ( $flag:expr, $i:expr ) => {
                        get_state!($i).insert($flag)
                    };
                }

                // manifest metadata validation
                {
                    let metadata = member.package().manifest().metadata();
                    if !(metadata.license.is_some() || metadata.license_file.is_some()) {
                        insert_state!(CrateStateFlags::MissingLicense);
                    }

                    if metadata.description.is_none() {
                        insert_state!(CrateStateFlags::MissingDescription);
                    }

                    // see https://doc.rust-lang.org/cargo/reference/manifest.html?highlight=keywords#the-keywords-field
                    // Note: crates.io has a maximum of 5 keywords. Each keyword must be ASCII text, start with a letter, and only contain letters, numbers, _ or -, and have at most 20 characters.
                    if metadata.keywords.iter().any(|keyword| keyword.len() > 20) {
                        insert_state!(CrateStateFlags::ManifestKeywordExceeds20Chars);
                    }
                    if metadata.keywords.iter().any(|keyword| !keyword_validation_re.is_match(keyword)) {
                        insert_state!(CrateStateFlags::ManifestKeywordContainsInvalidChar);
                    }
                    if metadata.keywords.len() > 5 {
                        insert_state!(CrateStateFlags::ManifestKeywordsMoreThan5);
                    }
                }

                // regex matching state
                if criteria.match_filter.is_match(&member.name())? {
                    insert_state!(CrateStateFlags::Matched);
                }

                // version requirements
                {
                    let version = member.version();

                    criteria
                        .enforced_version_reqs
                        .iter()
                        .filter(|enforced_version_req| !enforced_version_req.matches(&version))
                        .take(1)
                        .for_each(|enforced_version_req| {
                            warn!(
                                "'{}' version '{}' doesn't meet the enforced requirement '{}'",
                                member.name(),
                                version,
                                enforced_version_req
                            );
                            insert_state!(CrateStateFlags::EnforcedVersionReqViolated);
                        });

                    criteria
                        .disallowed_version_reqs
                        .iter()
                        .filter(|disallowed_version_req| disallowed_version_req.matches(&version))
                        .take(1)
                        .for_each(|disallowed_version_req| {
                            warn!(
                                "'{}' version '{}' matches the disallowed requirement '{}'",
                                member.name(),
                                version,
                                disallowed_version_req
                            );
                            insert_state!(CrateStateFlags::DisallowedVersionReqViolated);
                        });

                    if !std::path::Path::new(&member.root().join(Self::README_FILENAME)).exists() {
                        insert_state!(CrateStateFlags::MissingReadme);
                    }

                    // change related state
                    match member.changelog() {
                        None => {
                            warn!("'{}' is missing the changelog", member.name());
                            insert_state!(CrateStateFlags::MissingChangelog);
                        }

                        Some(changelog) => {
                            if let Some(front_matter) = changelog.front_matter().context(
                                format!("when parsing front matter of crate '{}'", member.name()),
                            )? {
                                if front_matter.unreleasable() {
                                    warn!("'{}' has unreleasable defined via the changelog frontmatter", member.name());
                                    insert_state!(
                                        CrateStateFlags::UnreleasableViaChangelogFrontmatter
                                    );
                                }
                            }

                            if let Some(changelog::ReleaseChange::CrateReleaseChange(previous_release_version)) =
                                changelog
                                    .changes()
                                    .ok()
                                    .iter()
                                    .flatten()
                                    .filter_map(|r| {
                                        if let ChangeT::Release(r) = r {
                                            Some(r)
                                        } else {
                                            None
                                        }
                                    })
                                    .take(1)
                                    .next()
                            {

                                // todo: derive the tagname from a function?
                                // lookup the git tag for the previous release
                                let maybe_git_tag =
                                        git_lookup_tag(&self.git_repo, format!("{}-{}", &member.name(), previous_release_version).as_str());

                                log::debug!("[{}] previous release: {}, previous git tag {:?}", member.name(), previous_release_version, maybe_git_tag);

                                if let Some(git_tag) = maybe_git_tag {

                                    insert_state!(CrateStateFlags::HasPreviousRelease);

                                    // todo: make comparison ref configurable
                                    let changed_files = changed_files(member.package.root(), &git_tag, "HEAD").context(format!("evaluating changes between {git_tag} and HEAD"))?;
                                    if !changed_files.is_empty()
                                    {
                                        debug!("[{}] changed files since {git_tag}: {changed_files:?}", member.name());
                                        insert_state!(CrateStateFlags::ChangedSincePreviousRelease)
                                    }
                                } else {
                                    insert_state!(CrateStateFlags::MissingReleaseTag);
                                }
                            } else {
                                    insert_state!(CrateStateFlags::NoPreviousRelease);
                            }
                        }
                    }

                    // semver_increment_mode checks
                    if let Some(allowed_semver_increment_modes) = &self.criteria.allowed_semver_increment_modes {
                        let effective_semver_increment_mode  = member
                            .changelog()
                            .map(|cl| cl.front_matter().ok())
                            .flatten()
                            .flatten()
                            .map(|fm| fm.semver_increment_mode())
                            .unwrap_or_default();


                        if !allowed_semver_increment_modes.contains(&effective_semver_increment_mode) {
                            debug!("Blocking {} due to {:?} with mode: {effective_semver_increment_mode:?}", member.name(), CrateStateFlags::AllowedSemverIncrementModeViolated);
                            insert_state!(CrateStateFlags::AllowedSemverIncrementModeViolated);
                        }
                    }
                }

                {
                    // dependency state
                    // only dependencies of explicitly matched packages are considered here.
                    // this detects changes in the transitive dependency chain by two mechanisms
                    // 1. the loop we're in iterates over the result of `ReleaseWorkspace::members`,
                    //    which orders the members according to the workspace dependency trees from leafs to roots.
                    //    this ensures that the states of a member's transitive dependencies have been evaluated by the time *it* is evaluated.
                    // 2. the `member.dependencies_in_workspace()` yields transitive results.
                    if get_state!(member.name()).is_matched()
                    {
                        for (_, deps) in member.dependencies_in_workspace()? {
                            for dep in deps {
                                insert_state!(
                                    match dep.kind() {
                                        CargoDepKind::Development => CrateStateFlags::IsWorkspaceDevDependency,
                                        _ => CrateStateFlags::IsWorkspaceDependency,
                                    },
                                    dep.package_name().to_string()
                                );
                            }
                        }

                        for dep in member.package().dependencies() {
                            if dep.version_req().to_string().contains('*') {
                                insert_state!(match dep.kind() {
                                    CargoDepKind::Normal | CargoDepKind::Build => CrateStateFlags::HasWildcardDependency,
                                    CargoDepKind::Development => CrateStateFlags::HasWildcardDevDependency,
                                });
                            }
                        }
                    }

                    // set DependencyChanged in dependants if this crate changed
                    if get_state!(member.name()).changed() {
                        for dependant in member.dependants_in_workspace()? {
                            insert_state!(
                                CrateStateFlags::DependencyChanged,
                                dependant.name()
                            );
                        }
                    }
                }

            }

            Ok(members_states)
        })
    }

    fn cargo_workspace(&'a self) -> Fallible<&'a CargoWorkspace> {
        self.cargo_workspace.get_or_try_init(|| {
            CargoWorkspace::new(&self.root_path.join("Cargo.toml"), &self.cargo_config)
        })
    }

    /// Returns the crates that are going to be processed for release.
    pub fn release_selection(&'a self) -> Fallible<Vec<&'a Crate>> {
        let members = self.members()?;

        let all_crates_states_iter = members.iter().map(|member| (member.name(), member.state()));
        let all_crates_states = all_crates_states_iter.clone().collect::<Vec<_>>();
        trace!(
            "{}",
            CrateState::format_crates_states(&all_crates_states, "ALL CRATES", true, true, true,)
        );
        let blocked_crates_states = all_crates_states_iter
            .clone()
            .filter(|(_, state)| state.selected() && !state.allowed())
            .collect::<Vec<_>>();

        // indicate an error if any unreleasable crates block the release
        if !blocked_crates_states.is_empty() {
            bail!(
                "the following crates are blocked but required for the release: \n{}",
                CrateState::format_crates_states(
                    &blocked_crates_states,
                    "DISALLOWED BLOCKING CRATES",
                    true,
                    false,
                    false,
                )
            )
        }

        let release_selection = members
            .iter()
            .filter(|member| {
                let release = member.state().release_selection();

                trace!(
                    "{} release indicator: {}, blocked: {:?}, state: {:#?}",
                    member.name(),
                    release,
                    member.state().blocked(),
                    member.state(),
                );

                release
            })
            .cloned()
            .collect::<Vec<_>>();

        Ok(release_selection)
    }

    fn members_unsorted(&'a self) -> Fallible<&'a Vec<Crate<'a>>> {
        self.members_unsorted.get_or_try_init(|| {
            let mut members = vec![];

            for package in self.cargo_workspace()?.members() {
                members.push(Crate::with_cargo_package(package.to_owned(), self)?);
            }

            Ok(members)
        })
    }

    /// Return all member crates matched by `SelectionCriteria::match_filter`
    pub fn members_matched(&'a self) -> Fallible<&'a Vec<&'a Crate<'a>>> {
        self.members_matched.get_or_try_init(|| {
            let states = self.members_states()?;

            self.members().map(|members| {
                members
                    .into_iter()
                    .filter(|crt| {
                        states
                            .get(&crt.name())
                            .cloned()
                            .unwrap_or_else(|| {
                                warn!(
                                    "cannot get CrateState for {}, using default state",
                                    crt.name()
                                );
                                CrateState::default()
                            })
                            .contains(CrateStateFlags::Matched)
                    })
                    .map(|crt| *crt)
                    .collect::<Vec<_>>()
            })
        })
    }

    /// Returns all non-excluded workspace members.
    /// Members are sorted according to their dependency tree from most independent to most dependent.
    pub fn members(&'a self) -> Fallible<&'a Vec<&'a Crate<'a>>> {
        self.members_sorted
            .get_or_try_init(|| -> Fallible<_> { flatten_forest(self.members_unsorted()?) })
    }

    /// Return the root path of the workspace.
    pub fn root(&'a self) -> &Path {
        &self.root_path
    }

    pub fn git_repo(&'a self) -> &git2::Repository {
        &self.git_repo
    }

    /// Tries to resolve the git HEAD to its corresponding branch.
    pub fn git_head_branch(&'a self) -> Fallible<(git2::Branch, git2::BranchType)> {
        for branch in self
            .git_repo
            .branches(None)
            .context("getting repo branches")?
        {
            let branch = branch?;
            if branch.0.is_head() {
                return Ok(branch);
            }
        }

        bail!("head branch not found")
    }

    /// Calls Self::git_head_branch and tries to resolve its name to String.
    pub fn git_head_branch_name(&'a self) -> Fallible<String> {
        self.git_head_branch().map(|(branch, _)| {
            branch
                .name()
                .context("looking for head branch")?
                .map(String::from)
                .ok_or_else(|| anyhow::anyhow!("the current git branch has no name"))
        })?
    }

    /// Creates a git branch with the given name off of the current HEAD, optionally overwriting the branch if it exists.
    pub fn git_checkout_branch(&'a self, name: &str, force: bool) -> Fallible<git2::Branch> {
        let head_commit = self.git_repo.head()?.peel_to_commit()?;

        let new_branch = self.git_repo.branch(name, &head_commit, force)?;

        let (object, reference) = self.git_repo.revparse_ext(name)?;

        self.git_repo.checkout_tree(&object, None)?;

        let reference_name = reference
            .ok_or_else(|| anyhow::anyhow!("couldn't parse branch new branch to reference"))?
            .name()
            .ok_or_else(|| anyhow::anyhow!("couldn't get reference name"))?
            .to_owned();

        self.git_repo.set_head(&reference_name)?;

        Ok(new_branch)
    }

    /// Creates a new git branch with the given name off of the current HEAD.
    pub fn git_checkout_new_branch(&'a self, name: &str) -> Fallible<git2::Branch> {
        self.git_checkout_branch(name, false)
    }

    // todo: make this configurable?
    fn git_signature(&self) -> Fallible<git2::Signature> {
        Ok(git2::Signature::now(
            &self.git_config_name,
            &self.git_config_email,
        )?)
    }

    /// Add the given files and create a commit.
    pub fn git_add_all_and_commit(
        &'a self,
        msg: &str,
        path_filter: Option<&mut git2::IndexMatchedPath<'_>>,
    ) -> Fallible<git2::Oid> {
        let repo = self.git_repo();

        let mut index = repo.index()?;
        index.add_all(["*"].iter(), git2::IndexAddOption::DEFAULT, path_filter)?;
        index.write()?;

        let tree_id = repo.index()?.write_tree()?;
        let sig = self.git_signature()?;
        let mut parents = Vec::new();

        if let Some(parent) = repo.head().ok().map(|h| h.target().unwrap()) {
            parents.push(repo.find_commit(parent)?)
        }
        let parents = parents.iter().collect::<Vec<_>>();
        repo.commit(
            Some("HEAD"),
            &sig,
            &sig,
            msg,
            &repo.find_tree(tree_id)?,
            &parents,
        )
        .map_err(anyhow::Error::from)
    }

    /// Create a new git tag from HEAD
    pub fn git_tag(&self, name: &str, force: bool) -> Fallible<git2::Oid> {
        let head = self
            .git_repo
            .head()?
            .target()
            .ok_or_else(|| anyhow::anyhow!("repo head doesn't have a target"))?;
        self.git_repo
            .tag(
                name,
                &self.git_repo.find_object(head, None)?,
                &self.git_signature()?,
                &format!("tag for release {}", name),
                force,
            )
            .context(format!("creating tag '{}'", name))
    }

    pub fn changelog(&'a self) -> Option<&'a ChangelogT<'a, WorkspaceChangelog>> {
        self.changelog.as_ref()
    }

    pub fn update_lockfile<T>(&'a self, dry_run: bool, additional_manifests: T) -> Fallible<()>
    where
        T: Iterator<Item = &'a str>,
        T: Clone,
    {
        for args in [
            vec![
                vec!["fetch", "--verbose", "--manifest-path", "Cargo.toml"],
                [
                    vec!["update", "--workspace", "--offline", "--verbose"],
                    if dry_run { vec!["--dry-run"] } else { vec![] },
                ]
                .concat(),
            ],
            additional_manifests
                .clone()
                .map(|mp| {
                    vec![
                        vec!["fetch", "--verbose", "--manifest-path", mp],
                        vec![
                            vec![
                                "update",
                                "--workspace",
                                "--offline",
                                "--verbose",
                                "--manifest-path",
                                mp,
                            ],
                            if dry_run { vec!["--dry-run"] } else { vec![] },
                        ]
                        .concat(),
                    ]
                })
                .collect::<Vec<Vec<_>>>()
                .concat(),
        ]
        .concat()
        {
            let mut cmd = std::process::Command::new("cargo");
            cmd.current_dir(self.root()).args(args);
            debug!("running command: {:?}", cmd);

            if !dry_run {
                let mut cmd = cmd.spawn()?;
                let cmd_status = cmd.wait()?;
                if !cmd_status.success() {
                    bail!("running {:?} failed: \n{:?}", cmd, cmd.stderr);
                }
            }
        }

        Ok(())
    }

    pub fn cargo_check<T>(&'a self, offline: bool, additional_manifests: T) -> Fallible<()>
    where
        T: Iterator<Item = &'a str>,
    {
        for args in [
            vec![vec![
                vec![
                    "check",
                    "--workspace",
                    "--all-targets",
                    "--all-features",
                    "--release",
                ],
                if offline { vec!["--offline"] } else { vec![] },
            ]
            .concat()],
            additional_manifests
                .map(|mp| -> Vec<&str> {
                    vec![
                        vec![
                            "check",
                            "--all-targets",
                            "--all-features",
                            "--release",
                            "--manifest-path",
                            mp,
                        ],
                        if offline { vec!["--offline"] } else { vec![] },
                    ]
                    .concat()
                })
                .collect::<Vec<_>>(),
        ]
        .concat()
        {
            let mut cmd = std::process::Command::new("cargo");
            cmd.current_dir(self.root()).args(args);
            debug!("running command: {:?}", cmd);

            let mut cmd = cmd.spawn()?;
            let cmd_status = cmd.wait()?;
            if !cmd_status.success() {
                bail!("running {:?} failed: \n{:?}", cmd, cmd.stderr);
            }
        }

        Ok(())
    }
}

/// Use the `git` shell command to detect changed files in the given directory between the given revisions.
///
/// Inspired by: https://github.com/sunng87/cargo-release/blob/master/src/git.rs
fn changed_files(dir: &Path, from_rev: &str, to_rev: &str) -> Fallible<Vec<PathBuf>> {
    use bstr::ByteSlice;

    let output = Command::new("git")
        .arg("diff")
        .arg(&format!("{}..{}", from_rev, to_rev))
        .arg("--name-only")
        .arg("--exit-code")
        .arg(".")
        .current_dir(dir)
        .output()?;

    match output.status.code() {
        Some(0) => Ok(Vec::new()),
        Some(1) => {
            let paths = output
                .stdout
                .lines()
                .map(|l| dir.join(l.to_path_lossy()))
                .collect();
            Ok(paths)
        }
        code => Err(anyhow!("git exited with code: {:?}", code)),
    }
}

/// Find a git tag in a repository
// todo: refactor into common place module
pub fn git_lookup_tag(git_repo: &git2::Repository, tag_name: &str) -> Option<String> {
    let tag = git_repo
        .revparse_single(tag_name)
        .ok()
        .map(|obj| obj.as_tag().cloned())
        .flatten()
        .map(|tag| tag.name().unwrap_or_default().to_owned());

    trace!("looking up tag '{}' -> {:?}", tag_name, tag);

    tag
}

// we shouldn't need this check but so far the failing case hasn't been reproduced in a test.
pub fn ensure_release_order_consistency<'a>(
    crates: &[&'a Crate<'a>],
) -> Fallible<LinkedHashSet<String>> {
    crates
        .iter()
        .try_fold(LinkedHashSet::new(), |mut acc, cur| {
            let wrong_order_deps = cur
                .dependencies_in_workspace()?
                .iter()
                .filter_map(|(dep_package_name, _)| {
                    if crates
                        .iter()
                        .any(|selected| &selected.name() == dep_package_name)
                        && !acc.contains(dep_package_name)
                    {
                        Some(dep_package_name.to_string())
                    } else {
                        None
                    }
                })
                .collect::<Vec<_>>();

            if !wrong_order_deps.is_empty() {
                bail!(
                    "{} depends on crates that are ordered after it: {:#?}. this is a bug.",
                    cur.name(),
                    wrong_order_deps
                );
            }

            acc.insert(cur.name());

            Ok(acc)
        })
}

#[cfg(test)]
mod tests;



================================================
File: crates/release-automation/src/lib/crate_selection/tests/mod.rs
================================================
use super::*;

use crate::tests::workspace_mocker::{
    example_workspace_1, example_workspace_2, example_workspace_3,
};
use enumflags2::make_bitflags;
use std::str::FromStr;

#[ctor::ctor]
fn init_logger() {
    env_logger::builder()
        .filter_level(log::LevelFilter::Trace)
        .is_test(true)
        .init();
}

#[test]
fn detect_changed_crates() {
    let workspace_mocker = example_workspace_1().unwrap();
    workspace_mocker.add_or_replace_file(
        "README",
        r#"# Example

            Some changes
        "#,
    );
    let before = workspace_mocker.head().unwrap();
    let after = workspace_mocker.commit(None);

    let workspace = ReleaseWorkspace::try_new(workspace_mocker.root()).unwrap();

    assert_eq!(
        vec![PathBuf::from(workspace.root()).join("README")],
        changed_files(workspace.root(), &before, &after).unwrap()
    );
}

#[test]
fn workspace_members() {
    let workspace_mocker = example_workspace_1().unwrap();
    let workspace = ReleaseWorkspace::try_new(workspace_mocker.root()).unwrap();

    let result = workspace
        .members()
        .unwrap()
        .iter()
        .map(|crt| crt.name())
        .collect::<HashSet<_>>();

    let expected_result = [
        "crate_g", "crate_a", "crate_b", "crate_c", "crate_e", "crate_f",
    ]
    .iter()
    .map(std::string::ToString::to_string)
    .collect::<HashSet<_>>();

    assert_eq!(expected_result, result);
}

#[test]
fn release_selection() {
    let criteria = SelectionCriteria {
        match_filter: fancy_regex::Regex::new("crate_(b|a|e)").unwrap(),
        disallowed_version_reqs: vec![semver::VersionReq::from_str(">=0.1.0").unwrap()],
        allowed_dev_dependency_blockers: make_bitflags!(CrateStateFlags::{MissingReadme}),
        allowed_selection_blockers: make_bitflags!(CrateStateFlags::{MissingReadme}),

        ..Default::default()
    };

    let workspace_mocker = example_workspace_1().unwrap();
    let workspace =
        ReleaseWorkspace::try_new_with_criteria(workspace_mocker.root(), criteria).unwrap();

    // TODO: verify that a crate can be selected by being an unmatched, changed crate that's a dependency of a matched, unchanged crate.

    let selection = workspace.release_selection().unwrap();

    assert_eq!(4, selection.len());
    ensure_release_order_consistency(&selection).unwrap();
}

#[test]
fn members_dependencies() {
    let workspace_mocker = example_workspace_2().unwrap();
    let workspace = ReleaseWorkspace::try_new_with_criteria(
        workspace_mocker.root(),
        SelectionCriteria {
            exclude_optional_deps: true,
            ..Default::default()
        },
    )
    .unwrap();

    let result = workspace
        .members()
        .unwrap()
        .iter()
        .map(|crt| {
            (
                crt.name(),
                crt.dependencies_in_workspace()
                    .unwrap()
                    .into_iter()
                    .map(|(dep_name, _)| dep_name.clone())
                    .collect::<HashSet<_>>(),
            )
        })
        .collect::<Vec<_>>();

    let expected_result = [
        ("crate_b".to_string(), vec![]),
        ("crate_c".to_string(), vec!["crate_b".to_string()]),
        (
            "crate_a".to_string(),
            vec!["crate_c".to_string(), "crate_b".to_string()],
        ),
        (
            "crate_d".to_string(),
            vec![
                "crate_a".to_string(),
                "crate_c".to_string(),
                "crate_b".to_string(),
            ],
        ),
    ]
    .into_iter()
    .map(|(name, deps)| (name, deps.into_iter().collect::<HashSet<_>>()))
    .collect::<Vec<_>>();

    pretty_assertions::assert_eq!(expected_result, result, "left is expected");
}

#[test]
fn crate_dependants_unfiltered_and_filtered() {
    let workspace_mocker = example_workspace_2().unwrap();
    let workspace = ReleaseWorkspace::try_new_with_criteria(
        workspace_mocker.root(),
        SelectionCriteria {
            exclude_optional_deps: true,
            ..Default::default()
        },
    )
    .unwrap();

    let crate_b = workspace
        .members()
        .unwrap()
        .iter()
        .find(|crt| crt.name() == "crate_b")
        .unwrap();

    // get something back
    pretty_assertions::assert_ne!(
        Vec::<&Crate>::new(),
        crate_b.dependants_in_workspace_filtered(|_| true).unwrap()
    );

    // unfiltered equals the 'true' filter
    pretty_assertions::assert_eq!(
        crate_b.dependants_in_workspace().unwrap(),
        &crate_b.dependants_in_workspace_filtered(|_| true).unwrap()
    );

    // filter changes work
    //
    // The actual values in here aren't that important, just need to see that the filter is applied and not
    // cached as `true` from above.
    pretty_assertions::assert_eq!(
        Vec::<&Crate>::new(),
        crate_b.dependants_in_workspace_filtered(|_| false).unwrap()
    );

    // dependency doesn't include itself
    pretty_assertions::assert_eq!(
        None,
        crate_b
            .dependants_in_workspace()
            .unwrap()
            .into_iter()
            .find(|crt| crt.name() == "crate_b")
    );

    // for the sake of completeness exhaustively check the result
    pretty_assertions::assert_eq!(
        vec!["crate_c", "crate_a", "crate_d"],
        crate_b
            .dependants_in_workspace()
            .unwrap()
            .iter()
            .map(|crt| crt.name())
            .collect::<Vec<_>>(),
    );
}

#[test]
fn members_sorted_ws1() {
    let workspace_mocker = example_workspace_1().unwrap();
    let workspace = ReleaseWorkspace::try_new_with_criteria(
        workspace_mocker.root(),
        SelectionCriteria {
            allowed_dev_dependency_blockers: (&[
                IsWorkspaceDependency,
                UnreleasableViaChangelogFrontmatter,
                MissingChangelog,
            ] as &[CrateStateFlags])
                .iter()
                .cloned()
                .collect(),

            ..Default::default()
        },
    )
    .unwrap();

    let result = workspace.members().unwrap();

    assert_eq!(6, result.len());
    ensure_release_order_consistency(result).unwrap();
}

#[test]
fn members_sorted_ws2() {
    let workspace_mocker = example_workspace_2().unwrap();
    let workspace = ReleaseWorkspace::try_new(workspace_mocker.root()).unwrap();

    let crates = workspace.members().unwrap();
    ensure_release_order_consistency(crates).unwrap();

    let result = crates.iter().map(|crt| crt.name()).collect::<Vec<_>>();

    let expected_result = ["crate_b", "crate_c", "crate_a", "crate_d"]
        .iter()
        .map(std::string::ToString::to_string)
        .collect::<Vec<_>>();

    assert_eq!(expected_result, result);
}

#[test]
fn unreleasable_dependencies_error() {
    let workspace_mocker = example_workspace_3().unwrap();
    let workspace = ReleaseWorkspace::try_new(workspace_mocker.root()).unwrap();

    let err = workspace.release_selection().unwrap_err().to_string();

    assert!(err.contains("blocked"), "{}", err);
}

use CrateStateFlags::ChangedSincePreviousRelease;
use CrateStateFlags::DisallowedVersionReqViolated;
use CrateStateFlags::EnforcedVersionReqViolated;
use CrateStateFlags::IsWorkspaceDependency;
use CrateStateFlags::IsWorkspaceDevDependency;
use CrateStateFlags::Matched;
use CrateStateFlags::MissingChangelog;
use CrateStateFlags::MissingReadme;
use CrateStateFlags::UnreleasableViaChangelogFrontmatter;

#[test]
fn crate_state_block_consistency() {
    let flags: BitFlags<CrateStateFlags> = (&[
        Matched,
        DisallowedVersionReqViolated,
        UnreleasableViaChangelogFrontmatter,
    ] as &[CrateStateFlags])
        .iter()
        .cloned()
        .collect();

    let allowed_dev_dependency_blockers: BitFlags<CrateStateFlags> = (&[
        // CrateStateFlags::MissingChangelog
    ]
        as &[CrateStateFlags])
        .iter()
        .cloned()
        .collect();
    let state = CrateState::new(flags, allowed_dev_dependency_blockers, Default::default());

    assert!(
        !state.blocked_by().is_empty(),
        "should be blocked_by something. {:#?}",
        state
    );
    assert!(state.blocked(), "should be blocked. {:#?}", state);
    assert!(state.selected(), "should be selected. {:#?}", state);
    assert!(
        !state.release_selection(),
        "shouldn't be release selection{:#?}",
        state
    );
}

#[test]
fn crate_state_allowed_dev_dependency_blockers() {
    let flags: BitFlags<CrateStateFlags> = (&[
        IsWorkspaceDevDependency,
        UnreleasableViaChangelogFrontmatter,
        MissingChangelog,
        EnforcedVersionReqViolated,
    ] as &[CrateStateFlags])
        .iter()
        .cloned()
        .collect();

    let allowed_blockers: BitFlags<CrateStateFlags> = (&[
        UnreleasableViaChangelogFrontmatter,
        MissingChangelog,
        EnforcedVersionReqViolated,
    ] as &[CrateStateFlags])
        .iter()
        .cloned()
        .collect();

    let state = CrateState::new(flags, allowed_blockers, Default::default());

    assert!(
        state.blocked() && !state.blocked_by().is_empty() && state.disallowed_blockers().is_empty(),
        "blocked by: {:#?}, disallowed blockers: {:#?}",
        state.blocked_by(),
        state.disallowed_blockers(),
    );
}

#[test]
fn crate_state_allowed_selection_blockers() {
    let flags: BitFlags<CrateStateFlags> = (&[
        Matched,
        UnreleasableViaChangelogFrontmatter,
        MissingChangelog,
        EnforcedVersionReqViolated,
    ] as &[CrateStateFlags])
        .iter()
        .cloned()
        .collect();

    let allowed_blockers: BitFlags<CrateStateFlags> = (&[
        UnreleasableViaChangelogFrontmatter,
        MissingChangelog,
        EnforcedVersionReqViolated,
    ] as &[CrateStateFlags])
        .iter()
        .cloned()
        .collect();

    let state = CrateState::new(flags, Default::default(), allowed_blockers);

    assert!(
        state.blocked() && !state.blocked_by().is_empty() && state.disallowed_blockers().is_empty(),
        "blocked by: {:#?}, disallowed blockers: {:#?}",
        state.blocked_by(),
        state.disallowed_blockers(),
    );
}

// todo: add git tests here
// #[test]
// fn git_branch_management() -> {
//     let workspace_mocker = example_workspace_1().unwrap();
//     let workspace = ReleaseWorkspace::try_new(workspace_mocker.root()).unwrap();

// }



================================================
File: crates/release-automation/src/lib/tests/cli.rs
================================================
use std::env::temp_dir;
use std::path::{Path, PathBuf};
use std::sync::Mutex;

use crate::changelog::{sanitize, Frontmatter};
use crate::changelog::{ChangelogT, CrateChangelog, WorkspaceChangelog};
use crate::common::SemverIncrementMode;
use crate::crate_selection::ReleaseWorkspace;
use crate::tests::workspace_mocker::{
    example_workspace_1, example_workspace_1_aggregated_changelog, example_workspace_4,
};
use crate::Fallible;
use anyhow::Context;
use once_cell::sync::OnceCell;
use predicates::prelude::*;
use serde::Deserialize;
use std::io::Write;

/// uses a shared temporary directory for all Commands that and sets their HOME and CARGO_HOME respectively.
/// optionally changes the working directory into the given path.
pub(crate) fn command_pure(
    program: &str,
    maybe_cwd: Option<&Path>,
) -> Fallible<assert_cmd::Command> {
    static TMP_HOME: once_cell::sync::Lazy<tempfile::TempDir> =
        once_cell::sync::Lazy::new(|| tempfile::tempdir().unwrap());

    let home = TMP_HOME.path().join("home");

    std::fs::create_dir_all(&home)?;

    let mut cmd = assert_cmd::Command::new(program);
    cmd.env("HOME", home.as_path())
        .env("CARGO_HOME", home.join(".cargo"));

    if let Some(cwd) = maybe_cwd {
        cmd.current_dir(cwd);
    }

    Ok(cmd)
}

#[test]
fn release_createreleasebranch() {
    let workspace_mocker = example_workspace_1().unwrap();
    let workspace = ReleaseWorkspace::try_new(workspace_mocker.root()).unwrap();
    workspace.git_checkout_new_branch("develop").unwrap();
    let mut cmd = command_pure("release-automation", Some(&workspace_mocker.root())).unwrap();
    let cmd = cmd.args(&[
        &format!("--workspace-path={}", workspace.root().display()),
        "release",
        &format!(
            "--cargo-target-dir={}",
            workspace.root().join("target").display()
        ),
        "--steps=CreateReleaseBranch",
    ]);
    cmd.assert().success();

    crate::release::ensure_release_branch(&workspace).unwrap();
}

#[test]
fn release_createreleasebranch_fails_on_dirty_repo() {
    let workspace_mocker = example_workspace_1().unwrap();
    workspace_mocker.add_or_replace_file(
        "crates/crate_a/README",
        indoc::indoc! {r#"
            # Example

            Some changes
            More changes
            "#,
        },
    );
    let workspace = ReleaseWorkspace::try_new(workspace_mocker.root()).unwrap();
    workspace.git_checkout_new_branch("develop").unwrap();

    let mut cmd = command_pure("release-automation", Some(&workspace_mocker.root())).unwrap();
    let cmd = cmd.args(&[
        &format!("--workspace-path={}", workspace.root().display()),
        "--log-level=debug",
        "release",
        &format!(
            "--cargo-target-dir={}",
            workspace.root().join("target").display()
        ),
        "--steps=CreateReleaseBranch",
    ]);

    cmd.assert()
        .stderr(predicate::str::contains("repository is not clean"))
        .failure();
}

#[macro_export]
macro_rules! assert_cmd_success {
    ($cmd:expr) => {{
        let output = $cmd.output().unwrap();

        let (stderr, stdout) = (
            String::from_utf8_lossy(&output.stderr),
            String::from_utf8_lossy(&output.stdout),
        );

        if !output.status.success() {
            panic!(
                "code: {:?}\nstderr:\n'{}'\n---\nstdout:\n'{}'\n---\n",
                output.status.code(),
                stderr,
                stdout,
            );
        };

        (String::from(stderr), String::from(stdout))
    }};
}

fn get_crate_versions<'a>(
    expected_crates: &[&str],
    workspace: &'a ReleaseWorkspace<'a>,
) -> Vec<String> {
    expected_crates
        .iter()
        .map(|name| get_crate_version(name, workspace))
        .collect::<Vec<_>>()
}

fn get_crate_version<'a>(name: &str, workspace: &'a ReleaseWorkspace<'a>) -> String {
    let cargo_toml_path = workspace
        .root()
        .join("crates")
        .join(name)
        .join("Cargo.toml");
    cargo_next::get_version(&cargo_toml_path)
        .context(format!(
            "trying to parse version in Cargo.toml at {:?}",
            cargo_toml_path
        ))
        .unwrap()
        .to_string()
}

// todo(backlog): ensure all of these conditions have unit tests?
#[test]
fn bump_versions_on_selection() {
    let workspace_mocker = example_workspace_1().unwrap();
    let workspace = ReleaseWorkspace::try_new(workspace_mocker.root()).unwrap();
    workspace.git_checkout_new_branch("develop").unwrap();

    let mut cmd = command_pure("release-automation", Some(&workspace_mocker.root())).unwrap();
    let cmd = cmd.args(&[
        &format!("--workspace-path={}", workspace.root().display()),
        "--log-level=trace",
        "release",
        &format!(
            "--cargo-target-dir={}",
            workspace.root().join("target").display()
        ),
        "--disallowed-version-reqs=>=0.2",
        "--allowed-matched-blockers=UnreleasableViaChangelogFrontmatter,DisallowedVersionReqViolated",
        "--steps=CreateReleaseBranch,BumpReleaseVersions",
        "--allowed-missing-dependencies=crate_b",
    ]);

    let output = assert_cmd_success!(cmd);
    println!("stderr:\n'{}'\n---\nstdout:\n'{}'\n---", output.0, output.1,);

    // set expectations
    let expected_crates = vec!["crate_b", "crate_a", "crate_e"];
    let expected_release_versions = vec!["0.0.0", "0.1.0", "0.0.1"];

    // check manifests for new release headings
    assert_eq!(
        expected_release_versions,
        get_crate_versions(&expected_crates, &workspace),
    );

    // ensure *all* dependants were updated
    // alas, after refactoring the code into a loop i noticed there's only one dependency in this example workspace
    for (name, dep_name, expected_crate_version) in &[("crate_a", "crate_b", "=0.0.0")] {
        assert_eq!(
            expected_crate_version,
            &crate::common::get_dependency_version(
                &workspace
                    .root()
                    .join("crates")
                    .join(name)
                    .join("Cargo.toml"),
                dep_name
            )
            .unwrap()
            .replace("\"", "")
            .replace("\\", "")
            .replace(" ", ""),
        );
    }

    // check changelogs for new release headings
    assert_eq!(
        expected_release_versions,
        expected_crates
            .iter()
            .map(|crt| {
                let path = workspace
                    .root()
                    .join("crates")
                    .join(crt)
                    .join("CHANGELOG.md");
                ChangelogT::<CrateChangelog>::at_path(&path)
                    .topmost_release()
                    .context(format!("querying topmost_release on changelog for {}", crt))
                    .unwrap()
                    .ok_or_else(|| {
                        anyhow::anyhow!(
                            "changelog for {} doesn't have any release. file content: \n{}",
                            crt,
                            std::fs::read_to_string(&path).unwrap()
                        )
                    })
                    .map(|change| change.title().to_string())
                    .unwrap()
            })
            .collect::<Vec<String>>()
    );

    let workspace_changelog =
        ChangelogT::<WorkspaceChangelog>::at_path(&workspace.root().join("CHANGELOG.md"));
    let topmost_workspace_release = workspace_changelog
        .topmost_release()
        .unwrap()
        .map(|change| change.title().to_string())
        .unwrap();

    // todo: ensure the returned title doesn't contain any brackets?
    assert!(
        // FIXME: make this compatible with years beyond 2099
        topmost_workspace_release.starts_with("[20") || topmost_workspace_release.starts_with("20"),
        "{}",
        topmost_workspace_release
    );
    assert_ne!("[20210304.120604]", topmost_workspace_release);

    {
        // check for release heading contents in the workspace changelog

        let expected = sanitize(indoc::formatdoc!(
            r#"
        # Changelog

        This file conveniently consolidates all of the crates individual CHANGELOG.md files and groups them by timestamps at which crates were released. The file is updated every time one or more crates are released.

        The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/). This project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

        # \[Unreleased\]

        ## Something outdated maybe

        This will be removed by aggregation.

        ## [crate_c](crates/crate_c/CHANGELOG.md#unreleased)
        Awesome changes!

        ### Breaking
        Breaking changes, be careful.

        ## [crate_f](crates/crate_f/CHANGELOG.md#unreleased)
        This will be released in the future.

        # {}

        The text beneath this heading will be retained which allows adding overarching release notes.

        ## [crate_a-0.1.0](crates/crate_a/CHANGELOG.md#0.1.0)

        ### Added

        - `InstallAppBundle`
        - `DnaSource`

        ### Removed

        - BREAKING:  `InstallAppDnaPayload`
        - BREAKING: `DnaSource(Path)`

        ## [crate_e-0.0.1](crates/crate_e/CHANGELOG.md#0.0.1)

        Awesome changes\!

        ## [crate_b-0.0.0](crates/crate_b/CHANGELOG.md#0.0.0)

        ### Changed

        - `Signature` is a 64 byte ‘secure primitive’

        ## [crate\_g-0.0.2](crates/crate_g/CHANGELOG.md#0.0.2)

        # \[20210304.120604\]

        This will include the hdk-0.0.100 release.

        ## [hdk-0.0.100](crates/hdk/CHANGELOG.md#0.0.100)

        ### Changed

        - hdk: fixup the autogenerated hdk documentation.
        "#,
            topmost_workspace_release
        ));

        let result = sanitize(std::fs::read_to_string(workspace_changelog.path()).unwrap());
        assert_eq!(
            result,
            expected,
            "{}",
            prettydiff::text::diff_lines(&result, &expected).format()
        );
    }

    // ensure the git commit for the whole release was created
    let commit_msg = {
        let commit = workspace
            .git_repo()
            .head()
            .unwrap()
            .peel_to_commit()
            .unwrap();

        commit.message().unwrap().to_string()
    };

    assert_eq!(
        indoc::formatdoc!(
            r#"
        create a release from branch release-{}

        the following crates are part of this release:

        - crate_g-0.0.2
        - crate_b-0.0.0
        - crate_e-0.0.1
        - crate_a-0.1.0
        "#,
            topmost_workspace_release
        ),
        commit_msg
    );

    // TODO: tag creation has been moved to publishing, test it there
    // ensure the git tags for the crate releases were created
    // for expected_tag in &["crate_b-0.0.0", "crate_a-0.0.2", "crate_e-0.0.1"] {
    //     crate::crate_selection::git_lookup_tag(workspace.git_repo(), &expected_tag)
    //         .expect(&format!("git tag '{}' not found", &expected_tag));
    // }

    if matches!(option_env!("FAIL_CLI_RELEASE_TEST"), Some(_)) {
        println!("stderr:\n'{}'\n---\nstdout:\n'{}'\n---", output.0, output.1,);

        panic!("workspace root: {:?}", workspace.root());
    }
}

#[test]
fn changelog_aggregation() {
    let workspace_mocker = example_workspace_1().unwrap();

    let workspace = ReleaseWorkspace::try_new(workspace_mocker.root()).unwrap();

    let mut cmd = command_pure("release-automation", Some(&workspace_mocker.root())).unwrap();
    let cmd = cmd.args(&[
        &format!("--workspace-path={}", workspace.root().display()),
        "--log-level=trace",
        "changelog",
        "aggregate",
    ]);

    let _output = assert_cmd_success!(cmd);

    let workspace_changelog =
        ChangelogT::<WorkspaceChangelog>::at_path(&workspace.root().join("CHANGELOG.md"));
    let result = sanitize(std::fs::read_to_string(workspace_changelog.path()).unwrap());

    let expected = example_workspace_1_aggregated_changelog(
        workspace
            .members()
            .unwrap()
            .iter()
            .map(|c| c.name())
            .collect(),
    );
    assert_eq!(
        result,
        expected,
        "{}",
        prettydiff::text::diff_lines(&result, &expected).format()
    );
}

#[test]
fn release_publish() {
    let workspace_mocker = example_workspace_1().unwrap();
    let workspace = ReleaseWorkspace::try_new(workspace_mocker.root()).unwrap();
    workspace.git_checkout_new_branch("develop").unwrap();

    // simulate a release
    let mut cmd = command_pure("release-automation", Some(&workspace_mocker.root())).unwrap();
    let cmd = cmd.args(&[
        &format!("--workspace-path={}", workspace.root().display()),
        "--log-level=trace",
        "release",
        &format!("--cargo-target-dir={}", workspace.root().join("target").display()),
        "--disallowed-version-reqs=>=0.1",
        "--allowed-matched-blockers=UnreleasableViaChangelogFrontmatter,DisallowedVersionReqViolated",
        "--steps=CreateReleaseBranch,BumpReleaseVersions",
    ]);
    let output = assert_cmd_success!(cmd);
    println!("stderr:\n'{}'\n---\nstdout:\n'{}'\n---", output.0, output.1,);

    // publish
    let mut cmd = command_pure("release-automation", Some(&workspace_mocker.root())).unwrap();
    let cmd = cmd.args(&[
        &format!("--workspace-path={}", workspace.root().display()),
        "--log-level=trace",
        "release",
        // todo: set up a custom registry and actually publish the crates
        "--dry-run",
        &format!(
            "--cargo-target-dir={}",
            workspace.root().join("target").display()
        ),
        "--steps=PublishToCratesIo",
    ]);
    let output = assert_cmd_success!(cmd);
    println!("stderr:\n'{}'\n---\nstdout:\n'{}'\n---", output.0, output.1,);
}

// the post release version bump functionliaty has been removed from the release
// it now lives in a separate command and these tests can be moved there
#[ignore]
#[test]
fn post_release_version_bumps() {
    let workspace_mocker = example_workspace_1().unwrap();
    let workspace = ReleaseWorkspace::try_new(workspace_mocker.root()).unwrap();
    workspace.git_checkout_new_branch("develop").unwrap();

    // simulate a release
    let mut cmd = command_pure("release-automation", Some(&workspace_mocker.root())).unwrap();
    let cmd = cmd.args(&[
        &format!("--workspace-path={}", workspace.root().display()),
        "--log-level=trace",
        "release",
        &format!(
            "--cargo-target-dir={}",
            workspace.root().join("target").display()
        ),
        "--disallowed-version-reqs=>=0.1",
        "--allowed-matched-blockers=UnreleasableViaChangelogFrontmatter,DisallowedVersionReqViolated",
        "--steps=CreateReleaseBranch,BumpReleaseVersions",
        "--allowed-missing-dependencies=crate_b",
    ]);
    let output = assert_cmd_success!(cmd);
    println!("stderr:\n'{}'\n---\nstdout:\n'{}'\n---", output.0, output.1,);

    let mut cmd = command_pure("release-automation", Some(&workspace_mocker.root())).unwrap();
    let cmd = cmd.args(&[
        &format!("--workspace-path={}", workspace.root().display()),
        "--log-level=trace",
        "release",
        &format!(
            "--cargo-target-dir={}",
            workspace.root().join("target").display()
        ),
        "--steps=BumpPostReleaseVersions",
    ]);
    let output = assert_cmd_success!(cmd);
    println!("stderr:\n'{}'\n---\nstdout:\n'{}'\n---", output.0, output.1,);

    assert_eq!(
        vec!["0.0.2-dev.0", "0.0.3-dev.0", "0.0.2-dev.0"],
        get_crate_versions(&["crate_b", "crate_a", "crate_e"], &workspace),
    );

    // ensure the git commit for the whole release was created
    let commit_msg = {
        let commit = workspace
            .git_repo()
            .head()
            .unwrap()
            .peel_to_commit()
            .unwrap();

        commit.message().unwrap().to_string()
    };

    let topmost_release_title = match workspace
        .changelog()
        .unwrap()
        .topmost_release()
        .unwrap()
        .unwrap()
    {
        crate::changelog::ReleaseChange::WorkspaceReleaseChange(title, _) => title,
        _ => "not found".to_string(),
    };

    assert!(
        commit_msg.starts_with(&format!(
            "setting develop versions to conclude 'release-{}'",
            topmost_release_title
        )),
        "unexpected commit msg: \n{}\n{}",
        commit_msg,
        topmost_release_title,
    );

    {
        // ensure the workspace release tag has been created
        let topmost_workspace_release = workspace
            .changelog()
            .unwrap()
            .topmost_release()
            .unwrap()
            .map(|change| change.title().to_string())
            .unwrap();
        let expected_tag = format!("release-{}", topmost_workspace_release);
        crate::crate_selection::git_lookup_tag(workspace.git_repo(), &expected_tag)
            .unwrap_or_else(|| panic!("git tag '{}' not found", &expected_tag));
    }
}

#[test]
fn multiple_subsequent_releases() {
    let workspace_mocker = example_workspace_1().unwrap();
    type A = (PathBuf, Vec<(String, String)>);
    type F = Box<dyn Fn(A)>;

    for (
        i,
        (
            description,
            expected_crate_versions,
            allowed_missing_dependencies,
            expect_new_release,
            maybe_match_filter,
            pre_release_fn,
        ),
    ) in [
        (
            "bump the first time as they're initially released",
            vec![("crate_b", "0.0.0"), ("crate_a", "0.1.0"), ("crate_e", "0.0.1"), ("crate_g", "0.0.2")],
            // allowed missing dependencies
            Vec::<&str>::new(),
            true,
            None,
            Box::new(|_| {}) as F,
        ),
        (
            "should not bump the second time without making any changes",
            vec![("crate_b", "0.0.0"), ("crate_a", "0.1.0"), ("crate_e", "0.0.1")],
            // allowed missing dependencies
            Vec::<&str>::new(),
            false,
            None,
            Box::new(|_| {}) as F,
        ),
        (
            "only crate_a and crate_e have changed, expect these to be bumped",
            vec![("crate_b", "0.0.0"), ("crate_a",  "0.1.1"), ("crate_e", "0.0.2"), ("crate_g", "0.0.2")],
            // crate_b won't be part of the release so we allow it to be missing as we're not publishing
            vec!["crate_b"],
            true,
            None,
            Box::new(|args: A| {
                let root = args.0;

                for crt in &["crate_a", "crate_e"] {
                    let mut readme = std::fs::OpenOptions::new()
                        .write(true)
                        .append(true)
                        .open(root.join(format!("crates/{}/README.md", crt)))
                        .unwrap();

                    writeln!(readme, "A new line!").unwrap();
                }

                ReleaseWorkspace::try_new(root)
                    .unwrap()
                    .git_add_all_and_commit("some chnages", None)
                    .unwrap();
            }) as F,
        ),
        (
            "matching only crate_a, a change of its transitive dependency crate_g leads to bump in the dependency chain",
            vec![("crate_b", "0.0.1"), ("crate_a", "0.1.2"), ("crate_g", "0.0.3")],
            // allowed missing dependencies
            vec![],
            true,
            Some("crate_a"),
            Box::new(|args: A| {
                let root = args.0;

                for crt in &["crate_g"] {
                    let mut readme = std::fs::OpenOptions::new()
                        .write(true)
                        .append(true)
                        .open(root.join(format!("crates/{}/README.md", crt)))
                        .unwrap();
                    writeln!(readme, "A new line!").unwrap();
                }

                ReleaseWorkspace::try_new(root)
                    .unwrap()
                    .git_add_all_and_commit("some chnages", None)
                    .unwrap();
            }) as F,
        ),
        (
            "add a pre-release for crate_b",
            vec![("crate_b", "1.0.0-rc.0"), ("crate_a", "0.1.3"), ("crate_e", "0.0.2")],
            // allowed missing dependencies
            vec![],
            true,
            None,
            Box::new(|args: A| {
                let root = args.0;

                for crt in &["crate_b"] {
                    let mut readme = std::fs::OpenOptions::new()
                        .write(true)
                        .append(true)
                        .open(root.join(format!("crates/{}/README.md", crt)))
                        .unwrap();
                    writeln!(readme, "A new line!").unwrap();

                    ChangelogT::<CrateChangelog>::at_path(
                        &root.join(format!("crates/{}/CHANGELOG.md", crt)),
                    )
                    .set_front_matter(
                        &serde_yaml::from_str(
                            indoc::formatdoc!(
                                r#"
                                default_semver_increment_mode: !pre_major rc
                                "#
                            )
                            .as_str(),
                        )
                        .unwrap(),
                    )
                    .unwrap();
                }

                ReleaseWorkspace::try_new(root)
                    .unwrap()
                    .git_add_all_and_commit("some chnages", None)
                    .unwrap();
            }) as F,
        ),
        (
            "do another pre-release for crate_b",
            vec![("crate_b", "1.0.0-rc.1"), ("crate_a", "0.1.4"), ("crate_e", "0.0.2")],
            // allowed missing dependencies
            vec![],
            true,
            None,
            Box::new(|args: A| {
                let root = args.0;

                for crt in &["crate_b"] {
                    let mut readme = std::fs::OpenOptions::new()
                        .write(true)
                        .append(true)
                        .open(root.join(format!("crates/{}/README.md", crt)))
                        .unwrap();
                    writeln!(readme, "A new line!").unwrap();
                }

                ReleaseWorkspace::try_new(root)
                    .unwrap()
                    .git_add_all_and_commit("some chnages", None)
                    .unwrap();
            }) as F,
        ),
        (
            "do major release for crate_b",
            vec![("crate_b", "1.0.0"), ("crate_a", "0.1.5"), ("crate_e", "0.0.2")],
            // allowed missing dependencies
            vec![],
            true,
            None,
            Box::new(|args: A| {
                let root = args.0;

                for crt in &["crate_b"] {
                    let mut readme = std::fs::OpenOptions::new()
                        .write(true)
                        .append(true)
                        .open(root.join(format!("crates/{}/README.md", crt)))
                        .unwrap();
                    writeln!(readme, "A new line!").unwrap();

                    ChangelogT::<CrateChangelog>::at_path(
                        &root.join(format!("crates/{}/CHANGELOG.md", crt)),
                    )
                    .set_front_matter(
                        &serde_yaml::from_str(
                            indoc::formatdoc!(
                                r#"
                                semver_increment_mode: major
                                "#
                            )
                            .as_str(),
                        )
                        .unwrap(),
                    )
                    .unwrap();
                }

                ReleaseWorkspace::try_new(root)
                    .unwrap()
                    .git_add_all_and_commit("some chnages", None)
                    .unwrap();
            }) as F,
        ),
        (
            "and a default patch release for crate_b again",
            vec![("crate_b", "1.0.1"), ("crate_a", "0.1.6"), ("crate_e", "0.0.2")],
            // allowed missing dependencies
            vec![],
            true,
            None,
            Box::new(|args: A| {
                let root = args.0;

                for crt in &["crate_b"] {
                    let mut readme = std::fs::OpenOptions::new()
                        .write(true)
                        .append(true)
                        .open(root.join(format!("crates/{}/README.md", crt)))
                        .unwrap();
                    writeln!(readme, "A new line!").unwrap();
                }

                ReleaseWorkspace::try_new(root)
                    .unwrap()
                    .git_add_all_and_commit("some chnages", None)
                    .unwrap();
            }) as F,
        ),
    ]
    .iter()
    .enumerate()
    {
        println!("---\ntest case {}\n---", i);

        pre_release_fn((
            workspace_mocker.root(),
            expected_crate_versions
                .clone()
                .into_iter()
                .map(|(name, ver)| (name.to_string(), ver.to_string()))
                .collect(),
        ));

        let match_filter = maybe_match_filter.unwrap_or("crate_(a|b|e)");

        let topmost_release_title_pre = {
            let workspace = ReleaseWorkspace::try_new(workspace_mocker.root()).unwrap();
            let topmost_release_title_pre = match workspace
                .changelog()
                .unwrap()
                .topmost_release()
                .unwrap()
                .unwrap()
            {
                crate::changelog::ReleaseChange::WorkspaceReleaseChange(title, _) => title,
                _ => "not found".to_string(),
            };

            workspace.git_checkout_branch("develop", true).unwrap();

            let mut cmd =
                command_pure("release-automation", Some(&workspace_mocker.root())).unwrap();
            let cmd = cmd.args(&[
                &format!("--workspace-path={}", workspace.root().display()),
                "--log-level=trace",
                &format!("--match-filter={match_filter}"),
                "release",
                &format!(
                    "--cargo-target-dir={}",
                    workspace.root().join("target").display()
                ),
                "--allowed-matched-blockers=UnreleasableViaChangelogFrontmatter",
                "--steps=CreateReleaseBranch,BumpReleaseVersions",
                &format!(
                    "--allowed-missing-dependencies={}",
                    allowed_missing_dependencies
                        .iter()
                        .fold("".to_string(), |acc, cur| { acc + "," + *cur })
                ),
            ]);
            let output = assert_cmd_success!(cmd);
            println!("stderr:\n'{}'\n---\nstdout:\n'{}'\n---", output.0, output.1,);

            topmost_release_title_pre
        };

        let topmost_release_title = {
            // todo: figure out how we can make the workspace re-read its data instead of creating a new one
            let workspace = ReleaseWorkspace::try_new(workspace_mocker.root()).unwrap();

            for (expected_name, expected_ver) in expected_crate_versions {
                assert_eq!(
                    expected_ver,
                    &get_crate_version(expected_name, &workspace),
                    "{} ({})",
                    description,
                    i
                );
            }

            let topmost_release_title = match workspace
                .changelog()
                .unwrap()
                .topmost_release()
                .unwrap()
                .unwrap()
            {
                crate::changelog::ReleaseChange::WorkspaceReleaseChange(title, _) => title,
                _ => "not found".to_string(),
            };

            {
                // ensure the git commit matches the most recent release.

                let commit_msg = {
                    let commit = workspace
                        .git_repo()
                        .head()
                        .unwrap()
                        .peel_to_commit()
                        .unwrap();

                    commit.message().unwrap().to_string()
                };

                let expected_start = format!(
                    "create a release from branch release-{}",
                    topmost_release_title
                );

                assert!(
                    commit_msg.starts_with(&expected_start),
                    "unexpected commit msg. got: \n'{}'\nexpected it to start with: \n'{}'",
                    commit_msg,
                    expected_start,
                );
            }

            topmost_release_title
        };

        if *expect_new_release {
            assert_ne!(
                topmost_release_title, topmost_release_title_pre,
                "expected new release? {}",
                *expect_new_release
            );
        } else {
            assert_eq!(
                topmost_release_title, topmost_release_title_pre,
                "expected new release? {}",
                *expect_new_release
            )
        }

        // sleep so the time based branch name is unique
        // todo: change to other branch name generator?
        std::thread::sleep(std::time::Duration::new(1, 0));
    }

    if matches!(option_env!("FAIL_CLI_RELEASE_TEST"), Some(_)) {
        panic!("workspace root: {:?}", workspace_mocker.root());
    }
}

#[test]
fn apply_dev_versions_works() {
    let workspace_mocker = example_workspace_1().unwrap();

    let get_crate_a_version = || -> String {
        let workspace = ReleaseWorkspace::try_new(workspace_mocker.root()).unwrap();
        let crate_a = workspace
            .members()
            .unwrap()
            .iter()
            .find(|m| m.name() == "crate_a")
            .unwrap();

        crate_a.version().to_string()
    };

    assert_eq!(get_crate_a_version(), "0.0.1");

    let mut cmd = command_pure("release-automation", Some(&workspace_mocker.root())).unwrap();
    let cmd = cmd.args(&[
        &format!("--workspace-path={}", workspace_mocker.root().display()),
        "--log-level=debug",
        "crate",
        "apply-dev-versions",
    ]);
    let output = assert_cmd_success!(cmd);
    println!("stderr:\n'{}'\n---\nstdout:\n'{}'\n---", output.0, output.1);

    assert_eq!(get_crate_a_version(), "0.0.2-dev.0");
}

#[test]
fn release_dry_run_fails_on_unallowed_conditions() {
    let workspace_mocker = example_workspace_4().unwrap();
    let workspace = ReleaseWorkspace::try_new(workspace_mocker.root()).unwrap();
    workspace.git_checkout_new_branch("develop").unwrap();

    let members = workspace
        .members()
        .unwrap()
        .iter()
        .map(|m| m.name())
        .collect::<Vec<_>>();

    // every member corresponds to a blocker and must thus fail separately
    for member in members {
        workspace_mocker.add_or_replace_file(
            &format!("crates/{}/README.md", member),
            indoc::indoc! {r#"
            # Example

            Some changes
            More changes
            "#,
            },
        );

        workspace
            .update_lockfile(false, std::iter::empty())
            .unwrap();

        workspace.git_add_all_and_commit("msg", None).unwrap();

        let mut cmd = command_pure("release-automation", Some(&workspace_mocker.root())).unwrap();
        let cmd = cmd.args(&[
            &format!("--workspace-path={}", workspace.root().display()),
            &format!("--match-filter={}", member),
            "--log-level=debug",
            "release",
            "--dry-run",
            "--allowed-semver-increment-modes=patch",
            "--steps=BumpReleaseVersions",
        ]);

        cmd.assert().failure();
    }
}



================================================
File: crates/release-automation/src/lib/tests/mod.rs
================================================
pub mod cli;
pub mod workspace_mocker;

use std::path::Path;

use chrono::{naive::NaiveDateTime, DateTime, TimeZone, Utc};
use linked_hash_set::LinkedHashSet;

use crate::release::{ReleaseSteps, ReleaseWorkspace};

#[test]
fn release_steps_are_ordered() {
    let input = r"
        CreateReleaseBranch,
        BumpReleaseVersions,
        PublishToCratesIo,
        AddOwnersToCratesIo,
    ";

    let parsed = super::cli::parse_releasesteps(input)
        .unwrap()
        .into_iter()
        .collect::<Vec<_>>();

    assert_eq!(parsed.get(0), Some(&ReleaseSteps::CreateReleaseBranch));

    assert_eq!(parsed.get(1), Some(&ReleaseSteps::BumpReleaseVersions));

    assert_eq!(parsed.last(), Some(&ReleaseSteps::AddOwnersToCratesIo));
}

#[test]
fn parse_publish_error() {
    use crate::release::PublishError;

    struct TestCase<'a> {
        package: &'a str,
        version: &'a str,
        string: &'a str,
        expected_error: PublishError,
    }

    let cases = vec![
        TestCase {
            package: "",
            version: "",
            string: indoc::indoc!(
                r#"
                Caused by:
                cargo publish failed for the following paths:
                "#,
            ),

            expected_error: PublishError::Other(
                "".to_string(),
                indoc::formatdoc!(
                    r#"
                Caused by:
                cargo publish failed for the following paths:
                "#
                ),
            ),
        },
        TestCase {
            package: "kitsune_p2p_proxy",
            version: "0.0.1",
            string: indoc::indoc!(
                r#"
        "/home/steveej/src/holo/holochain_release/crates/kitsune_p2p/proxy/Cargo.toml":
           error: failed to prepare local package for uploading

           Caused by:
             no matching package named `kitsune_p2p_transport_quic` found
             location searched: registry `https://github.com/rust-lang/crates.io-index`
             required by package `kitsune_p2p_proxy v0.0.1 (/home/steveej/src/holo/holochain_release/crates/kitsune_p2p/proxy)`
                "#
            ),

            expected_error: PublishError::PackageNotFound {
                package: "kitsune_p2p_proxy".to_string(),
                version: "0.0.1".to_string(),
                path:
                    "/home/steveej/src/holo/holochain_release/crates/kitsune_p2p/proxy/Cargo.toml"
                        .to_string(),

                dependency: "kitsune_p2p_transport_quic".to_string(),
                location: "registry `https://github.com/rust-lang/crates.io-index`".to_string(),
                package_found: "kitsune_p2p_proxy".to_string(),
            },
        },
        TestCase {
            package: "holochain",
            version: "0.0.100",
            string: indoc::indoc!(
                r#"
                "/home/steveej/src/holo/holochain_release/crates/holochain/Cargo.toml":
                error: failed to prepare local package for uploading

                Caused by:
                    failed to select a version for the requirement `hdk = "^0.0.101-alpha.0"`
                    candidate versions found which didn't match: 0.0.100
                    location searched: crates.io index
                    required by package `holochain v0.0.100 (/home/steveej/src/holo/holochain_release/crates/holochain)`
                "#
            ),

            expected_error: PublishError::PackageVersionNotFound {
                package: "holochain".to_string(),
                version: "0.0.100".to_string(),
                path: "/home/steveej/src/holo/holochain_release/crates/holochain/Cargo.toml"
                    .to_string(),
                dependency: "hdk".to_string(),
                version_req: "^0.0.101-alpha.0".to_string(),
                location: "crates.io index".to_string(),
                package_found: "holochain".to_string(),
                version_found: "0.0.100".to_string(),
            },
        },
        TestCase {
            package: "crate_a",
            version: "0.0.2",
            string: indoc::indoc!(
                r#"
                error: failed to prepare local package for uploading

                Caused by:
                    no matching package named `crate_b` found
                    location searched: registry `https://github.com/rust-lang/crates.io-index`
                    required by package `crate_a v0.0.2 (/tmp/tmp.Oqk7lmGgfW/.tmp5m2olB/crates/crate_a)`
                "#
            ),

            expected_error: PublishError::PackageNotFound {
                package: "crate_a".to_string(),
                version: "0.0.2".to_string(),
                path: "".to_string(),

                dependency: "crate_b".to_string(),
                location: "registry `https://github.com/rust-lang/crates.io-index`".to_string(),
                package_found: "crate_a".to_string(),
            },
        },
        TestCase {
            package: "",
            version: "0.0.3",
            string: indoc::indoc!(
                r#"
                error: failed to publish to registry at https://crates.io

                Caused by:
                    the remote server responded with an error: crate version `0.0.3` is already uploaded
                "#
            ),

            expected_error: PublishError::AlreadyUploaded {
                package: "".to_string(),
                version: "0.0.3".to_string(),
                path: "".to_string(),
                location: "registry at https://crates.io".to_string(),
                version_found: "0.0.3".to_string(),
            },
        },
        TestCase {
            package: "",
            version: "",
            string: indoc::indoc!(
                r#"
                error: failed to publish to registry at https://crates.io

                       Caused by:
                         the remote server responded with an error (status 429 Too Many Requests): You have published too many crates in a short period of time. Please try again after Wed, 30 Jun 2021 21:09:24 GMT or email help@crates.io to have your limit increased.
                "#
            ),

            expected_error: PublishError::PublishLimitExceeded {
                package: "".to_string(),
                version: "".to_string(),
                location: "registry at https://crates.io".to_string(),
                retry_after: DateTime::<Utc>::from_utc(
                    NaiveDateTime::parse_from_str("2021-06-30 21:09:24", "%Y-%m-%d %H:%M:%S")
                        .unwrap(),
                    Utc,
                ),
            },
        },
    ];

    for case in cases {
        let result = PublishError::with_str(
            case.package.to_string(),
            case.version.to_string(),
            case.string.to_string(),
        );

        assert_eq!(case.expected_error, result);
    }
}



================================================
File: crates/release-automation/src/lib/tests/workspace_mocker.rs
================================================
use crate::*;

use anyhow::{bail, Context};
use cargo_test_support::git::{self, Repository};
use cargo_test_support::paths::init_root;
use cargo_test_support::{Project, ProjectBuilder};
use educe::Educe;
use itertools::Itertools;
use log::debug;
use std::collections::HashMap;
use std::path::PathBuf;

#[derive(Educe)]
#[educe(Default)]
pub enum MockProjectType {
    #[educe(Default)]
    Lib,
    Bin,
}

#[derive(Educe)]
#[educe(Default)]
pub struct MockProject {
    pub name: String,
    pub version: String,
    pub dependencies: Vec<String>,
    pub dev_dependencies: Vec<String>,
    pub excluded: bool,
    pub ty: MockProjectType,
    pub changelog: Option<String>,
    #[educe(Default(expression = r##"Some(indoc::formatdoc!(
                r#"
                # README
                "#
            ))
    "##))]
    pub readme: Option<String>,
    #[educe(Default(expression = r##"Some("some crate".to_string())"##))]
    pub description: Option<String>,
    #[educe(Default(expression = r##"Some("Apache-2.0".to_string())"##))]
    pub license: Option<String>,
    pub keywords: Vec<String>,
}

pub struct WorkspaceMocker {
    pub dir: Option<tempfile::TempDir>,
    pub projects: HashMap<String, MockProject>,
    pub workspace_project: Project,
    pub workspace_repo: git2::Repository,
}

impl WorkspaceMocker {
    pub fn try_new(toplevel_changelog: Option<&str>, projects: Vec<MockProject>) -> Fallible<Self> {
        init_root(None);

        let (path, dir) = {
            let dir = tempfile::tempdir()?;
            if std::option_env!("KEEP_MOCK_WORKSPACE")
                .map(str::parse::<bool>)
                .map(Result::ok)
                .flatten()
                .unwrap_or_default()
            {
                debug!("keeping {:?}", dir.path());
                (dir.into_path(), None)
            } else {
                (dir.path().to_path_buf(), Some(dir))
            }
        };

        let projects = projects
            .into_iter()
            .map(|project| (project.name.clone(), project))
            .collect::<HashMap<_, _>>();

        let excluded = projects.iter().fold(String::new(), |acc, (name, project)| {
            if project.excluded {
                acc + indoc::formatdoc!(
                    r#"
                        "crates/{}",
                    "#,
                    name
                )
                .as_str()
            } else {
                acc
            }
        });

        let project_builder = ProjectBuilder::new(path).file(
            "Cargo.toml",
            &indoc::formatdoc!(
                r#"
                [workspace]
                members = [ "crates/*" ]
                exclude = [
                    {}
                ]
                "#,
                excluded
            ),
        );

        let project_builder = if let Some(toplevel_changelog) = toplevel_changelog {
            project_builder.file("CHANGELOG.md", toplevel_changelog)
        } else {
            project_builder
        };

        let project_builder =
            projects
                .iter()
                .fold(project_builder, |project_builder, (name, project)| {
                    use MockProjectType::{Bin, Lib};

                    let dependencies = project
                        .dependencies
                        .iter()
                        .fold(String::new(), |dependencies, dependency| {
                            format!("{}{}\n", dependencies, dependency)
                        });

                    let dev_dependencies = project.dev_dependencies.iter().fold(
                        String::new(),
                        |dev_dependencies, dependency| {
                            format!("{}{}\n", dev_dependencies, dependency)
                        },
                    );

                    let keywords = project
                        .keywords
                        .iter()
                        .map(|keyword| format!(r#""{}""#, keyword))
                        .collect::<Vec<_>>()
                        .join(",");

                    let project_builder = project_builder
                        .file(
                            format!("crates/{}/Cargo.toml", &name),
                            &indoc::formatdoc!(
                                r#"
                                [package]
                                name = "{}"
                                version = "{}"
                                authors = []
                                {description}
                                {license}
                                homepage = "https://github.com/holochain/holochain"
                                documentation = "https://github.com/holochain/holochain"
                                keywords = [{keywords}]

                                [dependencies]
                                {dependencies}

                                [dev-dependencies]
                                {dev_dependencies}
                                "#,
                                &name,
                                &project.version,
                                description = &project
                                    .description
                                    .clone()
                                    .map(|d| format!(r#"description = "{}""#, d))
                                    .unwrap_or_default(),
                                license = &project
                                    .license
                                    .clone()
                                    .map(|d| format!(r#"license = "{}""#, d))
                                    .unwrap_or_default(),
                                dependencies = dependencies,
                                dev_dependencies = dev_dependencies,
                                keywords = keywords,
                            ),
                        )
                        .file(
                            format!(
                                "crates/{}/src/{}",
                                &name,
                                match &project.ty {
