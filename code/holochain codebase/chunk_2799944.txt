    let (tx, rx) = TriggerSender::new();
    let keystore = conductor.keystore().clone();

    super::queue_consumer_dna_bound(
        "validation_receipt_consumer",
        dna_hash.clone(),
        conductor.task_manager(),
        (tx.clone(), rx),
        move || {
            validation_receipt_workflow(
                dna_hash.clone(),
                env.clone(),
                network.clone(),
                keystore.clone(),
                conductor.running_cell_ids(),
                {
                    let conductor = conductor.clone();
                    move |block| {
                        let conductor = conductor.clone();
                        // This can be cleaned up when the compiler is smarter - https://github.com/rust-lang/rust/issues/69663
                        async move { conductor.block(block).await }.boxed()
                    }
                },
            )
        },
    );

    tx
}



================================================
File: crates/holochain/src/core/queue_consumer/witnessing_consumer.rs
================================================
//! The queue consumer for the witnessing workflow.

use super::*;
use crate::conductor::manager::TaskManagerClient;
use crate::core::workflow::witnessing_workflow::witnessing_workflow;
use tracing::*;

/// Spawn the QueueConsumer for the witnessing workflow
#[instrument(skip_all)]
pub(crate) fn spawn_witnessing_consumer(
    space: Space,
    task_manager: TaskManagerClient,
    dna_network: HolochainP2pDna,
    trigger_sys: TriggerSender,
) -> TriggerSender {
    let (tx, rx) = TriggerSender::new();

    queue_consumer_dna_bound(
        "witnessing_consumer",
        space.dna_hash.clone(),
        task_manager,
        (tx.clone(), rx),
        move || witnessing_workflow(space.clone(), dna_network.clone(), trigger_sys.clone()),
    );

    tx
}



================================================
File: crates/holochain/src/core/ribosome/check_clone_access.rs
================================================
use crate::conductor::api::CellConductorReadHandle;
use holochain_types::app::{InstalledApp, InstalledAppId};
use holochain_util::tokio_helper;
use holochain_wasmer_host::prelude::{wasm_error, WasmError, WasmErrorInner, WasmHostError};
use holochain_zome_types::{call::RoleName, cell::CellId};
use wasmer::RuntimeError;

/// Check whether the current cell belongs to the app we're trying to perform a clone operation on.
/// If so, return the app id and role name that match the target cell. Otherwise, return an error.
///
/// This function takes the target cell to be cloned as an argument, and fetches the current cell from the call context
/// so that the check cannot accidentally be called on the wrong cell, permitting access to the wrong app.
pub fn check_clone_access(
    target_cell_id: &CellId,
    conductor_handle: &CellConductorReadHandle,
) -> Result<(InstalledAppId, RoleName), RuntimeError> {
    let current_cell_id = conductor_handle.cell_id();

    let installed_app: InstalledApp = tokio_helper::block_forever_on(async move {
        conductor_handle
            .find_app_containing_cell(current_cell_id)
            .await
    })
    .map_err(|conductor_error| -> RuntimeError {
        wasm_error!(WasmErrorInner::Host(conductor_error.to_string())).into()
    })?
    .ok_or::<RuntimeError>(
        wasm_error!(WasmErrorInner::Host(
            "App not found for current cell".to_string(),
        ))
        .into(),
    )?;

    let agent_key = installed_app.agent_key();

    // Check whether the current cell belongs to the app we're trying to perform a clone operation on.
    let matched_app_role = installed_app
        .primary_roles()
        .find(|(_, role)| {
            target_cell_id.agent_pubkey() == agent_key
                && target_cell_id.dna_hash() == role.dna_hash()
        })
        .map(|(role_name, _)| role_name);

    if let Some(role_name) = matched_app_role {
        Ok((installed_app.id().clone(), role_name.clone()))
    } else {
        Err(wasm_error!(WasmErrorInner::Host(
            "Invalid request to modify a cell which belongs to another app".to_string(),
        ))
        .into())
    }
}



================================================
File: crates/holochain/src/core/ribosome/error.rs
================================================
//! Errors occurring during a [`RealRibosome`](crate::core::ribosome::real_ribosome::RealRibosome) call

use crate::conductor::api::error::ConductorApiError;
use crate::conductor::interface::error::InterfaceError;
use holo_hash::AnyDhtHash;
use holochain_cascade::error::CascadeError;
use holochain_secure_primitive::SecurePrimitiveError;
use holochain_serialized_bytes::prelude::SerializedBytesError;
use holochain_state::source_chain::SourceChainError;
use holochain_types::prelude::*;
use thiserror::Error;
use tokio::task::JoinError;
use wasmer::DeserializeError;

/// Errors occurring during a [`RealRibosome`](crate::core::ribosome::real_ribosome::RealRibosome) call
#[derive(Error, Debug)]
pub enum RibosomeError {
    /// Dna error while working with Ribosome.
    #[error("Dna error while working with Ribosome: {0}")]
    DnaError(#[from] DnaError),

    /// Wasm runtime error while working with Ribosome.
    #[error("Wasm runtime error while working with Ribosome: {0}")]
    WasmRuntimeError(#[from] wasmer::RuntimeError),

    /// Serialization error while working with Ribosome.
    #[error("Serialization error while working with Ribosome: {0}")]
    SerializationError(#[from] SerializedBytesError),

    /// A Zome was referenced by name that doesn't exist
    #[error("Referenced a zome that doesn't exist: Zome: {0}")]
    ZomeNotExists(ZomeName),

    /// A ZomeFn was called by name that doesn't exist
    #[error("Attempted to call a zome function that doesn't exist: Zome: {0} Fn {1}")]
    ZomeFnNotExists(ZomeName, FunctionName),

    /// a problem with entry defs
    #[error("An error with entry defs in zome '{0}': {1}")]
    EntryDefs(ZomeName, String),

    /// a mandatory dependency for a record doesn't exist
    /// for example a remove link ribosome call needs to find the add link in order to infer the
    /// correct base and this dependent relationship exists before even subconscious validation
    /// kicks in
    #[error("A mandatory record is missing, dht hash: {0}")]
    RecordDeps(AnyDhtHash),

    /// ident
    #[error(transparent)]
    KeystoreError(#[from] holochain_keystore::KeystoreError),

    /// ident
    #[error(transparent)]
    DatabaseError(#[from] holochain_sqlite::error::DatabaseError),

    /// ident
    #[error(transparent)]
    StateQueryError(#[from] holochain_state::query::StateQueryError),

    /// ident
    #[error(transparent)]
    CascadeError(#[from] CascadeError),

    /// ident
    #[error(transparent)]
    ConductorApiError(#[from] Box<ConductorApiError>),

    /// ident
    #[error(transparent)]
    SourceChainError(#[from] SourceChainError),

    /// ident
    #[error(transparent)]
    InterfaceError(#[from] InterfaceError),

    /// ident
    #[error(transparent)]
    JoinError(#[from] JoinError),

    /// ident
    #[error(transparent)]
    InlineZomeError(#[from] InlineZomeError),

    /// ident
    #[error(transparent)]
    P2pError(#[from] holochain_p2p::HolochainP2pError),

    /// ident
    #[error(transparent)]
    SecurePrimitive(#[from] SecurePrimitiveError),

    /// Zome function doesn't have permissions to call a Host function.
    #[error("Host function {2} cannot be called from zome function {1} in zome {0}")]
    HostFnPermissions(ZomeName, FunctionName, String),

    /// An attempt to was made to perform a clone operation on a cell that is not provisioned or belongs to another app.
    #[error("Invalid request to modify a cell which belongs to another app")]
    InvalidCloneTarget,

    #[error(transparent)]
    ZomeTypesError(#[from] holochain_types::zome_types::ZomeTypesError),

    #[error(transparent)]
    ModuleDeserializeError(#[from] DeserializeError),

    #[error(transparent)]
    IO(#[from] std::io::Error),

    #[error("The callback has an invalid return type: {0}")]
    CallbackInvalidReturnType(String),

    #[error("The callback has invalid parameters: {0}")]
    CallbackInvalidParameters(String),
}

/// Type alias
pub type RibosomeResult<T> = Result<T, RibosomeError>;



================================================
File: crates/holochain/src/core/ribosome/guest_callback.rs
================================================
pub mod entry_defs;
pub mod genesis_self_check;
pub mod init;
pub mod post_commit;
pub mod validate;
use std::collections::VecDeque;

use super::HostContext;
use crate::core::ribosome::error::RibosomeError;
use crate::core::ribosome::Invocation;
use crate::core::ribosome::RibosomeT;
use holochain_types::prelude::*;
use tokio::task::JoinHandle;

pub type CallStreamItem = Result<(Zome, ExternIO), (Zome, RibosomeError)>;
pub type CallStream = tokio_stream::wrappers::ReceiverStream<CallStreamItem>;

pub fn call_stream<R: RibosomeT + 'static, I: Invocation + 'static>(
    host_context: HostContext,
    ribosome: R,
    invocation: I,
) -> (
    CallStream,
    JoinHandle<Result<(), tokio::sync::mpsc::error::SendError<CallStreamItem>>>,
) {
    let (tx, rx) = tokio::sync::mpsc::channel(1);

    let h = tokio::spawn(async move {
        let mut remaining_zomes: VecDeque<_> = ribosome
            .zomes_to_invoke(invocation.zomes())
            .into_iter()
            .collect();
        let remaining_components_original: VecDeque<_> = invocation.fn_components().collect();

        while let Some(zome) = remaining_zomes.pop_front() {
            // reset fn components
            let mut remaining_components = remaining_components_original.clone();
            while let Some(to_call) = remaining_components.pop_front() {
                let to_call = to_call.into();
                let r = ribosome
                    .maybe_call(host_context.clone(), &invocation, &zome, &to_call)
                    .await;
                match r {
                    Ok(None) => {}
                    Ok(Some(result)) => tx.send(Ok((zome.clone(), result))).await?,
                    Err(e) => tx.send(Err((zome.clone(), e))).await?,
                }
            }
        }
        Ok(())
    });
    (tokio_stream::wrappers::ReceiverStream::new(rx), h)
}

#[cfg(test)]
#[cfg(feature = "slow_tests")]
mod tests {
    use crate::core::ribosome::guest_callback::call_stream;
    use crate::core::ribosome::FnComponents;
    use crate::core::ribosome::MockInvocation;
    use crate::core::ribosome::MockRibosomeT;
    use crate::core::ribosome::ZomesToInvoke;
    use crate::fixt::FnComponentsFixturator;
    use crate::fixt::ZomeCallHostAccessFixturator;
    use crate::fixt::ZomeFixturator;
    use holochain_types::prelude::*;
    use kitsune_p2p_types::box_fut;
    use mockall::predicate::*;
    use mockall::Sequence;
    use tokio_stream::StreamExt;

    #[tokio::test(flavor = "multi_thread")]
    async fn call_stream_streams() {
        // stuff we need to test with
        let mut sequence = Sequence::new();
        let mut ribosome = MockRibosomeT::new();

        let mut invocation = MockInvocation::new();

        let host_access = ZomeCallHostAccessFixturator::new(::fixt::Empty)
            .next()
            .unwrap();
        let zome_fixturator = ZomeFixturator::new(::fixt::Unpredictable);
        let mut fn_components_fixturator = FnComponentsFixturator::new(::fixt::Unpredictable);

        // let returning_init_invocation = init_invocation.clone();
        let zomes: Vec<Zome> = zome_fixturator.take(3).collect();
        let fn_components: FnComponents = fn_components_fixturator.next().unwrap();

        invocation
            .expect_zomes()
            .times(1)
            .in_sequence(&mut sequence)
            .return_const(ZomesToInvoke::AllIntegrity);

        ribosome
            // this should happen inside the CallIterator constructor
            .expect_zomes_to_invoke()
            .times(1)
            .in_sequence(&mut sequence)
            .return_const(zomes.clone());

        invocation
            .expect_fn_components()
            .times(1)
            .in_sequence(&mut sequence)
            .return_const(fn_components.clone());

        // zomes are the outer loop as we process all callbacks in a single zome before moving to
        // the next one
        for zome in zomes.clone() {
            for fn_component in fn_components.clone() {
                // the invocation zome name and component will be called by the ribosome
                ribosome
                    .expect_maybe_call::<MockInvocation>()
                    .with(
                        always(),
                        always(),
                        eq(zome.clone()),
                        eq(FunctionName::from(fn_component)),
                    )
                    .times(1)
                    .in_sequence(&mut sequence)
                    .returning(|_, _, _, _| {
                        box_fut(Ok(Some(
                            ExternIO::encode(InitCallbackResult::Pass).unwrap(),
                        )))
                    });
            }
        }

        let (calls, _h) = call_stream(host_access.into(), ribosome, invocation);

        let output: Vec<Result<(_, ExternIO), _>> = calls.collect().await;
        assert!(output.iter().all(|r| r.is_ok()));
        assert_eq!(output.len(), zomes.len() * fn_components.0.len());
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn.rs
================================================
use super::CallContext;
use super::RibosomeT;
use holochain_types::prelude::*;
use holochain_wasmer_host::prelude::*;
use std::sync::Arc;

/// default size for KeyRefs
const DEF_REF_SIZE: usize = 32;

pub(crate) trait KeyRefExt: Sized {
    fn to_tag(&self) -> Arc<str>;
}

impl KeyRefExt for XSalsa20Poly1305KeyRef {
    fn to_tag(&self) -> Arc<str> {
        let tag = subtle_encoding::base64::encode(self);
        let tag = unsafe { String::from_utf8_unchecked(tag) };
        tag.into_boxed_str().into()
    }
}

pub struct HostFnApi<Ribosome: RibosomeT> {
    ribosome: Arc<Ribosome>,
    call_context: Arc<CallContext>,
}

impl<Ribosome: RibosomeT> HostFnApi<Ribosome> {
    pub fn new(ribosome: Arc<Ribosome>, call_context: Arc<CallContext>) -> Self {
        Self {
            ribosome,
            call_context,
        }
    }
}

macro_rules! host_fn_api_impls {
    ( $( $(#[cfg(feature = $feat:literal)])? fn $f:ident ( $input:ty ) -> $output:ty; )* ) => {
        $(
            $(#[cfg(feature = $feat)])?
            pub(crate) mod $f;
        )*

        impl<Ribosome: RibosomeT> HostFnApiT for HostFnApi<Ribosome> {
            $(
                $(#[cfg(feature = $feat)])?
                fn $f(&self, input: $input) -> Result<$output, HostFnApiError> {
                    $f::$f(
                        self.ribosome.clone(),
                        self.call_context.clone(),
                        input.into()
                    ).map_err(|e| HostFnApiError::RibosomeError(Box::new(e)))
                }
            )*
        }
    };
}

// All host_fn_api_impls below rely on this import
use holochain_zome_types as zt;

host_fn_api_impls! {

    // ------------------------------------------------------------------
    // These definitions are copy-pasted from
    // holochain_zome_types::zome_io
    // MAYBE: is there a way to unhygienically import this code in both places?

    // Attempt to accept a preflight request.
    #[cfg(feature = "unstable-countersigning")]
    fn accept_countersigning_preflight_request(zt::countersigning::PreflightRequest) -> zt::countersigning::PreflightRequestAcceptance;

    // Info about the calling agent.
    fn agent_info (()) -> zt::info::AgentInfo;

    // Block some agent on the same DNA.
    #[cfg(feature = "unstable-functions")]
    fn block_agent (zt::block::BlockAgentInput) -> ();

    // Info about the current DNA.
    fn dna_info_1 (()) -> zt::info::DnaInfoV1;
    fn dna_info_2 (()) -> zt::info::DnaInfoV2;

    // @todo
    fn call_info (()) -> zt::info::CallInfo;

    fn call (Vec<zt::call::Call>) -> Vec<zt::prelude::ZomeCallResponse>;

    // @todo List all the local capability claims.
    fn capability_claims (()) -> ();

    // @todo List all the local capability grants.
    fn capability_grants (()) -> ();

    // @todo Get the capability for the current zome call.
    fn capability_info (()) -> ();

    // The EntryDefId determines how a create is handled on the host side.
    // CapGrant and CapClaim are handled natively.
    // App entries are referenced by entry defs then SerializedBytes stuffed into an Entry::App.
    // Returns ActionHash of the newly created record.
    fn create (zt::entry::CreateInput) -> holo_hash::ActionHash;

    fn x_salsa20_poly1305_shared_secret_create_random(
        Option<zt::x_salsa20_poly1305::key_ref::XSalsa20Poly1305KeyRef>
    ) -> zt::x_salsa20_poly1305::key_ref::XSalsa20Poly1305KeyRef;

    fn x_salsa20_poly1305_shared_secret_export(
        zt::x_salsa20_poly1305::XSalsa20Poly1305SharedSecretExport
    ) -> zt::x_salsa20_poly1305::encrypted_data::XSalsa20Poly1305EncryptedData;

    fn x_salsa20_poly1305_shared_secret_ingest(
        zt::x_salsa20_poly1305::XSalsa20Poly1305SharedSecretIngest
    ) -> zt::x_salsa20_poly1305::key_ref::XSalsa20Poly1305KeyRef;

    fn x_salsa20_poly1305_encrypt(
        holochain_zome_types::x_salsa20_poly1305::XSalsa20Poly1305Encrypt
    ) -> holochain_zome_types::x_salsa20_poly1305::encrypted_data::XSalsa20Poly1305EncryptedData;

    fn x_salsa20_poly1305_decrypt(
        holochain_zome_types::x_salsa20_poly1305::XSalsa20Poly1305Decrypt
    ) -> Option<holochain_zome_types::x_salsa20_poly1305::data::XSalsa20Poly1305Data>;

    fn create_x25519_keypair(()) -> holochain_zome_types::x_salsa20_poly1305::x25519::X25519PubKey;

    // Sender, Recipient, Data.
    fn x_25519_x_salsa20_poly1305_encrypt (holochain_zome_types::x_salsa20_poly1305::X25519XSalsa20Poly1305Encrypt) -> holochain_zome_types::x_salsa20_poly1305::encrypted_data::XSalsa20Poly1305EncryptedData;

    // Recipient, Sender, Encrypted data.
    fn x_25519_x_salsa20_poly1305_decrypt (holochain_zome_types::x_salsa20_poly1305::X25519XSalsa20Poly1305Decrypt) -> Option<holochain_zome_types::x_salsa20_poly1305::data::XSalsa20Poly1305Data>;

    // Sender, Recipient, Data.
    fn ed_25519_x_salsa20_poly1305_encrypt (holochain_zome_types::x_salsa20_poly1305::Ed25519XSalsa20Poly1305Encrypt) -> holochain_zome_types::x_salsa20_poly1305::encrypted_data::XSalsa20Poly1305EncryptedData;

    // Recipient, Sender, Encrypted data.
    fn ed_25519_x_salsa20_poly1305_decrypt (holochain_zome_types::x_salsa20_poly1305::Ed25519XSalsa20Poly1305Decrypt) -> holochain_zome_types::x_salsa20_poly1305::data::XSalsa20Poly1305Data;

    // Create a link between two entries.
    fn create_link (zt::link::CreateLinkInput) -> holo_hash::ActionHash;

    // Delete an entry.
    fn delete (zt::entry::DeleteInput) -> holo_hash::ActionHash;

    // Delete a CreateLink record.
    fn delete_link (zt::link::DeleteLinkInput) -> holo_hash::ActionHash;

    // Action hash of the newly committed record.
    // Emit a Signal::App to subscribers on the interface
    fn emit_signal (zt::signal::AppSignal) -> ();

    // The trace host import takes a TraceMsg to output wherever the host wants to display it.
    // TraceMsg includes line numbers. so the wasm tells the host about it's own code structure.
    fn trace (zt::trace::TraceMsg) -> ();

    // Attempt to get a live entry from the cascade.
    fn get (Vec<zt::entry::GetInput>) -> Vec<Option<zt::record::Record>>;

    fn get_agent_activity (zt::agent_activity::GetAgentActivityInput) -> zt::query::AgentActivity;

    // Query agent key lineage for the provided key.
    #[cfg(feature = "unstable-functions")]
    fn get_agent_key_lineage (AgentPubKey) -> Vec<AgentPubKey>;

    fn get_details (Vec<zt::entry::GetInput>) -> Vec<Option<zt::metadata::Details>>;

    // Get links by entry hash from the cascade.
    fn get_links (Vec<zt::link::GetLinksInput>) -> Vec<Vec<zt::link::Link>>;

    fn get_link_details (Vec<zt::link::GetLinksInput>) -> Vec<zt::link::LinkDetails>;

    fn count_links(zt::query::LinkQuery) -> usize;

    // Hash data on the host.
    fn hash (zt::hash::HashInput) -> zt::hash::HashOutput;

    // Check if agent key 2 is of the same lineage as agent key 2.
    // TODO: This HDI function can't be easily removed, even though it's considered an
    // unstable function.
    fn is_same_agent ((AgentPubKey, AgentPubKey)) -> bool;

    // Retreive a record from the DHT or short circuit.
    fn must_get_valid_record (zt::entry::MustGetValidRecordInput) -> Record;

    // Retreive a entry from the DHT or short circuit.
    fn must_get_entry (zt::entry::MustGetEntryInput) -> EntryHashed;

    // Retrieve an action from the DHT or short circuit.
    fn must_get_action (zt::entry::MustGetActionInput) -> SignedActionHashed;

    fn must_get_agent_activity (zt::chain::MustGetAgentActivityInput) -> Vec<zt::op::RegisterAgentActivity>;

    // Query the source chain for data.
    fn query (zt::query::ChainQueryFilter) -> Vec<Record>;

    // the length of random bytes to create
    fn random_bytes (u32) -> zt::bytes::Bytes;

    // Remotely signal many agents without waiting for responses
    fn send_remote_signal (zt::signal::RemoteSignal) -> ();

    // @todo
    #[cfg(feature = "unstable-functions")]
    fn schedule (String) -> ();

    // TODO deprecated, remove me
    #[cfg(feature = "unstable-functions")]
    fn sleep (core::time::Duration) -> ();

    // @todo
    fn version (()) -> zt::version::ZomeApiVersion;

    // Attempt to have the keystore sign some data
    // The pubkey in the input needs to be found in the keystore for this to work
    fn sign (zt::signature::Sign) -> zt::signature::Signature;

    // Sign a list of datas with an ephemeral, randomly generated keypair.
    fn sign_ephemeral (zt::signature::SignEphemeral) -> zt::signature::EphemeralSignatures;

    // Current system time, in the opinion of the host, as a `Duration`.
    fn sys_time (()) -> zt::timestamp::Timestamp;

    // Unblock some previously blocked agent.
    #[cfg(feature = "unstable-functions")]
    fn unblock_agent (zt::block::BlockAgentInput) -> ();

    // Same as  but also takes the ActionHash of the updated record.
    fn update (zt::entry::UpdateInput) -> holo_hash::ActionHash;

    fn verify_signature (zt::signature::VerifySignature) -> bool;

    // The zome and agent info are constants specific to the current zome and chain.
    // All the information is provided by core so there is no input value.
    // These are constant for the lifetime of a zome call.
    fn zome_info (()) -> zt::info::ZomeInfo;

    // Create a clone of an existing cell.
    fn create_clone_cell(zt::clone::CreateCloneCellInput) -> zt::clone::ClonedCell;

    // Disable a clone cell.
    fn disable_clone_cell(zt::clone::DisableCloneCellInput) -> ();

    // Enable a clone cell.
    fn enable_clone_cell(zt::clone::EnableCloneCellInput) -> zt::clone::ClonedCell;

    // Delete a clone cell.
    fn delete_clone_cell(zt::clone::DeleteCloneCellInput) -> ();

    // Close your source chain, indicating that you are migrating to a new DNA
    fn close_chain(zt::chain::CloseChainInput) -> holo_hash::ActionHash;

    // Open your chain, pointing to the previous DNA
    fn open_chain(zt::chain::OpenChainInput) -> holo_hash::ActionHash;

    // Get validation receipts for an action
    fn get_validation_receipts(zt::validate::GetValidationReceiptsInput) -> Vec<zt::validate::ValidationReceiptSet>;
}



================================================
File: crates/holochain/src/core/ribosome/real_ribosome.rs
================================================
use super::guest_callback::call_stream;
use super::guest_callback::entry_defs::EntryDefsHostAccess;
use super::guest_callback::init::InitHostAccess;
use super::guest_callback::post_commit::PostCommitHostAccess;
use super::guest_callback::validate::ValidateHostAccess;
use super::host_fn::delete_clone_cell::delete_clone_cell;
use super::host_fn::disable_clone_cell::disable_clone_cell;
use super::host_fn::enable_clone_cell::enable_clone_cell;
use super::host_fn::get_agent_activity::get_agent_activity;
use super::host_fn::HostFnApi;
use super::HostContext;
use super::ZomeCallHostAccess;
use crate::core::ribosome::error::RibosomeError;
use crate::core::ribosome::error::RibosomeResult;
use crate::core::ribosome::guest_callback::entry_defs::EntryDefsInvocation;
use crate::core::ribosome::guest_callback::entry_defs::EntryDefsResult;
use crate::core::ribosome::guest_callback::genesis_self_check::v1::GenesisSelfCheckInvocationV1;
use crate::core::ribosome::guest_callback::genesis_self_check::v1::GenesisSelfCheckResultV1;
use crate::core::ribosome::guest_callback::genesis_self_check::v2::GenesisSelfCheckInvocationV2;
use crate::core::ribosome::guest_callback::genesis_self_check::GenesisSelfCheckHostAccess;
use crate::core::ribosome::guest_callback::genesis_self_check::GenesisSelfCheckInvocation;
use crate::core::ribosome::guest_callback::genesis_self_check::GenesisSelfCheckResult;
use crate::core::ribosome::guest_callback::init::InitInvocation;
use crate::core::ribosome::guest_callback::init::InitResult;
use crate::core::ribosome::guest_callback::post_commit::PostCommitInvocation;
use crate::core::ribosome::guest_callback::validate::ValidateInvocation;
use crate::core::ribosome::guest_callback::validate::ValidateResult;
use crate::core::ribosome::guest_callback::CallStream;
use crate::core::ribosome::host_fn::agent_info::agent_info;
use crate::core::ribosome::host_fn::call::call;
use crate::core::ribosome::host_fn::call_info::call_info;
use crate::core::ribosome::host_fn::capability_claims::capability_claims;
use crate::core::ribosome::host_fn::capability_grants::capability_grants;
use crate::core::ribosome::host_fn::capability_info::capability_info;
use crate::core::ribosome::host_fn::create::create;
use crate::core::ribosome::host_fn::create_clone_cell::create_clone_cell;
use crate::core::ribosome::host_fn::create_link::create_link;
use crate::core::ribosome::host_fn::create_x25519_keypair::create_x25519_keypair;
use crate::core::ribosome::host_fn::delete::delete;
use crate::core::ribosome::host_fn::delete_link::delete_link;
use crate::core::ribosome::host_fn::dna_info_1::dna_info_1;
use crate::core::ribosome::host_fn::dna_info_2::dna_info_2;
use crate::core::ribosome::host_fn::ed_25519_x_salsa20_poly1305_decrypt::ed_25519_x_salsa20_poly1305_decrypt;
use crate::core::ribosome::host_fn::ed_25519_x_salsa20_poly1305_encrypt::ed_25519_x_salsa20_poly1305_encrypt;
use crate::core::ribosome::host_fn::emit_signal::emit_signal;
use crate::core::ribosome::host_fn::get::get;
use crate::core::ribosome::host_fn::get_details::get_details;
use crate::core::ribosome::host_fn::get_link_details::get_link_details;
use crate::core::ribosome::host_fn::get_links::get_links;
use crate::core::ribosome::host_fn::hash::hash;
use crate::core::ribosome::host_fn::must_get_action::must_get_action;
use crate::core::ribosome::host_fn::must_get_agent_activity::must_get_agent_activity;
use crate::core::ribosome::host_fn::must_get_entry::must_get_entry;
use crate::core::ribosome::host_fn::must_get_valid_record::must_get_valid_record;
use crate::core::ribosome::host_fn::query::query;
use crate::core::ribosome::host_fn::random_bytes::random_bytes;
use crate::core::ribosome::host_fn::send_remote_signal::send_remote_signal;
use crate::core::ribosome::host_fn::sign::sign;
use crate::core::ribosome::host_fn::sign_ephemeral::sign_ephemeral;
use crate::core::ribosome::host_fn::sys_time::sys_time;
use crate::core::ribosome::host_fn::trace::trace;
use crate::core::ribosome::host_fn::update::update;
use crate::core::ribosome::host_fn::verify_signature::verify_signature;
use crate::core::ribosome::host_fn::version::version;
use crate::core::ribosome::host_fn::x_25519_x_salsa20_poly1305_decrypt::x_25519_x_salsa20_poly1305_decrypt;
use crate::core::ribosome::host_fn::x_25519_x_salsa20_poly1305_encrypt::x_25519_x_salsa20_poly1305_encrypt;
use crate::core::ribosome::host_fn::x_salsa20_poly1305_decrypt::x_salsa20_poly1305_decrypt;
use crate::core::ribosome::host_fn::x_salsa20_poly1305_encrypt::x_salsa20_poly1305_encrypt;
use crate::core::ribosome::host_fn::x_salsa20_poly1305_shared_secret_create_random::x_salsa20_poly1305_shared_secret_create_random;
use crate::core::ribosome::host_fn::x_salsa20_poly1305_shared_secret_export::x_salsa20_poly1305_shared_secret_export;
use crate::core::ribosome::host_fn::x_salsa20_poly1305_shared_secret_ingest::x_salsa20_poly1305_shared_secret_ingest;
use crate::core::ribosome::host_fn::zome_info::zome_info;
use crate::core::ribosome::CallContext;
use crate::core::ribosome::GenesisSelfCheckHostAccessV1;
use crate::core::ribosome::GenesisSelfCheckHostAccessV2;
use crate::core::ribosome::Invocation;
use crate::core::ribosome::RibosomeT;
use crate::core::ribosome::ZomeCallInvocation;
use futures::FutureExt;
use ghost_actor::dependencies::must_future::MustBoxFuture;
use holochain_types::prelude::*;
use holochain_util::timed;
use holochain_wasmer_host::module::build_module as build_wasmer_module;
use holochain_wasmer_host::module::CacheKey;
use holochain_wasmer_host::module::InstanceWithStore;
use holochain_wasmer_host::module::ModuleCache;
use holochain_wasmer_host::prelude::{wasm_error, WasmError, WasmErrorInner};
use tokio_stream::StreamExt;
use wasmer::AsStoreMut;
use wasmer::Exports;
use wasmer::Function;
use wasmer::FunctionEnv;
use wasmer::FunctionEnvMut;
use wasmer::Imports;
use wasmer::Instance;
use wasmer::Module;
use wasmer::RuntimeError;
use wasmer::Store;
use wasmer::Type;

#[cfg(feature = "unstable-functions")]
use super::host_fn::get_agent_key_lineage::get_agent_key_lineage;
#[cfg(feature = "unstable-countersigning")]
use crate::core::ribosome::host_fn::accept_countersigning_preflight_request::accept_countersigning_preflight_request;
#[cfg(feature = "unstable-functions")]
use crate::core::ribosome::host_fn::block_agent::block_agent;
#[cfg(feature = "unstable-functions")]
use crate::core::ribosome::host_fn::is_same_agent::is_same_agent;
#[cfg(feature = "unstable-functions")]
use crate::core::ribosome::host_fn::schedule::schedule;
#[cfg(feature = "unstable-functions")]
use crate::core::ribosome::host_fn::sleep::sleep;
#[cfg(feature = "unstable-functions")]
use crate::core::ribosome::host_fn::unblock_agent::unblock_agent;

use crate::core::ribosome::host_fn::close_chain::close_chain;
use crate::core::ribosome::host_fn::count_links::count_links;
use crate::core::ribosome::host_fn::get_validation_receipts::get_validation_receipts;
use crate::core::ribosome::host_fn::open_chain::open_chain;
use holochain_types::zome_types::GlobalZomeTypes;
use holochain_types::zome_types::ZomeTypesError;
use holochain_wasmer_host::prelude::*;
use once_cell::sync::Lazy;
use opentelemetry_api::global::meter_with_version;
use opentelemetry_api::metrics::Counter;
use std::collections::HashMap;
use std::path::PathBuf;
use std::sync::atomic::AtomicU64;
use std::sync::Arc;

#[cfg(feature = "wasmer_sys")]
mod wasmer_sys;
#[cfg(feature = "wasmer_sys")]
use wasmer_sys::*;

#[cfg(feature = "wasmer_wamr")]
mod wasmer_wamr;
#[cfg(feature = "wasmer_wamr")]
use wasmer_wamr::*;

pub(crate) type ModuleCacheLock = parking_lot::RwLock<ModuleCache>;

/// The only RealRibosome is a Wasm ribosome.
/// note that this is cloned on every invocation so keep clones cheap!
#[derive(Clone, Debug)]
pub struct RealRibosome {
    // NOTE - Currently taking a full DnaFile here.
    //      - It would be an optimization to pre-ensure the WASM bytecode
    //      - is already in the wasm cache, and only include the DnaDef portion
    //      - here in the ribosome.
    pub dna_file: DnaFile,

    /// Entry and link types for each integrity zome.
    pub zome_types: Arc<GlobalZomeTypes>,

    /// Dependencies for every zome.
    pub zome_dependencies: Arc<HashMap<ZomeName, Vec<ZomeIndex>>>,

    pub usage_meter: Arc<Counter<u64>>,

    /// File system and in-memory cache for wasm modules.
    pub wasmer_module_cache: Option<Arc<ModuleCacheLock>>,

    #[cfg(test)]
    /// Wasm cache for Deepkey wasm in a temporary directory to be shared across all tests.
    pub shared_test_module_cache: Arc<ModuleCacheLock>,
}

type ContextMap = Lazy<Arc<Mutex<HashMap<u64, Arc<CallContext>>>>>;
// Map from a context key to a call context. Call contexts are passed to host
// fn calls for execution.
static CONTEXT_MAP: ContextMap = Lazy::new(Default::default);

// Counter used to store and look up zome call contexts, which are passed to
// host fn calls.
static CONTEXT_KEY: AtomicU64 = AtomicU64::new(0);

struct HostFnBuilder {
    store: Arc<Mutex<Store>>,
    function_env: FunctionEnv<Env>,
    ribosome_arc: Arc<RealRibosome>,
    context_key: u64,
}

impl HostFnBuilder {
    fn with_host_function<I, O>(
        &self,
        ns: &mut Exports,
        host_function_name: &str,
        host_function: fn(Arc<RealRibosome>, Arc<CallContext>, I) -> Result<O, RuntimeError>,
    ) -> &Self
    where
        I: serde::de::DeserializeOwned + std::fmt::Debug + 'static,
        O: serde::Serialize + std::fmt::Debug + 'static,
    {
        let ribosome_arc = Arc::clone(&self.ribosome_arc);
        let context_key = self.context_key;
        {
            let mut store_lock = self.store.lock();
            let mut store_mut = store_lock.as_store_mut();
            ns.insert(
                host_function_name,
                Function::new_typed_with_env(
                    &mut store_mut,
                    &self.function_env,
                    move |mut function_env_mut: FunctionEnvMut<Env>, guest_ptr: GuestPtr, len: Len| -> Result<u64, RuntimeError> {
                        let context_arc = {
                            CONTEXT_MAP
                                .lock()
                                .get(&context_key)
                                .unwrap_or_else(|| {
                                    panic!(
                                    "Context must be set before call, this is a bug. context_key: {}",
                                    &context_key,
                                )
                                })
                                .clone()
                        };
                        let (env, mut store_mut) = function_env_mut.data_and_store_mut();
                        let result = match env.consume_bytes_from_guest(&mut store_mut, guest_ptr, len) {
                            Ok(input) => host_function(Arc::clone(&ribosome_arc), context_arc, input),
                            Err(runtime_error) => Result::<_, RuntimeError>::Err(runtime_error),
                        };
                        Ok(u64::from_le_bytes(
                            env.move_data_to_guest(&mut store_mut, match result {
                                Err(runtime_error) => match runtime_error.downcast::<WasmError>() {
                                    Ok(wasm_error) => match wasm_error {
                                        WasmError {
                                            error: WasmErrorInner::HostShortCircuit(_),
                                            ..
                                        } => return Err(WasmHostError(wasm_error).into()),
                                        _ => Err(WasmHostError(wasm_error)),
                                    },
                                    Err(runtime_error) => return Err(runtime_error),
                                },
                                Ok(o) => Result::<_, WasmHostError>::Ok(o),
                            })?
                            .to_le_bytes(),
                        ))
                    },
                ),
            );
        }

        self
    }
}

impl RealRibosome {
    pub fn standard_usage_meter() -> Arc<Counter<u64>> {
        meter_with_version(
            "hc.ribosome.wasm",
            Some("0"),
            None::<&'static str>,
            Some(vec![]),
        )
        .u64_counter("hc.ribosome.wasm.usage")
        .with_description("The metered usage of a wasm ribosome.")
        .init()
        .into()
    }

    /// Create a new instance
    #[cfg_attr(feature = "instrument", tracing::instrument(skip_all))]
    pub async fn new(
        dna_file: DnaFile,
        wasmer_module_cache: Option<Arc<ModuleCacheLock>>,
    ) -> RibosomeResult<Self> {
        let mut _shared_test_module_cache: Option<PathBuf> = None;
        #[cfg(test)]
        {
            // Create this temporary directory only in tests.
            let shared_test_module_cache_dir = std::env::temp_dir().join("deepkey_wasm_cache");
            let _ = std::fs::create_dir_all(shared_test_module_cache_dir.clone());
            _shared_test_module_cache = Some(shared_test_module_cache_dir);
        }
        let mut ribosome = Self {
            dna_file,
            zome_types: Default::default(),
            zome_dependencies: Default::default(),
            usage_meter: Self::standard_usage_meter(),
            wasmer_module_cache,
            #[cfg(test)]
            shared_test_module_cache: Arc::new(ModuleCacheLock::new(ModuleCache::new(
                _shared_test_module_cache,
            ))),
        };

        // Collect the number of entry and link types
        // for each integrity zome.
        // TODO: should this be in parallel? Are they all beholden to the same lock?
        let items = futures::future::join_all(ribosome.dna_def().integrity_zomes.iter().map(
            |(name, zome)| async {
                let zome = Zome::new(name.clone(), zome.clone().erase_type());

                // Call the const functions that return the number of types.
                let num_entry_types =
                    match ribosome.get_const_fn(&zome, "__num_entry_types").await? {
                        Some(i) => {
                            let i: u8 = i
                                .try_into()
                                .map_err(|_| ZomeTypesError::EntryTypeIndexOverflow)?;
                            EntryDefIndex(i)
                        }
                        None => EntryDefIndex(0),
                    };
                let num_link_types = match ribosome.get_const_fn(&zome, "__num_link_types").await? {
                    Some(i) => {
                        let i: u8 = i
                            .try_into()
                            .map_err(|_| ZomeTypesError::LinkTypeIndexOverflow)?;
                        LinkType(i)
                    }
                    None => LinkType(0),
                };
                RibosomeResult::Ok((num_entry_types, num_link_types))
            },
        ))
        .await
        .into_iter()
        .collect::<RibosomeResult<Vec<_>>>()?;

        // Create the global zome types from the totals.
        let map = GlobalZomeTypes::from_ordered_iterator(items.into_iter());

        ribosome.zome_types = Arc::new(map?);

        // Create a map of integrity zome names to ZomeIndexes.
        let integrity_zomes: HashMap<_, _> = ribosome
            .dna_def()
            .integrity_zomes
            .iter()
            .enumerate()
            .map(|(i, (n, _))| Some((n.clone(), ZomeIndex(i.try_into().ok()?))))
            .collect::<Option<_>>()
            .ok_or(ZomeTypesError::ZomeIndexOverflow)?;

        // Collect the dependencies for each zome.
        ribosome.zome_dependencies = ribosome
            .dna_def()
            .all_zomes()
            .map(|(zome_name, def)| {
                let mut dependencies = Vec::new();

                if integrity_zomes.len() == 1 {
                    // If there's only one integrity zome we add it to this zome and are done.
                    dependencies.push(ZomeIndex(0));
                } else {
                    // Integrity zomes need to have themselves as a dependency.
                    if ribosome.dna_def().is_integrity_zome(zome_name) {
                        // Get the ZomeIndex for this zome.
                        let id = integrity_zomes.get(zome_name).copied().ok_or_else(|| {
                            ZomeTypesError::MissingDependenciesForZome(zome_name.clone())
                        })?;
                        dependencies.push(id);
                    }
                    for name in def.dependencies() {
                        // Get the ZomeIndex for this dependency.
                        let id = integrity_zomes.get(name).copied().ok_or_else(|| {
                            ZomeTypesError::MissingDependenciesForZome(zome_name.clone())
                        })?;
                        dependencies.push(id);
                    }
                }

                Ok((zome_name.clone(), dependencies))
            })
            .collect::<RibosomeResult<HashMap<_, _>>>()?
            .into();

        Ok(ribosome)
    }

    #[cfg(any(test, feature = "test_utils"))]
    pub fn empty(dna_file: DnaFile) -> Self {
        Self {
            dna_file,
            zome_types: Default::default(),
            zome_dependencies: Default::default(),
            usage_meter: Self::standard_usage_meter(),
            wasmer_module_cache: Some(Arc::new(ModuleCacheLock::new(ModuleCache::new(None)))),
            #[cfg(test)]
            shared_test_module_cache: Arc::new(ModuleCacheLock::new(ModuleCache::new(None))),
        }
    }

    #[cfg_attr(feature = "instrument", tracing::instrument(skip(self)))]
    pub async fn build_module(&self, zome_name: &ZomeName) -> RibosomeResult<Arc<Module>> {
        let wasm = self.dna_file.get_wasm_for_zome(zome_name)?.code();

        if self.wasmer_module_cache.is_some() {
            let cache_key = self.get_module_cache_key(zome_name)?;
            // When running tests, use cache folder accessible to all tests.
            #[cfg(test)]
            let cache_lock = self.shared_test_module_cache.clone();
            #[cfg(not(test))]
            let cache_lock = self.wasmer_module_cache.clone().unwrap();

            tokio::task::spawn_blocking(move || {
                let cache = timed!([1, 10, 1000], cache_lock.write());
                Ok(timed!([1, 1000, 10_000], cache.get(cache_key, &wasm))?)
            })
            .await?
        } else {
            Ok(build_wasmer_module(&wasm)?)
        }
    }

    // Create a key for module cache.
    // Format: [WasmHash] as bytes
    // watch out for cache misses in the tests that make things slooow if you change this!
    #[cfg_attr(feature = "instrument", tracing::instrument(skip_all))]
    pub fn get_module_cache_key(&self, zome_name: &ZomeName) -> Result<CacheKey, DnaError> {
        let mut key = [0; 32];
        let wasm_zome_hash = self.dna_file.dna().get_wasm_zome_hash(zome_name)?;
        let bytes = wasm_zome_hash.get_raw_32();
        key.copy_from_slice(bytes);
        Ok(key)
    }

    #[cfg_attr(feature = "instrument", tracing::instrument(skip_all))]
    pub async fn get_module_for_zome(&self, zome: &Zome<ZomeDef>) -> RibosomeResult<Arc<Module>> {
        match &zome.def {
            ZomeDef::Wasm(wasm_zome) => {
                if let Some(module) = get_prebuilt_module(wasm_zome)? {
                    Ok(module)
                } else {
                    self.build_module(zome.zome_name()).await
                }
            }
            _ => RibosomeResult::Err(RibosomeError::DnaError(DnaError::ZomeError(
                ZomeError::NonWasmZome(zome.zome_name().clone()),
            ))),
        }
    }

    #[cfg_attr(feature = "instrument", tracing::instrument(skip_all))]
    pub fn build_instance_with_store(
        &self,
        module: Arc<Module>,
        context_key: u64,
        name: &str,
    ) -> RibosomeResult<Arc<InstanceWithStore>> {
        let store = Arc::new(Mutex::new(Store::default()));
        let function_env = FunctionEnv::new(&mut store.lock().as_store_mut(), Env::default());
        let (function_env, imports) = Self::imports(self, context_key, store.clone(), function_env);
        let instance;
        {
            let mut store = store.lock();
            let mut store_mut = store.as_store_mut();
            instance = Arc::new(Instance::new(&mut store_mut, &module, &imports).map_err(
                |e| -> RuntimeError {
                    wasm_error!(WasmErrorInner::ModuleBuild(format!("{}: {}", name, e))).into()
                },
            )?);
        }

        // It is only possible to initialize the function env after the instance is created.
        {
            let mut store_lock = store.lock();
            let mut function_env_mut = function_env.into_mut(&mut store_lock);
            let (data_mut, store_mut) = function_env_mut.data_and_store_mut();
            data_mut.memory = Some(
                instance
                    .exports
                    .get_memory("memory")
                    .map_err(|e| -> RuntimeError {
                        wasm_error!(WasmErrorInner::ModuleBuild(e.to_string())).into()
                    })?
                    .clone(),
            );
            data_mut.deallocate = Some(
                instance
                    .exports
                    .get_typed_function(&store_mut, "__hc__deallocate_1")
                    .map_err(|e| -> RuntimeError {
                        wasm_error!(WasmErrorInner::ModuleBuild(e.to_string())).into()
                    })?,
            );
            data_mut.allocate = Some(
                instance
                    .exports
                    .get_typed_function(&store_mut, "__hc__allocate_1")
                    .map_err(|e| -> RuntimeError {
                        wasm_error!(WasmErrorInner::ModuleBuild(e.to_string())).into()
                    })?,
            );
        }

        RibosomeResult::Ok(Arc::new(InstanceWithStore {
            instance,
            store: store.clone(),
        }))
    }

    #[cfg_attr(feature = "instrument", tracing::instrument(skip_all))]
    fn next_context_key() -> u64 {
        CONTEXT_KEY.fetch_add(1, std::sync::atomic::Ordering::SeqCst)
    }

    pub async fn tooling_imports() -> RibosomeResult<Vec<String>> {
        let empty_dna_def = DnaDef {
            name: Default::default(),
            modifiers: DnaModifiers {
                network_seed: Default::default(),
                properties: Default::default(),
                origin_time: Timestamp(0),
                quantum_time: Default::default(),
            },
            integrity_zomes: Default::default(),
            coordinator_zomes: Default::default(),
            lineage: Default::default(),
        };
        let empty_dna_file = DnaFile::new(empty_dna_def, vec![]).await;
        let empty_ribosome = RealRibosome::new(
            empty_dna_file,
            Some(Arc::new(ModuleCacheLock::new(ModuleCache::new(None)))),
        )
        .await?;
        let context_key = RealRibosome::next_context_key();
        let mut store = Store::default();
        // We just leave this Env uninitialized as default because we never make it
        // to an instance that needs to run on this code path.
        let function_env = FunctionEnv::new(&mut store.as_store_mut(), Env::default());
        let (_function_env, imports) =
            empty_ribosome.imports(context_key, Arc::new(Mutex::new(store)), function_env);
        let mut imports: Vec<String> = imports.into_iter().map(|((_ns, name), _)| name).collect();
        imports.sort();
        Ok(imports)
    }

    fn imports(
        &self,
        context_key: u64,
        store: Arc<Mutex<Store>>,
        function_env: FunctionEnv<Env>,
    ) -> (FunctionEnv<Env>, Imports) {
        let mut imports = wasmer::imports! {};
        let mut ns = Exports::new();

        // it is important that RealRibosome and ZomeCallInvocation are cheap to clone here
        let ribosome_arc = std::sync::Arc::new((*self).clone());

        let host_fn_builder = HostFnBuilder {
            store,
            function_env,
            ribosome_arc,
            context_key,
        };

        host_fn_builder
            .with_host_function(&mut ns, "__hc__agent_info_1", agent_info)
            .with_host_function(&mut ns, "__hc__trace_1", trace)
            .with_host_function(&mut ns, "__hc__hash_1", hash)
            .with_host_function(&mut ns, "__hc__version_1", version)
            .with_host_function(&mut ns, "__hc__verify_signature_1", verify_signature)
            .with_host_function(&mut ns, "__hc__sign_1", sign)
            .with_host_function(&mut ns, "__hc__sign_ephemeral_1", sign_ephemeral)
            .with_host_function(
                &mut ns,
                "__hc__x_salsa20_poly1305_shared_secret_create_random_1",
                x_salsa20_poly1305_shared_secret_create_random,
            )
            .with_host_function(
                &mut ns,
                "__hc__x_salsa20_poly1305_shared_secret_export_1",
                x_salsa20_poly1305_shared_secret_export,
            )
            .with_host_function(
                &mut ns,
                "__hc__x_salsa20_poly1305_shared_secret_ingest_1",
                x_salsa20_poly1305_shared_secret_ingest,
            )
            .with_host_function(
                &mut ns,
                "__hc__x_salsa20_poly1305_encrypt_1",
                x_salsa20_poly1305_encrypt,
            )
            .with_host_function(
                &mut ns,
                "__hc__x_salsa20_poly1305_decrypt_1",
                x_salsa20_poly1305_decrypt,
            )
            .with_host_function(
                &mut ns,
                "__hc__create_x25519_keypair_1",
                create_x25519_keypair,
            )
            .with_host_function(
                &mut ns,
                "__hc__x_25519_x_salsa20_poly1305_encrypt_1",
                x_25519_x_salsa20_poly1305_encrypt,
            )
            .with_host_function(
                &mut ns,
                "__hc__x_25519_x_salsa20_poly1305_decrypt_1",
                x_25519_x_salsa20_poly1305_decrypt,
            )
            .with_host_function(
                &mut ns,
                "__hc__ed_25519_x_salsa20_poly1305_encrypt_1",
                ed_25519_x_salsa20_poly1305_encrypt,
            )
            .with_host_function(
                &mut ns,
                "__hc__ed_25519_x_salsa20_poly1305_decrypt_1",
                ed_25519_x_salsa20_poly1305_decrypt,
            )
            .with_host_function(&mut ns, "__hc__zome_info_1", zome_info)
            .with_host_function(&mut ns, "__hc__dna_info_1", dna_info_1)
            .with_host_function(&mut ns, "__hc__dna_info_2", dna_info_2)
            .with_host_function(&mut ns, "__hc__call_info_1", call_info)
            .with_host_function(&mut ns, "__hc__random_bytes_1", random_bytes)
            .with_host_function(&mut ns, "__hc__sys_time_1", sys_time)
            .with_host_function(&mut ns, "__hc__capability_claims_1", capability_claims)
            .with_host_function(&mut ns, "__hc__capability_grants_1", capability_grants)
            .with_host_function(&mut ns, "__hc__capability_info_1", capability_info)
            .with_host_function(&mut ns, "__hc__get_1", get)
            .with_host_function(&mut ns, "__hc__get_details_1", get_details)
            .with_host_function(&mut ns, "__hc__get_links_1", get_links)
            .with_host_function(&mut ns, "__hc__get_link_details_1", get_link_details)
            .with_host_function(&mut ns, "__hc__count_links_1", count_links)
            .with_host_function(&mut ns, "__hc__get_agent_activity_1", get_agent_activity)
            .with_host_function(&mut ns, "__hc__must_get_entry_1", must_get_entry)
            .with_host_function(&mut ns, "__hc__must_get_action_1", must_get_action)
            .with_host_function(
                &mut ns,
                "__hc__must_get_valid_record_1",
                must_get_valid_record,
            )
            .with_host_function(
                &mut ns,
                "__hc__must_get_agent_activity_1",
                must_get_agent_activity,
            )
            .with_host_function(&mut ns, "__hc__query_1", query)
            .with_host_function(&mut ns, "__hc__send_remote_signal_1", send_remote_signal)
            .with_host_function(&mut ns, "__hc__call_1", call)
            .with_host_function(&mut ns, "__hc__create_1", create)
            .with_host_function(&mut ns, "__hc__emit_signal_1", emit_signal)
            .with_host_function(&mut ns, "__hc__create_link_1", create_link)
            .with_host_function(&mut ns, "__hc__delete_link_1", delete_link)
            .with_host_function(&mut ns, "__hc__update_1", update)
            .with_host_function(&mut ns, "__hc__delete_1", delete)
            .with_host_function(&mut ns, "__hc__create_clone_cell_1", create_clone_cell)
            .with_host_function(&mut ns, "__hc__disable_clone_cell_1", disable_clone_cell)
            .with_host_function(&mut ns, "__hc__enable_clone_cell_1", enable_clone_cell)
            .with_host_function(&mut ns, "__hc__delete_clone_cell_1", delete_clone_cell)
            .with_host_function(&mut ns, "__hc__close_chain_1", close_chain)
            .with_host_function(&mut ns, "__hc__open_chain_1", open_chain)
            .with_host_function(
                &mut ns,
                "__hc__get_validation_receipts_1",
                get_validation_receipts,
            );

        #[cfg(feature = "unstable-countersigning")]
        host_fn_builder.with_host_function(
            &mut ns,
            "__hc__accept_countersigning_preflight_request_1",
            accept_countersigning_preflight_request,
        );
        #[cfg(feature = "unstable-functions")]
        host_fn_builder
            .with_host_function(
                &mut ns,
                "__hc__get_agent_key_lineage_1",
                get_agent_key_lineage,
            )
            .with_host_function(&mut ns, "__hc__is_same_agent_1", is_same_agent)
            .with_host_function(&mut ns, "__hc__block_agent_1", block_agent)
            .with_host_function(&mut ns, "__hc__schedule_1", schedule)
            .with_host_function(&mut ns, "__hc__unblock_agent_1", unblock_agent)
            // TODO deprecated, remove me
            .with_host_function(&mut ns, "__hc__sleep_1", sleep);
        imports.register_namespace("env", ns);

        (host_fn_builder.function_env, imports)
    }

    pub fn get_zome_dependencies(&self, zome_name: &ZomeName) -> RibosomeResult<&[ZomeIndex]> {
        Ok(self
            .zome_dependencies
            .get(zome_name)
            .ok_or_else(|| ZomeTypesError::MissingDependenciesForZome(zome_name.clone()))?)
    }

    pub fn call_zome_fn(
        input: ExternIO,
        zome: Zome,
        fn_name: FunctionName,
        instance_with_store: Arc<InstanceWithStore>,
    ) -> Result<ExternIO, RibosomeError> {
        let fn_name = fn_name.clone();
        let instance = instance_with_store.instance.clone();

        let mut store_lock = instance_with_store.store.lock();
        let mut store_mut = store_lock.as_store_mut();
        let result =
            holochain_wasmer_host::guest::call(&mut store_mut, instance, fn_name.as_ref(), input);
        if let Err(runtime_error) = &result {
            tracing::error!(?runtime_error, ?zome, ?fn_name);
        }

        Ok(result?)
    }

    pub fn call_const_fn(
        instance_with_store: Arc<InstanceWithStore>,
        name: &str,
    ) -> Result<Option<i32>, RibosomeError> {
        let result;
        {
            let mut store_lock = instance_with_store.store.lock();
            let mut store_mut = store_lock.as_store_mut();
            // Call the function as a native function.
            result = instance_with_store
                .instance
                .exports
                .get_typed_function::<(), i32>(&store_mut, name)
                .ok()
                .map_or(Ok(None), |func| Ok(Some(func.call(&mut store_mut)?)))
                .map_err(|e: RuntimeError| {
                    RibosomeError::WasmRuntimeError(
                        wasm_error!(WasmErrorInner::Host(format!("{}", e))).into(),
                    )
                })?;
        }
        Ok(result)
    }

    pub fn get_extern_fns_for_wasm(&self, module: Arc<Module>) -> Vec<FunctionName> {
        let mut extern_fns: Vec<FunctionName> = module
            .info()
            .exports
            .iter()
            .filter(|(name, _)| {
                name.as_str() != "__num_entry_types" && name.as_str() != "__num_link_types"
            })
            .map(|(name, _index)| FunctionName::new(name))
            .collect();
        extern_fns.sort();
        extern_fns
    }
}

/// General purpose macro which relies heavily on various impls of the form:
/// From<Vec<(ZomeName, $callback_result)>> for ValidationResult
macro_rules! do_callback {
    ( $self:ident, $access:ident, $invocation:ident, $callback_result:ty ) => {{
        use tokio_stream::StreamExt;
        let mut results: Vec<(ZomeName, $callback_result)> = Vec::new();
        // fallible iterator syntax instead of for loop
        let mut call_stream = $self.call_stream($access.into(), $invocation);
        loop {
            let (zome_name, callback_result): (ZomeName, $callback_result) = match call_stream
                .next()
                .await
            {
                Some(Ok((zome, extern_io))) => match extern_io.decode() {
                    Ok(callback_result) => (zome.into(), callback_result),
                    Err(SerializedBytesError::Deserialize(err_msg)) => {
                        // Error returned when deserialization fails due to an invalid return type
                        return Err(RibosomeError::CallbackInvalidReturnType(err_msg));
                    }
                    Err(e) => return Err(RibosomeError::WasmRuntimeError(wasm_error!(e).into())),
                },
                Some(Err((zome, RibosomeError::WasmRuntimeError(runtime_error)))) => {
                    let wasm_error: WasmError = runtime_error.downcast()?;
                    if let WasmErrorInner::Deserialize(_) = wasm_error.error {
                        // Error returned when callback called via ribosome with invalid parameters
                        return Err(RibosomeError::CallbackInvalidParameters(String::default()));
                    }

                    (
                        zome.into(),
                        <$callback_result>::try_from_wasm_error(wasm_error)
                            .map_err(|e| -> RuntimeError { WasmHostError(e).into() })?,
                    )
                }
                Some(Err((
                    _zome,
                    RibosomeError::InlineZomeError(InlineZomeError::SerializationError(
                        SerializedBytesError::Deserialize(err_msg),
                    )),
                ))) => {
                    // Error returned when callback called via zome call with invalid parameters
                    return Err(RibosomeError::CallbackInvalidParameters(err_msg));
                }
                Some(Err((_zome, other_error))) => return Err(other_error),
                None => {
                    break;
                }
            };
            // return early if we have a definitive answer, no need to keep invoking callbacks
            // if we know we are done
            if callback_result.is_definitive() {
                return Ok(vec![(zome_name, callback_result)].into());
            }
            results.push((zome_name, callback_result));
        }
        // fold all the non-definitive callbacks down into a single overall result
        Ok(results.into())
    }};
}

impl RealRibosome {
    async fn run_genesis_self_check_v1(
        &self,
        host_access: GenesisSelfCheckHostAccessV1,
        invocation: GenesisSelfCheckInvocationV1,
    ) -> RibosomeResult<GenesisSelfCheckResultV1> {
        do_callback!(self, host_access, invocation, ValidateCallbackResult)
    }

    async fn run_genesis_self_check_v2(
        &self,
        host_access: GenesisSelfCheckHostAccessV2,
        invocation: GenesisSelfCheckInvocationV2,
    ) -> RibosomeResult<GenesisSelfCheckResultV1> {
        do_callback!(self, host_access, invocation, ValidateCallbackResult)
    }

    /// call a function in a zome for an invocation if it exists
    /// if it does not exist, then return Ok(None)
    pub async fn maybe_call<I: Invocation>(
        &self,
        host_context: HostContext,
        invocation: &I,
        zome: Zome,
        fn_name: FunctionName,
    ) -> Result<Option<ExternIO>, RibosomeError> {
        let mut otel_info = vec![
            opentelemetry_api::KeyValue::new("dna", self.dna_file.dna().hash.to_string()),
            opentelemetry_api::KeyValue::new("zome", zome.zome_name().to_string()),
            opentelemetry_api::KeyValue::new("fn", fn_name.to_string()),
        ];

        if let Some(agent_pubkey) = host_context.maybe_workspace().and_then(|workspace| {
            workspace
                .source_chain()
                .as_ref()
                .map(|source_chain| source_chain.agent_pubkey().to_string())
        }) {
            otel_info.push(opentelemetry_api::KeyValue::new("agent", agent_pubkey));
        }

        let call_context = CallContext {
            zome: zome.clone(),
            function_name: fn_name.clone(),
            host_context,
            auth: invocation.auth(),
        };

        match zome.zome_def() {
            ZomeDef::Wasm(_) => {
                let module = self.get_module_for_zome(&zome).await?;
                if module.info().exports.contains_key(fn_name.as_ref()) {
                    // there is a corresponding zome fn
                    let context_key = Self::next_context_key();
                    let instance_with_store =
                        self.build_instance_with_store(module, context_key, &zome.name.0)?;
                    // add call context to map for the following call
                    {
                        CONTEXT_MAP
                            .lock()
                            .insert(context_key, Arc::new(call_context));
                    }

                    // Reset available metering points to the maximum allowed per zome call
                    reset_metering_points(instance_with_store.clone());

                    // be aware of this clone!
                    // the whole invocation is cloned!
                    // @todo - is this a problem for large payloads like entries?
                    let input = invocation.clone().host_input()?;
                    let instance_with_store_clone = instance_with_store.clone();
                    let result = tokio::task::spawn_blocking(move || {
                        Self::call_zome_fn(input, zome, fn_name, instance_with_store_clone)
                            .map(Some)
                    })
                    .await?;

                    // Get metering points consumed in zome call and save to usage_meter
                    let points_used = get_used_metering_points(instance_with_store.clone());
                    self.usage_meter.add(points_used, &otel_info);

                    // remove context from map after call
                    {
                        CONTEXT_MAP.lock().remove(&context_key);
                    }
                    result
                } else {
                    // the callback fn does not exist
                    Ok(None)
                }
            }
            ZomeDef::Inline {
                inline_zome: zome, ..
            } => {
                let input = invocation.clone().host_input()?;
                let api = HostFnApi::new(Arc::new(self.clone()), Arc::new(call_context));
                let result = zome.0.maybe_call(Box::new(api), &fn_name, input)?;
                Ok(result)
            }
        }
    }
}

impl RibosomeT for RealRibosome {
    fn dna_def(&self) -> &DnaDefHashed {
        self.dna_file.dna()
    }

    async fn zome_info(&self, zome: Zome) -> RibosomeResult<ZomeInfo> {
        // Get the dependencies for this zome.
        let zome_dependencies = self.get_zome_dependencies(zome.zome_name())?;
        // Scope the zome types to these dependencies.
        let zome_types = self.zome_types.in_scope_subset(zome_dependencies);

        Ok(ZomeInfo {
            name: zome.zome_name().clone(),
            id: self
                .zome_name_to_id(zome.zome_name())
                .expect("Failed to get ID for current zome"),
            properties: SerializedBytes::default(),
            entry_defs: {
                match self
                    .run_entry_defs(EntryDefsHostAccess, EntryDefsInvocation)
                    .await
                    .map_err(|e| -> RuntimeError {
                        wasm_error!(WasmErrorInner::Host(e.to_string())).into()
                    })? {
                    EntryDefsResult::Err(zome, error_string) => {
                        return Err(RibosomeError::WasmRuntimeError(
                            wasm_error!(WasmErrorInner::Host(format!(
                                "{}: {}",
                                zome, error_string
                            )))
                            .into(),
                        ))
                    }
                    EntryDefsResult::Defs(defs) => {
                        let vec = zome_dependencies
                            .iter()
                            .filter_map(|zome_index| {
                                self.dna_def().integrity_zomes.get(zome_index.0 as usize)
                            })
                            .flat_map(|(zome_name, _)| {
                                defs.get(zome_name).map(|e| e.0.clone()).unwrap_or_default()
                            })
                            .collect::<Vec<_>>();
                        vec.into()
                    }
                }
            },
            extern_fns: {
                match zome.zome_def() {
                    ZomeDef::Wasm(wasm_zome) => {
                        let module = if let Some(module) = get_prebuilt_module(wasm_zome)? {
                            module
                        } else {
                            tokio_helper::block_forever_on(self.build_module(zome.zome_name()))?
                        };
                        self.get_extern_fns_for_wasm(module.clone())
                    }
                    ZomeDef::Inline { inline_zome, .. } => inline_zome.0.functions(),
                }
            },
            zome_types,
        })
    }

    /// call a function in a zome for an invocation if it exists
    /// if it does not exist, then return Ok(None)
    fn maybe_call<I: Invocation + 'static>(
        &self,
        host_context: HostContext,
        invocation: &I,
        zome: &Zome,
        fn_name: &FunctionName,
    ) -> MustBoxFuture<'static, Result<Option<ExternIO>, RibosomeError>>
    where
        Self: 'static,
    {
        let this = self.clone();
        let invocation = invocation.clone();
        let zome = zome.clone();
        let fn_name = fn_name.clone();
        let f = tokio::spawn(async move {
            this.maybe_call(host_context, &invocation, zome, fn_name)
                .await
        });
        async move { f.await.unwrap() }.boxed().into()
    }

    #[cfg_attr(feature = "instrument", tracing::instrument(skip_all))]
    async fn get_const_fn(&self, zome: &Zome, name: &str) -> Result<Option<i32>, RibosomeError> {
        match zome.zome_def() {
            ZomeDef::Wasm(_) => {
                let module = self.get_module_for_zome(zome).await?;
                if module.exports().functions().any(|f| {
                    f.name() == name
                        && f.ty().params().is_empty()
                        && f.ty().results() == [Type::I32]
                }) {
                    // there is a corresponding const fn

                    // create a blank context as this is not actually used.
                    let call_context = CallContext {
                        zome: zome.clone(),
                        function_name: name.into(),
                        host_context: HostContext::EntryDefs(EntryDefsHostAccess {}),
                        auth: super::InvocationAuth::LocalCallback,
                    };

                    // create a new key for the context map.
                    let context_key = Self::next_context_key();
                    let instance_with_store =
                        self.build_instance_with_store(module, context_key, &zome.name.0)?;

                    // add call context to map for following call
                    {
                        CONTEXT_MAP
                            .lock()
                            .insert(context_key, Arc::new(call_context));
                    }

                    let name = name.to_string();
                    let result = tokio::task::spawn_blocking(move || {
                        Self::call_const_fn(instance_with_store, &name)
                    })
                    .await?;
                    // remove the blank context.
                    {
                        CONTEXT_MAP.lock().remove(&context_key);
                    }

                    result
                } else {
                    // fn does not exist in the module
                    Ok(None)
                }
            }
            ZomeDef::Inline {
                inline_zome: zome, ..
            } => Ok(zome.0.get_global(name).map(|i| i as i32)),
        }
    }

    fn call_stream<I: crate::core::ribosome::Invocation + 'static>(
        &self,
        host_context: HostContext,
        invocation: I,
    ) -> CallStream {
        let (s, _h) = call_stream(host_context, self.clone(), invocation);
        s
    }

    /// Runs the specified zome fn. Returns the cursor used by HDK,
    /// so that it can be passed on to source chain manager for transactional writes
    async fn call_zome_function(
        &self,
        host_access: ZomeCallHostAccess,
        invocation: ZomeCallInvocation,
    ) -> RibosomeResult<ZomeCallResponse> {
        // make a copy of these for the error handling below
        let zome_name = invocation.zome.zome_name().clone();
        let fn_name = invocation.fn_name.clone();

        let guest_output: ExternIO = match self
            .call_stream(host_access.into(), invocation)
            .next()
            .await
        {
            None => return Err(RibosomeError::ZomeFnNotExists(zome_name, fn_name)),
            Some(Ok((_zome, extern_io))) => extern_io,
            Some(Err((_zome, ribosome_error))) => return Err(ribosome_error),
        };

        Ok(ZomeCallResponse::Ok(guest_output))
    }

    /// Post commit works a bit different to the other callbacks.
    /// As it is dispatched from a spawned task there is nothing to handle any
    /// result, good or bad, other than to maybe log some error.
    async fn run_post_commit(
        &self,
        host_access: PostCommitHostAccess,
        invocation: PostCommitInvocation,
    ) -> RibosomeResult<()> {
        match self
            .call_stream(host_access.into(), invocation)
            .next()
            .await
        {
            Some(Ok(_)) | None => Ok(()),
            Some(Err((_zome, ribosome_error))) => Err(ribosome_error),
        }
    }

    async fn run_genesis_self_check(
        &self,
        host_access: GenesisSelfCheckHostAccess,
        invocation: GenesisSelfCheckInvocation,
    ) -> RibosomeResult<GenesisSelfCheckResult> {
        let (invocation_v1, invocation_v2): (
            GenesisSelfCheckInvocationV1,
            GenesisSelfCheckInvocationV2,
        ) = invocation.into();
        let (host_access_v1, host_access_v2): (
            GenesisSelfCheckHostAccessV1,
            GenesisSelfCheckHostAccessV2,
        ) = host_access.into();
        match self
            .run_genesis_self_check_v1(host_access_v1, invocation_v1)
            .await
        {
            Ok(GenesisSelfCheckResultV1::Valid) => Ok(self
                .run_genesis_self_check_v2(host_access_v2, invocation_v2)
                .await?
                .into()),
            result => Ok(result?.into()),
        }
    }

    async fn run_validate(
        &self,
        host_access: ValidateHostAccess,
        invocation: ValidateInvocation,
    ) -> RibosomeResult<ValidateResult> {
        do_callback!(self, host_access, invocation, ValidateCallbackResult)
    }

    async fn run_init(
        &self,
        host_access: InitHostAccess,
        invocation: InitInvocation,
    ) -> RibosomeResult<InitResult> {
        do_callback!(self, host_access, invocation, InitCallbackResult)
    }

    async fn run_entry_defs(
        &self,
        host_access: EntryDefsHostAccess,
        invocation: EntryDefsInvocation,
    ) -> RibosomeResult<EntryDefsResult> {
        do_callback!(self, host_access, invocation, EntryDefsCallbackResult)
    }

    fn zome_types(&self) -> &Arc<GlobalZomeTypes> {
        &self.zome_types
    }

    fn dna_hash(&self) -> &DnaHash {
        self.dna_file.dna_hash()
    }

    fn dna_file(&self) -> &DnaFile {
        &self.dna_file
    }

    fn get_integrity_zome(&self, zome_index: &ZomeIndex) -> Option<IntegrityZome> {
        self.dna_file
            .dna_def()
            .integrity_zomes
            .get(zome_index.0 as usize)
            .cloned()
            .map(|(name, def)| IntegrityZome::new(name, def))
    }
}

#[cfg(test)]
#[cfg(feature = "slow_tests")]
pub mod wasm_test {
    use crate::core::ribosome::real_ribosome::CONTEXT_MAP;
    use crate::core::ribosome::wasm_test::RibosomeTestFixture;
    use crate::sweettest::SweetConductor;
    use crate::sweettest::SweetConductorConfig;
    use crate::sweettest::SweetDnaFile;
    use crate::sweettest::SweetLocalRendezvous;
    use crate::wait_for_10s;
    use hdk::prelude::*;
    use holochain_nonce::fresh_nonce;
    use holochain_wasm_test_utils::TestWasm;
    use holochain_zome_types::zome_io::ZomeCallParams;
    use parking_lot::Mutex;
    use std::collections::HashMap;
    use std::sync::Arc;
    use std::time::Duration;

    #[tokio::test(flavor = "multi_thread")]
    // guard to assure that response time to zome calls and concurrent zome calls
    // is not increasing disproportionally
    async fn concurrent_zome_call_response_time_guard() {
        holochain_trace::test_run();
        let mut conductor = SweetConductor::from_config_rendezvous(
            SweetConductorConfig::rendezvous(true),
            SweetLocalRendezvous::new().await,
        )
        .await;
        let (dna, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::AgentInfo]).await;
        let app = conductor.setup_app("", [&dna]).await.unwrap();
        let zome = app.cells()[0].zome(TestWasm::AgentInfo.coordinator_zome_name());

        let conductor = Arc::new(conductor);

        // run two zome calls concurrently
        // as the first zome calls, init and wasm compilation will happen and
        // should take less than 10 seconds in debug mode
        let zome_call_1 = tokio::spawn({
            let conductor = conductor.clone();
            let zome = zome.clone();
            async move {
                tokio::select! {
                    _ = conductor.call::<_, CallInfo>(&zome, "call_info", ()) => {true}
                    _ = tokio::time::sleep(Duration::from_secs(10)) => {false}
                }
            }
        });
        let zome_call_2 = tokio::spawn({
            let conductor = conductor.clone();
            let zome = zome.clone();
            async move {
                tokio::select! {
                    _ = conductor.call::<_, CallInfo>(&zome, "call_info", ()) => {true}
                    _ = tokio::time::sleep(Duration::from_secs(10)) => {false}
                }
            }
        });
        let results: Result<Vec<bool>, _> = futures::future::join_all([zome_call_1, zome_call_2])
            .await
            .into_iter()
            .collect();
        assert_eq!(results.unwrap(), [true, true]);

        // run two rounds of two concurrent zome calls
        // having been cached, responses should take less than 15 milliseconds
        for _ in 0..2 {
            let zome_call_1 = tokio::spawn({
                let conductor = conductor.clone();
                let zome = zome.clone();
                let now = tokio::time::Instant::now();
                async move {
                    tokio::select! {
                        _ = conductor.call::<_, CallInfo>(&zome, "call_info", ()) => {now.elapsed()}
                        _ = tokio::time::sleep(Duration::from_millis(100)) => {now.elapsed()}
                    }
                }
            });
            let zome_call_2 = tokio::spawn({
                let conductor = conductor.clone();
                let zome = zome.clone();
                let now = tokio::time::Instant::now();
                async move {
                    tokio::select! {
                        _ = conductor.call::<_, CallInfo>(&zome, "call_info", ()) => {now.elapsed()}
                        _ = tokio::time::sleep(Duration::from_millis(100)) => {now.elapsed()}
                    }
                }
            });
            let results = futures::future::join_all([zome_call_1, zome_call_2])
                .await
                .into_iter()
                .collect::<Result<Vec<_>, _>>()
                .unwrap();

            // With the `wasmer_wamr` feature, we expect zome calls to take longer,
            // because the wasm is interpreted instead of compiled.
            #[cfg(feature = "wasmer_wamr")]
            let maximum_response_time_ms = Duration::from_millis(150);

            #[cfg(not(feature = "wasmer_wamr"))]
            let maximum_response_time_ms = Duration::from_millis(15);

            assert!(
                results[0] <= maximum_response_time_ms,
                "{:?} > {:?}",
                results[0],
                maximum_response_time_ms
            );
            assert!(
                results[1] <= maximum_response_time_ms,
                "{:?} > {:?}",
                results[1],
                maximum_response_time_ms
            );
        }

        // Make sure the context map does not retain items.
        // Zome `deepkey_csr`` does a post_commit call which takes some time to complete,
        // before it is removed from the context map.
        wait_for_10s!(
            CONTEXT_MAP.clone(),
            |context_map: &Arc<Mutex<HashMap<u64, Arc<_>>>>| context_map.lock().is_empty(),
            |_| true
        );
    }

    #[tokio::test(flavor = "multi_thread")]
    /// Basic checks that we can call externs internally and externally the way we want using the
    /// hdk macros rather than low level rust extern syntax.
    async fn ribosome_extern_test() {
        holochain_trace::test_run();

        let (dna_file, _, _) =
            SweetDnaFile::unique_from_test_wasms(vec![TestWasm::HdkExtern]).await;

        let mut conductor = SweetConductor::from_standard_config().await;

        let apps = conductor.setup_apps("app-", 2, &[dna_file]).await.unwrap();

        let ((alice,), (_bob,)) = apps.into_tuples();
        let alice_pubkey = alice.cell_id().agent_pubkey().clone();
        let alice = alice.zome(TestWasm::HdkExtern);

        let foo_result: String = conductor.call(&alice, "foo", ()).await;

        assert_eq!("foo", &foo_result);

        let bar_result: String = conductor.call(&alice, "bar", ()).await;

        assert_eq!("foobar", &bar_result);

        let now = Timestamp::now();
        let (nonce, expires_at) = fresh_nonce(now).unwrap();

        let infallible_result = conductor
            .raw_handle()
            .call_zome(ZomeCallParams {
                cell_id: alice.cell_id().clone(),
                zome_name: alice.name().clone(),
                fn_name: "infallible".into(),
                cap_secret: None,
                provenance: alice_pubkey.clone(),
                payload: ExternIO::encode(()).unwrap(),
                nonce,
                expires_at,
            })
            .await
            .unwrap()
            .unwrap();

        if let ZomeCallResponse::Ok(response) = infallible_result {
            assert_eq!("infallible", &response.decode::<String>().unwrap(),);
        } else {
            unreachable!();
        }
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn wasm_tooling_test() {
        holochain_trace::test_run();

        pretty_assertions::assert_eq!(
            vec![
                #[cfg(feature = "unstable-countersigning")]
                "__hc__accept_countersigning_preflight_request_1",
                "__hc__agent_info_1",
                #[cfg(feature = "unstable-functions")]
                "__hc__block_agent_1",
                "__hc__call_1",
                "__hc__call_info_1",
                "__hc__capability_claims_1",
                "__hc__capability_grants_1",
                "__hc__capability_info_1",
                "__hc__close_chain_1",
                "__hc__count_links_1",
                "__hc__create_1",
                "__hc__create_clone_cell_1",
                "__hc__create_link_1",
                "__hc__create_x25519_keypair_1",
                "__hc__delete_1",
                "__hc__delete_clone_cell_1",
                "__hc__delete_link_1",
                "__hc__disable_clone_cell_1",
                "__hc__dna_info_1",
                "__hc__dna_info_2",
                "__hc__ed_25519_x_salsa20_poly1305_decrypt_1",
                "__hc__ed_25519_x_salsa20_poly1305_encrypt_1",
                "__hc__emit_signal_1",
                "__hc__enable_clone_cell_1",
                "__hc__get_1",
                "__hc__get_agent_activity_1",
                #[cfg(feature = "unstable-functions")]
                "__hc__get_agent_key_lineage_1",
                "__hc__get_details_1",
                "__hc__get_link_details_1",
                "__hc__get_links_1",
                "__hc__get_validation_receipts_1",
                "__hc__hash_1",
                #[cfg(feature = "unstable-functions")]
                "__hc__is_same_agent_1",
                "__hc__must_get_action_1",
                "__hc__must_get_agent_activity_1",
                "__hc__must_get_entry_1",
                "__hc__must_get_valid_record_1",
                "__hc__open_chain_1",
                "__hc__query_1",
                "__hc__random_bytes_1",
                #[cfg(feature = "unstable-functions")]
                "__hc__schedule_1",
                "__hc__send_remote_signal_1",
                "__hc__sign_1",
                "__hc__sign_ephemeral_1",
                #[cfg(feature = "unstable-functions")]
                "__hc__sleep_1",
                "__hc__sys_time_1",
                "__hc__trace_1",
                #[cfg(feature = "unstable-functions")]
                "__hc__unblock_agent_1",
                "__hc__update_1",
                "__hc__verify_signature_1",
                "__hc__version_1",
                "__hc__x_25519_x_salsa20_poly1305_decrypt_1",
                "__hc__x_25519_x_salsa20_poly1305_encrypt_1",
                "__hc__x_salsa20_poly1305_decrypt_1",
                "__hc__x_salsa20_poly1305_encrypt_1",
                "__hc__x_salsa20_poly1305_shared_secret_create_random_1",
                "__hc__x_salsa20_poly1305_shared_secret_export_1",
                "__hc__x_salsa20_poly1305_shared_secret_ingest_1",
                "__hc__zome_info_1"
            ]
            .into_iter()
            .map(|s| s.to_string())
            .collect::<Vec<String>>(),
            super::RealRibosome::tooling_imports().await.unwrap()
        );
    }

    #[tokio::test(flavor = "multi_thread")]
    #[ignore]
    async fn the_incredible_halt_test() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor, alice, ..
        } = RibosomeTestFixture::new(TestWasm::TheIncredibleHalt).await;

        // This will run infinitely until our metering kicks in and traps it.
        // Also we stop it running after 10 seconds.
        let result: Result<Result<(), _>, _> = tokio::time::timeout(
            std::time::Duration::from_secs(60),
            conductor.call_fallible(&alice, "smash", ()),
        )
        .await;
        assert!(result.unwrap().is_err());

        // The same thing will happen when we commit an entry due to a loop in
        // the validation logic.
        let create_result: Result<Result<(), _>, _> = tokio::time::timeout(
            std::time::Duration::from_secs(60),
            conductor.call_fallible(&alice, "create_a_thing", ()),
        )
        .await;
        assert!(create_result.unwrap().is_err());
    }
}



================================================
File: crates/holochain/src/core/ribosome/guest_callback/entry_defs.rs
================================================
use crate::core::ribosome::FnComponents;
use crate::core::ribosome::HostContext;
use crate::core::ribosome::Invocation;
use crate::core::ribosome::InvocationAuth;
use crate::core::ribosome::ZomesToInvoke;
use derive_more::Constructor;
use holochain_serialized_bytes::prelude::*;
use holochain_types::prelude::*;
use std::collections::BTreeMap;

#[derive(Debug, Clone)]
pub struct EntryDefsInvocation;

impl EntryDefsInvocation {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Self {
        Self
    }
}

#[derive(Clone, Constructor, Debug)]
pub struct EntryDefsHostAccess;

impl From<&HostContext> for EntryDefsHostAccess {
    fn from(_: &HostContext) -> Self {
        Self
    }
}

impl From<EntryDefsHostAccess> for HostContext {
    fn from(entry_defs_host_access: EntryDefsHostAccess) -> Self {
        Self::EntryDefs(entry_defs_host_access)
    }
}

impl From<&EntryDefsHostAccess> for HostFnAccess {
    fn from(_: &EntryDefsHostAccess) -> Self {
        Self::none()
    }
}

impl Invocation for EntryDefsInvocation {
    fn zomes(&self) -> ZomesToInvoke {
        ZomesToInvoke::AllIntegrity
    }
    fn fn_components(&self) -> FnComponents {
        vec!["entry_defs".into()].into()
    }
    fn host_input(self) -> Result<ExternIO, SerializedBytesError> {
        ExternIO::encode(())
    }
    fn auth(&self) -> InvocationAuth {
        InvocationAuth::LocalCallback
    }
}

/// the aggregate result of _all_ entry defs callbacks
#[derive(PartialEq, Debug, Clone)]
pub enum EntryDefsResult {
    /// simple mapping between zome and defs
    Defs(BTreeMap<ZomeName, EntryDefs>),
    Err(ZomeName, String),
}

impl From<Vec<(ZomeName, EntryDefsCallbackResult)>> for EntryDefsResult {
    fn from(callback_results: Vec<(ZomeName, EntryDefsCallbackResult)>) -> Self {
        callback_results.into_iter().fold(
            EntryDefsResult::Defs(BTreeMap::new()),
            |acc, x| match x {
                // passing callback allows the acc to carry forward
                (zome_name, EntryDefsCallbackResult::Defs(defs)) => match acc {
                    Self::Defs(mut btreemap) => {
                        btreemap.insert(zome_name, defs);
                        Self::Defs(btreemap)
                    }
                    Self::Err(_, _) => acc,
                },
            },
        )
    }
}

#[cfg(test)]
mod test {
    use super::EntryDefsHostAccess;
    use super::EntryDefsResult;
    use crate::core::ribosome::Invocation;
    use crate::core::ribosome::ZomesToInvoke;
    use crate::fixt::EntryDefsFixturator;
    use crate::fixt::EntryDefsInvocationFixturator;
    use crate::fixt::ZomeNameFixturator;
    use holochain_types::prelude::*;
    use std::collections::BTreeMap;

    #[test]
    /// this is a non-standard fold test because the result is not so simple
    fn entry_defs_callback_result_fold() {
        let mut zome_name_fixturator = ZomeNameFixturator::new(::fixt::Unpredictable);
        let mut entry_defs_fixturator = EntryDefsFixturator::new(::fixt::Unpredictable);

        // zero defs
        assert_eq!(EntryDefsResult::Defs(BTreeMap::new()), vec![].into(),);

        // one defs
        let zome_name = zome_name_fixturator.next().unwrap();
        let entry_defs = entry_defs_fixturator.next().unwrap();
        assert_eq!(
            EntryDefsResult::Defs({
                let mut tree = BTreeMap::new();
                tree.insert(zome_name.clone(), entry_defs.clone());
                tree
            }),
            vec![(zome_name, EntryDefsCallbackResult::Defs(entry_defs)),].into(),
        );

        // two defs
        let zome_name_one = zome_name_fixturator.next().unwrap();
        let entry_defs_one = entry_defs_fixturator.next().unwrap();
        let zome_name_two = zome_name_fixturator.next().unwrap();
        let entry_defs_two = entry_defs_fixturator.next().unwrap();
        assert_eq!(
            EntryDefsResult::Defs({
                let mut tree = BTreeMap::new();
                tree.insert(zome_name_one.clone(), entry_defs_one.clone());
                tree.insert(zome_name_two.clone(), entry_defs_two.clone());
                tree
            }),
            vec![
                (zome_name_one, EntryDefsCallbackResult::Defs(entry_defs_one)),
                (zome_name_two, EntryDefsCallbackResult::Defs(entry_defs_two)),
            ]
            .into()
        );
    }

    #[test]
    fn entry_defs_host_access() {
        assert_eq!(
            HostFnAccess::from(&EntryDefsHostAccess),
            HostFnAccess::none()
        );
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn entry_defs_invocation_zomes() {
        let entry_defs_invocation = EntryDefsInvocationFixturator::new(::fixt::Unpredictable)
            .next()
            .unwrap();
        assert_eq!(ZomesToInvoke::AllIntegrity, entry_defs_invocation.zomes(),);
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn entry_defs_invocation_fn_components() {
        let entry_defs_invocation = EntryDefsInvocationFixturator::new(::fixt::Unpredictable)
            .next()
            .unwrap();

        let mut expected = vec!["entry_defs"];
        for fn_component in entry_defs_invocation.fn_components() {
            assert_eq!(fn_component, expected.pop().unwrap());
        }
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn entry_defs_invocation_host_input() {
        let entry_defs_invocation = EntryDefsInvocationFixturator::new(::fixt::Unpredictable)
            .next()
            .unwrap();

        let host_input = entry_defs_invocation.clone().host_input().unwrap();

        assert_eq!(host_input, ExternIO::encode(()).unwrap());
    }
}

#[cfg(test)]
#[cfg(feature = "slow_tests")]
mod slow_tests {
    use crate::core::ribosome::guest_callback::entry_defs::EntryDefsHostAccess;
    use crate::core::ribosome::guest_callback::entry_defs::EntryDefsResult;
    use crate::core::ribosome::wasm_test::RibosomeTestFixture;
    use crate::core::ribosome::RibosomeT;
    use crate::fixt::curve::Zomes;
    use crate::fixt::EntryDefsInvocationFixturator;
    use crate::fixt::RealRibosomeFixturator;
    use holochain_types::prelude::*;
    use holochain_wasm_test_utils::TestWasm;
    pub use holochain_zome_types::entry_def::EntryVisibility;
    use std::collections::BTreeMap;

    #[tokio::test(flavor = "multi_thread")]
    async fn test_entry_defs_unimplemented() {
        let ribosome = RealRibosomeFixturator::new(Zomes(vec![TestWasm::Foo]))
            .next()
            .unwrap();
        let entry_defs_invocation = EntryDefsInvocationFixturator::new(::fixt::Empty)
            .next()
            .unwrap();

        let result = ribosome
            .run_entry_defs(EntryDefsHostAccess, entry_defs_invocation)
            .await
            .unwrap();
        assert_eq!(result, EntryDefsResult::Defs(BTreeMap::new()),);
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn test_entry_defs_index_lookup() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor, alice, ..
        } = RibosomeTestFixture::new(TestWasm::EntryDefs).await;

        let _: () = conductor.call(&alice, "assert_indexes", ()).await;
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn test_entry_defs_implemented_defs() {
        let ribosome = RealRibosomeFixturator::new(Zomes(vec![TestWasm::EntryDefs]))
            .next()
            .unwrap();
        let entry_defs_invocation = EntryDefsInvocationFixturator::new(::fixt::Empty)
            .next()
            .unwrap();

        let result = ribosome
            .run_entry_defs(EntryDefsHostAccess, entry_defs_invocation)
            .await
            .unwrap();
        assert_eq!(
            result,
            EntryDefsResult::Defs({
                let mut tree = BTreeMap::new();
                let zome_name: ZomeName = "integrity_entry_defs".into();
                let defs: EntryDefs = vec![
                    EntryDef {
                        id: "post".into(),
                        visibility: EntryVisibility::Public,
                        required_validations: 5.into(),
                        ..Default::default()
                    },
                    EntryDef {
                        id: "comment".into(),
                        visibility: EntryVisibility::Private,
                        required_validations: 5.into(),
                        ..Default::default()
                    },
                ]
                .into();
                tree.insert(zome_name, defs);
                tree
            }),
        );
    }
}



================================================
File: crates/holochain/src/core/ribosome/guest_callback/genesis_self_check.rs
================================================
pub mod v1;
pub mod v2;

use crate::core::ribosome::guest_callback::genesis_self_check::v1::GenesisSelfCheckHostAccessV1;
use crate::core::ribosome::guest_callback::genesis_self_check::v1::GenesisSelfCheckInvocationV1;
use crate::core::ribosome::guest_callback::genesis_self_check::v1::GenesisSelfCheckResultV1;
use crate::core::ribosome::guest_callback::genesis_self_check::v2::GenesisSelfCheckHostAccessV2;
use crate::core::ribosome::guest_callback::genesis_self_check::v2::GenesisSelfCheckInvocationV2;
use crate::core::ribosome::guest_callback::genesis_self_check::v2::GenesisSelfCheckResultV2;
use derive_more::Constructor;
use holochain_serialized_bytes::prelude::*;

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, SerializedBytes)]
pub enum GenesisSelfCheckResult {
    Valid,
    Invalid(String),
}

impl From<GenesisSelfCheckResultV1> for GenesisSelfCheckResult {
    fn from(result_v1: GenesisSelfCheckResultV1) -> Self {
        match result_v1 {
            GenesisSelfCheckResultV1::Valid => Self::Valid,
            GenesisSelfCheckResultV1::Invalid(s) => Self::Invalid(s),
        }
    }
}

impl From<GenesisSelfCheckResultV2> for GenesisSelfCheckResult {
    fn from(result_v2: GenesisSelfCheckResultV2) -> Self {
        match result_v2 {
            GenesisSelfCheckResultV2::Valid => Self::Valid,
            GenesisSelfCheckResultV2::Invalid(s) => Self::Invalid(s),
        }
    }
}

#[derive(Clone, Constructor, Debug)]
pub struct GenesisSelfCheckHostAccess {
    pub host_access_1: GenesisSelfCheckHostAccessV1,
    pub host_access_2: GenesisSelfCheckHostAccessV2,
}

impl From<GenesisSelfCheckHostAccess>
    for (GenesisSelfCheckHostAccessV1, GenesisSelfCheckHostAccessV2)
{
    fn from(invocation: GenesisSelfCheckHostAccess) -> Self {
        (invocation.host_access_1, invocation.host_access_2)
    }
}

#[derive(Clone)]
pub struct GenesisSelfCheckInvocation {
    pub invocation_1: GenesisSelfCheckInvocationV1,
    pub invocation_2: GenesisSelfCheckInvocationV2,
}

impl From<GenesisSelfCheckInvocation>
    for (GenesisSelfCheckInvocationV1, GenesisSelfCheckInvocationV2)
{
    fn from(invocation: GenesisSelfCheckInvocation) -> Self {
        (invocation.invocation_1, invocation.invocation_2)
    }
}

#[cfg(test)]
#[cfg(feature = "slow_tests")]
mod slow_tests {
    use super::v1;
    use super::v2;
    use super::GenesisSelfCheckInvocation;
    use crate::core::ribosome::GenesisSelfCheckHostAccessV1;
    use crate::core::ribosome::GenesisSelfCheckHostAccessV2;
    use crate::core::ribosome::{
        guest_callback::genesis_self_check::{GenesisSelfCheckHostAccess, GenesisSelfCheckResult},
        RibosomeT,
    };
    use crate::fixt::curve::Zomes;
    use crate::fixt::RealRibosomeFixturator;
    use holochain_wasm_test_utils::TestWasm;

    fn invocation_fixture() -> GenesisSelfCheckInvocation {
        GenesisSelfCheckInvocation {
            invocation_1: v1::slow_tests::invocation_fixture(),
            invocation_2: v2::slow_tests::invocation_fixture(),
        }
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn test_genesis_self_check_unimplemented() {
        let ribosome = RealRibosomeFixturator::new(Zomes(vec![TestWasm::Foo]))
            .next()
            .unwrap();
        let invocation = invocation_fixture();

        let result = ribosome
            .run_genesis_self_check(
                GenesisSelfCheckHostAccess {
                    host_access_1: GenesisSelfCheckHostAccessV1,
                    host_access_2: GenesisSelfCheckHostAccessV2,
                },
                invocation,
            )
            .await
            .unwrap();
        assert_eq!(result, GenesisSelfCheckResult::Valid,);
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn test_genesis_self_check_implemented_invalid() {
        let ribosome = RealRibosomeFixturator::new(Zomes(vec![TestWasm::GenesisSelfCheckInvalid]))
            .next()
            .unwrap();

        let invocation = invocation_fixture();

        let result = ribosome
            .run_genesis_self_check(
                GenesisSelfCheckHostAccess {
                    host_access_1: GenesisSelfCheckHostAccessV1,
                    host_access_2: GenesisSelfCheckHostAccessV2,
                },
                invocation,
            )
            .await
            .unwrap();
        assert_eq!(
            result,
            GenesisSelfCheckResult::Invalid("esoteric edge case".into()),
        );
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn test_genesis_self_check_implemented_valid() {
        let ribosome = RealRibosomeFixturator::new(Zomes(vec![TestWasm::GenesisSelfCheckValid]))
            .next()
            .unwrap();

        let invocation = invocation_fixture();

        let result = ribosome
            .run_genesis_self_check(
                GenesisSelfCheckHostAccess {
                    host_access_1: GenesisSelfCheckHostAccessV1,
                    host_access_2: GenesisSelfCheckHostAccessV2,
                },
                invocation,
            )
            .await
            .unwrap();
        assert_eq!(result, GenesisSelfCheckResult::Valid,);
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn test_genesis_self_check_implemented_valid_legacy() {
        let ribosome =
            RealRibosomeFixturator::new(Zomes(vec![TestWasm::GenesisSelfCheckValidLegacy]))
                .next()
                .unwrap();

        let invocation = invocation_fixture();

        let result = ribosome
            .run_genesis_self_check(
                GenesisSelfCheckHostAccess {
                    host_access_1: GenesisSelfCheckHostAccessV1,
                    host_access_2: GenesisSelfCheckHostAccessV2,
                },
                invocation,
            )
            .await
            .unwrap();
        assert_eq!(result, GenesisSelfCheckResult::Valid,);
    }
}



================================================
File: crates/holochain/src/core/ribosome/guest_callback/init.rs
================================================
use crate::conductor::api::CellConductorReadHandle;
use crate::core::ribosome::FnComponents;
use crate::core::ribosome::HostContext;
use crate::core::ribosome::Invocation;
use crate::core::ribosome::InvocationAuth;
use crate::core::ribosome::ZomesToInvoke;
use derive_more::Constructor;
use holochain_conductor_services::DpkiImpl;
use holochain_keystore::MetaLairClient;
use holochain_p2p::HolochainP2pDna;
use holochain_serialized_bytes::prelude::*;
use holochain_state::host_fn_workspace::HostFnWorkspace;
use holochain_types::prelude::*;
use tokio::sync::broadcast;

#[derive(Debug, Clone)]
pub struct InitInvocation {
    pub dna_def: DnaDef,
}

impl InitInvocation {
    pub fn new(dna_def: DnaDef) -> Self {
        Self { dna_def }
    }
}

#[derive(Clone, Constructor)]
pub struct InitHostAccess {
    pub workspace: HostFnWorkspace,
    pub keystore: MetaLairClient,
    pub dpki: Option<DpkiImpl>,
    pub network: HolochainP2pDna,
    pub signal_tx: broadcast::Sender<Signal>,
    pub call_zome_handle: CellConductorReadHandle,
}

impl std::fmt::Debug for InitHostAccess {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("InitHostAccess").finish()
    }
}

impl From<InitHostAccess> for HostContext {
    fn from(init_host_access: InitHostAccess) -> Self {
        Self::Init(init_host_access)
    }
}

impl From<&InitHostAccess> for HostFnAccess {
    fn from(_: &InitHostAccess) -> Self {
        Self::all()
    }
}

impl Invocation for InitInvocation {
    fn zomes(&self) -> ZomesToInvoke {
        ZomesToInvoke::All
    }
    fn fn_components(&self) -> FnComponents {
        vec!["init".into()].into()
    }
    fn host_input(self) -> Result<ExternIO, SerializedBytesError> {
        ExternIO::encode(())
    }
    fn auth(&self) -> InvocationAuth {
        InvocationAuth::LocalCallback
    }
}

impl TryFrom<InitInvocation> for ExternIO {
    type Error = SerializedBytesError;
    fn try_from(_: InitInvocation) -> Result<Self, Self::Error> {
        Self::encode(())
    }
}

/// the aggregate result of _all_ init callbacks
#[derive(PartialEq, Debug)]
pub enum InitResult {
    /// all init callbacks passed
    Pass,
    /// some init failed
    /// ZomeName is the first zome that failed to init
    /// String is a human-readable error string giving the reason for failure
    Fail(ZomeName, String),
    /// no init failed but some zome has unresolved dependencies
    /// ZomeName is the first zome that has unresolved dependencies
    /// `Vec<EntryHash>` is the list of all missing dependency addresses
    UnresolvedDependencies(ZomeName, UnresolvedDependencies),
}

impl From<Vec<(ZomeName, InitCallbackResult)>> for InitResult {
    fn from(callback_results: Vec<(ZomeName, InitCallbackResult)>) -> Self {
        callback_results
            .into_iter()
            .fold(Self::Pass, |acc, (zome_name, x)| match x {
                // fail overrides everything
                InitCallbackResult::Fail(fail_string) => Self::Fail(zome_name, fail_string),
                // unresolved deps overrides pass but not fail
                InitCallbackResult::UnresolvedDependencies(ud) => match acc {
                    Self::Fail(_, _) => acc,
                    _ => Self::UnresolvedDependencies(zome_name, ud),
                },
                // passing callback allows the acc to carry forward
                InitCallbackResult::Pass => acc,
            })
    }
}

#[cfg(test)]
mod test {
    use super::InitResult;
    use crate::core::ribosome::Invocation;
    use crate::core::ribosome::ZomesToInvoke;
    use crate::fixt::InitHostAccessFixturator;
    use crate::fixt::InitInvocationFixturator;
    use crate::fixt::ZomeNameFixturator;
    use ::fixt::prelude::*;
    use holochain_types::prelude::*;

    #[test]
    fn init_callback_result_fold() {
        let mut rng = ::fixt::rng();

        let result_pass = || InitResult::Pass;
        let result_ud = || {
            InitResult::UnresolvedDependencies(
                ZomeNameFixturator::new(::fixt::Predictable).next().unwrap(),
                UnresolvedDependencies::Hashes(vec![]),
            )
        };
        let result_fail = || {
            InitResult::Fail(
                ZomeNameFixturator::new(::fixt::Predictable).next().unwrap(),
                "".into(),
            )
        };

        let cb_pass = || {
            (
                ZomeNameFixturator::new(::fixt::Predictable).next().unwrap(),
                InitCallbackResult::Pass,
            )
        };
        let cb_ud = || {
            (
                ZomeNameFixturator::new(::fixt::Predictable).next().unwrap(),
                InitCallbackResult::UnresolvedDependencies(UnresolvedDependencies::Hashes(vec![])),
            )
        };
        let cb_fail = || {
            (
                ZomeNameFixturator::new(::fixt::Predictable).next().unwrap(),
                InitCallbackResult::Fail("".into()),
            )
        };

        for (mut results, expected) in vec![
            (vec![], result_pass()),
            (vec![cb_pass()], result_pass()),
            (vec![cb_fail()], result_fail()),
            (vec![cb_ud()], result_ud()),
            (vec![cb_fail(), cb_pass()], result_fail()),
            (vec![cb_fail(), cb_ud()], result_fail()),
            (vec![cb_pass(), cb_ud()], result_ud()),
            (vec![cb_pass(), cb_fail(), cb_ud()], result_fail()),
        ] {
            // order of the results should not change the final result
            results.shuffle(&mut rng);

            // number of times a callback result appears should not change the final result
            let number_of_extras = rng.gen_range(0..5);
            for _ in 0..number_of_extras {
                let maybe_extra = results.choose(&mut rng).cloned();
                if let Some(extra) = maybe_extra {
                    results.push(extra);
                }
            }

            assert_eq!(expected, results.into(),);
        }
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn init_access() {
        let init_host_access = InitHostAccessFixturator::new(::fixt::Unpredictable)
            .next()
            .unwrap();
        assert_eq!(HostFnAccess::from(&init_host_access), HostFnAccess::all(),);
    }

    #[test]
    fn init_invocation_zomes() {
        let init_invocation = InitInvocationFixturator::new(::fixt::Unpredictable)
            .next()
            .unwrap();
        assert_eq!(ZomesToInvoke::All, init_invocation.zomes(),);
    }

    #[test]
    fn init_invocation_fn_components() {
        let init_invocation = InitInvocationFixturator::new(::fixt::Unpredictable)
            .next()
            .unwrap();

        let mut expected = vec!["init"];
        for fn_component in init_invocation.fn_components() {
            assert_eq!(fn_component, expected.pop().unwrap());
        }
    }

    #[test]
    fn init_invocation_host_input() {
        let init_invocation = InitInvocationFixturator::new(::fixt::Unpredictable)
            .next()
            .unwrap();

        let host_input = init_invocation.clone().host_input().unwrap();

        assert_eq!(host_input, ExternIO::encode(()).unwrap(),);
    }
}

#[cfg(test)]
#[cfg(feature = "slow_tests")]
mod slow_tests {
    use super::InitResult;
    use crate::conductor::api::error::ConductorApiError;
    use crate::conductor::api::error::ConductorApiResult;
    use crate::conductor::CellError;
    use crate::core::ribosome::guest_callback::ValidateCallbackResult;
    use crate::core::ribosome::RibosomeError;
    use crate::core::ribosome::RibosomeT;
    use crate::core::workflow::WorkflowError;
    use crate::fixt::curve::Zomes;
    use crate::fixt::InitHostAccessFixturator;
    use crate::fixt::InitInvocationFixturator;
    use crate::fixt::RealRibosomeFixturator;
    use crate::sweettest::SweetConductor;
    use crate::sweettest::SweetDnaFile;
    use crate::sweettest::SweetZome;
    use crate::test_utils::host_fn_caller::Post;
    use ::fixt::prelude::*;
    use assert2::{assert, let_assert};
    use holo_hash::ActionHash;
    use holochain_types::app::DisableCloneCellPayload;
    use holochain_types::inline_zome::InlineZomeSet;
    use holochain_types::prelude::CreateCloneCellPayload;
    use holochain_wasm_test_utils::TestWasm;
    use holochain_zome_types::clone::CloneCellId;
    use holochain_zome_types::prelude::*;
    use std::sync::Arc;
    use std::time::Duration;

    #[tokio::test(flavor = "multi_thread")]
    async fn test_init_unimplemented() {
        let ribosome = RealRibosomeFixturator::new(Zomes(vec![TestWasm::Crud]))
            .next()
            .unwrap();
        let mut init_invocation = InitInvocationFixturator::new(::fixt::Empty).next().unwrap();
        init_invocation.dna_def = ribosome.dna_file.dna_def().clone();

        let host_access = fixt!(InitHostAccess);
        let result = ribosome
            .run_init(host_access, init_invocation)
            .await
            .unwrap();
        assert_eq!(result, InitResult::Pass,);
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn test_init_implemented_pass() {
        let ribosome = RealRibosomeFixturator::new(Zomes(vec![TestWasm::InitPass]))
            .next()
            .unwrap();
        let mut init_invocation = InitInvocationFixturator::new(::fixt::Empty).next().unwrap();
        init_invocation.dna_def = ribosome.dna_file.dna_def().clone();

        let host_access = fixt!(InitHostAccess);
        let result = ribosome
            .run_init(host_access, init_invocation)
            .await
            .unwrap();
        assert_eq!(result, InitResult::Pass,);
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn test_init_implemented_fail() {
        let ribosome = RealRibosomeFixturator::new(Zomes(vec![TestWasm::InitFail]))
            .next()
            .unwrap();
        let mut init_invocation = InitInvocationFixturator::new(::fixt::Empty).next().unwrap();
        init_invocation.dna_def = ribosome.dna_file.dna_def().clone();

        let host_access = fixt!(InitHostAccess);
        let result = ribosome
            .run_init(host_access, init_invocation)
            .await
            .unwrap();
        assert_eq!(
            result,
            InitResult::Fail(TestWasm::InitFail.into(), "because i said so".into()),
        );
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn test_init_multi_implemented_fail() {
        let ribosome =
            RealRibosomeFixturator::new(Zomes(vec![TestWasm::InitPass, TestWasm::InitFail]))
                .next()
                .unwrap();
        let mut init_invocation = InitInvocationFixturator::new(::fixt::Empty).next().unwrap();
        init_invocation.dna_def = ribosome.dna_file.dna_def().clone();

        let host_access = fixt!(InitHostAccess);
        let result = ribosome
            .run_init(host_access, init_invocation)
            .await
            .unwrap();
        assert_eq!(
            result,
            InitResult::Fail(TestWasm::InitFail.into(), "because i said so".into()),
        );
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn test_init_implemented_invalid_return() {
        let unit_entry_def = EntryDef::default_from_id("unit");
        let zome = InlineZomeSet::new_unique_single(
            "integrity",
            "coordinator",
            vec![unit_entry_def.clone()],
            0,
        )
        .function("integrity", "validate", |_api, _op: Op| {
            Ok(ValidateCallbackResult::Valid)
        })
        .function("coordinator", "init", |_api, ()| Ok(()))
        .function("coordinator", "create", move |api, ()| {
            let entry = Entry::app(().try_into().unwrap()).unwrap();
            let hash = api.create(CreateInput::new(
                InlineZomeSet::get_entry_location(&api, EntryDefIndex(0)),
                EntryVisibility::Public,
                entry,
                ChainTopOrdering::default(),
            ))?;
            Ok(hash)
        });

        let dnas = [SweetDnaFile::unique_from_inline_zomes(zome).await.0];
        let mut conductor = SweetConductor::from_standard_config().await;
        let app = conductor.setup_app("app", &dnas).await.unwrap();
        let conductor = Arc::new(conductor);
        let (cell,) = app.into_tuple();

        let err = conductor
            .call_fallible::<_, ()>(&cell.zome("coordinator"), "create", ())
            .await
            .unwrap_err();

        let_assert!(ConductorApiError::CellError(CellError::WorkflowError(workflow_err)) = err);

        let_assert!(
            WorkflowError::RibosomeError(RibosomeError::CallbackInvalidReturnType(err_msg)) =
                *workflow_err
        );

        assert_eq!(
            err_msg,
            "invalid type: unit value, expected variant identifier"
        );
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn test_init_implemented_invalid_params() {
        let ribosome = RealRibosomeFixturator::new(Zomes(vec![TestWasm::InitInvalidParams]))
            .next()
            .unwrap();
        let mut init_invocation = InitInvocationFixturator::new(::fixt::Empty).next().unwrap();
        init_invocation.dna_def = ribosome.dna_file.dna_def().clone();

        let host_access = fixt!(InitHostAccess);
        let err = ribosome
            .run_init(host_access, init_invocation)
            .await
            .unwrap_err();

        let_assert!(RibosomeError::CallbackInvalidParameters(err_msg) = err);
        assert!(err_msg == String::default());
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn conductor_will_not_accept_zome_calls_before_the_network_is_initialised() {
        let (dna_file, _, _) = SweetDnaFile::from_test_wasms(
            random_network_seed(),
            vec![TestWasm::Create],
            SerializedBytes::default(),
        )
        .await;

        let mut conductor = SweetConductor::from_standard_config().await;

        let app = conductor.setup_app("app", [&dna_file]).await.unwrap();

        let cloned = conductor
            .create_clone_cell(
                app.installed_app_id(),
                CreateCloneCellPayload {
                    role_name: dna_file.dna_hash().to_string().clone(),
                    modifiers: DnaModifiersOpt::none()
                        .with_network_seed("anything else".to_string()),
                    membrane_proof: None,
                    name: Some("cloned".to_string()),
                },
            )
            .await
            .unwrap();

        let enable_or_disable_payload = DisableCloneCellPayload {
            clone_cell_id: CloneCellId::CloneId(cloned.clone_id.clone()),
        };
        conductor
            .disable_clone_cell(app.installed_app_id(), &enable_or_disable_payload)
            .await
            .unwrap();

        let zome: SweetZome = SweetZome::new(
            cloned.cell_id.clone(),
            TestWasm::Create.coordinator_zome_name(),
        );

        // Run the cell enable in parallel. If we wait for it then we shouldn't see the error we're looking for
        let conductor_handle = conductor.raw_handle().clone();
        let payload = enable_or_disable_payload.clone();
        tokio::spawn(async move {
            conductor_handle
                .enable_clone_cell(app.installed_app_id(), &payload)
                .await
                .unwrap();
        });

        let mut had_successful_zome_call = false;
        for _ in 0..30 {
            let create_post_result: ConductorApiResult<ActionHash> = conductor
                .call_fallible(&zome, "create_post", Post("clone message".to_string()))
                .await;

            match create_post_result {
                Err(crate::conductor::api::error::ConductorApiError::ConductorError(
                    crate::conductor::error::ConductorError::CellDisabled(_),
                )) => {
                    // Expected errors
                }
                Ok(_) => {
                    had_successful_zome_call = true;

                    // Stop trying after the first successful zome call
                    break;
                }
                Err(e) => {
                    panic!("Other types of error are not expected {:?}", e);
                }
            }

            tokio::time::sleep(Duration::from_millis(100)).await;
        }

        assert!(
            had_successful_zome_call,
            "Should have seen a clone cell join the network and allow calls"
        );
    }
}



================================================
File: crates/holochain/src/core/ribosome/guest_callback/post_commit.rs
================================================
use std::sync::Arc;

use crate::conductor::ConductorHandle;
use crate::core::ribosome::FnComponents;
use crate::core::ribosome::HostContext;
use crate::core::ribosome::Invocation;
use crate::core::ribosome::InvocationAuth;
use crate::core::ribosome::ZomesToInvoke;
use derive_more::Constructor;
use holochain_keystore::MetaLairClient;
use holochain_p2p::HolochainP2pDna;
use holochain_serialized_bytes::prelude::*;
use holochain_state::host_fn_workspace::HostFnWorkspace;
use holochain_state::host_fn_workspace::SourceChainWorkspace;
use holochain_types::prelude::*;
use tokio::sync::broadcast;

pub const POST_COMMIT_CHANNEL_BOUND: usize = 100;
pub const POST_COMMIT_CONCURRENT_LIMIT: usize = 5;

#[derive(Clone)]
pub struct PostCommitInvocation {
    zome: CoordinatorZome,
    actions: Vec<SignedActionHashed>,
}

impl PostCommitInvocation {
    pub fn new(zome: CoordinatorZome, actions: Vec<SignedActionHashed>) -> Self {
        Self { zome, actions }
    }
}

#[derive(Clone, Constructor)]
pub struct PostCommitHostAccess {
    pub workspace: HostFnWorkspace,
    pub keystore: MetaLairClient,
    pub network: HolochainP2pDna,
    pub signal_tx: broadcast::Sender<Signal>,
}

impl std::fmt::Debug for PostCommitHostAccess {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("PostCommitHostAccess").finish()
    }
}

impl From<PostCommitHostAccess> for HostContext {
    fn from(post_commit_host_access: PostCommitHostAccess) -> Self {
        Self::PostCommit(post_commit_host_access)
    }
}

impl From<&PostCommitHostAccess> for HostFnAccess {
    fn from(_: &PostCommitHostAccess) -> Self {
        let mut access = Self::all();
        // Post commit happens after all workspace writes are complete.
        // Writing more to the workspace becomes circular.
        // If you need to trigger some more writes, try a `call_remote` back
        // into the current cell.
        access.write_workspace = Permission::Deny;
        access
    }
}

impl Invocation for PostCommitInvocation {
    fn zomes(&self) -> ZomesToInvoke {
        ZomesToInvoke::OneCoordinator(self.zome.to_owned())
    }
    fn fn_components(&self) -> FnComponents {
        vec!["post_commit".into()].into()
    }
    fn host_input(self) -> Result<ExternIO, SerializedBytesError> {
        ExternIO::encode(self.actions)
    }
    fn auth(&self) -> InvocationAuth {
        InvocationAuth::LocalCallback
    }
}

impl TryFrom<PostCommitInvocation> for ExternIO {
    type Error = SerializedBytesError;
    fn try_from(post_commit_invocation: PostCommitInvocation) -> Result<Self, Self::Error> {
        ExternIO::encode(&post_commit_invocation.actions)
    }
}

pub async fn send_post_commit(
    conductor_handle: ConductorHandle,
    workspace: SourceChainWorkspace,
    network: HolochainP2pDna,
    keystore: MetaLairClient,
    actions: Vec<SignedActionHashed>,
    zomes: Vec<CoordinatorZome>,
    signal_tx: broadcast::Sender<Signal>,
) -> Result<(), tokio::sync::mpsc::error::SendError<()>> {
    let cell_id = workspace.source_chain().cell_id();

    for zome in zomes {
        conductor_handle
            .post_commit_permit()
            .await?
            .send(PostCommitArgs {
                host_access: PostCommitHostAccess {
                    workspace: workspace.clone().into(),
                    keystore: keystore.clone(),
                    network: network.clone(),
                    signal_tx: signal_tx.clone(),
                },
                invocation: PostCommitInvocation::new(zome, actions.clone()),
                cell_id: cell_id.clone(),
            });
    }
    Ok(())
}

#[derive(Clone)]
pub struct PostCommitArgs {
    pub host_access: PostCommitHostAccess,
    pub invocation: PostCommitInvocation,
    pub cell_id: Arc<CellId>,
}

#[cfg(test)]
mod test {
    use crate::core::ribosome::Invocation;
    use crate::core::ribosome::ZomesToInvoke;
    use crate::fixt::PostCommitHostAccessFixturator;
    use crate::fixt::PostCommitInvocationFixturator;
    use holo_hash::fixt::ActionHashVecFixturator;
    use holochain_types::prelude::*;

    #[tokio::test(flavor = "multi_thread")]
    async fn post_commit_invocation_access() {
        let post_commit_host_access = PostCommitHostAccessFixturator::new(::fixt::Unpredictable)
            .next()
            .unwrap();
        let mut expected = HostFnAccess::all();
        expected.write_workspace = Permission::Deny;
        assert_eq!(HostFnAccess::from(&post_commit_host_access), expected);
    }

    #[test]
    fn post_commit_invocation_zomes() {
        let post_commit_invocation = PostCommitInvocationFixturator::new(::fixt::Unpredictable)
            .next()
            .unwrap();
        let zome = post_commit_invocation.zome.clone();
        assert_eq!(
            ZomesToInvoke::OneCoordinator(zome),
            post_commit_invocation.zomes(),
        );
    }

    #[test]
    fn post_commit_invocation_fn_components() {
        let post_commit_invocation = PostCommitInvocationFixturator::new(::fixt::Unpredictable)
            .next()
            .unwrap();

        let mut expected = vec!["post_commit"];
        for fn_component in post_commit_invocation.fn_components() {
            assert_eq!(fn_component, expected.pop().unwrap());
        }
    }

    #[test]
    fn post_commit_invocation_host_input() {
        let post_commit_invocation = PostCommitInvocationFixturator::new(::fixt::Empty)
            .next()
            .unwrap();

        let host_input = post_commit_invocation.clone().host_input().unwrap();

        assert_eq!(
            host_input,
            ExternIO::encode(ActionHashVecFixturator::new(::fixt::Empty).next().unwrap()).unwrap(),
        );
    }
}

#[cfg(test)]
#[cfg(feature = "slow_tests")]
mod slow_tests {
    use crate::core::ribosome::wasm_test::RibosomeTestFixture;
    use crate::core::ribosome::RibosomeT;
    use crate::fixt::curve::Zomes;
    use crate::fixt::PostCommitHostAccessFixturator;
    use crate::fixt::PostCommitInvocationFixturator;
    use crate::fixt::RealRibosomeFixturator;
    use hdk::prelude::*;
    use holochain_wasm_test_utils::TestWasm;

    #[tokio::test(flavor = "multi_thread")]
    async fn test_post_commit_unimplemented() {
        let host_access = PostCommitHostAccessFixturator::new(::fixt::Unpredictable)
            .next()
            .unwrap();
        let ribosome = RealRibosomeFixturator::new(Zomes(vec![TestWasm::Foo]))
            .next()
            .unwrap();
        let mut post_commit_invocation = PostCommitInvocationFixturator::new(::fixt::Empty)
            .next()
            .unwrap();
        post_commit_invocation.zome = CoordinatorZome::from(TestWasm::Foo);

        ribosome
            .run_post_commit(host_access, post_commit_invocation)
            .await
            .unwrap();
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn test_post_commit_implemented_success() {
        let host_access = PostCommitHostAccessFixturator::new(::fixt::Unpredictable)
            .next()
            .unwrap();
        let ribosome = RealRibosomeFixturator::new(Zomes(vec![TestWasm::PostCommitSuccess]))
            .next()
            .unwrap();
        let mut post_commit_invocation = PostCommitInvocationFixturator::new(::fixt::Empty)
            .next()
            .unwrap();
        post_commit_invocation.zome = CoordinatorZome::from(TestWasm::PostCommitSuccess);

        ribosome
            .run_post_commit(host_access, post_commit_invocation)
            .await
            .unwrap();
    }

    #[tokio::test(flavor = "multi_thread")]
    #[ignore = "flakey. Sometimes fails the second last assert with 3 instead of 5"]
    #[cfg(feature = "test_utils")]
    async fn post_commit_test_volley() -> anyhow::Result<()> {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor,
            alice,
            bob,
            bob_pubkey,
            ..
        } = RibosomeTestFixture::new(TestWasm::PostCommitVolley).await;

        let _set_access: () = conductor.call::<_, ()>(&alice, "set_access", ()).await;

        let _set_access: () = conductor.call::<_, ()>(&bob, "set_access", ()).await;

        let _ping: ActionHash = conductor.call(&alice, "ping", bob_pubkey).await;

        tokio::time::sleep(std::time::Duration::from_millis(600)).await;

        let alice_query: Vec<Record> = conductor.call(&alice, "query", ()).await;

        assert_eq!(alice_query.len(), 5);

        let bob_query: Vec<Record> = conductor.call(&bob, "query", ()).await;

        assert_eq!(bob_query.len(), 4);

        Ok(())
    }
}



================================================
File: crates/holochain/src/core/ribosome/guest_callback/validate.rs
================================================
use crate::conductor::api::DpkiApi;
use crate::core::ribosome::FnComponents;
use crate::core::ribosome::HostContext;
use crate::core::ribosome::Invocation;
use crate::core::ribosome::InvocationAuth;
use crate::core::ribosome::ZomesToInvoke;
use derive_more::Constructor;
use holochain_p2p::GenericNetwork;
use holochain_serialized_bytes::prelude::*;
use holochain_state::host_fn_workspace::HostFnWorkspaceRead;
use holochain_types::prelude::*;
use holochain_zome_types::op::Op;
use std::sync::Arc;

#[derive(Clone, Debug)]
/// An invocation of the validate callback function.
pub struct ValidateInvocation {
    /// The zomes this invocation will invoke.
    zomes_to_invoke: ZomesToInvoke,
    /// The serialized arguments to the callback function.
    data: Arc<ExternIO>,
}

impl ValidateInvocation {
    pub fn new(zomes_to_invoke: ZomesToInvoke, data: &Op) -> Result<Self, SerializedBytesError> {
        let data = Arc::new(ExternIO::encode(data)?);
        Ok(Self {
            zomes_to_invoke,
            data,
        })
    }
}

#[derive(Clone, Constructor)]
pub struct ValidateHostAccess {
    pub workspace: HostFnWorkspaceRead,
    pub network: GenericNetwork,
    pub dpki: DpkiApi,
    pub is_inline: bool,
}

impl std::fmt::Debug for ValidateHostAccess {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ValidateHostAccess").finish()
    }
}

impl From<ValidateHostAccess> for HostContext {
    fn from(validate_host_access: ValidateHostAccess) -> Self {
        Self::Validate(validate_host_access)
    }
}

impl From<&ValidateHostAccess> for HostFnAccess {
    fn from(_: &ValidateHostAccess) -> Self {
        let mut access = Self::none();
        access.read_workspace_deterministic = Permission::Allow;
        access.keystore_deterministic = Permission::Allow;
        access.bindings_deterministic = Permission::Allow;
        access
    }
}

impl Invocation for ValidateInvocation {
    fn zomes(&self) -> ZomesToInvoke {
        self.zomes_to_invoke.clone()
    }
    fn fn_components(&self) -> FnComponents {
        vec!["validate".to_string()].into()
    }
    fn host_input(self) -> Result<ExternIO, SerializedBytesError> {
        // No option here but to clone the actual data as it's passed
        // into the host now anyway.
        Ok((*self.data).clone())
    }
    fn auth(&self) -> InvocationAuth {
        InvocationAuth::LocalCallback
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, SerializedBytes)]
pub enum ValidateResult {
    Valid,
    Invalid(String),
    /// subconscious needs to map this to either pending or abandoned based on context that the
    /// wasm can't possibly have
    UnresolvedDependencies(UnresolvedDependencies),
}

impl From<Vec<(ZomeName, ValidateCallbackResult)>> for ValidateResult {
    /// This function is called after multiple app validation callbacks
    /// have been run by a Ribosome and it is necessary to return one
    /// decisive result to the host, even if that "decisive" result
    /// is the UnresolvedDependencies variant.
    /// It drops the irrelevant zome names and falls back to the conversion from
    /// a `Vec<ValidateCallbackResults>` -> ValidateResult
    fn from(a: Vec<(ZomeName, ValidateCallbackResult)>) -> Self {
        a.into_iter().map(|(_, v)| v).collect::<Vec<_>>().into()
    }
}

/// if any ValidateCallbackResult is Invalid, then ValidateResult::Invalid
/// If none are Invalid and there is an UnresolvedDependencies, then ValidateResult::UnresolvedDependencies
/// If all ValidateCallbackResult are Valid, then ValidateResult::Valid
impl From<Vec<ValidateCallbackResult>> for ValidateResult {
    fn from(callback_results: Vec<ValidateCallbackResult>) -> Self {
        callback_results
            .into_iter()
            .fold(Self::Valid, |acc, x| match x {
                ValidateCallbackResult::Invalid(i) => Self::Invalid(i),
                ValidateCallbackResult::UnresolvedDependencies(ud) => match acc {
                    Self::Invalid(_) => acc,
                    _ => Self::UnresolvedDependencies(ud),
                },
                ValidateCallbackResult::Valid => acc,
            })
    }
}

#[cfg(test)]
mod test {
    use super::ValidateInvocation;
    use super::ValidateResult;
    use crate::core::ribosome::Invocation;
    use crate::core::ribosome::ZomesToInvoke;
    use crate::fixt::ValidateHostAccessFixturator;
    use ::fixt::prelude::*;
    use holochain_types::prelude::*;
    use holochain_zome_types::op::Op;
    use rand::seq::SliceRandom;

    #[tokio::test(flavor = "multi_thread")]
    async fn validate_callback_result_fold() {
        let mut rng = ::fixt::rng();

        let result_valid = || ValidateResult::Valid;
        let result_ud =
            || ValidateResult::UnresolvedDependencies(UnresolvedDependencies::Hashes(vec![]));
        let result_invalid = || ValidateResult::Invalid("".into());

        let cb_valid = || ValidateCallbackResult::Valid;
        let cb_ud = || {
            ValidateCallbackResult::UnresolvedDependencies(UnresolvedDependencies::Hashes(vec![]))
        };
        let cb_invalid = || ValidateCallbackResult::Invalid("".into());

        for (mut results, expected) in vec![
            (vec![], result_valid()),
            (vec![cb_valid()], result_valid()),
            (vec![cb_invalid()], result_invalid()),
            (vec![cb_ud()], result_ud()),
            (vec![cb_invalid(), cb_valid()], result_invalid()),
            (vec![cb_invalid(), cb_ud()], result_invalid()),
            (vec![cb_valid(), cb_ud()], result_ud()),
            (vec![cb_valid(), cb_ud(), cb_invalid()], result_invalid()),
        ] {
            // order of the results should not change the final result
            results.shuffle(&mut rng);

            // number of times a callback result appears should not change the final result
            let number_of_extras = rng.gen_range(0..5);
            for _ in 0..number_of_extras {
                let maybe_extra = results.choose(&mut rng).cloned();
                if let Some(extra) = maybe_extra {
                    results.push(extra);
                };
            }

            assert_eq!(expected, results.into(),);
        }
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn validate_invocation_allow_side_effects() {
        let validate_host_access = ValidateHostAccessFixturator::new(::fixt::Unpredictable)
            .next()
            .unwrap();
        let mut access = HostFnAccess::none();
        access.read_workspace_deterministic = Permission::Allow;
        access.keystore_deterministic = Permission::Allow;
        access.bindings_deterministic = Permission::Allow;
        assert_eq!(HostFnAccess::from(&validate_host_access), access);
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn validate_invocation_zomes() {
        let validate_invocation = ValidateInvocation::new(
            ZomesToInvoke::All,
            &Op::RegisterAgentActivity(RegisterAgentActivity {
                action: SignedActionHashed::new_unchecked(
                    Action::CreateLink(fixt!(CreateLink)),
                    fixt!(Signature),
                ),
                cached_entry: None,
            }),
        )
        .unwrap();
        let zomes_to_invoke = validate_invocation.zomes_to_invoke.clone();
        assert_eq!(zomes_to_invoke, validate_invocation.zomes(),);
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn validate_invocation_fn_components() {
        let validate_invocation = ValidateInvocation::new(
            ZomesToInvoke::All,
            &Op::RegisterAgentActivity(RegisterAgentActivity {
                action: SignedActionHashed::new_unchecked(
                    Action::CreateLink(fixt!(CreateLink)),
                    fixt!(Signature),
                ),
                cached_entry: None,
            }),
        )
        .unwrap();

        let mut expected = vec!["validate"];
        for fn_component in validate_invocation.fn_components() {
            assert_eq!(fn_component, expected.pop().unwrap(),);
        }
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn validate_invocation_host_input() {
        let op = Op::RegisterAgentActivity(RegisterAgentActivity {
            action: SignedActionHashed::new_unchecked(
                Action::CreateLink(fixt!(CreateLink)),
                fixt!(Signature),
            ),
            cached_entry: None,
        });
        let validate_invocation = ValidateInvocation::new(ZomesToInvoke::All, &op).unwrap();

        let host_input = validate_invocation.clone().host_input().unwrap();

        assert_eq!(host_input, ExternIO::encode(&op).unwrap(),);
    }
}

#[cfg(test)]
#[cfg(feature = "slow_tests")]
mod slow_tests {
    use super::ValidateResult;
    use crate::conductor::api::error::ConductorApiError;
    use crate::conductor::CellError;
    use crate::core::ribosome::guest_callback::validate::ValidateInvocation;
    use crate::core::ribosome::wasm_test::RibosomeTestFixture;
    use crate::core::ribosome::RibosomeError;
    use crate::core::ribosome::RibosomeT;
    use crate::core::ribosome::ZomesToInvoke;
    use crate::core::workflow::WorkflowError;
    use crate::fixt::curve::Zomes;
    use crate::fixt::*;
    use crate::sweettest::{SweetConductor, SweetDnaFile};
    use ::fixt::prelude::*;
    use assert2::{assert, let_assert};
    use holochain_state::source_chain::SourceChainError;
    use holochain_types::inline_zome::InlineZomeSet;
    use holochain_types::prelude::*;
    use holochain_wasm_test_utils::TestWasm;
    use holochain_zome_types::op::Op;
    use std::sync::Arc;

    #[tokio::test(flavor = "multi_thread")]
    async fn test_validate_unimplemented() {
        let validate_invocation = ValidateInvocation::new(
            ZomesToInvoke::One(IntegrityZome::from(TestWasm::Foo).erase_type()),
            &Op::RegisterAgentActivity(RegisterAgentActivity {
                action: SignedActionHashed::new_unchecked(
                    Action::CreateLink(fixt!(CreateLink)),
                    fixt!(Signature),
                ),
                cached_entry: None,
            }),
        )
        .unwrap();

        let ribosome = RealRibosomeFixturator::new(Zomes(vec![TestWasm::Foo]))
            .next()
            .unwrap();

        let result = ribosome
            .run_validate(fixt!(ValidateHostAccess), validate_invocation)
            .await
            .unwrap();
        assert_eq!(result, ValidateResult::Valid,);
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn test_validate_implemented_valid() {
        let validate_invocation = ValidateInvocation::new(
            ZomesToInvoke::One(IntegrityZome::from(TestWasm::ValidateValid).erase_type()),
            &Op::RegisterAgentActivity(RegisterAgentActivity {
                action: SignedActionHashed::new_unchecked(
                    Action::CreateLink(fixt!(CreateLink)),
                    fixt!(Signature),
                ),
                cached_entry: None,
            }),
        )
        .unwrap();

        let ribosome = RealRibosomeFixturator::new(Zomes(vec![TestWasm::ValidateValid]))
            .next()
            .unwrap();

        let result = ribosome
            .run_validate(fixt!(ValidateHostAccess), validate_invocation)
            .await
            .unwrap();
        assert_eq!(result, ValidateResult::Valid,);
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn test_validate_implemented_invalid_return() {
        let unit_entry_def = EntryDef::default_from_id("unit");
        let zome = InlineZomeSet::new_unique_single(
            "integrity",
            "coordinator",
            vec![unit_entry_def.clone()],
            0,
        )
        .function("integrity", "validate", |_api, _op: Op| Ok(42usize))
        .function("coordinator", "create", move |api, ()| {
            let entry = Entry::app(().try_into().unwrap()).unwrap();
            let hash = api.create(CreateInput::new(
                InlineZomeSet::get_entry_location(&api, EntryDefIndex(0)),
                EntryVisibility::Public,
                entry,
                ChainTopOrdering::default(),
            ))?;
            Ok(hash)
        });

        let dnas = [SweetDnaFile::unique_from_inline_zomes(zome).await.0];
        let mut conductor = SweetConductor::from_standard_config().await;
        let app = conductor.setup_app("app", &dnas).await.unwrap();
        let conductor = Arc::new(conductor);
        let (cell,) = app.into_tuple();

        let err = conductor
            .call_fallible::<_, ()>(&cell.zome("coordinator"), "create", ())
            .await
            .unwrap_err();

        let_assert!(ConductorApiError::CellError(CellError::WorkflowError(workflow_err)) = err);

        let_assert!(
            WorkflowError::SourceChainError(SourceChainError::Other(other_err)) = *workflow_err
        );

        assert!(other_err
            .to_string()
            .contains("invalid value: integer `42`"));
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn test_validate_implemented_invalid_params() {
        let validate_invocation = ValidateInvocation::new(
            ZomesToInvoke::One(IntegrityZome::from(TestWasm::ValidateInvalidParams).erase_type()),
            &Op::RegisterAgentActivity(RegisterAgentActivity {
                action: SignedActionHashed::new_unchecked(
                    Action::CreateLink(fixt!(CreateLink)),
                    fixt!(Signature),
                ),
                cached_entry: None,
            }),
        )
        .unwrap();

        let ribosome = RealRibosomeFixturator::new(Zomes(vec![TestWasm::ValidateInvalidParams]))
            .next()
            .unwrap();

        let err = ribosome
            .run_validate(fixt!(ValidateHostAccess), validate_invocation)
            .await
            .unwrap_err();

        let_assert!(RibosomeError::CallbackInvalidParameters(err_msg) = err);
        assert!(err_msg == String::default());
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn test_adding_entry_when_validate_implemented_invalid_params() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor, alice, ..
        } = RibosomeTestFixture::new(TestWasm::ValidateInvalidParams).await;

        let err = conductor
            .call_fallible::<_, Record>(&alice, "create_entry_to_validate", ())
            .await
            .unwrap_err();

        let_assert!(ConductorApiError::CellError(CellError::WorkflowError(workflow_err)) = err);
        let_assert!(
            WorkflowError::SourceChainError(SourceChainError::Other(other_err)) = *workflow_err
        );
        // Can't downcast the `Box<dyn Error>` to a concrete type so just compare the error message.
        assert!(other_err.to_string() == "The callback has invalid parameters: ");
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn test_validate_implemented_multi() {
        let ribosome = RealRibosomeFixturator::new(Zomes(vec![TestWasm::ValidateInvalid]))
            .next()
            .unwrap();

        let agent = fixt!(AgentPubKey);
        let entry = Entry::Agent(agent.clone());
        let action = Create {
            author: agent.clone(),
            timestamp: Timestamp::now(),
            action_seq: 8,
            prev_action: fixt!(ActionHash),
            entry_type: EntryType::AgentPubKey,
            entry_hash: EntryHash::with_data_sync(&entry),
            weight: EntryRateWeight::default(),
        };

        let op = Op::StoreRecord(StoreRecord {
            record: Record::new(
                SignedActionHashed::with_presigned(
                    ActionHashed::from_content_sync(action),
                    Signature(vec![7; SIGNATURE_BYTES].try_into().unwrap()),
                ),
                Some(entry),
            ),
        });

        let zomes_to_invoke =
            ZomesToInvoke::One(IntegrityZome::from(TestWasm::ValidateInvalid).erase_type());
        let validate_invocation = ValidateInvocation::new(zomes_to_invoke, &op).unwrap();

        let result = ribosome
            .run_validate(fixt!(ValidateHostAccess), validate_invocation)
            .await
            .unwrap();
        assert_eq!(result, ValidateResult::Invalid("esoteric edge case".into()));
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn pass_validate_test() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor, alice, ..
        } = RibosomeTestFixture::new(TestWasm::Validate).await;

        let output: ActionHash = conductor.call(&alice, "always_validates", ()).await;
        let _output_record: Record = conductor
            .call(&alice, "must_get_valid_record", output)
            .await;

        let invalid_output: Result<ActionHash, _> =
            conductor.call_fallible(&alice, "never_validates", ()).await;
        assert!(invalid_output.is_err());
    }
}



================================================
File: crates/holochain/src/core/ribosome/guest_callback/genesis_self_check/v1.rs
================================================
use std::sync::Arc;

use crate::core::ribosome::FnComponents;
use crate::core::ribosome::HostContext;
use crate::core::ribosome::Invocation;
use crate::core::ribosome::InvocationAuth;
use crate::core::ribosome::ZomesToInvoke;
use derive_more::Constructor;
use holochain_serialized_bytes::prelude::*;
use holochain_types::prelude::*;

#[derive(Clone, Constructor, Debug)]
pub struct GenesisSelfCheckHostAccessV1;

#[derive(Clone)]
pub struct GenesisSelfCheckInvocationV1 {
    pub payload: Arc<GenesisSelfCheckDataV1>,
}

impl From<GenesisSelfCheckHostAccessV1> for HostContext {
    fn from(host_access: GenesisSelfCheckHostAccessV1) -> Self {
        Self::GenesisSelfCheckV1(host_access)
    }
}

impl From<&GenesisSelfCheckHostAccessV1> for HostFnAccess {
    fn from(_: &GenesisSelfCheckHostAccessV1) -> Self {
        let mut access = Self::none();
        access.keystore_deterministic = Permission::Allow;
        access.bindings_deterministic = Permission::Allow;
        access
    }
}

impl Invocation for GenesisSelfCheckInvocationV1 {
    fn zomes(&self) -> ZomesToInvoke {
        ZomesToInvoke::AllIntegrity
    }
    fn fn_components(&self) -> FnComponents {
        // Backwards compatibility for callbacks implemented pre-versioning, as
        // well as support for explicit v1 extern.
        vec!["genesis_self_check".into(), "1".into()].into()
    }
    fn host_input(self) -> Result<ExternIO, SerializedBytesError> {
        ExternIO::encode(self.payload)
    }
    fn auth(&self) -> InvocationAuth {
        InvocationAuth::LocalCallback
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, SerializedBytes)]
pub enum GenesisSelfCheckResultV1 {
    Valid,
    Invalid(String),
}

impl From<Vec<(ZomeName, ValidateCallbackResult)>> for GenesisSelfCheckResultV1 {
    fn from(a: Vec<(ZomeName, ValidateCallbackResult)>) -> Self {
        a.into_iter().map(|(_, v)| v).collect::<Vec<_>>().into()
    }
}

impl From<Vec<ValidateCallbackResult>> for GenesisSelfCheckResultV1 {
    fn from(callback_results: Vec<ValidateCallbackResult>) -> Self {
        callback_results.into_iter().fold(Self::Valid, |acc, x| {
            match x {
                // validation is invalid if any x is invalid
                ValidateCallbackResult::Invalid(i) => Self::Invalid(i),

                // valid x allows validation to continue
                ValidateCallbackResult::Valid => acc,

                // this can't happen because self check has no DHT access.
                // don't want to panic so i guess it is invalid.
                ValidateCallbackResult::UnresolvedDependencies(_) => {
                    Self::Invalid(format!("{:?}", x))
                }
            }
        })
    }
}

#[cfg(test)]
#[cfg(feature = "slow_tests")]
pub(crate) mod slow_tests {
    use std::sync::Arc;

    use super::GenesisSelfCheckInvocationV1;
    use crate::sweettest::*;
    use ::fixt::prelude::*;
    use holo_hash::fixt::AgentPubKeyFixturator;
    use holochain_types::prelude::*;
    use holochain_wasm_test_utils::{TestCoordinatorWasm, TestIntegrityWasm};

    pub(crate) fn invocation_fixture() -> GenesisSelfCheckInvocationV1 {
        GenesisSelfCheckInvocationV1 {
            payload: Arc::new(GenesisSelfCheckDataV1 {
                dna_info: fixt!(DnaInfoV1),
                membrane_proof: Some(Arc::new(().try_into().unwrap())),
                agent_key: fixt!(AgentPubKey),
            }),
        }
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn test_integrity_zome_can_run_self_check() {
        let mut conductor = SweetConductor::from_standard_config().await;
        let (dna, _, _) = SweetDnaFile::unique_from_zomes(
            vec![TestIntegrityWasm::IntegrityZome],
            Vec::<TestCoordinatorWasm>::new(),
            vec![TestIntegrityWasm::IntegrityZome],
        )
        .await;

        let app = conductor.setup_app("app", [&dna]).await.unwrap();
        let cells = app.into_cells();

        let _: EntryHashed = conductor
            .call(
                &cells[0].zome(TestIntegrityWasm::IntegrityZome),
                "call_must_get_entry",
                EntryHash::from(cells[0].cell_id().agent_pubkey().clone()),
            )
            .await;
    }
}



================================================
File: crates/holochain/src/core/ribosome/guest_callback/genesis_self_check/v2.rs
================================================
use std::sync::Arc;

use crate::core::ribosome::FnComponents;
use crate::core::ribosome::HostContext;
use crate::core::ribosome::Invocation;
use crate::core::ribosome::InvocationAuth;
use crate::core::ribosome::ZomesToInvoke;
use derive_more::Constructor;
use holochain_serialized_bytes::prelude::*;
use holochain_types::prelude::*;

#[derive(Clone, Constructor, Debug)]
pub struct GenesisSelfCheckHostAccessV2;

#[derive(Clone)]
pub struct GenesisSelfCheckInvocationV2 {
    pub payload: Arc<GenesisSelfCheckDataV2>,
}

impl From<GenesisSelfCheckHostAccessV2> for HostContext {
    fn from(host_access: GenesisSelfCheckHostAccessV2) -> Self {
        Self::GenesisSelfCheckV2(host_access)
    }
}

impl From<&GenesisSelfCheckHostAccessV2> for HostFnAccess {
    fn from(_: &GenesisSelfCheckHostAccessV2) -> Self {
        let mut access = Self::none();
        access.keystore_deterministic = Permission::Allow;
        access.bindings_deterministic = Permission::Allow;
        access
    }
}

impl Invocation for GenesisSelfCheckInvocationV2 {
    fn zomes(&self) -> ZomesToInvoke {
        ZomesToInvoke::AllIntegrity
    }
    fn fn_components(&self) -> FnComponents {
        vec!["genesis_self_check_2".into()].into()
    }
    fn host_input(self) -> Result<ExternIO, SerializedBytesError> {
        ExternIO::encode(self.payload)
    }
    fn auth(&self) -> InvocationAuth {
        InvocationAuth::LocalCallback
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, SerializedBytes)]
pub enum GenesisSelfCheckResultV2 {
    Valid,
    Invalid(String),
}

impl From<Vec<(ZomeName, ValidateCallbackResult)>> for GenesisSelfCheckResultV2 {
    fn from(a: Vec<(ZomeName, ValidateCallbackResult)>) -> Self {
        a.into_iter().map(|(_, v)| v).collect::<Vec<_>>().into()
    }
}

impl From<Vec<ValidateCallbackResult>> for GenesisSelfCheckResultV2 {
    fn from(callback_results: Vec<ValidateCallbackResult>) -> Self {
        callback_results.into_iter().fold(Self::Valid, |acc, x| {
            match x {
                // validation is invalid if any x is invalid
                ValidateCallbackResult::Invalid(i) => Self::Invalid(i),

                // valid x allows validation to continue
                ValidateCallbackResult::Valid => acc,

                // this can't happen because self check has no DHT access.
                // don't want to panic so i guess it is invalid.
                ValidateCallbackResult::UnresolvedDependencies(_) => {
                    Self::Invalid(format!("{:?}", x))
                }
            }
        })
    }
}

#[cfg(test)]
#[cfg(feature = "slow_tests")]
pub(crate) mod slow_tests {
    use holo_hash::fixt::AgentPubKeyFixturator;
    use std::sync::Arc;

    use super::GenesisSelfCheckInvocationV2;
    use crate::sweettest::*;
    use ::fixt::prelude::*;
    use holochain_types::prelude::*;
    use holochain_wasm_test_utils::{TestCoordinatorWasm, TestIntegrityWasm};

    pub(crate) fn invocation_fixture() -> GenesisSelfCheckInvocationV2 {
        GenesisSelfCheckInvocationV2 {
            payload: Arc::new(GenesisSelfCheckDataV2 {
                membrane_proof: Some(Arc::new(().try_into().unwrap())),
                agent_key: fixt!(AgentPubKey),
            }),
        }
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn test_integrity_zome_can_run_self_check() {
        let mut conductor = SweetConductor::from_standard_config().await;
        let (dna, _, _) = SweetDnaFile::unique_from_zomes(
            vec![TestIntegrityWasm::IntegrityZome],
            Vec::<TestCoordinatorWasm>::new(),
            vec![TestIntegrityWasm::IntegrityZome],
        )
        .await;

        let app = conductor.setup_app("app", [&dna]).await.unwrap();
        let cells = app.into_cells();

        let _: EntryHashed = conductor
            .call(
                &cells[0].zome(TestIntegrityWasm::IntegrityZome),
                "call_must_get_entry",
                EntryHash::from(cells[0].cell_id().agent_pubkey().clone()),
            )
            .await;
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/accept_countersigning_preflight_request.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::HostFnAccess;
use crate::core::ribosome::RibosomeError;
use crate::core::ribosome::RibosomeT;
use holochain_types::prelude::*;
use holochain_wasmer_host::prelude::*;
use std::sync::Arc;
use wasmer::RuntimeError;

#[allow(clippy::extra_unused_lifetimes)]
#[cfg_attr(
    feature = "instrument",
    tracing::instrument(skip(_ribosome, call_context))
)]
pub fn accept_countersigning_preflight_request<'a>(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    input: PreflightRequest,
) -> Result<PreflightRequestAcceptance, RuntimeError> {
    match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            agent_info: Permission::Allow,
            keystore: Permission::Allow,
            non_determinism: Permission::Allow,
            write_workspace: Permission::Allow,
            ..
        } => {
            if let Err(e) = input.check_integrity() {
                return Ok(PreflightRequestAcceptance::Invalid(e.to_string()));
            }
            tokio_helper::block_forever_on(async move {
                if (Timestamp::now() + SESSION_TIME_FUTURE_MAX).unwrap_or(Timestamp::MAX)
                    < *input.session_times.start()
                {
                    return Ok(PreflightRequestAcceptance::UnacceptableFutureStart);
                }

                let cell_id = call_context.host_context.call_zome_handle().cell_id();

                call_context
                    .host_context
                    .call_zome_handle()
                    .accept_countersigning_session(cell_id.clone(), input.clone())
                    .await
                    .map_err(|e| -> RuntimeError {
                        wasm_error!(WasmErrorInner::Host(e.to_string())).into()
                    })
            })
        }
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "accept_countersigning_preflight_request".into(),
            )
            .to_string(),
        ))
        .into()),
    }
}

#[cfg(test)]
#[cfg(all(feature = "slow_tests", feature = "unstable-countersigning"))]
pub mod wasm_test {
    use crate::conductor::api::error::ConductorApiError;
    use crate::conductor::CellError;
    use crate::core::ribosome::error::RibosomeError;
    use crate::core::ribosome::wasm_test::RibosomeTestFixture;
    use crate::core::workflow::WorkflowError;
    use crate::sweettest::*;
    use hdk::prelude::*;
    use holochain_state::source_chain::SourceChainError;
    use holochain_wasm_test_utils::TestWasm;
    use holochain_zome_types::zome_io::ZomeCallParams;
    use matches::assert_matches;
    use wasmer::RuntimeError;

    /// Allow ChainLocked error, panic on anything else
    fn expect_chain_locked(
        result: Result<Result<ZomeCallResponse, RibosomeError>, ConductorApiError>,
    ) {
        match result {
            Err(ConductorApiError::CellError(CellError::WorkflowError(workflow_error))) => {
                match *workflow_error {
                    WorkflowError::SourceChainError(SourceChainError::ChainLocked) => {}
                    _ => panic!("{:?}", workflow_error),
                }
            }
            something_else => panic!("{:?}", something_else),
        };
    }

    /// Allow LockExpired error, panic on anything else
    fn expect_error_for_write_without_lock<T>(result: Result<T, ConductorApiError>)
    where
        T: std::fmt::Debug,
    {
        match result {
            Err(ConductorApiError::CellError(CellError::WorkflowError(workflow_error))) => {
                match *workflow_error {
                    WorkflowError::SourceChainError(
                        SourceChainError::CountersigningWriteWithoutSession,
                    ) => {}
                    _ => panic!("{:?}", workflow_error),
                }
            }
            something_else => panic!("{:?}", something_else),
        };
    }

    #[tokio::test(flavor = "multi_thread")]
    #[cfg_attr(target_os = "macos", ignore = "flaky on macos")]
    async fn unlock_timeout_session() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor,
            alice,
            alice_pubkey,
            bob,
            bob_pubkey,
            ..
        } = RibosomeTestFixture::new(TestWasm::CounterSigning).await;

        // Before preflight everyone commits some stuff.
        let _: ActionHash = conductor.call(&alice, "create_a_thing", ()).await;
        let _: ActionHash = conductor.call(&bob, "create_a_thing", ()).await;

        let alice_agent_activity_alice_observed_before: AgentActivity = conductor
            .call(
                &alice,
                "get_agent_activity",
                GetAgentActivityInput {
                    agent_pubkey: alice_pubkey.clone(),
                    chain_query_filter: ChainQueryFilter::new(),
                    activity_request: ActivityRequest::Full,
                },
            )
            .await;
        let alice_agent_activity_bob_observed_before: AgentActivity = conductor
            .call(
                &bob,
                "get_agent_activity",
                GetAgentActivityInput {
                    agent_pubkey: alice_pubkey.clone(),
                    chain_query_filter: ChainQueryFilter::new(),
                    activity_request: ActivityRequest::Full,
                },
            )
            .await;
        let bob_agent_activity_alice_observed_before: AgentActivity = conductor
            .call(
                &alice,
                "get_agent_activity",
                GetAgentActivityInput {
                    agent_pubkey: bob_pubkey.clone(),
                    chain_query_filter: ChainQueryFilter::new(),
                    activity_request: ActivityRequest::Full,
                },
            )
            .await;
        let bob_agent_activity_bob_observed_before: AgentActivity = conductor
            .call(
                &bob,
                "get_agent_activity",
                GetAgentActivityInput {
                    agent_pubkey: bob_pubkey.clone(),
                    chain_query_filter: ChainQueryFilter::new(),
                    activity_request: ActivityRequest::Full,
                },
            )
            .await;

        // Everyone accepts a short-lived session.
        let preflight_request: PreflightRequest = conductor
            .call(
                &alice,
                "generate_countersigning_preflight_request_fast",
                vec![
                    (alice_pubkey.clone(), vec![Role(0)]),
                    (bob_pubkey.clone(), vec![]),
                ],
            )
            .await;
        let alice_acceptance: PreflightRequestAcceptance = conductor
            .call(
                &alice,
                "accept_countersigning_preflight_request",
                preflight_request.clone(),
            )
            .await;
        let alice_response =
            if let PreflightRequestAcceptance::Accepted(ref response) = alice_acceptance {
                response
            } else {
                unreachable!();
            };
        let bob_acceptance: PreflightRequestAcceptance = conductor
            .call(
                &bob,
                "accept_countersigning_preflight_request",
                preflight_request.clone(),
            )
            .await;
        let bob_response =
            if let PreflightRequestAcceptance::Accepted(ref response) = bob_acceptance {
                response
            } else {
                unreachable!();
            };

        // Alice commits the session entry.
        let (countersigned_action_hash_alice, countersigned_entry_hash_alice): (
            ActionHash,
            EntryHash,
        ) = conductor
            .call(
                &alice,
                "create_a_countersigned_thing_with_entry_hash",
                vec![alice_response.clone(), bob_response.clone()],
            )
            .await;

        // @TODO - the following three zome must_get_* all pass but perhaps we do NOT want them to?
        // @TODO updated: You can no longer get these entries after the session has expired and
        //       been abandoned but this comment is still relevant during the session, once a
        //       commit has been done and before the session has timed out.
        //
        // It's not immediately clear what direct requests by hash should do in all cases here.
        //
        // If an author does a must_get during a zome call like we do in this test, should it
        // be returned even though it hasn't been countersigned and so may never be included
        // in a source chain?
        //
        // Should it be returned in subsequent zome calls by an author who has signed it but it
        // hasn't been coauthored yet, but the session is still active? (c.f. private entries
        // being visible to author). And what about after the session?
        //
        // What about returned by/for coauthors who do NOT sign during and after the session?
        //
        // What about everyone else during and after the session?
        //
        // The answer to the above may be different per call, idk at this point.
        // Seems intuitive that an action that is in nobody's agent activity should never be visible
        // but then how can you get the entry hash and entry data during the session, like we do in this test?
        //
        // Maybe it also seems intuitive that must_get_entry should return the entry as we know its
        // hash and normally must_get ignores validity or even which headers created it, but what if NO
        // headers created it?
        //
        // etc. etc. I'm just leaving this commentary here to germinate future headaches and self doubt.
        conductor
            .call_fallible::<_, SignedActionHashed>(
                &alice,
                "must_get_action",
                countersigned_action_hash_alice.clone(),
            )
            .await
            .unwrap();

        conductor
            .call_fallible::<_, Record>(
                &alice,
                "must_get_valid_record",
                countersigned_action_hash_alice.clone(),
            )
            .await
            .unwrap();
        conductor
            .call_fallible::<_, EntryHashed>(
                &alice,
                "must_get_entry",
                countersigned_entry_hash_alice.clone(),
            )
            .await
            .unwrap();

        // Bob tries to commit the session entry as well but after timeout.
        tokio::time::sleep(std::time::Duration::from_millis(10500)).await;
        let bob_result: Result<ActionHash, _> = conductor
            .call_fallible(
                &bob,
                "create_a_countersigned_thing",
                vec![alice_response.clone(), bob_response.clone()],
            )
            .await;

        expect_error_for_write_without_lock(bob_result);

        // At this point Alice's session entry is a liability so can't exist.
        let alice_agent_activity_alice_observed_after: AgentActivity = conductor
            .call(
                &alice,
                "get_agent_activity",
                GetAgentActivityInput {
                    agent_pubkey: alice_pubkey.clone(),
                    chain_query_filter: ChainQueryFilter::new(),
                    activity_request: ActivityRequest::Full,
                },
            )
            .await;
        let alice_agent_activity_bob_observed_after: AgentActivity = conductor
            .call(
                &bob,
                "get_agent_activity",
                GetAgentActivityInput {
                    agent_pubkey: alice_pubkey.clone(),
                    chain_query_filter: ChainQueryFilter::new(),
                    activity_request: ActivityRequest::Full,
                },
            )
            .await;
        let bob_agent_activity_alice_observed_after: AgentActivity = conductor
            .call(
                &alice,
                "get_agent_activity",
                GetAgentActivityInput {
                    agent_pubkey: bob_pubkey.clone(),
                    chain_query_filter: ChainQueryFilter::new(),
                    activity_request: ActivityRequest::Full,
                },
            )
            .await;
        let bob_agent_activity_bob_observed_after: AgentActivity = conductor
            .call(
                &bob,
                "get_agent_activity",
                GetAgentActivityInput {
                    agent_pubkey: bob_pubkey.clone(),
                    chain_query_filter: ChainQueryFilter::new(),
                    activity_request: ActivityRequest::Full,
                },
            )
            .await;

        assert_eq!(
            alice_agent_activity_alice_observed_before,
            alice_agent_activity_alice_observed_after
        );
        assert_eq!(
            alice_agent_activity_bob_observed_before,
            alice_agent_activity_bob_observed_after
        );
        assert_eq!(
            bob_agent_activity_alice_observed_before,
            bob_agent_activity_alice_observed_after
        );
        assert_eq!(
            bob_agent_activity_bob_observed_before,
            bob_agent_activity_bob_observed_after
        );
    }

    #[tokio::test(flavor = "multi_thread")]
    #[cfg_attr(target_os = "macos", ignore = "flaky")]
    async fn unlock_invalid_session() {
        use holochain_nonce::fresh_nonce;

        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor,
            alice,
            alice_pubkey,
            bob,
            bob_pubkey,
            ..
        } = RibosomeTestFixture::new(TestWasm::CounterSigning).await;
        let now = Timestamp::now();

        // Before preflight Alice can commit
        let _: ActionHash = conductor.call(&alice, "create_a_thing", ()).await;

        let preflight_request: PreflightRequest = conductor
            .call(
                &alice,
                "generate_invalid_countersigning_preflight_request",
                vec![
                    (alice_pubkey.clone(), vec![Role(0)]),
                    (bob_pubkey.clone(), vec![]),
                ],
            )
            .await;

        // Before accepting preflight Alice can commit
        let _: ActionHash = conductor.call(&alice, "create_a_thing", ()).await;

        // Alice can accept the preflight request.
        let alice_acceptance: PreflightRequestAcceptance = conductor
            .call(
                &alice,
                "accept_countersigning_preflight_request",
                preflight_request.clone(),
            )
            .await;
        let alice_response =
            if let PreflightRequestAcceptance::Accepted(ref response) = alice_acceptance {
                response
            } else {
                unreachable!();
            };

        // Bob can also accept the preflight request.
        let bob_acceptance: PreflightRequestAcceptance = conductor
            .call(
                &bob,
                "accept_countersigning_preflight_request",
                preflight_request.clone(),
            )
            .await;
        let bob_response =
            if let PreflightRequestAcceptance::Accepted(ref response) = bob_acceptance {
                response
            } else {
                unreachable!();
            };

        let (nonce, expires_at) = fresh_nonce(now).unwrap();

        // With an accepted preflight creations must fail for alice.
        let thing_fail_create_alice = conductor
            .raw_handle()
            .call_zome(ZomeCallParams {
                cell_id: alice.cell_id().clone(),
                zome_name: alice.name().clone(),
                fn_name: "create_a_thing".into(),
                cap_secret: None,
                provenance: alice_pubkey.clone(),
                payload: ExternIO::encode(()).unwrap(),
                nonce,
                expires_at,
            })
            .await;

        expect_chain_locked(thing_fail_create_alice);

        let (nonce, expires_at) = fresh_nonce(now).unwrap();

        // Creating the INCORRECT countersigned entry WILL immediately unlock
        // the chain.
        let countersign_fail_create_alice = conductor
            .raw_handle()
            .call_zome(ZomeCallParams {
                cell_id: alice.cell_id().clone(),
                zome_name: alice.name().clone(),
                fn_name: "create_an_invalid_countersigned_thing".into(),
                cap_secret: None,
                provenance: alice_pubkey.clone(),
                payload: ExternIO::encode(vec![alice_response.clone(), bob_response.clone()])
                    .unwrap(),
                nonce,
                expires_at,
            })
            .await;
        assert!(countersign_fail_create_alice.is_err());
        let _: ActionHash = conductor.call(&alice, "create_a_thing", ()).await;
    }

    #[tokio::test(flavor = "multi_thread")]
    #[cfg_attr(target_os = "macos", ignore = "flaky on macos")]
    #[cfg_attr(target_os = "windows", ignore = "stack overflow on windows")]
    async fn lock_chain() {
        use holochain_nonce::fresh_nonce;
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor,
            alice,
            alice_cell,
            alice_pubkey,
            bob,
            bob_cell,
            bob_pubkey,
            ..
        } = RibosomeTestFixture::new(TestWasm::CounterSigning).await;
        let now = Timestamp::now();
        // Before the preflight creation of things should work.
        let _: ActionHash = conductor.call(&alice, "create_a_thing", ()).await;

        // Bob's zome must be initialized for countersigning to work.
        let _: ActionHash = conductor.call(&bob, "create_a_thing", ()).await;

        // Alice can create a preflight request.
        let preflight_request: PreflightRequest = conductor
            .call(
                &alice,
                "generate_countersigning_preflight_request",
                vec![
                    (alice_pubkey.clone(), vec![Role(0)]),
                    (bob_pubkey.clone(), vec![]),
                ],
            )
            .await;

        // Alice can accept the preflight request.
        let alice_acceptance: PreflightRequestAcceptance = conductor
            .call(
                &alice,
                "accept_countersigning_preflight_request",
                preflight_request.clone(),
            )
            .await;
        let alice_response =
            if let PreflightRequestAcceptance::Accepted(ref response) = alice_acceptance {
                response
            } else {
                unreachable!();
            };

        // Alice can create a second preflight request.
        let preflight_request_2: PreflightRequest = conductor
            .call(
                &alice,
                "generate_countersigning_preflight_request",
                vec![
                    (alice_pubkey.clone(), vec![Role(1)]),
                    (bob_pubkey.clone(), vec![]),
                ],
            )
            .await;

        let (nonce, expires_at) = fresh_nonce(now).unwrap();

        // Can't accept a second preflight request while the first is active.
        let preflight_acceptance_fail = conductor
            .raw_handle()
            .call_zome(ZomeCallParams {
                cell_id: alice.cell_id().clone(),
                zome_name: alice.name().clone(),
                fn_name: "accept_countersigning_preflight_request".into(),
                cap_secret: None,
                provenance: alice_pubkey.clone(),
                payload: ExternIO::encode(&preflight_request_2).unwrap(),
                nonce,
                expires_at,
            })
            .await;
        assert_matches!(
            preflight_acceptance_fail,
            Ok(Err(RibosomeError::WasmRuntimeError(RuntimeError { .. })))
        );

        // Bob can also accept the preflight request.
        let bob_acceptance: PreflightRequestAcceptance = conductor
            .call(
                &bob,
                "accept_countersigning_preflight_request",
                preflight_request.clone(),
            )
            .await;
        let bob_response =
            if let PreflightRequestAcceptance::Accepted(ref response) = bob_acceptance {
                response
            } else {
                unreachable!();
            };

        let (nonce, expires_at) = fresh_nonce(now).unwrap();

        // With an accepted preflight creations must fail for alice.
        let thing_fail_create_alice = conductor
            .raw_handle()
            .call_zome(ZomeCallParams {
                cell_id: alice.cell_id().clone(),
                zome_name: alice.name().clone(),
                fn_name: "create_a_thing".into(),
                cap_secret: None,
                provenance: alice_pubkey.clone(),
                payload: ExternIO::encode(()).unwrap(),
                nonce,
                expires_at,
            })
            .await;
        expect_chain_locked(thing_fail_create_alice);

        let (nonce, expires_at) = fresh_nonce(now).unwrap();

        let thing_fail_create_bob = conductor
            .raw_handle()
            .call_zome(ZomeCallParams {
                cell_id: bob.cell_id().clone(),
                zome_name: bob.name().clone(),
                fn_name: "create_a_thing".into(),
                cap_secret: None,
                provenance: bob_pubkey.clone(),
                payload: ExternIO::encode(()).unwrap(),
                nonce,
                expires_at,
            })
            .await;
        expect_chain_locked(thing_fail_create_bob);

        // Creating the correct countersigned entry will NOT immediately unlock
        // the chain (it needs Bob to countersign).
        let countersigned_action_hash_alice: ActionHash = conductor
            .call(
                &alice,
                "create_a_countersigned_thing",
                vec![alice_response.clone(), bob_response.clone()],
            )
            .await;

        let (nonce, expires_at) = fresh_nonce(now).unwrap();

        let thing_fail_create_alice = conductor
            .raw_handle()
            .call_zome(ZomeCallParams {
                cell_id: alice.cell_id().clone(),
                zome_name: alice.name().clone(),
                fn_name: "create_a_thing".into(),
                cap_secret: None,
                provenance: alice_pubkey.clone(),
                payload: ExternIO::encode(()).unwrap(),
                nonce,
                expires_at,
            })
            .await;

        tokio::time::sleep(std::time::Duration::from_millis(500)).await;

        expect_chain_locked(thing_fail_create_alice);

        // The countersigned entry does NOT appear in alice's activity yet.
        let alice_activity_pre: AgentActivity = conductor
            .call(
                &alice,
                "get_agent_activity",
                GetAgentActivityInput {
                    agent_pubkey: alice_pubkey.clone(),
                    chain_query_filter: ChainQueryFilter::new(),
                    activity_request: ActivityRequest::Full,
                },
            )
            .await;
        assert_eq!(alice_activity_pre.valid_activity.len(), 5);

        let (nonce, expires_at) = fresh_nonce(now).unwrap();

        // Creation will still fail for bob.
        let thing_fail_create_bob = conductor
            .raw_handle()
            .call_zome(ZomeCallParams {
                cell_id: bob.cell_id().clone(),
                zome_name: bob.name().clone(),
                fn_name: "create_a_thing".into(),
                cap_secret: None,
                provenance: bob_pubkey.clone(),
                payload: ExternIO::encode(()).unwrap(),
                nonce,
                expires_at,
            })
            .await;
        expect_chain_locked(thing_fail_create_bob);

        // After bob commits the same countersigned entry he can unlock his chain.
        let countersigned_action_hash_bob: ActionHash = conductor
            .call(
                &bob,
                "create_a_countersigned_thing",
                vec![alice_response, bob_response],
            )
            .await;
        let _: ActionHash = conductor.call(&alice, "create_a_thing", ()).await;
        let _: ActionHash = conductor.call(&bob, "create_a_thing", ()).await;

        // Action get must not error.
        let countersigned_action_bob: SignedActionHashed = conductor
            .call(
                &bob,
                "must_get_action",
                countersigned_action_hash_bob.clone(),
            )
            .await;
        let countersigned_action_alice: SignedActionHashed = conductor
            .call(
                &alice,
                "must_get_action",
                countersigned_action_hash_alice.clone(),
            )
            .await;

        // Entry get must not error.
        if let Some((countersigned_entry_hash_bob, _)) =
            countersigned_action_bob.action().entry_data()
        {
            let _countersigned_entry_bob: EntryHashed = conductor
                .call(&bob, "must_get_entry", countersigned_entry_hash_bob)
                .await;
        } else {
            unreachable!();
        }

        // Record get must not error.
        let _countersigned_record_bob: Record = conductor
            .call(&bob, "must_get_valid_record", countersigned_action_hash_bob)
            .await;

        let alice_activity: AgentActivity = conductor
            .call(
                &alice,
                "get_agent_activity",
                GetAgentActivityInput {
                    agent_pubkey: alice_pubkey.clone(),
                    chain_query_filter: ChainQueryFilter::new(),
                    activity_request: ActivityRequest::Full,
                },
            )
            .await;

        await_consistency(60, [&alice_cell, &bob_cell])
            .await
            .unwrap();

        assert_eq!(alice_activity.valid_activity.len(), 7);
        assert_eq!(
            &alice_activity.valid_activity[5].1,
            countersigned_action_alice.action_address(),
        );

        let bob_activity: AgentActivity = conductor
            .call(
                &bob,
                "get_agent_activity",
                GetAgentActivityInput {
                    agent_pubkey: bob_pubkey.clone(),
                    chain_query_filter: ChainQueryFilter::new(),
                    activity_request: ActivityRequest::Full,
                },
            )
            .await;
        assert_eq!(bob_activity.valid_activity.len(), 7);
        assert_eq!(
            &bob_activity.valid_activity[5].1,
            countersigned_action_bob.action_address(),
        );
    }

    #[tokio::test(flavor = "multi_thread")]
    #[ignore = "countersigning_an_entry_before_bobs_zome_initialized_fails"]
    async fn lock_chain_failure() {
        use holochain_nonce::fresh_nonce;
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor,
            alice,
            alice_cell,
            alice_pubkey,
            bob,
            bob_cell,
            bob_pubkey,
            ..
        } = RibosomeTestFixture::new(TestWasm::CounterSigning).await;
        let now = Timestamp::now();
        // Before the preflight creation of things should work.
        let _: ActionHash = conductor.call(&alice, "create_a_thing", ()).await;

        // Alice can create multiple preflight requests.
        let preflight_request: PreflightRequest = conductor
            .call(
                &alice,
                "generate_countersigning_preflight_request",
                vec![
                    (alice_pubkey.clone(), vec![Role(0)]),
                    (bob_pubkey.clone(), vec![]),
                ],
            )
            .await;
        let preflight_request_2: PreflightRequest = conductor
            .call(
                &alice,
                "generate_countersigning_preflight_request",
                vec![
                    (alice_pubkey.clone(), vec![Role(1)]),
                    (bob_pubkey.clone(), vec![]),
                ],
            )
            .await;

        // Alice can still create things before the preflight is accepted.
        let _: ActionHash = conductor.call(&alice, "create_a_thing", ()).await;

        // Alice can accept the preflight request.
        let alice_acceptance: PreflightRequestAcceptance = conductor
            .call(
                &alice,
                "accept_countersigning_preflight_request",
                preflight_request.clone(),
            )
            .await;
        let alice_response =
            if let PreflightRequestAcceptance::Accepted(ref response) = alice_acceptance {
                response
            } else {
                unreachable!();
            };

        let (nonce, expires_at) = fresh_nonce(now).unwrap();

        // Can't accept a second preflight request while the first is active.
        let preflight_acceptance_fail = conductor
            .raw_handle()
            .call_zome(ZomeCallParams {
                cell_id: alice.cell_id().clone(),
                zome_name: alice.name().clone(),
                fn_name: "accept_countersigning_preflight_request".into(),
                cap_secret: None,
                provenance: alice_pubkey.clone(),
                payload: ExternIO::encode(&preflight_request_2).unwrap(),
                nonce,
                expires_at,
            })
            .await;
        assert!(matches!(
            preflight_acceptance_fail,
            Ok(Err(RibosomeError::WasmRuntimeError(RuntimeError { .. })))
        ));

        // Bob can also accept the preflight request.
        let bob_acceptance: PreflightRequestAcceptance = conductor
            .call(
                &bob,
                "accept_countersigning_preflight_request",
                preflight_request.clone(),
            )
            .await;
        let bob_response =
            if let PreflightRequestAcceptance::Accepted(ref response) = bob_acceptance {
                response
            } else {
                unreachable!();
            };

        let (nonce, expires_at) = fresh_nonce(now).unwrap();

        // With an accepted preflight creations must fail for alice.
        let thing_fail_create_alice = conductor
            .raw_handle()
            .call_zome(ZomeCallParams {
                cell_id: alice.cell_id().clone(),
                zome_name: alice.name().clone(),
                fn_name: "create_a_thing".into(),
                cap_secret: None,
                provenance: alice_pubkey.clone(),
                payload: ExternIO::encode(()).unwrap(),
                nonce,
                expires_at,
            })
            .await;
        expect_chain_locked(thing_fail_create_alice);

        let (nonce, expires_at) = fresh_nonce(now).unwrap();

        let thing_fail_create_bob = conductor
            .raw_handle()
            .call_zome(ZomeCallParams {
                cell_id: bob.cell_id().clone(),
                zome_name: bob.name().clone(),
                fn_name: "create_a_thing".into(),
                cap_secret: None,
                provenance: bob_pubkey.clone(),
                payload: ExternIO::encode(()).unwrap(),
                nonce,
                expires_at,
            })
            .await;
        expect_chain_locked(thing_fail_create_bob);

        // Creating the correct countersigned entry will NOT immediately unlock
        // the chain (it needs Bob to countersign).
        let countersigned_action_hash_alice: ActionHash = conductor
            .call(
                &alice,
                "create_a_countersigned_thing",
                vec![alice_response.clone(), bob_response.clone()],
            )
            .await;

        let (nonce, expires_at) = fresh_nonce(now).unwrap();

        let thing_fail_create_alice = conductor
            .raw_handle()
            .call_zome(ZomeCallParams {
                cell_id: alice.cell_id().clone(),
                zome_name: alice.name().clone(),
                fn_name: "create_a_thing".into(),
                cap_secret: None,
                provenance: alice_pubkey.clone(),
                payload: ExternIO::encode(()).unwrap(),
                nonce,
                expires_at,
            })
            .await;

        tokio::time::sleep(std::time::Duration::from_millis(500)).await;

        expect_chain_locked(thing_fail_create_alice);

        // The countersigned entry does NOT appear in alice's activity yet.
        let alice_activity_pre: AgentActivity = conductor
            .call(
                &alice,
                "get_agent_activity",
                GetAgentActivityInput {
                    agent_pubkey: alice_pubkey.clone(),
                    chain_query_filter: ChainQueryFilter::new(),
                    activity_request: ActivityRequest::Full,
                },
            )
            .await;
        assert_eq!(alice_activity_pre.valid_activity.len(), 6);

        let (nonce, expires_at) = fresh_nonce(now).unwrap();

        // Creation will still fail for bob.
        let thing_fail_create_bob = conductor
            .raw_handle()
            .call_zome(ZomeCallParams {
                cell_id: bob.cell_id().clone(),
                zome_name: bob.name().clone(),
                fn_name: "create_a_thing".into(),
                cap_secret: None,
                provenance: bob_pubkey.clone(),
                payload: ExternIO::encode(()).unwrap(),
                nonce,
                expires_at,
            })
            .await;
        expect_chain_locked(thing_fail_create_bob);

        // After bob commits the same countersigned entry he can unlock his chain.
        let countersigned_action_hash_bob: ActionHash = conductor
            .call(
                &bob,
                "create_a_countersigned_thing",
                vec![alice_response, bob_response],
            )
            .await;
        let _: ActionHash = conductor.call(&alice, "create_a_thing", ()).await;
        let _: ActionHash = conductor.call(&bob, "create_a_thing", ()).await;

        // Action get must not error.
        let countersigned_action_bob: SignedActionHashed = conductor
            .call(
                &bob,
                "must_get_action",
                countersigned_action_hash_bob.clone(),
            )
            .await;
        let countersigned_action_alice: SignedActionHashed = conductor
            .call(
                &alice,
                "must_get_action",
                countersigned_action_hash_alice.clone(),
            )
            .await;

        // Entry get must not error.
        if let Some((countersigned_entry_hash_bob, _)) =
            countersigned_action_bob.action().entry_data()
        {
            let _countersigned_entry_bob: EntryHashed = conductor
                .call(&bob, "must_get_entry", countersigned_entry_hash_bob)
                .await;
        } else {
            unreachable!();
        }

        // Record get must not error.
        let _countersigned_record_bob: Record = conductor
            .call(&bob, "must_get_valid_record", countersigned_action_hash_bob)
            .await;

        let alice_activity: AgentActivity = conductor
            .call(
                &alice,
                "get_agent_activity",
                GetAgentActivityInput {
                    agent_pubkey: alice_pubkey.clone(),
                    chain_query_filter: ChainQueryFilter::new(),
                    activity_request: ActivityRequest::Full,
                },
            )
            .await;

        await_consistency(10, [&alice_cell, &bob_cell])
            .await
            .unwrap();

        assert_eq!(alice_activity.valid_activity.len(), 8);
        assert_eq!(
            &alice_activity.valid_activity[6].1,
            countersigned_action_alice.action_address(),
        );

        let bob_activity: AgentActivity = conductor
            .call(
                &bob,
                "get_agent_activity",
                GetAgentActivityInput {
                    agent_pubkey: bob_pubkey.clone(),
                    chain_query_filter: ChainQueryFilter::new(),
                    activity_request: ActivityRequest::Full,
                },
            )
            .await;
        assert_eq!(bob_activity.valid_activity.len(), 6);
        assert_eq!(
            &bob_activity.valid_activity[4].1,
            countersigned_action_bob.action_address(),
        );
    }

    #[tokio::test(flavor = "multi_thread")]
    #[ignore = "flaky"]
    // TODO: this test and the following one (`enzymatic_session_success_forced_init`) form a pair.
    // The latter includes a "fix" to the test to remove the flakiness, but the flakiness itself is a problem
    // that we need to address.
    // The flakiness is described in https://github.com/holochain/holochain/pull/3046. When that is resolved,
    // this test can be unignored, and the companion test can be removed.
    async fn enzymatic_session_success_flaky() {
        enzymatic_session_success(false).await
    }

    #[tokio::test(flavor = "multi_thread")]
    #[cfg(feature = "slow_tests")]
    async fn enzymatic_session_success_forced_init() {
        enzymatic_session_success(true).await
    }

    async fn enzymatic_session_success(force_init: bool) {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor,
            alice,
            alice_cell,
            alice_pubkey,
            bob,
            bob_cell,
            bob_pubkey,
            ..
        } = RibosomeTestFixture::new(TestWasm::CounterSigning).await;

        if force_init {
            // Run any arbitrary zome call for bob to force him to run init
            let _: AgentActivity = conductor
                .call(
                    &bob,
                    "get_agent_activity",
                    GetAgentActivityInput {
                        agent_pubkey: bob_pubkey.clone(),
                        chain_query_filter: ChainQueryFilter::new(),
                        activity_request: ActivityRequest::Full,
                    },
                )
                .await;
        }

        // Start an enzymatic session
        let preflight_request: PreflightRequest = conductor
            .call(
                &alice,
                "generate_countersigning_preflight_request_enzymatic",
                vec![
                    // Alice is enzyme
                    (alice_pubkey.clone(), vec![Role(0)]),
                    (bob_pubkey.clone(), vec![]),
                ],
            )
            .await;

        // Alice can accept.
        let alice_acceptance: PreflightRequestAcceptance = conductor
            .call(
                &alice,
                "accept_countersigning_preflight_request",
                preflight_request.clone(),
            )
            .await;
        let alice_response =
            if let PreflightRequestAcceptance::Accepted(ref response) = alice_acceptance {
                response
            } else {
                unreachable!();
            };

        // Bob can also accept the preflight request.
        let bob_acceptance: PreflightRequestAcceptance = conductor
            .call(
                &bob,
                "accept_countersigning_preflight_request",
                preflight_request.clone(),
            )
            .await;
        let bob_response =
            if let PreflightRequestAcceptance::Accepted(ref response) = bob_acceptance {
                response
            } else {
                unreachable!();
            };

        // Alice commits the action.
        let _countersigned_action_hash_alice: ActionHash = conductor
            .call(
                &alice,
                "create_a_countersigned_thing",
                vec![alice_response.clone(), bob_response.clone()],
            )
            .await;

        // The countersigned entry does NOT appear in alice's activity yet.
        let alice_activity_pre: AgentActivity = conductor
            .call(
                &alice,
                "get_agent_activity",
                GetAgentActivityInput {
                    agent_pubkey: alice_pubkey.clone(),
                    chain_query_filter: ChainQueryFilter::new(),
                    activity_request: ActivityRequest::Full,
                },
            )
            .await;
        // Nor bob's.
        let bob_activity_pre: AgentActivity = conductor
            .call(
                &alice,
                "get_agent_activity",
                GetAgentActivityInput {
                    agent_pubkey: bob_pubkey.clone(),
                    chain_query_filter: ChainQueryFilter::new(),
                    activity_request: ActivityRequest::Full,
                },
            )
            .await;

        // Bob commits the action also.
        let _countersigned_action_hash_bob: ActionHash = conductor
            .call(
                &bob,
                "create_a_countersigned_thing",
                vec![alice_response, bob_response],
            )
            .await;

        await_consistency(10, [&alice_cell, &bob_cell])
            .await
            .unwrap();

        // Now the action appears in alice's activty.
        let alice_activity: AgentActivity = conductor
            .call(
                &alice,
                "get_agent_activity",
                GetAgentActivityInput {
                    agent_pubkey: alice_pubkey.clone(),
                    chain_query_filter: ChainQueryFilter::new(),
                    activity_request: ActivityRequest::Full,
                },
            )
            .await;
        // And bob's.
        let bob_activity: AgentActivity = conductor
            .call(
                &alice,
                "get_agent_activity",
                GetAgentActivityInput {
                    agent_pubkey: bob_pubkey.clone(),
                    chain_query_filter: ChainQueryFilter::new(),
                    activity_request: ActivityRequest::Full,
                },
            )
            .await;

        assert_eq!(
            alice_activity.valid_activity.len(),
            alice_activity_pre.valid_activity.len() + 1
        );
        assert_eq!(
            bob_activity.valid_activity.len(),
            bob_activity_pre.valid_activity.len() + 1
        );
    }

    #[tokio::test(flavor = "multi_thread")]
    #[ignore = "countersigning_an_entry_before_bobs_zome_initialized_fails"]
    async fn enzymatic_session_failure() {
        holochain_trace::test_run();

        let (dna_file, _, _) =
            SweetDnaFile::unique_from_test_wasms(vec![TestWasm::CounterSigning]).await;

        let mut conductors = SweetConductorBatch::from_standard_config(3).await;
        let apps = conductors
            .setup_app("countersigning", [&dna_file])
            .await
            .unwrap();

        let ((alice_cell,), (bob_cell,), (carol_cell,)) = apps.into_tuples();

        let alice = alice_cell.zome(TestWasm::CounterSigning);
        let bob = bob_cell.zome(TestWasm::CounterSigning);

        let alice_pubkey = alice_cell.cell_id().agent_pubkey();
        let bob_pubkey = bob_cell.cell_id().agent_pubkey();

        // Alice and bob can see carol but not each other.
        // We will simply teleport the countersigning requests and responses.
        conductors.reveal_peer_info(0, 2).await;
        conductors.reveal_peer_info(1, 2).await;

        let alice_conductor = conductors.get(0).unwrap();
        let bob_conductor = conductors.get(1).unwrap();

        // NON ENZYMATIC
        {
            await_consistency(10, [&alice_cell, &bob_cell, &carol_cell])
                .await
                .unwrap();

            // The countersigned entry does NOT appear in alice's activity yet.
            let alice_activity_pre: AgentActivity = bob_conductor
                .call(
                    &bob,
                    "get_agent_activity",
                    GetAgentActivityInput {
                        agent_pubkey: alice_pubkey.clone(),
                        chain_query_filter: ChainQueryFilter::new(),
                        activity_request: ActivityRequest::Full,
                    },
                )
                .await;
            // Nor bob's.
            let bob_activity_pre: AgentActivity = alice_conductor
                .call(
                    &alice,
                    "get_agent_activity",
                    GetAgentActivityInput {
                        agent_pubkey: bob_pubkey.clone(),
                        chain_query_filter: ChainQueryFilter::new(),
                        activity_request: ActivityRequest::Full,
                    },
                )
                .await;

            // Start a session
            let preflight_request: PreflightRequest = alice_conductor
                .call(
                    &alice,
                    "generate_countersigning_preflight_request",
                    vec![
                        // Alice is enzyme
                        (alice_pubkey.clone(), vec![Role(0)]),
                        (bob_pubkey.clone(), vec![]),
                    ],
                )
                .await;

            // Alice can accept.
            let alice_acceptance: PreflightRequestAcceptance = alice_conductor
                .call(
                    &alice,
                    "accept_countersigning_preflight_request",
                    preflight_request.clone(),
                )
                .await;
            let alice_response =
                if let PreflightRequestAcceptance::Accepted(ref response) = alice_acceptance {
                    response
                } else {
                    unreachable!();
                };

            // Bob can also accept the preflight request.
            let bob_acceptance: PreflightRequestAcceptance = bob_conductor
                .call(
                    &bob,
                    "accept_countersigning_preflight_request",
                    preflight_request.clone(),
                )
                .await;
            let bob_response =
                if let PreflightRequestAcceptance::Accepted(ref response) = bob_acceptance {
                    response
                } else {
                    unreachable!();
                };

            await_consistency(10, [&alice_cell, &bob_cell, &carol_cell])
                .await
                .unwrap();

            // Alice commits the action.
            let _countersigned_action_hash_alice: ActionHash = alice_conductor
                .call(
                    &alice,
                    "create_a_countersigned_thing",
                    vec![alice_response.clone(), bob_response.clone()],
                )
                .await;

            // Bob commits the action also.
            let _countersigned_action_hash_bob: ActionHash = bob_conductor
                .call(
                    &bob,
                    "create_a_countersigned_thing",
                    vec![alice_response, bob_response],
                )
                .await;

            await_consistency(10, [&alice_cell, &bob_cell, &carol_cell])
                .await
                .unwrap();

            // Now the action appears in alice's activty.
            let alice_activity: AgentActivity = bob_conductor
                .call(
                    &bob,
