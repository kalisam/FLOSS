                                    Lib => "lib.rs",
                                    Bin => "main.rs",
                                }
                            ),
                            match &project.ty {
                                Lib => "",
                                Bin => "fn main() {}",
                            },
                        );

                    let project_builder = if let Some(changelog) = &project.changelog {
                        project_builder.file(format!("crates/{}/CHANGELOG.md", &name), changelog)
                    } else {
                        project_builder
                    };

                    if let Some(readme) = &project.readme {
                        project_builder.file(format!("crates/{}/README.md", &name), readme)
                    } else {
                        project_builder
                    }
                });

        let workspace_project = project_builder.build();

        let workspace_mocker = Self {
            dir,
            projects,
            workspace_repo: git::init(&workspace_project.root()),
            workspace_project,
        };

        workspace_mocker.commit(None);

        Ok(workspace_mocker)
    }

    pub fn root(&self) -> std::path::PathBuf {
        self.workspace_project.root()
    }

    pub fn add_or_replace_file(&self, path: &str, content: &str) {
        self.workspace_project.change_file(path, content);
    }

    pub fn commit(&self, tag: Option<&str>) -> String {
        git::add(&self.workspace_repo);
        let commit = git::commit(&self.workspace_repo).to_string();

        if let Some(tag) = tag {
            let _ = self.tag(tag);
        }

        commit
    }

    pub fn tag(&self, tag: &str) {
        git::tag(&self.workspace_repo, tag)
    }

    pub fn head(&self) -> Fallible<String> {
        self.workspace_repo
            .revparse_single("HEAD")
            .context("revparse HEAD")
            .map(|o| o.id())
            .map(|id| id.to_string())
    }

    pub fn update_lockfile(&self) -> Fallible<()> {
        let mut cmd = std::process::Command::new("cargo");
        cmd.args(
            &[vec![
                "update",
                "--workspace",
                "--offline",
                "--verbose",
                "--manifest-path",
                &format!("{}/Cargo.toml", self.root().to_string_lossy()),
            ]]
            .concat(),
        );
        debug!("running command: {:?}", cmd);

        let mut cmd = cmd.spawn()?;
        let cmd_status = cmd.wait()?;
        if !cmd_status.success() {
            bail!("running {:?} failed: \n{:?}", cmd, cmd.stderr);
        }

        Ok(())
    }
}

/// Expected changelog after aggregation.
pub fn example_workspace_1_aggregated_changelog(crate_order: Vec<String>) -> String {
    let change_fragments: HashMap<String, String> = vec![
        (
            "crate_a",
            r#"
## [crate_a](crates/crate_a/CHANGELOG.md#unreleased)
### Added

- `InstallAppBundle`
- `DnaSource`

### Removed

- BREAKING:  `InstallAppDnaPayload`
- BREAKING: `DnaSource(Path)`
    "#,
        ),
        (
            "crate_b",
            r#"
## [crate_b](crates/crate_b/CHANGELOG.md#unreleased)

### Changed
- `Signature` is a 64 byte 'secure primitive'
    "#,
        ),
        (
            "crate_c",
            r#"
## [crate_c](crates/crate_c/CHANGELOG.md#unreleased)
Awesome changes!

### Breaking
Breaking changes, be careful.
    "#,
        ),
        (
            "crate_e",
            r#"
## [crate_e](crates/crate_e/CHANGELOG.md#unreleased)
Awesome changes!
    "#,
        ),
    ]
    .into_iter()
    .map(|(name, frag)| (name.to_string(), frag.trim().to_string()))
    .collect();

    let fragments = crate_order
        .into_iter()
        .filter_map(|name| change_fragments.get(&name))
        .join("\n\n");

    crate::changelog::sanitize(indoc::formatdoc!(
        r#"
        # Changelog
        This file conveniently consolidates all of the crates individual CHANGELOG.md files and groups them by timestamps at which crates were released.
        The file is updated every time one or more crates are released.

        The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).
        This project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

        # [Unreleased]
        The text beneath this heading will be retained which allows adding overarching release notes.

        {fragments}

        # [20210304.120604]
        This will include the hdk-0.0.100 release.

        ## [hdk-0.0.100](crates/hdk/CHANGELOG.md#0.0.100)

        ### Changed
        - hdk: fixup the autogenerated hdk documentation.
        "#,
        fragments = fragments
    ))
}

/// A workspace to test changelogs and change detection.
/// crate_a -> crate_b -> crate_g
/// crate_b -> []
/// crate_c -> []
/// crate_d -> []
/// crate_e -> []
/// crate_f -> []
/// crate_g -> []
pub fn example_workspace_1<'a>() -> Fallible<WorkspaceMocker> {
    use crate::tests::workspace_mocker::{self, MockProject, WorkspaceMocker};

    let members = vec![
        MockProject {
            name: "crate_a".to_string(),
            version: "0.0.1".to_string(),
            dependencies: vec![
                r#"crate_b = { path = "../crate_b", version = "=0.0.0-alpha.1" }"#.to_string(),
            ],
            excluded: false,
            ty: workspace_mocker::MockProjectType::Bin,
            changelog: Some(
                indoc::indoc!(
                    r#"
                    ---
                    semver_increment_mode: minor
                    default_semver_increment_mode: patch
                    ---
                    # Changelog

                    The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).
                    This project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

                    *Note: Versions 0.0.52-alpha2 and older are part belong to previous iterations of the Holochain architecture and are not tracked here.*

                    ## Unreleased

                    ### Added

                    - `InstallAppBundle`
                    - `DnaSource`

                    ### Removed

                    - BREAKING:  `InstallAppDnaPayload`
                    - BREAKING: `DnaSource(Path)`

                    ## 0.0.1

                    This is the first version number for the version of Holochain with a refactored state model (you may see references to it as Holochain RSM).
                    "#
                )
                .to_string(),
            ),
            .. Default::default()
        },
        MockProject {
            name: "crate_b".to_string(),
            version: "0.0.0-alpha.1".to_string(),
            dependencies: vec![
                r#"crate_g = { path = "../crate_g", version = "=0.0.1" }"#.to_string(),
            ],
            excluded: false,
            ty: workspace_mocker::MockProjectType::Lib,
            changelog: Some(indoc::formatdoc!(
                r#"
                ---
                ---
                # Changelog
                The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).
                This project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

                ## [Unreleased]

                ### Changed
                - `Signature` is a 64 byte 'secure primitive'

                [Unreleased]: https://duckduckgo.com/?q=version&t=hd&va=u
                "#
            )),
            .. Default::default()
        },
        MockProject {
            name: "crate_c".to_string(),
            version: "0.0.1".to_string(),
            dependencies: vec![],
            excluded: false,
            ty: workspace_mocker::MockProjectType::Lib,
            changelog: Some(indoc::formatdoc!(
                r#"
                ---
                unreleasable: true
                default_unreleasable: true
                ---
                # Changelog
                Hello

                ## [Unreleased]
                Awesome changes!

                ### Breaking
                Breaking changes, be careful.

                [Unreleased]: file:///dev/null
                "#
            )),
            .. Default::default()
        },
        MockProject {
            name: "crate_d".to_string(),
            version: "0.0.1".to_string(),
            dependencies: vec![],
            excluded: true,
            ty: workspace_mocker::MockProjectType::Bin,
            .. Default::default()
        },
        MockProject {
            name: "crate_e".to_string(),
            version: "0.0.1-dev.0".to_string(),
            dependencies: vec![],
            excluded: false,
            ty: workspace_mocker::MockProjectType::Lib,
            changelog: Some(indoc::formatdoc!(
                r#"
                # Changelog
                Hello. This crate is releasable.

                ## [Unreleased]
                Awesome changes!

                [Unreleased]: file:///dev/null
                "#
            )),
            .. Default::default()
        },
        MockProject {
            name: "crate_f".to_string(),
            version: "0.2.0".to_string(),
            dependencies: vec![],
            excluded: false,
            ty: workspace_mocker::MockProjectType::Lib,
            changelog: Some(indoc::formatdoc!(
                    r#"
                    # Changelog
                    Hello. This crate is releasable.

                    ## Unreleased
                    "#
                )),
            .. Default::default()
        },
        MockProject {
            name: "crate_g".to_string(),
            version: "0.0.1".to_string(),
            dependencies: vec![],
            excluded: false,
            ty: workspace_mocker::MockProjectType::Lib,
            changelog: Some(indoc::formatdoc!(
                    r#"
                    # Changelog
                    Hello. This crate is releasable.

                    ## Unreleased
                    "#
                )),
            .. Default::default()
        },
    ];

    let workspace_mocker = WorkspaceMocker::try_new(
        Some(indoc::indoc! {r#"
        # Changelog
        This file conveniently consolidates all of the crates individual CHANGELOG.md files and groups them by timestamps at which crates were released.
        The file is updated every time one or more crates are released.

        The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).
        This project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

        # [Unreleased]
        The text beneath this heading will be retained which allows adding overarching release notes.

        ## Something outdated maybe
        This will be removed by aggregation.

        ## [crate_a](crates/crate_a/CHANGELOG.md#unreleased)
        ### Added

        - `InstallAppBundle`

        ## [crate_c](crates/crate_c/CHANGELOG.md#unreleased)
        Awesome changes!

        ### Breaking
        Breaking changes, be careful.

        ## [crate_f](crates/crate_f/CHANGELOG.md#unreleased)
        This will be released in the future.

        # [20210304.120604]
        This will include the hdk-0.0.100 release.

        ## [hdk-0.0.100](crates/hdk/CHANGELOG.md#0.0.100)

        ### Changed
        - hdk: fixup the autogenerated hdk documentation.
        "#
        }),
        members,
    )?;

    // todo: derive the tag from a function
    workspace_mocker.tag("crate_a-0.0.1");
    workspace_mocker.add_or_replace_file(
        "crates/crate_a/README.md",
        indoc::indoc! {r#"
            # Example

            Some changes
            "#,
        },
    );
    workspace_mocker.commit(None);

    // todo: derive the tag from a function
    workspace_mocker.add_or_replace_file(
        "crates/crate_b/README.md",
        indoc::indoc! {r#"
            # Example

            Some changes
            "#,
        },
    );
    workspace_mocker.commit(None);

    workspace_mocker.add_or_replace_file(
        "crates/crate_e/README.md",
        indoc::indoc! {r##"
            # Example

            Some changes
            "##,
        },
    );
    workspace_mocker.commit(None);

    workspace_mocker.add_or_replace_file(
        "crates/crate_f/README.md",
        indoc::indoc! {r#"
            # Example

            Some changes
            "#,
        },
    );
    workspace_mocker.commit(None);

    workspace_mocker.update_lockfile()?;
    workspace_mocker.commit(None);

    Ok(workspace_mocker)
}

/// A workspace to test dependencies and crate sorting.
/// crate_a -> [crate_b, crate_c]
/// crate_b -> []
/// crate_c -> [crate_b]
/// crate_d -> [crate_a]
pub fn example_workspace_2<'a>() -> Fallible<WorkspaceMocker> {
    use crate::tests::workspace_mocker::{self, MockProject, WorkspaceMocker};

    let members = vec![
        MockProject {
            name: "crate_a".to_string(),
            version: "0.0.1".to_string(),
            dependencies: vec![
                r#"crate_b = { path = "../crate_b", version = "0.0.1" }"#.to_string(),
                r#"crate_c = { path = "../crate_c", version = "0.0.1" }"#.to_string(),
            ],
            excluded: false,
            ty: workspace_mocker::MockProjectType::Bin,
            ..Default::default()
        },
        MockProject {
            name: "crate_b".to_string(),
            version: "0.0.1".to_string(),
            dependencies: vec![],
            excluded: false,
            ty: workspace_mocker::MockProjectType::Bin,
            ..Default::default()
        },
        MockProject {
            name: "crate_c".to_string(),
            version: "0.0.1".to_string(),
            dependencies: vec![
                r#"crate_b = { path = "../crate_b", version = "0.0.1" }"#.to_string()
            ],
            excluded: false,
            ty: workspace_mocker::MockProjectType::Lib,
            changelog: None,
            ..Default::default()
        },
        MockProject {
            name: "crate_d".to_string(),
            version: "0.0.1".to_string(),
            dependencies: vec![
                r#"crate_a = { path = "../crate_a", version = "0.0.1" }"#.to_string()
            ],
            excluded: false,
            ty: workspace_mocker::MockProjectType::Bin,
            ..Default::default()
        },
    ];

    WorkspaceMocker::try_new(None, members)
}

/// A workspace that is blocked by an unreleasable dependency.
pub fn example_workspace_3<'a>() -> Fallible<WorkspaceMocker> {
    use crate::tests::workspace_mocker::{self, MockProject, WorkspaceMocker};

    let members = vec![
        MockProject {
            name: "crate_a".to_string(),
            version: "0.0.1".to_string(),
            dependencies: vec![
                r#"crate_b = { path = "../crate_b", version = "0.0.1", optional = true }"#
                    .to_string(),
            ],
            dev_dependencies: vec![
                r#"crate_b = { path = "../crate_b", version = "0.0.1", optional = false }"#
                    .to_string(),
            ],
            excluded: false,
            ty: workspace_mocker::MockProjectType::Bin,
            changelog: Some(indoc::formatdoc!(
                r#"
                # Changelog
                Hello. This crate is releasable.

                ## [Unreleased]
                Awesome changes!

                [Unreleased]: file:///dev/null
                "#
            )),
            ..Default::default()
        },
        MockProject {
            name: "crate_b".to_string(),
            version: "0.0.1".to_string(),
            dependencies: vec![
                // todo: debug dependency cycle
                // r#"crate_b = { path = "../crate_b", version = "0.0.1" }"#.to_string(),
            ],
            excluded: false,
            ty: workspace_mocker::MockProjectType::Bin,
            changelog: Some(indoc::formatdoc!(
                r#"
                ---
                unreleasable: true
                ---
                # Changelog
                Hello. This crate is releasable.

                ## [Unreleased]
                Awesome changes!

                [Unreleased]: file:///dev/null
                "#
            )),
            ..Default::default()
        },
    ];

    let workspace_mocker = WorkspaceMocker::try_new(None, members)?;

    Ok(workspace_mocker)
}

/// A workspace to test some release blockers
pub fn example_workspace_4<'a>() -> Fallible<WorkspaceMocker> {
    use crate::tests::workspace_mocker::{self, MockProject, WorkspaceMocker};

    let members = vec![
        MockProject {
            name: "wildcard_dependency".to_string(),
            version: "0.0.1".to_string(),
            dependencies: vec![],
            dev_dependencies: vec![
                r#"wildcard_dependency = {path = ".", version = '*'}"#.to_string()
            ],
            excluded: false,
            ty: workspace_mocker::MockProjectType::Bin,
            changelog: Some(indoc::formatdoc!(
                r#"
                # Changelog
                "#
            )),
            ..Default::default()
        },
        MockProject {
            name: "no_description".to_string(),
            version: "0.0.1".to_string(),
            dependencies: vec![],
            excluded: false,
            ty: workspace_mocker::MockProjectType::Bin,
            changelog: Some(indoc::formatdoc!(
                r#"
                # Changelog
                "#
            )),
            description: None,
            ..Default::default()
        },
        MockProject {
            name: "no_license".to_string(),
            version: "0.0.1".to_string(),
            dependencies: vec![],
            excluded: false,
            ty: workspace_mocker::MockProjectType::Bin,
            changelog: Some(indoc::formatdoc!(
                r#"
                # Changelog
                "#
            )),
            license: None,
            ..Default::default()
        },
        MockProject {
            name: "keyword_invalid_char".to_string(),
            version: "0.0.1".to_string(),
            dependencies: vec![],
            excluded: false,
            ty: workspace_mocker::MockProjectType::Bin,
            changelog: Some(indoc::formatdoc!(
                r#"
                # Changelog
                "#
            )),
            keywords: vec!["1nvalid".to_string()],
            ..Default::default()
        },
        MockProject {
            name: "keyword_toolong".to_string(),
            version: "0.0.1".to_string(),
            dependencies: vec![],
            excluded: false,
            ty: workspace_mocker::MockProjectType::Bin,
            changelog: Some(indoc::formatdoc!(
                r#"
                # Changelog
                "#
            )),
            keywords: vec!["toolongtoolongtoolongtoolongtoolong".to_string()],
            ..Default::default()
        },
        MockProject {
            name: "keyword_toomany".to_string(),
            version: "0.0.1".to_string(),
            dependencies: vec![],
            excluded: false,
            ty: workspace_mocker::MockProjectType::Bin,
            changelog: Some(indoc::formatdoc!(
                r#"
                # Changelog
                "#
            )),
            keywords: vec![
                "one".to_string(),
                "two".to_string(),
                "three".to_string(),
                "four".to_string(),
                "five".to_string(),
                "many".to_string(),
            ],
            ..Default::default()
        },
        MockProject {
            name: "disallowed_semver_increment_mode".to_string(),
            version: "0.0.1".to_string(),
            dependencies: vec![],
            excluded: false,
            ty: workspace_mocker::MockProjectType::Bin,
            changelog: Some(indoc::formatdoc!(
                r#"---
                default_semver_increment_mode: minor
                ---
                # Changelog
                "#
            )),
            keywords: vec![],
            ..Default::default()
        },
    ];

    let workspace_mocker = WorkspaceMocker::try_new(
        Some(indoc::indoc! {r#"
        # Changelog
        "#}),
        members,
    )?;

    Ok(workspace_mocker)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn example() {
        let workspace_mocker = example_workspace_1().unwrap();
        workspace_mocker.add_or_replace_file(
            "README.md",
            indoc::indoc! {r#"
            # Example

            Some changes
            "#,
            },
        );
        let before = workspace_mocker.head().unwrap();
        let after = workspace_mocker.commit(None);

        assert_ne!(before, after);
        assert_eq!(after, workspace_mocker.head().unwrap());
    }
}



================================================
File: crates/test_utils/wasm/README.md
================================================
# Wasm test utilities

This crate contains:

- several small crates that compile to Wasm and are used as test values.
- `enum TestWasm` which enumerates all of those crates.
-  `impl From<TestWasm> for DnaWasm` to obtain the compiled Wasm artifacts for those crates.
- a `build.rs` file that builds all those crates for compile-time inclusion in the library.

These Wasm crates _directly_ test the host/guest implementation of Holochain without going through an HDK or other convenience interface.

We do this to make sure that it stays reasonably easy to interact with Holochain without using the `hdk` and `holochain_wasmer_*` crates.

The tests that run this Wasm generally sit in the [`ribosome.rs` module in core][ribosome]. This is necessary because the Wasm crates depend on certain global functions that core defines and needs to inject.

[ribosome]: https://github.com/holochain/holochain/blob/2b83a9340fba999e8c32adb9c342bd268f0ef480/crates/holochain/src/core/ribosome.rs



================================================
File: crates/test_utils/wasm/build.rs
================================================
use std::io::Write;
use std::path::PathBuf;
use std::process::Stdio;

fn main() {
    let should_build = std::env::var_os("CARGO_FEATURE_BUILD").is_some();
    let only_check = std::env::var_os("CARGO_FEATURE_ONLY_CHECK").is_some();
    let enable_unstable_functions = std::env::var_os("CARGO_FEATURE_UNSTABLE_FUNCTIONS").is_some();

    if !(should_build || only_check) {
        return;
    }

    let wasms_path = format!("{}/{}/", env!("CARGO_MANIFEST_DIR"), "wasm_workspace");
    println!("cargo:rerun-if-changed=Cargo.toml");
    println!("cargo:rerun-if-changed=../../../Cargo.lock");

    // We want to rebuild if anything upstream of the wasms has changed.
    // Since we use local paths, changes to those crates will not affect the
    // Cargo.toml, so we check each upstream local source directory directly.
    for dir in parse_cargo_toml_local_dependency_paths() {
        for item in walkdir::WalkDir::new(dir)
            .into_iter()
            .filter_map(|e| e.ok())
            .filter(|e| e.file_type().is_file())
        {
            println!("cargo:rerun-if-changed={}", item.path().display());
        }
    }
    // If any of the files in the wasms change rebuild
    for item in walkdir::WalkDir::new(wasms_path.clone())
        .into_iter()
        .filter_entry(|e| {
            e.file_name()
                .to_str()
                .map(|e| e != "target")
                .unwrap_or(false)
        })
        .filter_map(|e| e.ok())
        .filter(|e| e.file_type().is_file())
    {
        println!("cargo:rerun-if-changed={}", item.path().display());
    }
    let wasm_out = std::env::var_os("HC_TEST_WASM_DIR");
    let cargo_command = std::env::var_os("CARGO");
    let cargo_command = cargo_command.as_deref().unwrap_or_else(|| "cargo".as_ref());

    build_test_wasms(
        &wasm_out,
        cargo_command,
        should_build,
        false,
        enable_unstable_functions,
        &wasms_path,
    );
    build_test_wasms(
        &wasm_out,
        cargo_command,
        should_build,
        true,
        enable_unstable_functions,
        &wasms_path,
    );
}

fn build_test_wasms(
    wasm_out: &Option<std::ffi::OsString>,
    cargo_command: &std::ffi::OsStr,
    should_build: bool,
    build_integrity_zomes: bool,
    enable_unstable_functions: bool,
    wasms_path: &str,
) {
    let paths = list_wasms(PathBuf::from(wasms_path));
    for path in paths {
        let project = load_project_toml(path.clone());
        let mut cmd = std::process::Command::new(cargo_command);
        cmd.env_remove("RUSTFLAGS");
        cmd.env_remove("CARGO_BUILD_RUSTFLAGS");
        cmd.env_remove("CARGO_ENCODED_RUSTFLAGS");
        if should_build {
            cmd.stdout(Stdio::piped());
            cmd.stderr(Stdio::piped());
            cmd.env("RUSTFLAGS", "-C opt-level=z");
            cmd.arg("build")
                .arg("--manifest-path")
                .arg(&path)
                .arg("--release")
                .arg("--target")
                .arg("wasm32-unknown-unknown");

            if enable_unstable_functions && defines_feature(&project, "unstable-functions") {
                cmd.arg("--features").arg("unstable-functions");
            }
        } else {
            cmd.arg("check").arg("--manifest-path").arg(&path);
        }
        if build_integrity_zomes {
            let mut features = "".to_string();
            if defines_feature(&project, "integrity") {
                features.push_str("integrity");
            }
            if enable_unstable_functions && defines_feature(&project, "unstable-functions") {
                if !features.is_empty() {
                    features.push(',');
                }
                features.push_str("unstable-functions");
            }

            cmd.arg("--examples");
            cmd.arg("--no-default-features");

            if !features.is_empty() {
                cmd.arg("--features");
                cmd.arg(features);
            }
        }
        match wasm_out {
            Some(wasm_out) => {
                cmd.env("CARGO_TARGET_DIR", wasm_out);
            }
            None => {
                cmd.env("CARGO_TARGET_DIR", format!("{}/target", wasms_path));
            }
        }
        let output = cmd.output().unwrap();
        if !output.status.success() {
            std::io::stderr().write_all(&output.stderr).ok();
            eprintln!("While building {:?}", path);
            assert!(output.status.success());
        }
    }
}

/// Return the list of local path dependencies specified in the Cargo.toml
fn parse_cargo_toml_local_dependency_paths() -> Vec<String> {
    let cargo_toml: toml::Value = std::fs::read_to_string("Cargo.toml")
        .unwrap()
        .parse()
        .unwrap();
    let mut table = toml_table(cargo_toml);

    let deps: Vec<_> = match (
        table.remove("dependencies"),
        table.remove("dev-dependencies"),
    ) {
        (Some(deps), Some(dev_deps)) => toml_table(deps)
            .values()
            .chain(toml_table(dev_deps).values())
            .cloned()
            .collect(),
        (Some(deps), None) => toml_table(deps).values().cloned().collect(),
        (None, Some(dev_deps)) => toml_table(dev_deps).values().cloned().collect(),
        (None, None) => Vec::new(),
    };

    deps.into_iter()
        .filter_map(|v| {
            if let toml::Value::Table(mut table) = v {
                table.remove("path").map(toml_string)
            } else {
                None
            }
        })
        .collect()
}

fn list_wasms(wasms_path: PathBuf) -> Vec<PathBuf> {
    let project = std::fs::read_to_string(wasms_path.join("Cargo.toml"))
        .expect("Could not find workspace Cargo.toml");
    let project = toml_table(
        toml::from_str::<toml::Value>(&project).expect("Could not parse workspace Cargo.toml"),
    );
    let workspace = toml_table(
        project
            .get("workspace")
            .expect("Could not find workspace in Cargo.toml")
            .clone(),
    );
    let members = toml_array(
        workspace
            .get("members")
            .expect("Could not find members in workspace")
            .clone(),
    );
    members
        .into_iter()
        .map(|v| {
            let member = toml_string(v);
            let path = wasms_path.join(member);
            path.join("Cargo.toml")
        })
        .collect()
}

fn load_project_toml(cargo_toml: PathBuf) -> toml::value::Table {
    let project = std::fs::read_to_string(cargo_toml).expect("Could not load Cargo.toml");

    toml_table(toml::from_str::<toml::Value>(&project).expect("Could not parse Cargo.toml"))
}

fn defines_feature(project: &toml::value::Table, feature: &str) -> bool {
    if let Some(features) = project.get("features") {
        let features = toml_table(features.clone());
        if features.contains_key(feature) {
            return true;
        }
    }

    false
}

/// Interpret toml Value as a String or panic
fn toml_string(value: toml::Value) -> String {
    if let toml::Value::String(string) = value {
        string
    } else {
        panic!("Expected TOML string, got: {:?}", value)
    }
}

/// Interpret toml Value as a Table or panic
fn toml_table(value: toml::Value) -> toml::value::Table {
    if let toml::Value::Table(table) = value {
        table
    } else {
        panic!("Expected TOML table, got: {:?}", value)
    }
}

/// Interpret toml Value as a Table or panic
fn toml_array(value: toml::Value) -> toml::value::Array {
    if let toml::Value::Array(array) = value {
        array
    } else {
        panic!("Expected TOML array, got: {:?}", value)
    }
}



================================================
File: crates/test_utils/wasm/Cargo.toml
================================================
[package]
name = "holochain_wasm_test_utils"
version = "0.5.0-dev.21"
authors = ["thedavidmeister", "thedavidmeister@gmail.com"]
edition = "2021"
description = "Utilities for Wasm testing for Holochain"
license = "Apache-2.0"
documentation = "https://docs.rs/holochain_wasm_test_utils"

[lib]
name = "holochain_wasm_test_utils"
crate-type = ["cdylib", "rlib"]
path = "./src/lib.rs"

[features]
default = []
build = []
only_check = []
unstable-functions = []

# reminder - do not use workspace deps
[dependencies]
holochain_types = { path = "../../holochain_types", version = "^0.5.0-dev.21"}
strum = "0.18.0"
strum_macros = "0.18.0"
holochain_util = { version = "^0.5.0-dev.1", path = "../../holochain_util" }

[build-dependencies]
toml = "0.8"
walkdir = "2.3.1"



================================================
File: crates/test_utils/wasm/CHANGELOG.md
================================================
---
default_semver_increment_mode: !pre_minor dev
---
# Changelog

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/). This project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## \[Unreleased\]

## 0.5.0-dev.21

## 0.5.0-dev.20

## 0.5.0-dev.19

## 0.5.0-dev.18

## 0.5.0-dev.17

## 0.5.0-dev.16

## 0.5.0-dev.15

## 0.5.0-dev.14

## 0.5.0-dev.13

## 0.5.0-dev.12

## 0.5.0-dev.11

## 0.5.0-dev.10

## 0.5.0-dev.9

## 0.5.0-dev.8

## 0.5.0-dev.7

## 0.5.0-dev.6

## 0.5.0-dev.5

## 0.5.0-dev.4

## 0.5.0-dev.3

## 0.5.0-dev.2

## 0.5.0-dev.1

## 0.5.0-dev.0

## 0.4.0

## 0.4.0-dev.27

## 0.4.0-dev.26

## 0.4.0-dev.25

## 0.4.0-dev.24

## 0.4.0-dev.23

## 0.4.0-dev.22

## 0.4.0-dev.21

## 0.4.0-dev.20

## 0.4.0-dev.19

## 0.4.0-dev.18

## 0.4.0-dev.17

## 0.4.0-dev.16

## 0.4.0-dev.15

## 0.4.0-dev.14

## 0.4.0-dev.13

## 0.4.0-dev.12

## 0.4.0-dev.11

## 0.4.0-dev.10

## 0.4.0-dev.9

## 0.4.0-dev.8

## 0.4.0-dev.7

## 0.4.0-dev.6

## 0.4.0-dev.5

## 0.4.0-dev.4

## 0.4.0-dev.3

## 0.4.0-dev.2

## 0.4.0-dev.1

## 0.4.0-dev.0

## 0.3.0

## 0.3.0-beta-dev.45

## 0.3.0-beta-dev.44

## 0.3.0-beta-dev.43

## 0.3.0-beta-dev.42

## 0.3.0-beta-dev.41

## 0.3.0-beta-dev.40

## 0.3.0-beta-dev.39

## 0.3.0-beta-dev.38

## 0.3.0-beta-dev.37

## 0.3.0-beta-dev.36

## 0.3.0-beta-dev.35

## 0.3.0-beta-dev.34

## 0.3.0-beta-dev.33

## 0.3.0-beta-dev.32

## 0.3.0-beta-dev.31

## 0.3.0-beta-dev.30

## 0.3.0-beta-dev.29

## 0.3.0-beta-dev.28

## 0.3.0-beta-dev.27

## 0.3.0-beta-dev.26

## 0.3.0-beta-dev.25

## 0.3.0-beta-dev.24

## 0.3.0-beta-dev.23

## 0.3.0-beta-dev.22

## 0.3.0-beta-dev.21

## 0.3.0-beta-dev.20

## 0.3.0-beta-dev.19

## 0.3.0-beta-dev.18

## 0.3.0-beta-dev.17

## 0.3.0-beta-dev.16

## 0.3.0-beta-dev.15

## 0.3.0-beta-dev.14

## 0.3.0-beta-dev.13

## 0.3.0-beta-dev.12

## 0.3.0-beta-dev.11

## 0.3.0-beta-dev.10

## 0.3.0-beta-dev.9

## 0.3.0-beta-dev.8

## 0.3.0-beta-dev.7

## 0.3.0-beta-dev.6

## 0.3.0-beta-dev.5

## 0.3.0-beta-dev.4

## 0.3.0-beta-dev.3

## 0.3.0-beta-dev.2

## 0.3.0-beta-dev.1

## 0.3.0-beta-dev.0

## 0.2.0

## 0.2.0-beta-rc.7

## 0.2.0-beta-rc.6

## 0.2.0-beta-rc.5

## 0.2.0-beta-rc.4

## 0.2.0-beta-rc.3

## 0.2.0-beta-rc.2

## 0.2.0-beta-rc.1

## 0.2.0-beta-rc.0

## 0.1.0

## 0.1.0-beta-rc.3

## 0.1.0-beta-rc.2

## 0.1.0-beta-rc.1

## 0.1.0-beta-rc.0

## 0.0.71

## 0.0.70

## 0.0.69

## 0.0.68

## 0.0.67

## 0.0.66

## 0.0.65

## 0.0.64

## 0.0.63

## 0.0.62

## 0.0.61

## 0.0.60

## 0.0.59

## 0.0.58

## 0.0.57

## 0.0.56

## 0.0.55

## 0.0.54

## 0.0.53

## 0.0.52

## 0.0.51

## 0.0.50

## 0.0.49

## 0.0.48

## 0.0.47

## 0.0.46

## 0.0.45

## 0.0.44

## 0.0.43

## 0.0.42

## 0.0.41

## 0.0.40

## 0.0.39

## 0.0.38

## 0.0.37

## 0.0.36

## 0.0.35

## 0.0.34

## 0.0.33

## 0.0.32

## 0.0.31

## 0.0.30

## 0.0.29

## 0.0.28

## 0.0.27

## 0.0.26

## 0.0.25

## 0.0.24

## 0.0.23

## 0.0.22

## 0.0.21

## 0.0.20

## 0.0.19

## 0.0.18

## 0.0.17

## 0.0.16

## 0.0.15

## 0.0.14

## 0.0.13

## 0.0.12

## 0.0.11

## 0.0.10

## 0.0.9

## 0.0.8

## 0.0.7

## 0.0.6

## 0.0.5

## 0.0.4

## 0.0.3

## 0.0.2

## 0.0.1



================================================
File: crates/test_utils/wasm/src/lib.rs
================================================
use std::ffi::OsString;
use std::path::PathBuf;

use holochain_types::prelude::*;
use strum_macros::EnumIter;

const WASM_WORKSPACE_TARGET: &str = "wasm_workspace/target";

#[derive(EnumIter, Clone, Copy)]
pub enum TestIntegrityWasm {
    IntegrityZome,
    HcStressTestIntegrity,
}

#[derive(EnumIter, Clone, Copy)]
pub enum TestCoordinatorWasm {
    CoordinatorZome,
    CoordinatorZomeUpdate,
    HcStressTestCoordinator,
}

#[derive(EnumIter, Clone, Copy)]
pub enum TestWasm {
    AgentInfo,
    AgentKeyLineage,
    Anchor,
    AppValidation,
    Bench,
    Capability,
    Clone,
    CounterSigning,
    Create,
    Crd,
    Crud,
    Debug,
    DnaProperties,
    EntryDefs,
    EmitSignal,
    PostCommitSignal,
    HashEntry,
    Foo,
    GenesisSelfCheckValidLegacy,
    GenesisSelfCheckValidV1,
    GenesisSelfCheckInvalid,
    GenesisSelfCheckValid,
    GenesisSelfCheckRequiresProperties,
    HashPath,
    HdkExtern,
    InitFail,
    InitInvalidParams,
    InitPass,
    InitSingle,
    Link,
    MigrateInitial,
    MigrateNew,
    MultipleCalls,
    MustGet,
    MustGetAgentActivity,
    PostCommitSuccess,
    PostCommitVolley,
    Query,
    RandomBytes,
    Schedule,
    XSalsa20Poly1305,
    SerRegression,
    Sign,
    SysTime,
    TheIncredibleHalt,
    Update,
    Validate,
    ValidateLink,
    ValidateInvalid,
    ValidateCreateLinkInvalid,
    ValidateValid,
    ValidateCreateLinkValid,
    ValidateRejectAppTypes,
    ValidateInvalidParams,
    WhoAmI,
    ZomeInfo,
}
/// Utility type for combining a test wasm's coordinator
/// zome with it's integrity zome.
pub struct TestWasmPair<I, C = I> {
    pub integrity: I,
    pub coordinator: C,
}

pub type TestZomes = TestWasmPair<IntegrityZome, CoordinatorZome>;

impl TestWasm {
    /// Get the [`ZomeName`] for the integrity zome.
    pub fn integrity_zome_name(self) -> ZomeName {
        TestWasmPair::<ZomeName>::from(self).integrity
    }
    /// Get the [`ZomeName`] for the coordinator zome.
    pub fn coordinator_zome_name(self) -> ZomeName {
        TestWasmPair::<ZomeName>::from(self).coordinator
    }
    /// Get the [`Zome`] for the integrity zome.
    pub fn integrity_zome(self) -> Zome {
        TestWasmPair::<IntegrityZome, CoordinatorZome>::from(self)
            .integrity
            .erase_type()
    }
    /// Get the [`Zome`] for the coordinator zome.
    pub fn coordinator_zome(self) -> Zome {
        TestWasmPair::<IntegrityZome, CoordinatorZome>::from(self)
            .coordinator
            .erase_type()
    }
}

impl From<TestIntegrityWasm> for ZomeName {
    fn from(test_wasm: TestIntegrityWasm) -> ZomeName {
        ZomeName::from(match test_wasm {
            TestIntegrityWasm::IntegrityZome => "integrity_zome",
            TestIntegrityWasm::HcStressTestIntegrity => "files_integrity",
        })
    }
}

impl From<TestCoordinatorWasm> for ZomeName {
    fn from(test_wasm: TestCoordinatorWasm) -> ZomeName {
        ZomeName::from(match test_wasm {
            TestCoordinatorWasm::CoordinatorZome => "coordinator_zome",
            TestCoordinatorWasm::CoordinatorZomeUpdate => "coordinator_zome_update",
            TestCoordinatorWasm::HcStressTestCoordinator => "files",
        })
    }
}

impl From<TestWasm> for ZomeName {
    fn from(test_wasm: TestWasm) -> ZomeName {
        ZomeName::from(match test_wasm {
            TestWasm::AgentInfo => "agent_info",
            TestWasm::AgentKeyLineage => "agent_key_lineage",
            TestWasm::Anchor => "anchor",
            TestWasm::AppValidation => "app_validation",
            TestWasm::Bench => "bench",
            TestWasm::Capability => "capability",
            TestWasm::Clone => "clone",
            TestWasm::CounterSigning => "countersigning",
            TestWasm::Create => "create_entry",
            TestWasm::Crd => "crd",
            TestWasm::Crud => "crud",
            TestWasm::Debug => "debug",
            TestWasm::DnaProperties => "dna_properties",
            TestWasm::EntryDefs => "entry_defs",
            TestWasm::EmitSignal => "emit_signal",
            TestWasm::PostCommitSignal => "post_commit_signal",
            TestWasm::HashEntry => "hash_entry",
            TestWasm::Foo => "foo",
            TestWasm::GenesisSelfCheckValidLegacy => "genesis_self_check_legacy",
            TestWasm::GenesisSelfCheckValidV1 => "genesis_self_check_1",
            TestWasm::GenesisSelfCheckInvalid => "genesis_self_check_invalid",
            TestWasm::GenesisSelfCheckValid => "genesis_self_check_valid",
            TestWasm::GenesisSelfCheckRequiresProperties => {
                "genesis_self_check_requires_properties"
            }
            TestWasm::HashPath => "hash_path",
            TestWasm::HdkExtern => "hdk_extern",
            TestWasm::InitFail => "init_fail",
            TestWasm::InitInvalidParams => "init_invalid_params",
            TestWasm::InitPass => "init_pass",
            TestWasm::InitSingle => "init_single",
            TestWasm::Link => "link",
            TestWasm::MigrateInitial => "migrate_initial",
            TestWasm::MigrateNew => "migrate_new",
            TestWasm::MultipleCalls => "multiple_calls",
            TestWasm::MustGet => "must_get",
            TestWasm::MustGetAgentActivity => "must_get_agent_activity",
            TestWasm::PostCommitSuccess => "post_commit_success",
            TestWasm::PostCommitVolley => "post_commit_volley",
            TestWasm::Query => "query",
            TestWasm::RandomBytes => "random_bytes",
            TestWasm::Schedule => "schedule",
            TestWasm::XSalsa20Poly1305 => "x_salsa20_poly1305",
            TestWasm::SerRegression => "ser_regression",
            TestWasm::Sign => "sign",
            TestWasm::SysTime => "sys_time",
            TestWasm::TheIncredibleHalt => "the_incredible_halt",
            TestWasm::Update => "update_entry",
            TestWasm::Validate => "validate",
            TestWasm::ValidateLink => "validate_link",
            TestWasm::ValidateInvalid => "validate_invalid",
            TestWasm::ValidateCreateLinkInvalid => "validate_link_add_invalid",
            TestWasm::ValidateValid => "validate_valid",
            TestWasm::ValidateCreateLinkValid => "validate_link_add_valid",
            TestWasm::ValidateRejectAppTypes => "validate_reject_app_types",
            TestWasm::ValidateInvalidParams => "validate_invalid_params",
            TestWasm::WhoAmI => "whoami",
            TestWasm::ZomeInfo => "zome_info",
        })
    }
}

impl From<TestWasm> for TestWasmPair<ZomeName> {
    fn from(test_wasm: TestWasm) -> Self {
        let coordinator: ZomeName = test_wasm.into();
        let integrity = ZomeName::new(format!("integrity_{}", coordinator));
        TestWasmPair {
            integrity,
            coordinator,
        }
    }
}

impl From<TestWasm> for PathBuf {
    fn from(test_wasm: TestWasm) -> Self {
        PathBuf::from(match test_wasm {
            TestWasm::AgentInfo => "wasm32-unknown-unknown/release/test_wasm_agent_info.wasm",
            TestWasm::AgentKeyLineage => "wasm32-unknown-unknown/release/test_wasm_agent_key_lineage.wasm",
            TestWasm::Anchor => "wasm32-unknown-unknown/release/test_wasm_anchor.wasm",
            TestWasm::AppValidation => "wasm32-unknown-unknown/release/test_wasm_app_validation.wasm",
            TestWasm::Bench => "wasm32-unknown-unknown/release/test_wasm_bench.wasm",
            TestWasm::Capability => "wasm32-unknown-unknown/release/test_wasm_capability.wasm",
            TestWasm::Clone => "wasm32-unknown-unknown/release/test_wasm_clone.wasm",
            TestWasm::CounterSigning => {
                "wasm32-unknown-unknown/release/test_wasm_countersigning.wasm"
            }
            TestWasm::Create => "wasm32-unknown-unknown/release/test_wasm_create_entry.wasm",
            TestWasm::Crd => "wasm32-unknown-unknown/release/test_wasm_crd.wasm",
            TestWasm::Crud => "wasm32-unknown-unknown/release/test_wasm_crud.wasm",
            TestWasm::Debug => "wasm32-unknown-unknown/release/test_wasm_debug.wasm",
            TestWasm::DnaProperties => {
                "wasm32-unknown-unknown/release/test_wasm_dna_properties.wasm"
            }
            TestWasm::EntryDefs => "wasm32-unknown-unknown/release/test_wasm_entry_defs.wasm",
            TestWasm::EmitSignal => "wasm32-unknown-unknown/release/test_wasm_emit_signal.wasm",
            TestWasm::PostCommitSignal => "wasm32-unknown-unknown/release/test_wasm_post_commit_signal.wasm",
            TestWasm::HashEntry => "wasm32-unknown-unknown/release/test_wasm_hash_entry.wasm",
            TestWasm::Foo => "wasm32-unknown-unknown/release/test_wasm_foo.wasm",
            TestWasm::GenesisSelfCheckValidLegacy => {
                "wasm32-unknown-unknown/release/test_wasm_genesis_self_check_legacy.wasm"
            }
            TestWasm::GenesisSelfCheckValidV1 => {
                "wasm32-unknown-unknown/release/test_wasm_genesis_self_check_1.wasm"
            }
            TestWasm::GenesisSelfCheckInvalid => {
                "wasm32-unknown-unknown/release/test_wasm_genesis_self_check_invalid.wasm"
            }
            TestWasm::GenesisSelfCheckValid => {
                "wasm32-unknown-unknown/release/test_wasm_genesis_self_check_valid.wasm"
            }
            TestWasm::GenesisSelfCheckRequiresProperties => {
                "wasm32-unknown-unknown/release/test_wasm_genesis_self_check_requires_properties.wasm"
            }
            TestWasm::HashPath => "wasm32-unknown-unknown/release/test_wasm_hash_path.wasm",
            TestWasm::HdkExtern => "wasm32-unknown-unknown/release/test_wasm_hdk_extern.wasm",
            TestWasm::InitFail => "wasm32-unknown-unknown/release/test_wasm_init_fail.wasm",
            TestWasm::InitInvalidParams => "wasm32-unknown-unknown/release/test_wasm_init_invalid_params.wasm",
            TestWasm::InitPass => "wasm32-unknown-unknown/release/test_wasm_init_pass.wasm",
            TestWasm::InitSingle => "wasm32-unknown-unknown/release/test_wasm_init_single.wasm",
            TestWasm::Link => "wasm32-unknown-unknown/release/test_wasm_link.wasm",
            TestWasm::MigrateInitial => {
                "wasm32-unknown-unknown/release/test_wasm_migrate_initial.wasm"
            }
            TestWasm::MigrateNew => {
                "wasm32-unknown-unknown/release/test_wasm_migrate_new.wasm"
            },
            TestWasm::MultipleCalls => {
                "wasm32-unknown-unknown/release/test_wasm_multiple_calls.wasm"
            }
            TestWasm::MustGet => "wasm32-unknown-unknown/release/test_wasm_must_get.wasm",
            TestWasm::MustGetAgentActivity => "wasm32-unknown-unknown/release/test_wasm_must_get_agent_activity.wasm",
            TestWasm::PostCommitSuccess => {
                "wasm32-unknown-unknown/release/test_wasm_post_commit_success.wasm"
            }
            TestWasm::PostCommitVolley => {
                "wasm32-unknown-unknown/release/test_wasm_post_commit_volley.wasm"
            }
            TestWasm::Query => "wasm32-unknown-unknown/release/test_wasm_query.wasm",
            TestWasm::RandomBytes => "wasm32-unknown-unknown/release/test_wasm_random_bytes.wasm",
            TestWasm::Schedule => "wasm32-unknown-unknown/release/test_wasm_schedule.wasm",
            TestWasm::XSalsa20Poly1305 => {
                "wasm32-unknown-unknown/release/test_wasm_x_salsa20_poly1305.wasm"
            }
            TestWasm::SerRegression => {
                "wasm32-unknown-unknown/release/test_wasm_ser_regression.wasm"
            }
            TestWasm::Sign => "wasm32-unknown-unknown/release/test_wasm_sign.wasm",
            TestWasm::SysTime => "wasm32-unknown-unknown/release/test_wasm_sys_time.wasm",
            TestWasm::TheIncredibleHalt => {
                "wasm32-unknown-unknown/release/test_wasm_the_incredible_halt.wasm"
            }
            TestWasm::Update => "wasm32-unknown-unknown/release/test_wasm_update_entry.wasm",
            TestWasm::Validate => "wasm32-unknown-unknown/release/test_wasm_validate.wasm",
            TestWasm::ValidateLink => "wasm32-unknown-unknown/release/test_wasm_validate_link.wasm",
            TestWasm::ValidateInvalid => {
                "wasm32-unknown-unknown/release/test_wasm_validate_invalid.wasm"
            }
            TestWasm::ValidateCreateLinkInvalid => {
                "wasm32-unknown-unknown/release/test_wasm_validate_link_add_invalid.wasm"
            }
            TestWasm::ValidateValid => {
                "wasm32-unknown-unknown/release/test_wasm_validate_valid.wasm"
            }
            TestWasm::ValidateCreateLinkValid => {
                "wasm32-unknown-unknown/release/test_wasm_validate_link_add_valid.wasm"
            }
            TestWasm::ValidateRejectAppTypes => {
                "wasm32-unknown-unknown/release/test_wasm_validate_reject_app_types.wasm"
            }
            TestWasm::ValidateInvalidParams => "wasm32-unknown-unknown/release/test_wasm_validate_invalid_params.wasm",
            TestWasm::WhoAmI => "wasm32-unknown-unknown/release/test_wasm_whoami.wasm",
            TestWasm::ZomeInfo => "wasm32-unknown-unknown/release/test_wasm_zome_info.wasm",
        })
    }
}

impl From<TestWasm> for DnaWasm {
    fn from(t: TestWasm) -> Self {
        DnaWasm::from(get_code(PathBuf::from(t)))
    }
}

impl From<TestWasm> for Vec<DnaWasm> {
    fn from(t: TestWasm) -> Self {
        let TestWasmPair {
            integrity,
            coordinator,
        } = TestWasmPair::<DnaWasm>::from(t);
        vec![integrity, coordinator]
    }
}

impl From<TestIntegrityWasm> for DnaWasm {
    fn from(t: TestIntegrityWasm) -> Self {
        DnaWasm::from(get_code(PathBuf::from(t)))
    }
}

impl From<TestCoordinatorWasm> for DnaWasm {
    fn from(t: TestCoordinatorWasm) -> Self {
        DnaWasm::from(get_code(PathBuf::from(t)))
    }
}

impl From<TestWasm> for TestWasmPair<DnaWasm> {
    fn from(t: TestWasm) -> Self {
        TestWasmPair::<PathBuf>::from(t).into()
    }
}

impl From<TestWasm> for TestWasmPair<PathBuf> {
    fn from(t: TestWasm) -> Self {
        let coordinator = PathBuf::from(t);
        let mut integrity = coordinator.clone();
        let mut integrity_file_name = OsString::new();
        integrity_file_name.push("integrity_");
        integrity_file_name.push(coordinator.file_name().expect("Must have file name"));
        integrity.pop();
        integrity.push("examples");
        integrity.push(integrity_file_name);
        TestWasmPair {
            integrity,
            coordinator,
        }
    }
}

impl From<TestWasmPair<PathBuf>> for TestWasmPair<DnaWasm> {
    fn from(p: TestWasmPair<PathBuf>) -> Self {
        let TestWasmPair {
            integrity,
            coordinator,
        } = p;
        Self {
            integrity: DnaWasm::from(get_code(integrity)),
            coordinator: DnaWasm::from(get_code(coordinator)),
        }
    }
}

impl From<TestIntegrityWasm> for PathBuf {
    fn from(t: TestIntegrityWasm) -> Self {
        PathBuf::from(match t {
            TestIntegrityWasm::IntegrityZome => {
                "wasm32-unknown-unknown/release/test_wasm_integrity_zome.wasm"
            }
            TestIntegrityWasm::HcStressTestIntegrity => {
                "wasm32-unknown-unknown/release/files_integrity.wasm"
            }
        })
    }
}

impl From<TestCoordinatorWasm> for PathBuf {
    fn from(t: TestCoordinatorWasm) -> Self {
        PathBuf::from(match t {
            TestCoordinatorWasm::CoordinatorZome => {
                "wasm32-unknown-unknown/release/test_wasm_coordinator_zome.wasm"
            }
            TestCoordinatorWasm::CoordinatorZomeUpdate => {
                "wasm32-unknown-unknown/release/test_wasm_coordinator_zome_update.wasm"
            }
            TestCoordinatorWasm::HcStressTestCoordinator => {
                "wasm32-unknown-unknown/release/files.wasm"
            }
        })
    }
}

fn get_code(path: PathBuf) -> Vec<u8> {
    let path = match option_env!("HC_TEST_WASM_DIR") {
        Some(dir) => PathBuf::from(dir).join(path),
        None => PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join(WASM_WORKSPACE_TARGET)
            .join(path),
    };
    let warning = format!(
        "Wasm: {:?} was not found. Maybe you need to build the test wasms\n
        Run `cargo build --features 'build_wasms' --manifest-path=crates/holochain/Cargo.toml`
        or pass the feature flag to `cargo test`
        ",
        path
    );
    std::fs::read(path).expect(&warning)
}

impl From<TestWasm> for TestWasmPair<IntegrityZomeDef, CoordinatorZomeDef> {
    fn from(test_wasm: TestWasm) -> Self {
        let TestWasmPair {
            integrity,
            coordinator,
        } = TestWasmPair::<PathBuf>::from(test_wasm);
        let TestWasmPair {
            integrity: dep_name,
            ..
        } = TestWasmPair::<ZomeName>::from(test_wasm);
        tokio_helper::block_forever_on(async move {
            TestWasmPair {
                integrity: path_to_def(integrity, Default::default()).await.into(),
                coordinator: path_to_def(coordinator, vec![dep_name]).await.into(),
            }
        })
    }
}

impl From<TestWasm> for TestWasmPair<IntegrityZome, CoordinatorZome> {
    fn from(t: TestWasm) -> Self {
        let TestWasmPair {
            integrity: integrity_name,
            coordinator: coordinator_name,
        } = TestWasmPair::<ZomeName>::from(t);
        let TestWasmPair {
            integrity,
            coordinator,
        } = TestWasmPair::<IntegrityZomeDef, CoordinatorZomeDef>::from(t);
        TestWasmPair {
            integrity: IntegrityZome::new(integrity_name, integrity),
            coordinator: CoordinatorZome::new(coordinator_name, coordinator),
        }
    }
}

impl From<TestWasm> for IntegrityZome {
    fn from(test_wasm: TestWasm) -> Self {
        let TestWasmPair { integrity, .. } = TestWasmPair::<PathBuf>::from(test_wasm);

        let def = tokio_helper::block_forever_on(path_to_def(integrity, Default::default()));
        let TestWasmPair {
            integrity: zome_name,
            ..
        } = TestWasmPair::<ZomeName>::from(test_wasm);
        Self::new(zome_name, def.into())
    }
}

impl From<TestIntegrityWasm> for IntegrityZome {
    fn from(t: TestIntegrityWasm) -> Self {
        let def = tokio_helper::block_forever_on(path_to_def(t.into(), Default::default()));
        Self::new(t.into(), def.into())
    }
}

impl From<TestWasm> for CoordinatorZome {
    fn from(test_wasm: TestWasm) -> Self {
        let TestWasmPair { coordinator, .. } = TestWasmPair::<PathBuf>::from(test_wasm);
        let TestWasmPair {
            integrity: dep_name,
            ..
        } = TestWasmPair::<ZomeName>::from(test_wasm);
        let def = tokio_helper::block_forever_on(path_to_def(coordinator, vec![dep_name]));
        Self::new(test_wasm.into(), def.into())
    }
}

impl From<TestCoordinatorWasm> for TestIntegrityWasm {
    fn from(t: TestCoordinatorWasm) -> Self {
        match t {
            TestCoordinatorWasm::CoordinatorZome | TestCoordinatorWasm::CoordinatorZomeUpdate => {
                Self::IntegrityZome
            }
            TestCoordinatorWasm::HcStressTestCoordinator => Self::HcStressTestIntegrity,
        }
    }
}
impl From<TestCoordinatorWasm> for CoordinatorZome {
    fn from(t: TestCoordinatorWasm) -> Self {
        let dep_name: ZomeName = TestIntegrityWasm::from(t).into();
        let def = tokio_helper::block_forever_on(path_to_def(t.into(), vec![dep_name]));
        Self::new(t.into(), def.into())
    }
}

async fn path_to_def(path: PathBuf, dependencies: Vec<ZomeName>) -> ZomeDef {
    let wasm = DnaWasm::from(get_code(path));
    let wasm_hash = WasmHash::with_data(&wasm).await;
    ZomeDef::Wasm(WasmZome {
        wasm_hash,
        dependencies,
        preserialized_path: None,
    })
}



================================================
File: crates/test_utils/wasm/tests/integrations.rs
================================================
use holochain_types::prelude::DnaWasm;
use holochain_wasm_test_utils::TestWasm;
use holochain_wasm_test_utils::TestWasmPair;

#[test]
fn can_get_code() {
    let _dna: TestWasmPair<DnaWasm> = TestWasm::AgentInfo.into();
}



================================================
File: crates/test_utils/wasm/wasm_workspace/Cargo.lock
================================================
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "agent_key_lineage"
version = "0.1.0"
dependencies = [
 "hdi",
 "hdk",
 "serde",
]

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "android-tzdata"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0"

[[package]]
name = "android_system_properties"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
dependencies = [
 "libc",
]

[[package]]
name = "approx"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cab112f0a86d568ea0e627cc1d6be74a1e9cd55214684db5561995f6dad897c6"
dependencies = [
 "num-traits",
]

[[package]]
name = "arrayref"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76a2e8124351fda1ef8aaaa3bbd7ebbcb486bbcd4225aca0aa0d84bb2db8fecb"

[[package]]
name = "arrayvec"
version = "0.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7c02d123df017efcdfbd739ef81735b36c5ba83ec3c59c80a9d7ecc718f92e50"

[[package]]
name = "autocfg"
version = "1.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ace50bade8e6234aa140d9a2f552bbee1db4d353f69b8217bc503490fc1a9f26"

[[package]]
name = "base64"
version = "0.22.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b3254f16251a8381aa12e40e3c4d2f0199f8c6508fbecb9d91f575e0fbb8c6"

[[package]]
name = "bit-set"
version = "0.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0700ddab506f33b20a03b13996eccd309a48e5ff77d0d95926aa0210fb4e95f1"
dependencies = [
 "bit-vec",
]

[[package]]
name = "bit-vec"
version = "0.6.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "349f9b6a179ed607305526ca489b34ad0a41aed5f7980fa90eb03160b69598fb"

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f68f53c83ab957f72c32642f3868eec03eb974d1fb82e453128456482613d36"

[[package]]
name = "blake2b_simd"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06e903a20b159e944f91ec8499fe1e55651480c541ea0a584f5d967c49ad9d99"
dependencies = [
 "arrayref",
 "arrayvec",
 "constant_time_eq",
]

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "bumpalo"
version = "3.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1628fb46dfa0b37568d12e5edd512553eccf6a22a78e8bde00bb4aed84d5bdbf"

[[package]]
name = "bytemuck"
version = "1.21.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ef657dfab802224e671f5818e9a4935f9b1957ed18e58292690cc39e7a4092a3"

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "cc"
version = "1.2.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0c3d1b2e905a3a7b00a6141adb0e4c0bb941d11caf55349d863942a1cc44e3c9"
dependencies = [
 "shlex",
]

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "chrono"
version = "0.4.39"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7e36cc9d416881d2e24f9a963be5fb1cd90966419ac844274161d10488b3e825"
dependencies = [
 "android-tzdata",
 "iana-time-zone",
 "num-traits",
 "serde",
 "windows-targets",
]

[[package]]
name = "colored"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "117725a109d387c937a1533ce01b450cbde6b88abceea8473c4d7a85853cda3c"
dependencies = [
 "lazy_static",
 "windows-sys",
]

[[package]]
name = "constant_time_eq"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7c74b8349d32d297c9134b8c88677813a227df8f779daa29bfc29c183fe3dca6"

[[package]]
name = "convert_case"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6245d59a3e82a7fc217c5828a6692dbc6dfb63a0c8c90495621f7b9d79704a0e"

[[package]]
name = "core-foundation-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"

[[package]]
name = "cpufeatures"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59ed5838eebb26a2bb2e58f6d5b5316989ae9d08bab10e0e6d103e656d1b0280"
dependencies = [
 "libc",
]

[[package]]
name = "crypto-common"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "darling"
version = "0.14.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7b750cb3417fd1b327431a470f388520309479ab0bf5e323505daf0290cd3850"
dependencies = [
 "darling_core 0.14.4",
 "darling_macro 0.14.4",
]

[[package]]
name = "darling"
version = "0.20.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6f63b86c8a8826a49b8c21f08a2d07338eec8d900540f8630dc76284be802989"
dependencies = [
 "darling_core 0.20.10",
 "darling_macro 0.20.10",
]

[[package]]
name = "darling_core"
version = "0.14.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "109c1ca6e6b7f82cc233a97004ea8ed7ca123a9af07a8230878fcfda9b158bf0"
dependencies = [
 "fnv",
 "ident_case",
 "proc-macro2",
 "quote",
 "strsim 0.10.0",
 "syn 1.0.109",
]

[[package]]
name = "darling_core"
version = "0.20.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "95133861a8032aaea082871032f5815eb9e98cef03fa916ab4500513994df9e5"
dependencies = [
 "fnv",
 "ident_case",
 "proc-macro2",
 "quote",
 "strsim 0.11.1",
 "syn 2.0.98",
]

[[package]]
name = "darling_macro"
version = "0.14.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4aab4dbc9f7611d8b55048a3a16d2d010c2c8334e46304b40ac1cc14bf3b48e"
dependencies = [
 "darling_core 0.14.4",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "darling_macro"
version = "0.20.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d336a2a514f6ccccaa3e09b02d41d35330c07ddf03a62165fcec10bb561c7806"
dependencies = [
 "darling_core 0.20.10",
 "quote",
 "syn 2.0.98",
]

[[package]]
name = "derivative"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fcc3dd5e9e9c0b295d6e1e4d811fb6f157d5ffd784b8d202fc62eac8035a770b"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "derive_builder"
version = "0.20.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "507dfb09ea8b7fa618fcf76e953f4f5e192547945816d5358edffe39f6f94947"
dependencies = [
 "derive_builder_macro",
]

[[package]]
name = "derive_builder_core"
version = "0.20.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2d5bcf7b024d6835cfb3d473887cd966994907effbe9227e8c8219824d06c4e8"
dependencies = [
 "darling 0.20.10",
 "proc-macro2",
 "quote",
 "syn 2.0.98",
]

[[package]]
name = "derive_builder_macro"
version = "0.20.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ab63b0e2bf4d5928aff72e83a7dace85d7bba5fe12dcc3c5a572d78caffd3f3c"
dependencies = [
 "derive_builder_core",
 "syn 2.0.98",
]

[[package]]
name = "derive_more"
version = "0.99.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3da29a38df43d6f156149c9b43ded5e018ddff2a855cf2cfd62e8cd7d079c69f"
dependencies = [
 "convert_case",
 "proc-macro2",
 "quote",
 "rustc_version",
 "syn 2.0.98",
]

[[package]]
name = "difflib"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6184e33543162437515c2e2b48714794e37845ec9851711914eec9d308f6ebe8"

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer",
 "crypto-common",
]

[[package]]
name = "downcast"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1435fa1053d8b2fbbe9be7e97eca7f33d37b28409959813daefc1446a14247f1"

[[package]]
name = "dunce"
version = "1.0.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "92773504d58c093f6de2459af4af33faa518c13451eb8f2b5698ed3d36e7c813"

[[package]]
name = "either"
version = "1.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "60b1af1c220855b6ceac025d3f6ecdd2b7c4894bfe9cd9bda4fbb4bc7c0d4cf0"

[[package]]
name = "equivalent"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"

[[package]]
name = "files"
version = "0.0.1"
dependencies = [
 "files_integrity",
 "hdk",
 "serde",
]

[[package]]
name = "files_integrity"
version = "0.0.1"
dependencies = [
 "hdi",
 "serde",
]

[[package]]
name = "fixt"
version = "0.5.0-dev.1"
dependencies = [
 "holochain_serialized_bytes",
 "lazy_static",
 "parking_lot",
 "paste",
 "rand",
 "rand_core",
 "serde",
 "strum",
 "strum_macros",
]

[[package]]
name = "float-cmp"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "98de4bbd547a563b716d8dfa9aad1cb19bfab00f4fa09a6a4ed21dbcf44ce9c4"
dependencies = [
 "num-traits",
]

[[package]]
name = "fnv"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"

[[package]]
name = "fragile"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c2141d6d6c8512188a7891b4b01590a45f6dac67afb4f255c4124dbb86d4eaa"

[[package]]
name = "futures"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "65bc07b1a8bc7c85c5f2e110c476c7389b4554ba72af57d8445ea63a576b0876"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-executor",
 "futures-io",
 "futures-sink",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-channel"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2dff15bf788c671c1934e366d07e30c1814a8ef514e1af724a602e8a2fbe1b10"
dependencies = [
 "futures-core",
 "futures-sink",
]

[[package]]
name = "futures-core"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e"

[[package]]
name = "futures-executor"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e28d1d997f585e54aebc3f97d39e72338912123a67330d723fdbb564d646c9f"
dependencies = [
 "futures-core",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-io"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e5c1b78ca4aae1ac06c48a526a655760685149f0d465d21f37abfe57ce075c6"

[[package]]
name = "futures-macro"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "162ee34ebcb7c64a8abebc059ce0fee27c2262618d7b60ed8faf72fef13c3650"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.98",
]

[[package]]
name = "futures-sink"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e575fab7d1e0dcb8d0c7bcf9a63ee213816ab51902e6d244a95819acacf1d4f7"

[[package]]
name = "futures-task"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f90f7dce0722e95104fcb095585910c0977252f286e354b5e3bd38902cd99988"

[[package]]
name = "futures-util"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fa08315bb612088cc391249efdc3bc77536f16c91f6cf495e6fbe85b20a4a81"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-io",
 "futures-macro",
 "futures-sink",
 "futures-task",
 "memchr",
 "pin-project-lite",
 "pin-utils",
 "slab",
]

[[package]]
name = "gcollections"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f551fdf23ef80329f754919669147a71c67b6cfe3569cd93b6fabdd62044377"
dependencies = [
 "bit-set",
 "num-integer",
 "num-traits",
 "trilean",
]

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
]

[[package]]
name = "getrandom"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7"
dependencies = [
 "cfg-if",
 "libc",
 "wasi",
]

[[package]]
name = "hashbrown"
version = "0.15.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bf151400ff0baff5465007dd2f3e717f3fe502074ca563069ce3a6629d07b289"

[[package]]
name = "hdi"
version = "0.6.0-dev.15"
dependencies = [
 "getrandom",
 "hdk_derive",
 "holo_hash",
 "holochain_integrity_types",
 "holochain_wasmer_guest",
 "paste",
 "serde",
 "serde_bytes",
 "tracing",
 "tracing-core",
]

[[package]]
name = "hdk"
version = "0.5.0-dev.19"
dependencies = [
 "getrandom",
 "hdi",
 "hdk_derive",
 "holo_hash",
 "holochain_wasmer_guest",
 "holochain_zome_types",
 "mockall",
 "paste",
 "serde",
 "serde_bytes",
 "thiserror 1.0.69",
 "tracing",
 "tracing-core",
]

[[package]]
name = "hdk_derive"
version = "0.5.0-dev.14"
dependencies = [
 "darling 0.14.4",
 "heck 0.5.0",
 "holochain_integrity_types",
 "paste",
 "proc-macro-error",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "heck"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6d621efb26863f0e9924c6ac577e8275e5e6b77455db64ffa6c65c904e9e132c"
dependencies = [
 "unicode-segmentation",
]

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "holo_hash"
version = "0.5.0-dev.7"
dependencies = [
 "base64",
 "blake2b_simd",
 "derive_more",
 "fixt",
 "futures",
 "holochain_serialized_bytes",
 "holochain_util",
 "holochain_wasmer_common",
 "kitsune_p2p_dht_arc",
 "must_future",
 "rand",
 "serde",
 "serde_bytes",
 "sha2",
 "thiserror 1.0.69",
]

[[package]]
name = "holochain_integrity_types"
version = "0.5.0-dev.12"
dependencies = [
 "derive_builder",
 "holo_hash",
 "holochain_secure_primitive",
 "holochain_serialized_bytes",
 "holochain_timestamp",
 "holochain_util",
 "serde",
 "serde_bytes",
 "subtle",
 "subtle-encoding",
 "tracing",
]

[[package]]
name = "holochain_mock_hdi"
version = "0.0.1"
dependencies = [
 "hdi",
 "mockall",
]

[[package]]
name = "holochain_nonce"
version = "0.5.0-dev.2"
dependencies = [
 "getrandom",
 "holochain_secure_primitive",
 "holochain_timestamp",
]

[[package]]
name = "holochain_secure_primitive"
version = "0.5.0-dev.1"
dependencies = [
 "paste",
 "serde",
 "subtle",
]

[[package]]
name = "holochain_serialized_bytes"
version = "0.0.55"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "719fa847cf9f772f7e8e1a6f11d801e1383cc5af043292042665da9a6ce5c742"
dependencies = [
 "holochain_serialized_bytes_derive",
 "rmp-serde",
 "serde",
 "serde-transcode",
 "serde_bytes",
 "serde_json",
 "thiserror 1.0.69",
]

[[package]]
name = "holochain_serialized_bytes_derive"
version = "0.0.55"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3e6a221b5650251e09ef0b9223cf39e72b5222492cffc6bb4bdf36b2a6bc91aa"
dependencies = [
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "holochain_test_wasm_common"
version = "0.5.0-dev.19"
dependencies = [
 "hdk",
 "serde",
]

[[package]]
name = "holochain_timestamp"
version = "0.5.0-dev.1"
dependencies = [
 "chrono",
 "serde",
]

[[package]]
name = "holochain_util"
version = "0.5.0-dev.1"
dependencies = [
 "cfg-if",
 "colored",
 "dunce",
 "futures",
 "once_cell",
]

[[package]]
name = "holochain_wasmer_common"
version = "0.0.99"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7c826653a839b4cd5ac5728c52daab4cd27e1bcc23bdd5121ef64977f7a25196"
dependencies = [
 "holochain_serialized_bytes",
 "serde",
 "serde_bytes",
 "thiserror 2.0.11",
]

[[package]]
name = "holochain_wasmer_guest"
version = "0.0.99"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbe3e79d77552986719fd47a1134bbb46f67c16a09b96ca0b6ef90af03d4f34d"
dependencies = [
 "holochain_serialized_bytes",
 "holochain_wasmer_common",
 "paste",
 "serde",
 "tracing",
]

[[package]]
name = "holochain_zome_types"
version = "0.5.0-dev.17"
dependencies = [
 "derive_builder",
 "derive_more",
 "fixt",
 "holo_hash",
 "holochain_integrity_types",
 "holochain_nonce",
 "holochain_serialized_bytes",
 "holochain_timestamp",
 "holochain_wasmer_common",
 "kitsune_p2p_block",
 "kitsune_p2p_dht",
 "nanoid",
 "rand",
 "serde",
 "serde_bytes",
 "serde_yaml",
 "shrinkwraprs",
 "strum",
 "subtle",
 "thiserror 1.0.69",
 "tracing",
]

[[package]]
name = "iana-time-zone"
version = "0.1.61"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "235e081f3925a06703c2d0117ea8b91f042756fd6e7a6e5d901e8ca1a996b220"
dependencies = [
 "android_system_properties",
 "core-foundation-sys",
 "iana-time-zone-haiku",
 "js-sys",
 "wasm-bindgen",
 "windows-core",
]

[[package]]
name = "iana-time-zone-haiku"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
dependencies = [
 "cc",
]

[[package]]
name = "ident_case"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9e0384b61958566e926dc50660321d12159025e767c18e043daf26b70104c39"

[[package]]
name = "indexmap"
version = "2.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8c9c992b02b5b4c94ea26e32fe5bccb7aa7d9f390ab5c1221ff895bc7ea8b652"
dependencies = [
 "equivalent",
 "hashbrown",
]

[[package]]
name = "intervallum"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "18bfda24d3930aa647f90044d5ef87d0c8120f13b86b2d60e8aade66e656e659"
dependencies = [
 "bit-set",
 "gcollections",
 "num-integer",
 "num-traits",
 "trilean",
]

[[package]]
name = "itertools"
version = "0.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f56a2d0bc861f9165be4eb3442afd3c236d8a98afd426f65d92324ae1091a484"
dependencies = [
 "either",
]

[[package]]
name = "itertools"
version = "0.10.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473"
dependencies = [
 "either",
]

[[package]]
name = "itoa"
version = "1.0.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d75a2a4b1b190afb6f5425f10f6a8f959d2ea0b9c2b1d79553551850539e4674"

[[package]]
name = "js-sys"
version = "0.3.77"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1cfaf33c695fc6e08064efbc1f72ec937429614f25eef83af942d0e227c3a28f"
dependencies = [
 "once_cell",
 "wasm-bindgen",
]

[[package]]
name = "kitsune_p2p_bin_data"
version = "0.5.0-dev.5"
dependencies = [
 "base64",
 "derive_more",
 "holochain_util",
 "kitsune_p2p_dht_arc",
 "serde",
 "serde_bytes",
 "shrinkwraprs",
]

[[package]]
name = "kitsune_p2p_block"
version = "0.5.0-dev.5"
dependencies = [
 "kitsune_p2p_bin_data",
 "kitsune_p2p_timestamp",
 "serde",
]

[[package]]
name = "kitsune_p2p_dht"
version = "0.5.0-dev.3"
dependencies = [
 "derivative",
 "derive_more",
 "kitsune_p2p_dht_arc",
 "kitsune_p2p_timestamp",
 "num-traits",
 "rand",
 "serde",
 "statrs",
 "thiserror 1.0.69",
 "tracing",
]

[[package]]
name = "kitsune_p2p_dht_arc"
version = "0.5.0-dev.2"
dependencies = [
 "derive_more",
 "gcollections",
 "intervallum",
 "num-traits",
 "serde",
]

[[package]]
name = "kitsune_p2p_timestamp"
version = "0.5.0-dev.1"
dependencies = [
 "chrono",
 "serde",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"

[[package]]
name = "libc"
version = "0.2.169"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b5aba8db14291edd000dfcc4d620c7ebfb122c613afb886ca8803fa4e128a20a"

[[package]]
name = "libm"
version = "0.2.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8355be11b20d696c8f18f6cc018c4e372165b1fa8126cef092399c9951984ffa"

[[package]]
name = "lock_api"
version = "0.4.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07af8b9cdd281b7915f413fa73f29ebd5d55d0d3f0155584dade1ff18cea1b17"
dependencies = [
 "autocfg",
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.25"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04cbf5b083de1c7e0222a7a51dbfdba1cbe1c6ab0b15e29fff3f6c077fd9cd9f"

[[package]]
name = "matrixmultiply"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9380b911e3e96d10c1f415da0876389aaf1b56759054eeb0de7df940c456ba1a"
dependencies = [
 "autocfg",
 "rawpointer",
]

[[package]]
name = "memchr"
version = "2.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3"

[[package]]
name = "mockall"
version = "0.11.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4c84490118f2ee2d74570d114f3d0493cbf02790df303d2707606c3e14e07c96"
dependencies = [
 "cfg-if",
 "downcast",
 "fragile",
 "lazy_static",
 "mockall_derive",
 "predicates",
 "predicates-tree",
]

[[package]]
name = "mockall_derive"
version = "0.11.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22ce75669015c4f47b289fd4d4f56e894e4c96003ffdf3ac51313126f94c6cbb"
dependencies = [
 "cfg-if",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "must_future"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a160ffed3c2f98d2906c67a9b6e4e1f09cca7e17e3f780286a349061459eeebe"
dependencies = [
 "futures",
 "pin-utils",
]

[[package]]
name = "nalgebra"
version = "0.29.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d506eb7e08d6329505faa8a3a00a5dcc6de9f76e0c77e4b75763ae3c770831ff"
dependencies = [
 "approx",
 "matrixmultiply",
 "nalgebra-macros",
 "num-complex",
 "num-rational",
 "num-traits",
 "rand",
 "rand_distr",
 "simba",
 "typenum",
]

[[package]]
name = "nalgebra-macros"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "01fcc0b8149b4632adc89ac3b7b31a12fb6099a0317a4eb2ebff574ef7de7218"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "nanoid"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3ffa00dec017b5b1a8b7cf5e2c008bfda1aa7e0697ac1508b491fdf2622fb4d8"
dependencies = [
 "rand",
]

[[package]]
name = "normalize-line-endings"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "61807f77802ff30975e01f4f071c8ba10c022052f98b3294119f3e615d13e5be"

[[package]]
name = "num-complex"
version = "0.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "73f88a1307638156682bada9d7604135552957b7818057dcef22705b4d509495"
dependencies = [
 "num-traits",
]

[[package]]
name = "num-integer"
version = "0.1.46"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7969661fd2958a5cb096e56c8e1ad0444ac2bbcd0061bd28660485a44879858f"
dependencies = [
 "num-traits",
]

[[package]]
name = "num-rational"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f83d14da390562dca69fc84082e73e548e1ad308d24accdedd2720017cb37824"
dependencies = [
 "num-integer",
 "num-traits",
]

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
 "libm",
]

[[package]]
name = "once_cell"
version = "1.20.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "945462a4b81e43c4e3ba96bd7b49d834c6f61198356aa858733bc4acf3cbe62e"

[[package]]
name = "parking_lot"
version = "0.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f1bf18183cf54e8d6059647fc3063646a1801cf30896933ec2311622cc4b9a27"
dependencies = [
 "lock_api",
 "parking_lot_core",
]

[[package]]
name = "parking_lot_core"
version = "0.9.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e401f977ab385c9e4e3ab30627d6f26d00e2c73eef317493c4ec6d468726cf8"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall",
 "smallvec",
 "windows-targets",
]

[[package]]
name = "paste"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57c0d7b74b563b49d38dae00a0c37d4d6de9b432382b2892f0574ddcae73fd0a"

[[package]]
name = "pin-project-lite"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b"

[[package]]
name = "pin-utils"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"

[[package]]
name = "ppv-lite86"
version = "0.2.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77957b295656769bb8ad2b6a6b09d897d94f05c41b069aede1fcdaa675eaea04"
dependencies = [
 "zerocopy",
]

[[package]]
name = "predicates"
version = "2.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59230a63c37f3e18569bdb90e4a89cbf5bf8b06fea0b84e65ea10cc4df47addd"
dependencies = [
 "difflib",
 "float-cmp",
 "itertools 0.10.5",
 "normalize-line-endings",
 "predicates-core",
 "regex",
]

[[package]]
name = "predicates-core"
version = "1.0.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "727e462b119fe9c93fd0eb1429a5f7647394014cf3c04ab2c0350eeb09095ffa"

[[package]]
name = "predicates-tree"
version = "1.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72dd2d6d381dfb73a193c7fca536518d7caee39fc8503f74e7dc0be0531b425c"
dependencies = [
 "predicates-core",
 "termtree",
]

[[package]]
name = "proc-macro-error"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "da25490ff9892aab3fcf7c36f08cfb902dd3e71ca0f9f9517bea02a73a5ce38c"
dependencies = [
 "proc-macro-error-attr",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
 "version_check",
]

[[package]]
name = "proc-macro-error-attr"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1be40180e52ecc98ad80b184934baf3d0d29f979574e439af5a55274b35f869"
dependencies = [
 "proc-macro2",
 "quote",
 "version_check",
]

[[package]]
name = "proc-macro2"
version = "1.0.93"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "60946a68e5f9d28b0dc1c21bb8a97ee7d018a8b322fa57838ba31cc878e22d99"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.38"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0e4dccaaaf89514f546c693ddc140f729f958c247918a13380cccc6078391acc"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha",
 "rand_core",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
dependencies = [
 "ppv-lite86",
 "rand_core",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom",
]

[[package]]
name = "rand_distr"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32cb0b9bc82b0a0876c2dd994a7e7a2683d3e7390ca40e6886785ef0c7e3ee31"
dependencies = [
 "num-traits",
 "rand",
]

[[package]]
name = "rawpointer"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "60a357793950651c4ed0f3f52338f53b2f809f32d83a07f72909fa13e4c6c1e3"

[[package]]
name = "redox_syscall"
version = "0.5.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "03a862b389f93e68874fbf580b9de08dd02facb9a788ebadaf4a3fd33cf58834"
dependencies = [
 "bitflags 2.8.0",
]

[[package]]
name = "regex"
version = "1.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b544ef1b4eac5dc2db33ea63606ae9ffcfac26c1416a2806ae0bf5f56b201191"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata",
 "regex-syntax",
]

[[package]]
name = "regex-automata"
version = "0.4.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "809e8dc61f6de73b46c85f4c96486310fe304c434cfa43669d7b40f711150908"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-syntax"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b15c43186be67a4fd63bee50d0303afffcef381492ebe2c5d87f324e1b8815c"

[[package]]
name = "rmp"
version = "0.8.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "228ed7c16fa39782c3b3468e974aec2795e9089153cd08ee2e9aefb3613334c4"
dependencies = [
 "byteorder",
 "num-traits",
 "paste",
]

[[package]]
name = "rmp-serde"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "52e599a477cf9840e92f2cde9a7189e67b42c57532749bf90aea6ec10facd4db"
dependencies = [
 "byteorder",
 "rmp",
 "serde",
]

[[package]]
name = "rustc_version"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cfcb3a22ef46e85b45de6ee7e79d063319ebb6594faafcf1c225ea92ab6e9b92"
dependencies = [
 "semver",
]

[[package]]
name = "rustversion"
version = "1.0.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f7c45b9784283f1b2e7fb61b42047c2fd678ef0960d4f6f1eba131594cc369d4"

[[package]]
name = "ryu"
version = "1.0.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6ea1a2d0a644769cc99faa24c3ad26b379b786fe7c36fd3c546254801650e6dd"

[[package]]
name = "safe_arch"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96b02de82ddbe1b636e6170c21be622223aea188ef2e139be0a5b219ec215323"
dependencies = [
 "bytemuck",
]

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "semver"
version = "1.0.25"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f79dfe2d285b0488816f30e700a7438c5a73d816b5b7d3ac72fbc48b0d185e03"

[[package]]
name = "serde"
version = "1.0.203"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7253ab4de971e72fb7be983802300c30b5a7f0c2e56fab8abfc6a214307c0094"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde-transcode"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "590c0e25c2a5bb6e85bf5c1bce768ceb86b316e7a01bdf07d2cb4ec2271990e2"
dependencies = [
 "serde",
]

[[package]]
name = "serde_bytes"
version = "0.11.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "387cc504cb06bb40a96c8e04e951fe01854cf6bc921053c954e4a606d9675c6a"
dependencies = [
 "serde",
]

[[package]]
name = "serde_derive"
version = "1.0.203"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "500cbc0ebeb6f46627f50f3f5811ccf6bf00643be300b4c3eabc0ef55dc5b5ba"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.98",
]

[[package]]
name = "serde_json"
version = "1.0.138"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d434192e7da787e94a6ea7e9670b26a036d0ca41e0b7efb2676dd32bae872949"
dependencies = [
 "indexmap",
 "itoa",
 "memchr",
 "ryu",
 "serde",
]

[[package]]
name = "serde_yaml"
version = "0.9.34+deprecated"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a8b1a1a2ebf674015cc02edccce75287f1a0130d394307b36743c2f5d504b47"
dependencies = [
 "indexmap",
 "itoa",
 "ryu",
 "serde",
 "unsafe-libyaml",
]

[[package]]
name = "sha2"
version = "0.10.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "793db75ad2bcafc3ffa7c68b215fee268f537982cd901d132f89c6343f3a3dc8"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "shrinkwraprs"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e63e6744142336dfb606fe2b068afa2e1cca1ee6a5d8377277a92945d81fa331"
dependencies = [
 "bitflags 1.3.2",
 "itertools 0.8.2",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "simba"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0b7840f121a46d63066ee7a99fc81dcabbc6105e437cae43528cea199b5a05f"
dependencies = [
 "approx",
 "num-complex",
 "num-traits",
 "paste",
 "wide",
]

[[package]]
name = "slab"
version = "0.4.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f92a496fb766b417c996b9c5e57daf2f7ad3b0bebe1ccfca4856390e3d3bb67"
dependencies = [
 "autocfg",
]

[[package]]
name = "smallvec"
version = "1.14.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7fcf8323ef1faaee30a44a340193b1ac6814fd9b7b4e88e9d4519a3e4abe1cfd"

[[package]]
name = "statrs"
version = "0.16.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b35a062dbadac17a42e0fc64c27f419b25d6fae98572eb43c8814c9e873d7721"
dependencies = [
 "approx",
 "lazy_static",
 "nalgebra",
 "num-traits",
 "rand",
]

[[package]]
name = "strsim"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "73473c0e59e6d5812c5dfe2a064a6444949f089e20eec9a2e5506596494e4623"

[[package]]
name = "strsim"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"

[[package]]
name = "strum"
version = "0.18.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57bd81eb48f4c437cadc685403cad539345bf703d78e63707418431cecd4522b"

[[package]]
name = "strum_macros"
version = "0.18.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87c85aa3f8ea653bfd3ddf25f7ee357ee4d204731f6aa9ad04002306f6e2774c"
dependencies = [
 "heck 0.3.3",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "subtle"
version = "2.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13c2bddecc57b384dee18652358fb23172facb8a2c51ccc10d74c157bdea3292"

[[package]]
name = "subtle-encoding"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7dcb1ed7b8330c5eed5441052651dd7a12c75e2ed88f2ec024ae1fa3a5e59945"
dependencies = [
 "zeroize",
]

[[package]]
name = "syn"
version = "1.0.109"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "syn"
version = "2.0.98"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "36147f1a48ae0ec2b5b3bc5b537d267457555a10dc06f3dbc8cb11ba3006d3b1"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "termtree"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f50febec83f5ee1df3015341d8bd429f2d1cc62bcba7ea2076759d315084683"

[[package]]
name = "test_wasm_agent_info"
version = "0.0.1"
dependencies = [
 "fixt",
 "hdi",
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_anchor"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "holochain_test_wasm_common",
 "serde",
]

[[package]]
name = "test_wasm_app_validation"
version = "0.1.0"
dependencies = [
 "hdi",
 "hdk",
 "holochain_test_wasm_common",
 "serde",
]

[[package]]
name = "test_wasm_bench"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_capability"
version = "0.0.1"
dependencies = [
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_clone"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_coordinator_zome"
version = "0.0.1"
dependencies = [
 "hdk",
 "holochain_test_wasm_common",
 "serde",
 "test_wasm_integrity_zome",
]

[[package]]
name = "test_wasm_coordinator_zome_update"
version = "0.0.1"
dependencies = [
 "hdk",
 "holochain_test_wasm_common",
 "serde",
 "test_wasm_integrity_zome",
]

[[package]]
name = "test_wasm_countersigning"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "holochain_test_wasm_common",
 "serde",
]

[[package]]
name = "test_wasm_crd"
version = "0.0.1"
dependencies = [
 "fixt",
 "hdi",
 "hdk",
 "holochain_test_wasm_common",
 "serde",
]

[[package]]
name = "test_wasm_create_entry"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "holochain_test_wasm_common",
 "serde",
]

[[package]]
name = "test_wasm_crud"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "holochain_test_wasm_common",
 "serde",
]

[[package]]
name = "test_wasm_debug"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "serde",
 "tracing",
 "tracing-core",
]

[[package]]
name = "test_wasm_dna_properties"
version = "0.0.1"
dependencies = [
 "fixt",
 "hdi",
 "hdk",
 "holochain_test_wasm_common",
 "serde",
]

[[package]]
name = "test_wasm_emit_signal"
version = "0.0.1"
dependencies = [
 "hdk",
 "holochain_test_wasm_common",
 "serde",
]

[[package]]
name = "test_wasm_entry_defs"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_foo"
version = "0.0.1"
dependencies = [
 "hdk",
 "holochain_test_wasm_common",
 "serde",
]

[[package]]
name = "test_wasm_genesis_self_check_1"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_genesis_self_check_invalid"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_genesis_self_check_legacy"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_genesis_self_check_requires_properties"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "serde",
 "serde_yaml",
]

[[package]]
name = "test_wasm_genesis_self_check_valid"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_hash_entry"
version = "0.0.1"
dependencies = [
 "fixt",
 "hdi",
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_hash_path"
version = "0.0.1"
dependencies = [
 "hdk",
 "holochain_test_wasm_common",
 "serde",
]

[[package]]
name = "test_wasm_hdk_extern"
version = "0.0.1"
dependencies = [
 "hdk",
 "holochain_test_wasm_common",
 "serde",
]

[[package]]
name = "test_wasm_init_fail"
version = "0.0.1"
dependencies = [
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_init_invalid_params"
version = "0.0.1"
dependencies = [
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_init_pass"
version = "0.0.1"
dependencies = [
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_init_single"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_integrity_zome"
version = "0.0.1"
dependencies = [
 "hdi",
 "holochain_mock_hdi",
 "serde",
]

[[package]]
name = "test_wasm_link"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "holochain_test_wasm_common",
 "serde",
]

[[package]]
name = "test_wasm_migrate_initial"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "holochain_test_wasm_common",
 "serde",
]

[[package]]
name = "test_wasm_migrate_new"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "holochain_test_wasm_common",
 "serde",
]

[[package]]
name = "test_wasm_multiple_calls"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "holochain_test_wasm_common",
 "serde",
]

[[package]]
name = "test_wasm_must_get"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "holochain_test_wasm_common",
 "serde",
 "thiserror 1.0.69",
]

[[package]]
name = "test_wasm_must_get_agent_activity"
version = "0.1.0"
dependencies = [
 "hdi",
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_post_commit_signal"
version = "0.0.1"
dependencies = [
 "hdk",
 "holochain_test_wasm_common",
 "serde",
]

[[package]]
name = "test_wasm_post_commit_success"
version = "0.0.1"
dependencies = [
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_post_commit_volley"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_query"
version = "0.0.1"
dependencies = [
 "hdk",
 "holochain_test_wasm_common",
 "serde",
]

[[package]]
name = "test_wasm_random_bytes"
version = "0.0.1"
dependencies = [
 "fixt",
 "hdk",
 "rand",
 "serde",
]

[[package]]
name = "test_wasm_schedule"
version = "0.0.1"
dependencies = [
 "fixt",
 "hdi",
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_ser_regression"
version = "0.0.1"
dependencies = [
 "derive_more",
 "hdi",
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_sign"
version = "0.0.1"
dependencies = [
 "fixt",
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_sys_time"
version = "0.0.1"
dependencies = [
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_the_incredible_halt"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_update_entry"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "holochain_test_wasm_common",
 "serde",
]

[[package]]
name = "test_wasm_validate"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_validate_invalid"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_validate_invalid_params"
version = "0.0.1"
dependencies = [
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_validate_link"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_validate_link_add_invalid"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_validate_link_add_valid"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_validate_reject_app_types"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_validate_valid"
version = "0.0.1"
dependencies = [
 "hdi",
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_whoami"
version = "0.0.1"
dependencies = [
 "hdk",
 "holochain_test_wasm_common",
 "serde",
]

[[package]]
name = "test_wasm_x_salsa20_poly1305"
version = "0.0.1"
dependencies = [
 "hdk",
 "serde",
]

[[package]]
name = "test_wasm_zome_info"
version = "0.0.1"
dependencies = [
 "fixt",
 "hdi",
 "hdk",
 "serde",
 "serde_yaml",
]

[[package]]
name = "thiserror"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6aaf5339b578ea85b50e080feb250a3e8ae8cfcdff9a461c9ec2904bc923f52"
dependencies = [
 "thiserror-impl 1.0.69",
]

[[package]]
name = "thiserror"
version = "2.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d452f284b73e6d76dd36758a0c8684b1d5be31f92b89d07fd5822175732206fc"
dependencies = [
 "thiserror-impl 2.0.11",
]

[[package]]
name = "thiserror-impl"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.98",
]

[[package]]
name = "thiserror-impl"
version = "2.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26afc1baea8a989337eeb52b6e72a039780ce45c3edfcc9c5b9d112feeb173c2"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.98",
]

[[package]]
name = "tracing"
version = "0.1.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "784e0ac535deb450455cbfa28a6f0df145ea1bb7ae51b821cf5e7927fdcfbdd0"
dependencies = [
 "pin-project-lite",
 "tracing-attributes",
 "tracing-core",
]

[[package]]
name = "tracing-attributes"
version = "0.1.28"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "395ae124c09f9e6918a2310af6038fba074bcf474ac352496d5910dd59a2226d"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.98",
]

[[package]]
name = "tracing-core"
version = "0.1.33"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e672c95779cf947c5311f83787af4fa8fffd12fb27e4993211a84bdfd9610f9c"
dependencies = [
 "once_cell",
 "valuable",
]

[[package]]
name = "trilean"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "683ba5022fe6dbd7133cad150478ccf51bdb6d861515181e5fc6b4323d4fa424"

[[package]]
name = "typenum"
version = "1.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42ff0bf0c66b8238c6f3b578df37d0b7848e55df8577b3f74f92a69acceeb825"

[[package]]
name = "unicode-ident"
version = "1.0.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a210d160f08b701c8721ba1c726c11662f877ea6b7094007e1ca9a1041945034"

[[package]]
name = "unicode-segmentation"
version = "1.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6ccf251212114b54433ec949fd6a7841275f9ada20dddd2f29e9ceea4501493"

[[package]]
name = "unsafe-libyaml"
version = "0.2.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "673aac59facbab8a9007c7f6108d11f63b603f7cabff99fabf650fea5c32b861"

[[package]]
name = "valuable"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba73ea9cf16a25df0c8caa16c51acb937d5712a8429db78a3ee29d5dcacd3a65"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "wasi"
version = "0.11.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"

[[package]]
name = "wasm-bindgen"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1edc8929d7499fc4e8f0be2262a241556cfc54a0bea223790e71446f2aab1ef5"
dependencies = [
 "cfg-if",
 "once_cell",
 "rustversion",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f0a0651a5c2bc21487bde11ee802ccaf4c51935d0d3d42a6101f98161700bc6"
dependencies = [
 "bumpalo",
 "log",
 "proc-macro2",
 "quote",
 "syn 2.0.98",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7fe63fc6d09ed3792bd0897b314f53de8e16568c2b3f7982f468c0bf9bd0b407"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ae87ea40c9f689fc23f209965b6fb8a99ad69aeeb0231408be24920604395de"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.98",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a05d73b933a847d6cccdda8f838a22ff101ad9bf93e33684f39c1f5f0eece3d"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "wide"
version = "0.7.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41b5576b9a81633f3e8df296ce0063042a73507636cbe956c61133dd7034ab22"
dependencies = [
 "bytemuck",
 "safe_arch",
]

[[package]]
name = "windows-core"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33ab640c8d7e35bf8ba19b884ba838ceb4fba93a4e8c65a9059d08afcfc683d9"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_gnullvm",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "zerocopy"
version = "0.7.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b9b4fd18abc82b8136838da5d50bae7bdea537c574d8dc1a34ed098d6c166f0"
dependencies = [
 "byteorder",
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.7.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa4f8080344d4671fb4e831a13ad1e68092748387dfc4f55e356242fae12ce3e"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.98",
]

[[package]]
name = "zeroize"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ced3678a2879b30306d323f4542626697a464a97c0a07c9aebf7ebca65cd4dde"



================================================
File: crates/test_utils/wasm/wasm_workspace/Cargo.toml
================================================
[workspace]
members = [
  "agent_info",
  "agent_key_lineage",
  "anchor",
  "app_validation",
  "bench",
  "capability",
  "clone",
  "coordinator_zome",
  "coordinator_zome_update",
  "countersigning",
  "create_entry",
  "crd",
  "crud",
  "debug",
  "dna_properties",
  "emit_signal",
  "post_commit_signal",
  "entry_defs",
  "hash_entry",
  "foo",
  "genesis_self_check_legacy",
  "genesis_self_check_1",
  "genesis_self_check_invalid",
  "genesis_self_check_valid",
  "genesis_self_check_requires_properties",
  "hc-stress-test-integrity",
  "hc-stress-test-coordinator",
  "hash_path",
  "hdk_extern",
  "init_fail",
  "init_invalid_params",
  "init_pass",
  "init_single",
  "integrity_zome",
  "link",
  "migrate_new",
  "migrate_initial",
  "multiple_calls",
  "must_get",
  "must_get_agent_activity",
  "post_commit_success",
  "post_commit_volley",
  "query",
  "random_bytes",
  "schedule",
  "x_salsa20_poly1305",
  "ser_regression",
  "sign",
  "sys_time",
  "the_incredible_halt",
  "update_entry",
  "validate",
  "validate_invalid",
  "validate_link",
  "validate_link_add_invalid",
  "validate_link_add_valid",
  "validate_valid",
  "validate_reject_app_types",
  "validate_invalid_params",
  "whoami",
  "zome_info",
]

resolver = "2"

[profile.release]
opt-level = "z"

[workspace.dependencies]
# !!!
# WARNING - PUT NOTHING HERE
# !!!
#
# release automation currently cannot handle workspace.dependencies
# it will publish unbuildable releases to crates.io

[patch.crates-io]
# holochain_wasmer_common = { git = "https://github.com/holochain/holochain-wasmer.git", branch = "develop" }
# holochain_wasmer_guest = { git = "https://github.com/holochain/holochain-wasmer.git", branch = "2021-04-27-singlepass" }
# holochain_wasmer_host = { path = "../../../../../holochain-wasmer/crates/host" }
# holochain_wasmer_host = { git = "https://github.com/holochain/holochain-wasmer.git", branch = "bump-serde" }
# holochain_serialized_bytes = { git = "https://github.com/holochain/holochain-serialization.git", branch = "arbitrary" }
# holochain_serialized_bytes_derive = { git = "https://github.com/holochain/holochain-serialization.git", branch = "arbitrary" }



================================================
File: crates/test_utils/wasm/wasm_workspace/fetch-hc-stress-test.bash
================================================
#!/usr/bin/bash

rm -rf hc-stress-test-integrity
mkdir hc-stress-test-integrity
(cd hc-stress-test-integrity && curl -L https://github.com/matthme/hc-stress-test/tarball/hc-0.2.2-beta-rc.1 | tar xzf - --wildcards --strip-components=6 */dnas/files/zomes/integrity/files)

rm -rf hc-stress-test-coordinator
mkdir hc-stress-test-coordinator
(cd hc-stress-test-coordinator && curl -L https://github.com/matthme/hc-stress-test/tarball/hc-0.2.2-beta-rc.1 | tar xzf - --wildcards --strip-components=6 */dnas/files/zomes/coordinator/files)



================================================
File: crates/test_utils/wasm/wasm_workspace/agent_info/Cargo.toml
================================================
[package]
name = "test_wasm_agent_info"
version = "0.0.1"
authors = ["thedavidmeister", "thedavidmeister@gmail.com"]
edition = "2021"

[lib]
name = "test_wasm_agent_info"
crate-type = ["cdylib", "rlib"]

[[example]]
name = "integrity_test_wasm_agent_info"
path = "src/integrity.rs"
crate-type = ["cdylib", "rlib"]

# reminder - do not use workspace deps
[dependencies]
hdk = { path = "../../../../hdk", optional = true }
serde = "1.0"
hdi = { path = "../../../../hdi" }

[dev-dependencies]
hdk = { path = "../../../../hdk", features = ["fixturators"] }
fixt = { path = "../../../../fixt" }

[features]
default = ["hdk"]
integrity = []
mock = ["hdk/mock"]



================================================
File: crates/test_utils/wasm/wasm_workspace/agent_info/src/coordinator.rs
================================================
use crate::integrity::*;
use hdk::prelude::*;

#[hdk_extern]
fn call_info(_: ()) -> ExternResult<CallInfo> {
    hdk::prelude::call_info()
}

#[hdk_extern]
fn agent_info(_: ()) -> ExternResult<AgentInfo> {
    hdk::prelude::create_entry(EntryTypes::Thing(Thing))?;
    hdk::prelude::agent_info()
}

#[cfg(all(test, feature = "mock"))]
pub mod test {
    use ::fixt::prelude::*;
    use hdk::prelude::*;

    #[test]
    fn agent_info_smoke() {
        let mut mock_hdk = hdk::prelude::MockHdkT::new();

        let agent_info = fixt!(AgentInfo);
        let closure_agent_info = agent_info.clone();
        mock_hdk
            .expect_create()
            .times(1)
            .return_once(move |_| Ok(fixt!(ActionHash)));
        mock_hdk
            .expect_agent_info()
            .with(hdk::prelude::mockall::predicate::eq(()))
            .times(1)
            .return_once(move |_| Ok(closure_agent_info));

        hdk::prelude::set_hdk(mock_hdk);

        let result = super::agent_info(());

        assert_eq!(result, Ok(agent_info))
    }
}



================================================
File: crates/test_utils/wasm/wasm_workspace/agent_info/src/integrity.rs
================================================
use hdi::prelude::*;

#[hdk_entry_helper]
pub struct Thing;

#[hdk_entry_types]
#[unit_enum(EntryTypesUnit)]
pub enum EntryTypes {
    Thing(Thing),
}



================================================
File: crates/test_utils/wasm/wasm_workspace/agent_info/src/lib.rs
================================================
pub mod integrity;

#[cfg(not(feature = "integrity"))]
pub mod coordinator;



================================================
File: crates/test_utils/wasm/wasm_workspace/agent_key_lineage/Cargo.toml
================================================
[package]
name = "agent_key_lineage"
version = "0.1.0"
edition = "2021"

[lib]
name = "test_wasm_agent_key_lineage"
crate-type = ["cdylib", "rlib"]

[[example]]
name = "integrity_test_wasm_agent_key_lineage"
path = "src/integrity.rs"
crate-type = ["cdylib", "rlib"]

# reminder - do not use workspace deps
[dependencies]
hdk = { path = "../../../../hdk", features = ["unstable-functions"] }
serde = "1.0"
hdi = { path = "../../../../hdi", features = ["unstable-functions"] }



================================================
File: crates/test_utils/wasm/wasm_workspace/agent_key_lineage/src/coordinator.rs
================================================
use hdi::{hdk_extern, prelude::ExternResult};
use hdk::{agent::get_agent_key_lineage, prelude::*};

use crate::integrity::{EntryTypes, SomeEntry};

#[hdk_extern]
fn init() -> ExternResult<InitCallbackResult> {
    // Make sure key lineage can be gotten from init host context.
    let agent_key = agent_info()?.agent_initial_pubkey;
    get_agent_key_lineage(agent_key)?;
    Ok(InitCallbackResult::Pass)
}

#[hdk_extern]
fn no_op_init() -> ExternResult<()> {
    // Only used to trigger init.
    Ok(())
}

#[hdk_extern]
fn create_entry_if_keys_of_same_lineage(
    agent_keys: (AgentPubKey, AgentPubKey),
) -> ExternResult<ActionHash> {
    create_entry(EntryTypes::SomeEntry(SomeEntry {
        key_1: agent_keys.0,
        key_2: agent_keys.1,
        content: "some_text".to_string(),
    }))
}

#[hdk_extern]
fn get_lineage_of_agent_keys(agent_key: AgentPubKey) -> ExternResult<Vec<AgentPubKey>> {
    get_agent_key_lineage(agent_key)
}



================================================
File: crates/test_utils/wasm/wasm_workspace/agent_key_lineage/src/integrity.rs
================================================
use hdi::{agent::is_same_agent, prelude::OpEntry};
use hdk::prelude::*;

#[hdk_entry_helper]
pub(crate) struct SomeEntry {
    pub content: String,
    pub key_1: AgentPubKey,
    pub key_2: AgentPubKey,
}

#[hdk_entry_types]
#[unit_enum(EntryTypesUnit)]
pub(crate) enum EntryTypes {
    SomeEntry(SomeEntry),
}

#[hdk_extern]
fn validate(op: Op) -> ExternResult<ValidateCallbackResult> {
    match op.flattened::<EntryTypes, ()>()? {
        hdi::prelude::FlatOp::StoreEntry(OpEntry::CreateEntry {
            app_entry: EntryTypes::SomeEntry(some_entry),
            ..
        }) => {
            if is_same_agent(some_entry.key_1, some_entry.key_2)? {
                Ok(ValidateCallbackResult::Valid)
            } else {
                Ok(ValidateCallbackResult::Invalid(
                    "agent key is not of same lineage".to_string(),
                ))
            }
        }
        _ => Ok(ValidateCallbackResult::Valid),
    }
}



================================================
File: crates/test_utils/wasm/wasm_workspace/agent_key_lineage/src/lib.rs
================================================
mod coordinator;
mod integrity;



================================================
File: crates/test_utils/wasm/wasm_workspace/anchor/Cargo.toml
================================================
[package]
name = "test_wasm_anchor"
version = "0.0.1"
authors = ["thedavidmeister", "thedavidmeister@gmail.com"]
edition = "2021"

[lib]
name = "test_wasm_anchor"
crate-type = ["cdylib", "rlib"]

[[example]]
name = "integrity_test_wasm_anchor"
path = "src/integrity.rs"
crate-type = ["cdylib", "rlib"]


# reminder - do not use workspace deps
[dependencies]
hdk = { path = "../../../../hdk", optional = true }
serde = "1.0"
hdi = { path = "../../../../hdi" }
holochain_test_wasm_common = { path = "../../../wasm_common" }

[features]
default = ["hdk"]
integrity = []



================================================
File: crates/test_utils/wasm/wasm_workspace/anchor/src/coordinator.rs
================================================
use crate::integrity::LinkTypes;
use hdk::prelude::*;
use holochain_test_wasm_common::*;

#[hdk_extern]
fn anchor(input: AnchorInput) -> ExternResult<EntryHash> {
    hdk::prelude::anchor(LinkTypes::Anchor, input.0, input.1)
}

#[hdk_extern]
fn anchor_many(inputs: ManyAnchorInput) -> ExternResult<Vec<EntryHash>> {
    let mut out = Vec::with_capacity(inputs.0.len());
    for input in inputs.0 {
        out.push(hdk::prelude::anchor(LinkTypes::Anchor, input.0, input.1)?);
    }
    Ok(out)
}

#[hdk_extern]
fn list_anchor_type_addresses(_: ()) -> ExternResult<Vec<AnyLinkableHash>> {
    hdk::prelude::list_anchor_type_addresses(LinkTypes::Anchor)
}

#[hdk_extern]
fn list_anchor_addresses(anchor_type: String) -> ExternResult<Vec<AnyLinkableHash>> {
    hdk::prelude::list_anchor_addresses(LinkTypes::Anchor, anchor_type)
}

#[hdk_extern]
fn list_anchor_tags(anchor_type: String) -> ExternResult<Vec<String>> {
    hdk::prelude::list_anchor_tags(LinkTypes::Anchor, anchor_type)
}



================================================
File: crates/test_utils/wasm/wasm_workspace/anchor/src/integrity.rs
================================================
use hdi::prelude::*;

#[hdk_link_types]
pub enum LinkTypes {
    Anchor,
}



================================================
File: crates/test_utils/wasm/wasm_workspace/anchor/src/lib.rs
================================================
pub mod integrity;

#[cfg(not(feature = "integrity"))]
pub mod coordinator;



================================================
File: crates/test_utils/wasm/wasm_workspace/app_validation/Cargo.toml
================================================
[package]
name = "test_wasm_app_validation"
version = "0.1.0"
edition = "2021"

[lib]
name = "test_wasm_app_validation"
crate-type = ["cdylib", "rlib"]

[[example]]
name = "integrity_test_wasm_app_validation"
path = "src/integrity.rs"
crate-type = ["cdylib", "rlib"]

# reminder - do not use workspace deps
[dependencies]
serde = "1.0"
holochain_test_wasm_common = { path = "../../../wasm_common", optional = true }
hdk = { path = "../../../../hdk" }
hdi = { path = "../../../../hdi" }



================================================
File: crates/test_utils/wasm/wasm_workspace/app_validation/src/coordinator.rs
================================================
use crate::integrity::*;
use hdk::prelude::*;

#[hdk_extern]
pub fn create_post(post: Post) -> ExternResult<Record> {
    let post_hash = create_entry(&EntryTypes::Post(post.clone()))?;
    let record = get(post_hash.clone(), GetOptions::default())?.ok_or(wasm_error!(
        WasmErrorInner::Guest("Could not find the newly created Post".to_string())
    ))?;
    let path = Path::from("all_posts");
    create_link(
        path.path_entry_hash()?,
        post_hash.clone(),
        LinkTypes::AllPosts,
        (),
    )?;
    let path = Path::from("some_other_path");
    create_link(
        path.path_entry_hash()?,
        post_hash.clone(),
        LinkTypes::AllPosts,
        (),
    )?;
    let path = Path::from("yet_another_path");
    create_link(
        path.path_entry_hash()?,
        post_hash.clone(),
        LinkTypes::AllPosts,
        (),
    )?;
    let path = Path::from("yap");
    create_link(
        path.path_entry_hash()?,
        post_hash.clone(),
        LinkTypes::AllPosts,
        (),
    )?;
    let my_agent_pub_key = agent_info()?.agent_latest_pubkey;
    create_link(
        my_agent_pub_key,
        post_hash.clone(),
        LinkTypes::PostsByAuthor,
        (),
    )?;
    Ok(record)
}

#[hdk_extern]
pub fn get_all_posts() -> ExternResult<Vec<Link>> {
    let path = Path::from("all_posts");
    get_links(GetLinksInputBuilder::try_new(path.path_entry_hash()?, LinkTypes::AllPosts)?.build())
}



================================================
File: crates/test_utils/wasm/wasm_workspace/app_validation/src/integrity.rs
================================================
// pub mod post;
use hdi::prelude::*;

#[hdk_entry_helper]
#[derive(Clone, PartialEq)]
pub struct Post(String);
#[derive(Serialize, Deserialize)]
#[serde(tag = "type")]
#[hdk_entry_types]
#[unit_enum(UnitEntryTypes)]
pub enum EntryTypes {
    Post(Post),
}
#[derive(Serialize, Deserialize)]
#[hdk_link_types]
pub enum LinkTypes {
    AllPosts,
    PostsByAuthor,
}

#[hdk_extern]
pub fn validate(op: Op) -> ExternResult<ValidateCallbackResult> {
    match op.flattened::<EntryTypes, LinkTypes>()? {
        FlatOp::StoreRecord(store_record) => {
            match store_record {
                OpRecord::CreateLink { target_address, .. } => {
                    let action_hash = target_address.into_action_hash().ok_or(wasm_error!(
                        WasmErrorInner::Guest("No action hash associated with link".to_string())
                    ))?;
                    let record = must_get_valid_record(action_hash)?;
                    let _post: Post = record
                        .entry()
                        .to_app_option()
                        .map_err(|e| wasm_error!(e))?
                        .ok_or(wasm_error!(WasmErrorInner::Guest(
                            "Linked action must reference an entry".to_string()
                        )))?;
                    Ok(ValidateCallbackResult::Valid)
                }
                _ => Ok(ValidateCallbackResult::Valid),
            }
        }
        _ => Ok(ValidateCallbackResult::Valid),
    }
}



================================================
File: crates/test_utils/wasm/wasm_workspace/app_validation/src/lib.rs
================================================
pub mod coordinator;
pub mod integrity;



================================================
File: crates/test_utils/wasm/wasm_workspace/bench/Cargo.toml
================================================
[package]
name = "test_wasm_bench"
version = "0.0.1"
authors = ["thedavidmeister", "thedavidmeister@gmail.com"]
edition = "2021"

[lib]
name = "test_wasm_bench"
crate-type = ["cdylib", "rlib"]

[[example]]
name = "integrity_test_wasm_bench"
path = "src/integrity.rs"
crate-type = ["cdylib", "rlib"]


# reminder - do not use workspace deps
[dependencies]
hdk = { path = "../../../../hdk", optional = true }
serde = "1.0"
hdi = { path = "../../../../hdi" }

[features]
default = ["hdk"]
integrity = []



================================================
File: crates/test_utils/wasm/wasm_workspace/bench/src/coordinator.rs
================================================
//! externs to help bench the wasm ribosome

use hdk::prelude::*;

/// round trip bytes back to the host
/// useful to see what the basic throughput of our wasm implementation is
#[hdk_extern]
fn echo_bytes(bytes: Bytes) -> ExternResult<Bytes> {
    Ok(bytes)
}



================================================
File: crates/test_utils/wasm/wasm_workspace/bench/src/integrity.rs
================================================



================================================
File: crates/test_utils/wasm/wasm_workspace/bench/src/lib.rs
================================================
pub mod integrity;

#[cfg(not(feature = "integrity"))]
pub mod coordinator;



================================================
File: crates/test_utils/wasm/wasm_workspace/capability/Cargo.toml
================================================
[package]
name = "test_wasm_capability"
version = "0.0.1"
authors = ["thedavidmeister", "thedavidmeister@gmail.com"]
edition = "2021"

[lib]
name = "test_wasm_capability"
crate-type = ["cdylib", "rlib"]

[[example]]
name = "integrity_test_wasm_capability"
path = "src/integrity.rs"
crate-type = ["cdylib", "rlib"]

# reminder - do not use workspace deps
[dependencies]
serde = "1.0"
hdk = { path = "../../../../hdk", optional = true }

[features]
default = ["hdk"]
integrity = []
unstable-functions = [
    "hdk?/unstable-functions",
]



================================================
File: crates/test_utils/wasm/wasm_workspace/capability/src/coordinator.rs
================================================
use hdk::prelude::*;

#[derive(serde::Serialize, serde::Deserialize, Debug)]
pub struct CapFor(CapSecret, AgentPubKey);

#[hdk_extern]
fn init(_: ()) -> ExternResult<InitCallbackResult> {
    // grant unrestricted access to accept_cap_claim so other agents can send us claims
    let mut fns = BTreeSet::new();
    fns.insert((zome_info()?.name, "accept_cap_claim".into()));
    fns.insert((zome_info()?.name, "another_cap_grant".into()));
    let functions = GrantedFunctions::Listed(fns);
    create_cap_grant(CapGrantEntry {
        tag: "".into(),
        // empty access converts to unrestricted
        access: ().into(),
        functions,
    })?;

    Ok(InitCallbackResult::Pass)
}

#[hdk_extern]
pub fn cap_secret(_: ()) -> ExternResult<CapSecret> {
    CapSecret::try_from_random()
}

#[cfg(feature = "unstable-functions")]
#[hdk_extern]
pub fn block_agent(target: AgentPubKey) -> ExternResult<()> {
    HDK.with(|h| {
        h.borrow()
            .block_agent(holochain_zome_types::block::BlockAgentInput {
                target,
                reason: vec![],
                interval: InclusiveTimestampInterval::try_new(Timestamp::MIN, Timestamp::MAX)
                    .unwrap(),
            })
    })
}

#[cfg(feature = "unstable-functions")]
#[hdk_extern]
pub fn unblock_agent(target: AgentPubKey) -> ExternResult<()> {
    HDK.with(|h| {
        h.borrow()
            .unblock_agent(holochain_zome_types::block::BlockAgentInput {
                target,
                reason: vec![],
                interval: InclusiveTimestampInterval::try_new(Timestamp::MIN, Timestamp::MAX)
                    .unwrap(),
            })
    })
}

fn cap_grant_entry(secret: CapSecret) -> ExternResult<CapGrantEntry> {
    let mut fns = BTreeSet::new();
    let this_zome = zome_info()?.name;
    fns.insert((this_zome, "needs_cap_claim".into()));
    let functions = GrantedFunctions::Listed(fns);
    Ok(CapGrantEntry {
        tag: "".into(),
        access: secret.into(),
        functions,
    })
}

#[hdk_extern]
pub fn transferable_cap_grant(secret: CapSecret) -> ExternResult<ActionHash> {
    create_cap_grant(cap_grant_entry(secret)?)
}

#[hdk_extern]
pub fn roll_cap_grant(action_hash: ActionHash) -> ExternResult<ActionHash> {
    let secret = CapSecret::try_from_random()?;
    update_cap_grant(action_hash, cap_grant_entry(secret)?)
}

#[hdk_extern]
pub fn delete_cap_grant(action_hash: ActionHash) -> ExternResult<ActionHash> {
    hdk::prelude::delete_cap_grant(action_hash)
}

#[hdk_extern]
fn get_entry(action_hash: ActionHash) -> ExternResult<Option<Record>> {
    get(action_hash, GetOptions::network())
}

#[hdk_extern]
fn another_cap_grant(_: ()) -> ExternResult<()> {
    Ok(())
}

/// accepts a cap claim and commits it to the local chain
/// intended to
#[hdk_extern]
fn accept_cap_claim(claim: CapClaim) -> ExternResult<ActionHash> {
    create_cap_claim(claim)
}

#[hdk_extern]
fn needs_cap_claim(_: ()) -> ExternResult<()> {
    Ok(())
}

#[hdk_extern]
fn try_cap_claim(cap_for: crate::CapFor) -> ExternResult<ZomeCallResponse> {
    call_remote(
        cap_for.1,
        zome_info()?.name,
        "needs_cap_claim".to_string().into(),
        Some(cap_for.0),
        &(),
    )
}

#[hdk_extern]
fn send_assigned_cap_claim(agent: AgentPubKey) -> ExternResult<()> {
    let tag = String::from("has_cap_claim");

    // make a new secret
    let secret = CapSecret::try_from_random()?;

    // grant the secret as assigned (can only be used by the intended agent)
    let mut fns = BTreeSet::new();
    let this_zome = zome_info()?.name;
    fns.insert((this_zome.clone(), "needs_cap_claim".into()));
    let functions = GrantedFunctions::Listed(fns);
    create_cap_grant(CapGrantEntry {
        access: (secret, agent.clone()).into(),
        functions,
        tag: tag.clone(),
    })?;

    // send the assigned cap token
    call_remote(
        agent,
        this_zome,
        "accept_cap_claim".into(),
        None,
        &CapClaim::new(tag, agent_info()?.agent_latest_pubkey, secret),
    )?;
    Ok(())
}



================================================
File: crates/test_utils/wasm/wasm_workspace/capability/src/integrity.rs
================================================



================================================
File: crates/test_utils/wasm/wasm_workspace/capability/src/lib.rs
================================================
pub mod integrity;

#[cfg(not(feature = "integrity"))]
pub mod coordinator;

#[cfg(not(feature = "integrity"))]
pub use coordinator::*;



================================================
File: crates/test_utils/wasm/wasm_workspace/clone/Cargo.toml
================================================
[package]
name = "test_wasm_clone"
version = "0.0.1"
edition = "2021"

[lib]
name = "test_wasm_clone"
crate-type = ["cdylib", "rlib"]

[[example]]
name = "integrity_test_wasm_clone"
path = "src/integrity.rs"
crate-type = ["cdylib", "rlib"]

# reminder - do not use workspace deps
[dependencies]
serde = "1.0"
hdk = { path = "../../../../hdk", optional = true, features = ["properties"] }
hdi = { path = "../../../../hdi" }

[features]
default = ["hdk"]
integrity = []



================================================
File: crates/test_utils/wasm/wasm_workspace/clone/src/coordinator.rs
================================================
use hdk::prelude::*;

#[hdk_extern]
fn create_clone(input: CreateCloneCellInput) -> ExternResult<ClonedCell> {
    create_clone_cell(input)
}

#[hdk_extern]
fn disable_clone(input: DisableCloneCellInput) -> ExternResult<()> {
    disable_clone_cell(input)
}

#[hdk_extern]
fn enable_clone(input: EnableCloneCellInput) -> ExternResult<ClonedCell> {
    enable_clone_cell(input)
}

#[hdk_extern]
fn delete_clone(input: DeleteCloneCellInput) -> ExternResult<()> {
    delete_clone_cell(input)
}



================================================
File: crates/test_utils/wasm/wasm_workspace/clone/src/integrity.rs
================================================



================================================
File: crates/test_utils/wasm/wasm_workspace/clone/src/lib.rs
================================================
pub mod integrity;

#[cfg(not(feature = "integrity"))]
pub mod coordinator;



================================================
File: crates/test_utils/wasm/wasm_workspace/coordinator_zome/Cargo.toml
================================================
[package]
name = "test_wasm_coordinator_zome"
version = "0.0.1"
authors = ["Holochain Core Dev Team <devcore@holochain.org>"]
edition = "2021"

[lib]
name = "test_wasm_coordinator_zome"
crate-type = ["cdylib", "rlib"]

# reminder - do not use workspace deps
[dependencies]
serde = "1.0"
holochain_test_wasm_common = { path = "../../../wasm_common" }
hdk = { path = "../../../../hdk" }
test_wasm_integrity_zome = { path = "../integrity_zome" }

[features]
default = []
mock = ["hdk/mock"]



================================================
File: crates/test_utils/wasm/wasm_workspace/coordinator_zome/src/lib.rs
================================================
use hdk::prelude::*;
use integrity_zome::EntryTypes;
use integrity_zome::Msg;
use integrity_zome::Post;
use integrity_zome::PrivMsg;
use test_wasm_integrity_zome as integrity_zome;

fn post() -> Post {
    Post("foo".into())
}

fn new_post() -> EntryTypes {
    EntryTypes::Post(Post("foo".into()))
}

fn msg() -> Msg {
    Msg("hello".into())
}

#[hdk_extern]
fn create_entry(_: ()) -> ExternResult<ActionHash> {
    let post = new_post();
    let index = ScopedEntryDefIndex::try_from(&post)?;
    let vis = EntryVisibility::from(&post);
    let entry = post.try_into().unwrap();
    HDK.with(|h| {
        h.borrow().create(CreateInput::new(
            index,
            vis,
            entry,
            // This is used to test many conductors thrashing creates between
            // each other so we want to avoid retries that make the test take
            // a long time.
            ChainTopOrdering::Relaxed,
        ))
    })
}

#[hdk_extern]
fn create_post(post: Post) -> ExternResult<ActionHash> {
    hdk::prelude::create_entry(&EntryTypes::Post(post))
}

#[hdk_extern]
fn delete_post(post_hash: ActionHash) -> ExternResult<ActionHash> {
    hdk::prelude::delete_entry(post_hash)
}

#[hdk_extern]
fn get_entry(_: ()) -> ExternResult<Option<Record>> {
    get(hash_entry(&post())?, GetOptions::local())
}

#[hdk_extern]
fn get_entry_twice(_: ()) -> ExternResult<Vec<Option<Record>>> {
    HDK.with(|h| {
        h.borrow().get(vec![
            GetInput::new(
                hash_entry(&post())?.into(),
                GetOptions::local()
            );
            2
        ])
    })
}

#[hdk_extern]
fn get_post(hash: ActionHash) -> ExternResult<Option<Record>> {
    get(hash, GetOptions::local())
}

#[hdk_extern]
fn create_msg(_: ()) -> ExternResult<ActionHash> {
    hdk::prelude::create_entry(EntryTypes::Msg(msg()))
}

#[hdk_extern]
fn create_priv_msg(_: ()) -> ExternResult<ActionHash> {
    hdk::prelude::create_entry(&EntryTypes::PrivMsg(PrivMsg("Don't tell anyone".into())))
}

#[hdk_extern]
fn get_activity(
    input: holochain_test_wasm_common::AgentActivitySearch,
) -> ExternResult<AgentActivity> {
    get_agent_activity(input.agent, input.query, input.request)
}

#[hdk_extern]
fn init(_: ()) -> ExternResult<InitCallbackResult> {
    // grant unrestricted access to accept_cap_claim so other agents can send us claims
    let mut fns = BTreeSet::new();
    fns.insert((zome_info()?.name, "create_entry".into()));
    let functions = GrantedFunctions::Listed(fns);
    create_cap_grant(CapGrantEntry {
        tag: "".into(),
        // empty access converts to unrestricted
        access: ().into(),
        functions,
    })?;

    Ok(InitCallbackResult::Pass)
}

/// Create a post entry then
/// create another post through a
/// call
#[hdk_extern]
fn call_create_entry(_: ()) -> ExternResult<ActionHash> {
    // Create an entry directly via. the hdk.
    hdk::prelude::create_entry(&new_post())?;
    // Create an entry via a `call`.
    let zome_call_response: ZomeCallResponse = call(
        CallTargetCell::Local,
        zome_info()?.name,
        "create_entry".to_string().into(),
        None,
        &(),
    )?;

    match zome_call_response {
        ZomeCallResponse::Ok(v) => Ok(v.decode().map_err(|e| wasm_error!(e))?),
        ZomeCallResponse::AuthenticationFailed(signature, provenance) => {
            Err(wasm_error!(WasmErrorInner::Guest(format!(
                "Authentication failed with signature {signature:?} from provenance {provenance}"
            ))))
        }
        ZomeCallResponse::Unauthorized(reason, cap_secret, zome_name, function_name) => {
            Err(wasm_error!(WasmErrorInner::Guest(format!(
                "Unauthorized: {} {:?} {} {}",
                reason, cap_secret, zome_name, function_name
            ))))
        }
        // Unbounded recursion.
        ZomeCallResponse::NetworkError(_) => call_create_entry(()),
        ZomeCallResponse::CountersigningSession(e) => Err(wasm_error!(WasmErrorInner::Guest(
            format!("Countersigning session failed: {}", e)
        ))),
    }
}

#[hdk_extern]
fn call_create_entry_remotely(agent: AgentPubKey) -> ExternResult<ActionHash> {
    let zome_call_response: ZomeCallResponse = call_remote(
        agent.clone(),
        zome_info()?.name,
        "create_entry".to_string().into(),
        None,
        &(),
    )?;

    match zome_call_response {
        ZomeCallResponse::Ok(v) => Ok(v.decode().map_err(|e| wasm_error!(e))?),
        ZomeCallResponse::AuthenticationFailed(signature, provenance) => {
            Err(wasm_error!(WasmErrorInner::Guest(format!(
                "Authentication failed with signature {signature:?} from provenance {provenance}"
            ))))
        }
        ZomeCallResponse::Unauthorized(reason, cap_secret, zome_name, function_name) => {
            Err(wasm_error!(WasmErrorInner::Guest(format!(
                "Unauthorized: {} {:?} {} {}",
                reason, cap_secret, zome_name, function_name
            ))))
        }
        // Unbounded recursion.
        ZomeCallResponse::NetworkError(_) => call_create_entry_remotely(agent),
        ZomeCallResponse::CountersigningSession(e) => Err(wasm_error!(WasmErrorInner::Guest(
            format!("Countersigning session failed: {}", e)
        ))),
    }
}

#[hdk_extern]
fn must_get_valid_record(action_hash: ActionHash) -> ExternResult<Record> {
    hdk::prelude::must_get_valid_record(action_hash)
}

/// Same as above but doesn't recurse on network errors.
#[hdk_extern]
fn call_create_entry_remotely_no_rec(agent: AgentPubKey) -> ExternResult<ActionHash> {
    let zome_call_response: ZomeCallResponse = call_remote(
        agent.clone(),
        zome_info()?.name,
        "create_entry".to_string().into(),
        None,
        &(),
    )?;

    match zome_call_response {
        ZomeCallResponse::Ok(v) => Ok(v.decode().map_err(|e| wasm_error!(e))?),
        ZomeCallResponse::AuthenticationFailed(signature, provenance) => {
            Err(wasm_error!(WasmErrorInner::Guest(format!(
                "Authentication failed with signature {signature:?} from provenance {provenance}"
            ))))
        }
        ZomeCallResponse::Unauthorized(reason, cap_secret, zome_name, function_name) => {
            Err(wasm_error!(WasmErrorInner::Guest(format!(
                "Unauthorized: {} {:?} {} {}",
                reason, cap_secret, zome_name, function_name
            ))))
        }
        // Unbounded recursion.
        ZomeCallResponse::NetworkError(e) => Err(wasm_error!(WasmErrorInner::Guest(format!(
            "Network Error: {}",
            e
        )))),
        ZomeCallResponse::CountersigningSession(e) => Err(wasm_error!(WasmErrorInner::Guest(
            format!("Countersigning session failed: {}", e)
        ))),
    }
}



================================================
File: crates/test_utils/wasm/wasm_workspace/coordinator_zome_update/Cargo.toml
================================================
[package]
name = "test_wasm_coordinator_zome_update"
version = "0.0.1"
authors = ["Holochain Core Dev Team <devcore@holochain.org>"]
edition = "2021"

[lib]
name = "test_wasm_coordinator_zome_update"
crate-type = ["cdylib", "rlib"]

# reminder - do not use workspace deps
[dependencies]
serde = "1.0"
holochain_test_wasm_common = { path = "../../../wasm_common" }
hdk = { path = "../../../../hdk" }
test_wasm_integrity_zome = { path = "../integrity_zome" }

[features]
default = []
mock = ["hdk/mock"]



================================================
File: crates/test_utils/wasm/wasm_workspace/coordinator_zome_update/src/lib.rs
================================================
use hdk::prelude::*;
use integrity_zome::Post;
use test_wasm_integrity_zome as integrity_zome;

#[hdk_dependent_entry_types]
enum EntryZomes {
    IntegrityZome(integrity_zome::EntryTypes),
}

#[hdk_extern]
fn get_entry(hash: ActionHash) -> ExternResult<Option<Record>> {
    get(hash, GetOptions::local())
}

#[hdk_extern]
fn create_post(post: Post) -> ExternResult<ActionHash> {
    hdk::prelude::create_entry(&EntryZomes::IntegrityZome(
        integrity_zome::EntryTypes::Post(post),
    ))
}



================================================
File: crates/test_utils/wasm/wasm_workspace/countersigning/Cargo.toml
================================================
[package]
name = "test_wasm_countersigning"
version = "0.0.1"
authors = ["thedavidmeister", "thedavidmeister@gmail.com"]
edition = "2021"

[lib]
name = "test_wasm_countersigning"
crate-type = ["cdylib", "rlib"]

[[example]]
name = "integrity_test_wasm_countersigning"
path = "src/integrity.rs"
crate-type = ["cdylib", "rlib"]


# reminder - do not use workspace deps
[dependencies]
hdk = { path = "../../../../hdk", optional = true, features = [
    "unstable-countersigning",
] }
serde = "1.0"
holochain_test_wasm_common = { path = "../../../wasm_common" }
hdi = { path = "../../../../hdi" }

[features]
default = ["hdk"]
integrity = []
unstable-functions = ["hdk/unstable-functions"]



================================================
File: crates/test_utils/wasm/wasm_workspace/countersigning/src/coordinator.rs
================================================
use crate::integrity::*;
use hdk::prelude::*;

const STANDARD_TIMEOUT_MILLIS: u64 = 30000;
const FAST_TIMEOUT_MILLIS: u64 = 10000;

#[hdk_extern]
fn create_a_thing(_: ()) -> ExternResult<ActionHash> {
    create_entry(&EntryTypes::Thing(Thing::Valid))
}

#[hdk_extern]
fn create_an_invalid_thing(_: ()) -> ExternResult<ActionHash> {
    create_entry(&EntryTypes::Thing(Thing::Invalid))
}

fn create_countersigned(
    responses: Vec<PreflightResponse>,
    thing: Thing,
) -> ExternResult<(ActionHash, EntryHash)> {
    let thing = EntryTypes::Thing(thing);
    let entry_def_index = ScopedEntryDefIndex::try_from(&thing)?;
    let visibility = EntryVisibility::from(&thing);

    let thing = match thing {
        EntryTypes::Thing(t) => t,
    };

    let entry = Entry::CounterSign(
        Box::new(
            CounterSigningSessionData::try_from_responses(responses, vec![]).map_err(
                |countersigning_error| {
                    wasm_error!(WasmErrorInner::Guest(countersigning_error.to_string()))
                },
            )?,
        ),
        thing.try_into()?,
    );
    let action_hash: ActionHash = HDK.with(|h| {
        h.borrow().create(CreateInput::new(
            entry_def_index,
            visibility,
            entry,
            // Countersigned entries MUST have strict ordering.
            ChainTopOrdering::Strict,
        ))
    })?;

    let signed_action: SignedActionHashed = must_get_action(action_hash.clone())?;
    let entry_hash: EntryHash = signed_action.action().entry_hash().unwrap().clone();

    Ok((action_hash, entry_hash))
}

#[hdk_extern]
fn create_an_invalid_countersigned_thing(
    responses: Vec<PreflightResponse>,
) -> ExternResult<ActionHash> {
    Ok(create_countersigned(responses, Thing::Invalid)?.0)
}

#[hdk_extern]
fn create_a_countersigned_thing(responses: Vec<PreflightResponse>) -> ExternResult<ActionHash> {
    Ok(create_countersigned(responses, Thing::Valid)?.0)
}

#[hdk_extern]
fn create_a_countersigned_thing_with_entry_hash(
    responses: Vec<PreflightResponse>,
) -> ExternResult<(ActionHash, EntryHash)> {
    create_countersigned(responses, Thing::Valid)
}

fn generate_preflight_request(
    agents: Vec<(AgentPubKey, Vec<Role>)>,
    thing: Thing,
    enzymatic: bool,
    session_timeout: u64,
) -> ExternResult<PreflightRequest> {
    let hash = hash_entry(&thing)?;
    let thing = EntryTypes::Thing(thing);
    let entry_type = thing.try_into()?;
    PreflightRequest::try_new(
        hash,
        agents,
        vec![],
        0,
        enzymatic,
        session_times_from_millis(session_timeout)?,
        ActionBase::Create(CreateBase::new(entry_type)),
        PreflightBytes(vec![]),
    )
    .map_err(|e| wasm_error!(WasmErrorInner::Guest(e.to_string())))
}

#[hdk_extern]
fn generate_countersigning_preflight_request(
    agents: Vec<(AgentPubKey, Vec<Role>)>,
) -> ExternResult<PreflightRequest> {
    generate_preflight_request(agents, Thing::Valid, false, STANDARD_TIMEOUT_MILLIS)
}

#[hdk_extern]
fn generate_countersigning_preflight_request_fast(
    agents: Vec<(AgentPubKey, Vec<Role>)>,
) -> ExternResult<PreflightRequest> {
    generate_preflight_request(agents, Thing::Valid, false, FAST_TIMEOUT_MILLIS)
}

#[hdk_extern]
fn generate_countersigning_preflight_request_enzymatic(
    agents: Vec<(AgentPubKey, Vec<Role>)>,
) -> ExternResult<PreflightRequest> {
    generate_preflight_request(agents, Thing::Valid, true, STANDARD_TIMEOUT_MILLIS)
}

#[hdk_extern]
fn generate_invalid_countersigning_preflight_request(
    agents: Vec<(AgentPubKey, Vec<Role>)>,
) -> ExternResult<PreflightRequest> {
    generate_preflight_request(agents, Thing::Invalid, false, STANDARD_TIMEOUT_MILLIS)
}

#[hdk_extern]
fn generate_invalid_countersigning_preflight_request_enzymatic(
    agents: Vec<(AgentPubKey, Vec<Role>)>,
) -> ExternResult<PreflightRequest> {
    generate_preflight_request(agents, Thing::Invalid, true, STANDARD_TIMEOUT_MILLIS)
}

#[hdk_extern]
fn accept_countersigning_preflight_request(
    preflight_request: PreflightRequest,
) -> ExternResult<PreflightRequestAcceptance> {
    hdk::prelude::accept_countersigning_preflight_request(preflight_request)
}

#[hdk_extern]
fn must_get_action(action_hash: ActionHash) -> ExternResult<SignedActionHashed> {
    hdk::prelude::must_get_action(action_hash)
}

#[hdk_extern]
fn must_get_entry(entry_hash: EntryHash) -> ExternResult<EntryHashed> {
    hdk::prelude::must_get_entry(entry_hash)
}

#[hdk_extern]
fn must_get_valid_record(action_hash: ActionHash) -> ExternResult<Record> {
    hdk::prelude::must_get_valid_record(action_hash)
}

#[hdk_extern]
fn get_agent_activity(input: GetAgentActivityInput) -> ExternResult<AgentActivity> {
    HDK.with(|h| h.borrow().get_agent_activity(input))
}

#[cfg(feature = "unstable-functions")]
#[hdk_extern]
fn schedule_signal() -> ExternResult<()> {
    HDK.with(|h| h.borrow().schedule("scheduled_fn".to_string()))
}

#[cfg(feature = "unstable-functions")]
#[hdk_extern(infallible)]
fn scheduled_fn(_: Option<Schedule>) -> Option<Schedule> {
    emit_signal("scheduled hello");
    Some(Schedule::from("*/1 * * * * *".to_string()))
}



================================================
File: crates/test_utils/wasm/wasm_workspace/countersigning/src/integrity.rs
================================================
use hdi::prelude::*;

#[hdk_entry_helper]
pub enum Thing {
    Valid,
    Invalid,
}

impl From<Thing> for ValidateCallbackResult {
    fn from(thing: Thing) -> Self {
        match thing {
            Thing::Valid => ValidateCallbackResult::Valid,
            Thing::Invalid => ValidateCallbackResult::Invalid("never valid".to_string()),
        }
    }
}

#[hdk_entry_types]
#[unit_enum(EntryTypesUnit)]
pub enum EntryTypes {
    Thing(Thing),
}

#[hdk_extern]
fn validate(op: Op) -> ExternResult<ValidateCallbackResult> {
    match op {
        Op::StoreRecord(StoreRecord {
            record:
                Record {
                    signed_action,
                    entry: RecordEntry::Present(entry),
                },
        }) => {
            match signed_action.action().entry_type().and_then(|entry_type| match entry_type {
                EntryType::App(AppEntryDef { entry_index, zome_index, .. }) => Some((zome_index, entry_index)),
                _ => None,
            }) {
                Some((zome_index, entry_index)) => {
                    match EntryTypes::deserialize_from_type(*zome_index, *entry_index, &entry) {
                        Ok(Some(EntryTypes::Thing(thing))) => Ok(thing.into()),
                        Ok(None) => Ok(ValidateCallbackResult::Valid),
                        Err(WasmError {
                            error: WasmErrorInner::Deserialize(_),
                            ..
                        }) => Ok(ValidateCallbackResult::Invalid(
                            "Failed to deserialize entry".to_string(),
                        )),
                        Err(e) => Err(e),
                    }
                }
                None => Ok(ValidateCallbackResult::Valid),
            }
        }
        _ => Ok(ValidateCallbackResult::Valid),
    }
}



================================================
File: crates/test_utils/wasm/wasm_workspace/countersigning/src/lib.rs
================================================
pub mod integrity;

#[cfg(not(feature = "integrity"))]
pub mod coordinator;



================================================
File: crates/test_utils/wasm/wasm_workspace/crd/Cargo.toml
================================================
[package]
name = "test_wasm_crd"
version = "0.0.1"
authors = ["thedavidmeister", "thedavidmeister@gmail.com"]
edition = "2021"

[lib]
name = "test_wasm_crd"
crate-type = ["cdylib", "rlib"]

[[example]]
name = "integrity_test_wasm_crd"
path = "src/integrity.rs"
crate-type = ["cdylib", "rlib"]

# reminder - do not use workspace deps
[dependencies]
serde = "1.0"
holochain_test_wasm_common = { path = "../../../wasm_common" }
hdk = { path = "../../../../hdk", optional = true }
hdi = { path = "../../../../hdi" }

[features]
default = ["hdk"]
integrity = []
mock = ["hdk/mock"]

[dev-dependencies]
fixt = { path = "../../../../fixt" }
hdk = { path = "../../../../hdk", features = ["fixturators"] }



================================================
File: crates/test_utils/wasm/wasm_workspace/crd/src/coordinator.rs
================================================
use crate::integrity::*;
use hdk::prelude::*;

use EntryZomes::*;

#[hdk_dependent_entry_types]
enum EntryZomes {
    IntegrityCrd(EntryTypes),
}

#[hdk_extern]
fn create(_: ()) -> ExternResult<ActionHash> {
    create_entry(&IntegrityCrd(EntryTypes::Thing(Thing)))
}

/// `read` seems to be a reserved worked that causes SIGSEGV invalid memory reference when used as `#[hdk_extern]`
#[hdk_extern]
fn reed(action_hash: ActionHash) -> ExternResult<Option<Record>> {
    get(action_hash, GetOptions::network())
}

#[hdk_extern]
fn delete_via_hash(action_hash: ActionHash) -> ExternResult<ActionHash> {
    delete_entry(action_hash)
}

#[hdk_extern]
fn delete_via_input(delete_input: DeleteInput) -> ExternResult<ActionHash> {
    delete_entry(delete_input)
}

#[hdk_extern]
fn get_agent_activity(input: AgentPubKey) -> ExternResult<AgentActivity> {
    let query = ChainQueryFilter::new().include_entries(true);
    let options = ActivityRequest::Full;
    hdk::prelude::get_agent_activity(input, query, options)
}

#[cfg(all(test, feature = "mock"))]
pub mod test {
    use ::fixt::prelude::*;
    use hdk::prelude::*;

    #[test]
    fn create_smoke() {
        let mut mock_hdk = hdk::prelude::MockHdkT::new();

        let thing = EntryTypes::Thing(Thing);
        let action_hash = fixt!(ActionHash);
        let closure_action_hash = action_hash.clone();
        mock_hdk
            .expect_create()
            .with(hdk::prelude::mockall::predicate::eq(CreateInput {
                entry_def_id: thing.entry_def_id(),
                entry: thing.try_into().unwrap(),
                chain_top_ordering: Default::default(),
            }))
            .times(1)
            .return_once(move |_| Ok(closure_action_hash));

        hdk::prelude::set_hdk(mock_hdk);

        let result = super::create(());

        assert_eq!(result, Ok(action_hash))
    }

    #[test]
    fn get_smoke() {
        let mut mock_hdk = hdk::prelude::MockHdkT::new();

        let input_action_hash = fixt!(ActionHash);
        mock_hdk
            .expect_get()
            .with(hdk::prelude::mockall::predicate::eq(vec![GetInput::new(
                input_action_hash.clone().into(),
                GetOptions::network(),
            )]))
            .times(1)
            .return_once(move |_| Ok(vec![None]));

        hdk::prelude::set_hdk(mock_hdk);

        let result = super::reed(input_action_hash);

        assert_eq!(result, Ok(None))
    }

    #[test]
    fn delete_hash_smoke() {
        let mut mock_hdk = hdk::prelude::MockHdkT::new();

        let input_action_hash = fixt!(ActionHash);
        let output_action_hash = fixt!(ActionHash);
        let output_action_hash_closure = output_action_hash.clone();
        mock_hdk
            .expect_delete()
            .with(hdk::prelude::mockall::predicate::eq(DeleteInput::new(
                input_action_hash.clone(),
                ChainTopOrdering::default(),
            )))
            .times(1)
            .return_once(move |_| Ok(output_action_hash_closure));

        hdk::prelude::set_hdk(mock_hdk);

        let result = super::delete_via_hash(input_action_hash);

        assert_eq!(result, Ok(output_action_hash))
    }

    #[test]
    fn delete_input_smoke() {
        let mut mock_hdk = hdk::prelude::MockHdkT::new();

        let input_action_hash = fixt!(ActionHash);
        let output_action_hash = fixt!(ActionHash);
        let output_action_hash_closure = output_action_hash.clone();
        mock_hdk
            .expect_delete()
            .with(hdk::prelude::mockall::predicate::eq(DeleteInput::new(
                input_action_hash.clone(),
                ChainTopOrdering::Relaxed,
            )))
            .times(1)
            .return_once(move |_| Ok(output_action_hash_closure));

        hdk::prelude::set_hdk(mock_hdk);

        let input = DeleteInput {
            deletes_action_hash: input_action_hash,
            chain_top_ordering: ChainTopOrdering::Relaxed,
        };
        let result = super::delete_via_input(input);

        assert_eq!(result, Ok(output_action_hash))
    }
}



================================================
File: crates/test_utils/wasm/wasm_workspace/crd/src/integrity.rs
================================================
use hdi::prelude::*;

#[hdk_entry_helper]
pub struct Thing;

#[hdk_entry_types]
#[unit_enum(EntryTypesUnit)]
pub enum EntryTypes {
    Thing(Thing),
}



================================================
File: crates/test_utils/wasm/wasm_workspace/crd/src/lib.rs
================================================
pub mod integrity;

#[cfg(not(feature = "integrity"))]
pub mod coordinator;



================================================
File: crates/test_utils/wasm/wasm_workspace/create_entry/Cargo.toml
================================================
[package]
name = "test_wasm_create_entry"
version = "0.0.1"
authors = ["thedavidmeister", "thedavidmeister@gmail.com"]
edition = "2021"

[lib]
name = "test_wasm_create_entry"
crate-type = ["cdylib", "rlib"]

[[example]]
name = "integrity_test_wasm_create_entry"
path = "src/integrity.rs"
crate-type = ["cdylib", "rlib"]

# reminder - do not use workspace deps
[dependencies]
serde = "1.0"
holochain_test_wasm_common = { path = "../../../wasm_common", optional = true }
hdk = { path = "../../../../hdk", optional = true }
hdi = { path = "../../../../hdi" }

[features]
default = ["holochain_test_wasm_common", "hdk"]
integrity = []
mock = ["hdk/mock", "default"]
unstable-functions = [
    "hdk?/unstable-functions",
    "hdi/unstable-functions",
]



================================================
File: crates/test_utils/wasm/wasm_workspace/create_entry/src/coordinator.rs
================================================
use crate::integrity::*;
use hdk::prelude::*;

#[hdk_dependent_entry_types]
enum EntryZomes {
    IntegrityCreateEntry(crate::integrity::EntryTypes),
}

fn post() -> Post {
    Post("foo".into())
}

fn new_post() -> EntryZomes {
    EntryZomes::IntegrityCreateEntry(EntryTypes::Post(Post("foo".into())))
}

fn msg() -> Msg {
    Msg("hello".into())
}

#[cfg(feature = "unstable-functions")]
#[hdk_extern]
pub fn block_agent(target: AgentPubKey) -> ExternResult<()> {
    HDK.with(|h| {
        h.borrow()
            .block_agent(holochain_zome_types::block::BlockAgentInput {
                target,
                reason: vec![],
                interval: InclusiveTimestampInterval::try_new(Timestamp::MIN, Timestamp::MAX)
                    .unwrap(),
            })
    })
}

#[cfg(feature = "unstable-functions")]
#[hdk_extern]
pub fn unblock_agent(target: AgentPubKey) -> ExternResult<()> {
    HDK.with(|h| {
        h.borrow()
            .unblock_agent(holochain_zome_types::block::BlockAgentInput {
                target,
                reason: vec![],
                interval: InclusiveTimestampInterval::try_new(Timestamp::MIN, Timestamp::MAX)
                    .unwrap(),
            })
    })
}

#[hdk_extern]
fn create_entry(_: ()) -> ExternResult<ActionHash> {
    let post = new_post();
    HDK.with(|h| {
        h.borrow().create(CreateInput::new(
            ScopedEntryDefIndex::try_from(&post)?,
            EntryVisibility::from(&post),
            post.try_into().unwrap(),
            // This is used to test many conductors thrashing creates between
            // each other so we want to avoid retries that make the test take
            // a long time.
            ChainTopOrdering::Relaxed,
        ))
    })
}

#[hdk_extern]
fn create_post(post: Post) -> ExternResult<ActionHash> {
    hdk::prelude::create_entry(&EntryZomes::IntegrityCreateEntry(
        crate::integrity::EntryTypes::Post(post),
    ))
}

#[hdk_extern]
fn delete_post(post_hash: ActionHash) -> ExternResult<ActionHash> {
    hdk::prelude::delete_entry(post_hash)
}

#[hdk_extern]
fn get_entry(_: ()) -> ExternResult<Option<Record>> {
    get(hash_entry(&post())?, GetOptions::local())
}

#[hdk_extern]
fn get_entry_twice(_: ()) -> ExternResult<Vec<Option<Record>>> {
    HDK.with(|h| {
        h.borrow().get(vec![
            GetInput::new(
                hash_entry(&post())?.into(),
                GetOptions::local()
            );
            2
        ])
    })
}

#[hdk_extern]
fn get_post(hash: ActionHash) -> ExternResult<Option<Record>> {
    get(hash, GetOptions::local())
}

#[hdk_extern]
fn create_msg(_: ()) -> ExternResult<ActionHash> {
    use EntryTypes::*;
    use EntryZomes::*;
    hdk::prelude::create_entry(IntegrityCreateEntry(Msg(msg())))
}

#[hdk_extern]
fn create_priv_msg(_: ()) -> ExternResult<ActionHash> {
    use EntryTypes::*;
    use EntryZomes::*;
    hdk::prelude::create_entry(&IntegrityCreateEntry(PrivMsg(crate::integrity::PrivMsg(
        "Don't tell anyone".into(),
    ))))
}

#[hdk_extern]
fn get_activity(
    input: holochain_test_wasm_common::AgentActivitySearch,
) -> ExternResult<AgentActivity> {
    get_agent_activity(input.agent, input.query, input.request)
}

#[hdk_extern]
fn init(_: ()) -> ExternResult<InitCallbackResult> {
    // grant unrestricted access to accept_cap_claim so other agents can send us claims
    let mut fns = BTreeSet::new();
    fns.insert((zome_info()?.name, "create_entry".into()));
    let functions = GrantedFunctions::Listed(fns);
    create_cap_grant(CapGrantEntry {
        tag: "".into(),
        // empty access converts to unrestricted
        access: ().into(),
        functions,
    })?;

    Ok(InitCallbackResult::Pass)
}

/// Create a post entry then
/// create another post through a
/// call
#[hdk_extern]
fn call_create_entry(_: ()) -> ExternResult<ActionHash> {
    // Create an entry directly via. the hdk.
    hdk::prelude::create_entry(&new_post())?;
    // Create an entry via a `call`.
    let zome_call_response: ZomeCallResponse = call(
        CallTargetCell::Local,
        zome_info()?.name,
        "create_entry".to_string().into(),
        None,
        &(),
    )?;

    match zome_call_response {
        ZomeCallResponse::Ok(v) => Ok(v.decode().map_err(|e| wasm_error!(e))?),
        ZomeCallResponse::AuthenticationFailed(signature, provenance) => {
            Err(wasm_error!(WasmErrorInner::Guest(format!(
                "Authentication failed with signature {signature:?} from provenance {provenance}"
            ))))
        }
        ZomeCallResponse::Unauthorized(reason, cap_secret, zome_name, function_name) => {
            Err(wasm_error!(WasmErrorInner::Guest(format!(
                "Unauthorized: {} {:?} {} {}",
                reason, cap_secret, zome_name, function_name
            ))))
        }
        // Unbounded recursion.
        ZomeCallResponse::NetworkError(_) => call_create_entry(()),
        ZomeCallResponse::CountersigningSession(e) => Err(wasm_error!(WasmErrorInner::Guest(
            format!("Countersigning session failed: {}", e)
        ))),
    }
}

#[hdk_extern]
fn call_create_entry_remotely(agent: AgentPubKey) -> ExternResult<ActionHash> {
    let zome_call_response: ZomeCallResponse = call_remote(
        agent.clone(),
        zome_info()?.name,
        "create_entry".to_string().into(),
        None,
        &(),
    )?;

    match zome_call_response {
        ZomeCallResponse::Ok(v) => Ok(v.decode().map_err(|e| wasm_error!(e))?),
        ZomeCallResponse::AuthenticationFailed(signature, provenance) => {
            Err(wasm_error!(WasmErrorInner::Guest(format!(
                "Authentication failed with signature {signature:?} from provenance {provenance}"
            ))))
        }
        ZomeCallResponse::Unauthorized(reason, cap_secret, zome_name, function_name) => {
            Err(wasm_error!(WasmErrorInner::Guest(format!(
                "Unauthorized: {} {:?} {} {}",
                reason, cap_secret, zome_name, function_name
            ))))
        }
        // Unbounded recursion.
        ZomeCallResponse::NetworkError(_) => call_create_entry_remotely(agent),
        ZomeCallResponse::CountersigningSession(e) => Err(wasm_error!(WasmErrorInner::Guest(
            format!("Countersigning session failed: {}", e)
        ))),
    }
}

#[hdk_extern]
fn must_get_valid_record(action_hash: ActionHash) -> ExternResult<Record> {
    hdk::prelude::must_get_valid_record(action_hash)
}

/// Same as above but doesn't recurse on network errors.
#[hdk_extern]
fn call_create_entry_remotely_no_rec(agent: AgentPubKey) -> ExternResult<ActionHash> {
    let zome_call_response: ZomeCallResponse = call_remote(
        agent.clone(),
        zome_info()?.name,
        "create_entry".to_string().into(),
        None,
        &(),
    )?;

    match zome_call_response {
        ZomeCallResponse::Ok(v) => Ok(v.decode().map_err(|e| wasm_error!(e))?),
        ZomeCallResponse::AuthenticationFailed(signature, provenance) => {
            Err(wasm_error!(WasmErrorInner::Guest(format!(
                "Authentication failed with signature {signature:?} from provenance {provenance}"
            ))))
        }
        ZomeCallResponse::Unauthorized(reason, cap_secret, zome_name, function_name) => {
            Err(wasm_error!(WasmErrorInner::Guest(format!(
                "Unauthorized: {} {:?} {} {}",
                reason, cap_secret, zome_name, function_name
            ))))
        }
        // Unbounded recursion.
        ZomeCallResponse::NetworkError(e) => Err(wasm_error!(WasmErrorInner::Guest(format!(
            "Network Error: {}",
            e
        )))),
        ZomeCallResponse::CountersigningSession(e) => Err(wasm_error!(WasmErrorInner::Guest(
            format!("Countersigning session failed: {}", e)
        ))),
    }
}

#[hdk_extern]
fn get_validation_receipts(
    input: GetValidationReceiptsInput,
) -> ExternResult<Vec<ValidationReceiptSet>> {
    hdk::prelude::get_validation_receipts(input)
}



================================================
File: crates/test_utils/wasm/wasm_workspace/create_entry/src/integrity.rs
================================================
use hdi::prelude::*;

#[hdk_entry_helper]
pub struct Post(pub String);

#[hdk_entry_helper]
pub struct Msg(pub String);

#[hdk_entry_helper]
pub struct PrivMsg(pub String);

#[hdk_entry_types]
#[unit_enum(EntryTypesUnit)]
pub enum EntryTypes {
    #[entry_type(required_validations = 5)]
    Post(Post),
    #[entry_type(required_validations = 5)]
    Msg(Msg),
    #[entry_type(required_validations = 5, visibility = "private")]
    PrivMsg(PrivMsg),
}

#[hdk_link_types]
pub enum LinkTypes {
    Post,
}

#[cfg_attr(feature = "integrity", hdk_extern)]
pub fn validate(op: Op) -> ExternResult<ValidateCallbackResult> {
    if let Op::StoreEntry(StoreEntry {
        action:
            SignedHashed {
                hashed: HoloHashed {
                    content: action, ..
                },
                ..
            },
        entry,
    }) = op
    {
        action
            .app_entry_def()
            .map(
                |AppEntryDef {
                     entry_index,
                     zome_index,
                     ..
                 }| (zome_index, entry_index),
            )
            .map_or(
                Ok(ValidateCallbackResult::Valid),
                |(zome_index, entry_index)| match EntryTypes::deserialize_from_type(
                    *zome_index,
                    *entry_index,
                    &entry,
                )? {
                    Some(EntryTypes::Post(post)) if post.0 == "Banana" => {
                        Ok(ValidateCallbackResult::Invalid("No Bananas!".to_string()))
                    }
                    _ => Ok(ValidateCallbackResult::Valid),
                },
            )
    } else {
        Ok(ValidateCallbackResult::Valid)
    }
}



================================================
File: crates/test_utils/wasm/wasm_workspace/create_entry/src/lib.rs
================================================
pub mod integrity;

#[cfg(not(feature = "integrity"))]
pub mod coordinator;

#[cfg(not(feature = "integrity"))]
pub use coordinator::*;



================================================
File: crates/test_utils/wasm/wasm_workspace/crud/Cargo.toml
================================================
[package]
name = "test_wasm_crud"
version = "0.0.1"
authors = ["thedavidmeister", "thedavidmeister@gmail.com"]
edition = "2021"

[lib]
name = "test_wasm_crud"
crate-type = ["cdylib", "rlib"]

[[example]]
name = "integrity_test_wasm_crud"
path = "src/integrity.rs"
crate-type = ["cdylib", "rlib"]

# reminder - do not use workspace deps
[dependencies]
serde = "1.0"
holochain_test_wasm_common = { path = "../../../wasm_common" }
hdk = { path = "../../../../hdk", optional = true }
hdi = { path = "../../../../hdi" }

[features]
default = ["hdk"]
integrity = []



================================================
File: crates/test_utils/wasm/wasm_workspace/crud/src/coordinator.rs
================================================
use hdk::prelude::*;

mod countree;

#[hdk_dependent_entry_types]
enum EntryZomes {
    IntegrityCrud(crate::integrity::EntryTypes),
}

#[hdk_extern]
fn new(_: ()) -> ExternResult<ActionHash> {
    countree::CounTree::new()
}

#[hdk_extern]
fn action_details(action_hashes: Vec<ActionHash>) -> ExternResult<Vec<Option<Details>>> {
    countree::CounTree::action_details(action_hashes)
}

#[hdk_extern]
fn action_details_local_only(action_hashes: Vec<ActionHash>) -> ExternResult<Vec<Option<Details>>> {
    countree::CounTree::action_details_local_only(action_hashes)
}

#[hdk_extern]
fn entry_details(entry_hashes: Vec<EntryHash>) -> ExternResult<Vec<Option<Details>>> {
    countree::CounTree::entry_details(entry_hashes)
}

#[hdk_extern]
fn entry_details_local_only(_: ()) -> ExternResult<Vec<Option<Details>>> {
    countree::CounTree::entry_details_local_only(entry_hash(countree::CounTree::default())?)
}

#[hdk_extern]
fn entry_hash(countree: countree::CounTree) -> ExternResult<EntryHash> {
    hash_entry(&countree)
}

#[hdk_extern]
fn inc(action_hash: ActionHash) -> ExternResult<ActionHash> {
    countree::CounTree::incsert(action_hash)
}

#[hdk_extern]
fn dec(action_hash: ActionHash) -> ExternResult<ActionHash> {
    countree::CounTree::dec(action_hash)
}



================================================
File: crates/test_utils/wasm/wasm_workspace/crud/src/integrity.rs
================================================
use hdi::prelude::*;

/// a tree of counters
#[hdk_entry_helper]
#[derive(Default, Clone, Copy, PartialEq)]
pub struct CounTree(pub u32);

#[hdk_entry_types]
#[unit_enum(EntryTypesUnit)]
pub enum EntryTypes {
    Countree(CounTree),
}



================================================
File: crates/test_utils/wasm/wasm_workspace/crud/src/lib.rs
================================================
pub mod integrity;

#[cfg(not(feature = "integrity"))]
pub mod coordinator;



================================================
File: crates/test_utils/wasm/wasm_workspace/crud/src/coordinator/countree.rs
================================================
pub use crate::integrity::*;
use hdk::prelude::*;

use super::EntryZomes::*;

impl std::ops::Add for CounTree {
    type Output = Self;

    fn add(self, other: Self) -> Self {
        Self(self.0 + other.0)
    }
}

impl CounTree {
    #[allow(clippy::new_ret_no_self)]
    /// ensures that a default countree exists and returns the action
    pub fn new() -> ExternResult<ActionHash> {
        Self::ensure(Self::default())
    }

    /// commits if not exists else returns found action
    /// produces redundant actions in a partition
    pub fn ensure(countree: CounTree) -> ExternResult<ActionHash> {
        match get(hash_entry(&countree)?, GetOptions::network())? {
            Some(record) => Ok(record.action_address().to_owned()),
            None => create_entry(&IntegrityCrud(EntryTypes::Countree(countree))),
        }
    }

    pub fn action_details(action_hashes: Vec<ActionHash>) -> ExternResult<Vec<Option<Details>>> {
        HDK.with(|h| {
            h.borrow().get_details(
                action_hashes
                    .into_iter()
                    .map(|action_hash| GetInput::new(action_hash.into(), GetOptions::network()))
                    .collect(),
            )
        })
    }

    /// return the Option<Details> for the entry hash from the action
    pub fn entry_details(entry_hashes: Vec<EntryHash>) -> ExternResult<Vec<Option<Details>>> {
        HDK.with(|h| {
            h.borrow().get_details(
                entry_hashes
                    .into_iter()
                    .map(|entry_hash| GetInput::new(entry_hash.into(), GetOptions::network()))
                    .collect(),
            )
        })
    }

    pub fn action_details_local_only(
        action_hashes: Vec<ActionHash>,
    ) -> ExternResult<Vec<Option<Details>>> {
        HDK.with(|h| {
            h.borrow().get_details(
                action_hashes
                    .into_iter()
                    .map(|action_hash| GetInput::new(action_hash.into(), GetOptions::local()))
                    .collect(),
            )
        })
    }

    /// return the Option<Details> for the entry hash from the action
    pub fn entry_details_local_only(entry_hash: EntryHash) -> ExternResult<Vec<Option<Details>>> {
        HDK.with(|h| {
            h.borrow()
                .get_details(vec![GetInput::new(entry_hash.into(), GetOptions::local())])
        })
    }

    /// increments the given action hash by 1 or creates it if not found
    /// this is silly as being offline resets the counter >.<
    pub fn incsert(action_hash: ActionHash) -> ExternResult<ActionHash> {
        let current: CounTree = match get(action_hash.clone(), GetOptions::network())? {
            Some(record) => match record.entry().to_app_option().map_err(|e| wasm_error!(e))? {
                Some(v) => v,
                None => return Self::new(),
            },
            None => return Self::new(),
        };

        update_entry(action_hash, &(current + CounTree(1)))
    }

    pub fn dec(action_hash: ActionHash) -> ExternResult<ActionHash> {
        delete_entry(action_hash)
    }
}



================================================
File: crates/test_utils/wasm/wasm_workspace/debug/Cargo.toml
================================================
[package]
name = "test_wasm_debug"
version = "0.0.1"
authors = ["thedavidmeister", "thedavidmeister@gmail.com"]
edition = "2021"

[lib]
name = "test_wasm_debug"
crate-type = ["cdylib", "rlib"]

[[example]]
name = "integrity_test_wasm_debug"
path = "src/integrity.rs"
crate-type = ["cdylib", "rlib"]

# reminder - do not use workspace deps
[dependencies]
serde = "1.0"
tracing = "0.1"
tracing-core = "0.1"
hdi = { path = "../../../../hdi", features = ["trace"] }
hdk = { path = "../../../../hdk" }

[features]
default = []
mock = ["hdk/mock"]



================================================
File: crates/test_utils/wasm/wasm_workspace/debug/src/integrity.rs
================================================
use hdi::prelude::*;

#[hdk_extern]
fn validate(_op: Op) -> ExternResult<ValidateCallbackResult> {
    tracing::info!("tracing in validation works");
    Ok(ValidateCallbackResult::Valid)
}



================================================
File: crates/test_utils/wasm/wasm_workspace/debug/src/lib.rs
================================================
use hdk::prelude::*;

#[hdk_extern]
fn debug(_: ()) -> ExternResult<()> {
    trace!("tracing {}", "works!");
    debug!("debug works");
    info!("info works");
    warn!("warn works");
    error!("error works");
    debug!(foo = "fields", bar = "work", "too");

    Ok(())
}


================================================
File: crates/test_utils/wasm/wasm_workspace/dna_properties/Cargo.toml
================================================
[package]
name = "test_wasm_dna_properties"
version = "0.0.1"
edition = "2021"

[lib]
name = "test_wasm_dna_properties"
crate-type = ["cdylib", "rlib"]

[[example]]
name = "integrity_test_wasm_dna_properties"
path = "src/integrity.rs"
crate-type = ["cdylib", "rlib"]

# reminder - do not use workspace deps
[dependencies]
hdk = { path = "../../../../hdk", optional = true }
serde = "1.0"
hdi = { path = "../../../../hdi" }
holochain_test_wasm_common = { path = "../../../wasm_common" }

[dev-dependencies]
hdk = { path = "../../../../hdk", features = ["fixturators"] }
fixt = { path = "../../../../fixt" }

[features]
default = ["hdk"]
integrity = []
mock = ["hdk/mock"]



================================================
File: crates/test_utils/wasm/wasm_workspace/dna_properties/src/integrity.rs
================================================
use hdi::prelude::*;
use holochain_test_wasm_common::MyValidDnaProperties;

#[hdk_extern]
pub fn get_dna_properties(_: ()) -> ExternResult<MyValidDnaProperties> {
    MyValidDnaProperties::try_from_dna_properties()
}



================================================
File: crates/test_utils/wasm/wasm_workspace/dna_properties/src/lib.rs
================================================
pub mod integrity;


================================================
File: crates/test_utils/wasm/wasm_workspace/emit_signal/Cargo.toml
================================================
[package]
name = "test_wasm_emit_signal"
version = "0.0.1"
authors = ["thedavidmeister", "thedavidmeister@gmail.com"]
edition = "2021"

[lib]
name = "test_wasm_emit_signal"
crate-type = ["cdylib", "rlib"]

[[example]]
name = "integrity_test_wasm_emit_signal"
path = "src/integrity.rs"
crate-type = ["cdylib", "rlib"]


# reminder - do not use workspace deps
[dependencies]
hdk = { path = "../../../../hdk" }
serde = "1.0"
holochain_test_wasm_common = { path = "../../../wasm_common" }

[features]
default = []
mock = ["hdk/mock"]



================================================
File: crates/test_utils/wasm/wasm_workspace/emit_signal/src/integrity.rs
================================================



================================================
File: crates/test_utils/wasm/wasm_workspace/emit_signal/src/lib.rs
================================================
use hdk::prelude::*;

#[hdk_extern]
fn emit(_: ()) -> ExternResult<()> {
    emit_signal(&())?;
    Ok(())
}

#[hdk_extern]
fn signal_others(signal: RemoteSignal) -> ExternResult<()> {
    send_remote_signal(&signal.signal, signal.agents)
}

#[hdk_extern]
fn recv_remote_signal(signal: ExternIO) -> ExternResult<()> {
    HDK.with(|h| h.borrow().emit_signal(AppSignal::new(signal)))
}

#[hdk_extern]
fn init(_: ()) -> ExternResult<InitCallbackResult> {
    let mut fns = BTreeSet::new();
    fns.insert((zome_info()?.name, "recv_remote_signal".into()));
    let functions = GrantedFunctions::Listed(fns);
    create_cap_grant(CapGrantEntry {
        tag: "".into(),
        // empty access converts to unrestricted
        access: ().into(),
        functions,
    })?;

    Ok(InitCallbackResult::Pass)
}



================================================
File: crates/test_utils/wasm/wasm_workspace/entry_defs/Cargo.toml
================================================
[package]
name = "test_wasm_entry_defs"
version = "0.0.1"
authors = ["thedavidmeister", "thedavidmeister@gmail.com"]
edition = "2021"

[lib]
name = "test_wasm_entry_defs"
crate-type = ["cdylib", "rlib"]

[[example]]
name = "integrity_test_wasm_entry_defs"
path = "src/integrity.rs"
crate-type = ["cdylib", "rlib"]

# reminder - do not use workspace deps
[dependencies]
serde = "1.0"
hdk = { path = "../../../../hdk", optional = true }
hdi = { path = "../../../../hdi" }

[features]
default = ["hdk"]
integrity = []
mock = ["hdk/mock"]



================================================
File: crates/test_utils/wasm/wasm_workspace/entry_defs/src/coordinator.rs
================================================
use crate::integrity::*;
use hdk::prelude::*;

#[hdk_extern]
pub fn assert_indexes(_: ()) -> ExternResult<()> {
    // Note that this only works if there is a single integrity zome.
    assert_eq!(
        EntryDefIndex(0),
        ScopedEntryDefIndex::try_from(EntryTypes::Post(Post))?.zome_type
    );
    assert_eq!(
        EntryDefIndex(1),
        ScopedEntryDefIndex::try_from(EntryTypes::Comment(Comment))?.zome_type
    );
    Ok(())
}

#[hdk_extern]
pub fn zome_info(_: ()) -> ExternResult<ZomeInfo> {
    hdk::prelude::zome_info()
}



================================================
File: crates/test_utils/wasm/wasm_workspace/entry_defs/src/integrity.rs
================================================
use hdi::prelude::*;

#[hdk_entry_helper]
pub struct Post;

#[hdk_entry_helper]
pub struct Comment;

#[hdk_entry_types]
#[unit_enum(EntryTypesUnit)]
pub enum EntryTypes {
    Post(Post),
    #[entry_type(visibility = "private")]
    Comment(Comment),
}



================================================
File: crates/test_utils/wasm/wasm_workspace/entry_defs/src/lib.rs
================================================
pub mod integrity;

#[cfg(not(feature = "integrity"))]
pub mod coordinator;

#[cfg(not(feature = "integrity"))]
pub use coordinator::*;



================================================
File: crates/test_utils/wasm/wasm_workspace/foo/Cargo.toml
================================================
[package]
name = "test_wasm_foo"
version = "0.0.1"
authors = ["thedavidmeister", "thedavidmeister@gmail.com"]
edition = "2021"

[lib]
name = "test_wasm_foo"
crate-type = ["cdylib", "rlib"]

[[example]]
name = "integrity_test_wasm_foo"
path = "src/integrity.rs"
crate-type = ["cdylib", "rlib"]

# reminder - do not use workspace deps
[dependencies]
serde = "1.0"
holochain_test_wasm_common = { path = "../../../wasm_common" }
hdk = { path = "../../../../hdk" }

[features]
default = []
mock = ["hdk/mock"]



================================================
File: crates/test_utils/wasm/wasm_workspace/foo/src/integrity.rs
================================================




================================================
File: crates/test_utils/wasm/wasm_workspace/foo/src/lib.rs
================================================
use hdk::prelude::*;

#[hdk_extern]
fn init(_: ()) -> ExternResult<InitCallbackResult> {
    // grant unrestricted access to accept_cap_claim so other agents can send us claims
    let mut fns = BTreeSet::new();
    fns.insert((zome_info()?.name, "foo".into()));
    // fns.insert((zome_info()?.name, "needs_cap_claim".into()));
    let functions = GrantedFunctions::Listed(fns);
    create_cap_grant(CapGrantEntry {
        tag: "".into(),
        // empty access converts to unrestricted
        access: ().into(),
        functions,
    })?;

    Ok(InitCallbackResult::Pass)
}

#[hdk_extern]
fn foo(_: ()) -> ExternResult<String> {
    Ok(String::from("foo"))
}



================================================
File: crates/test_utils/wasm/wasm_workspace/genesis_self_check_1/Cargo.toml
================================================
[package]
name = "test_wasm_genesis_self_check_1"
version = "0.0.1"
authors = ["thedavidmeister", "thedavidmeister@gmail.com"]
edition = "2021"

[lib]
name = "test_wasm_genesis_self_check_1"
crate-type = ["cdylib", "rlib"]

[[example]]
name = "integrity_test_wasm_genesis_self_check_1"
path = "src/integrity.rs"
crate-type = ["cdylib", "rlib"]

# reminder - do not use workspace deps
[dependencies]
serde = "1.0"
hdk = { path = "../../../../hdk" }
hdi = { path = "../../../../hdi" }

[features]
default = []
mock = ["hdk/mock"]



================================================
File: crates/test_utils/wasm/wasm_workspace/genesis_self_check_1/src/integrity.rs
================================================
use hdi::prelude::*;

#[hdk_extern]
fn genesis_self_check_1(data: GenesisSelfCheckDataV1) -> ExternResult<ValidateCallbackResult> {
    let GenesisSelfCheckDataV1 {
        dna_info: _dna_info,
        membrane_proof: _membrane_proof,
        agent_key: _agent_key,
    } = data;
    Ok(ValidateCallbackResult::Valid)
}



================================================
File: crates/test_utils/wasm/wasm_workspace/genesis_self_check_1/src/lib.rs
================================================



================================================
File: crates/test_utils/wasm/wasm_workspace/genesis_self_check_invalid/Cargo.toml
================================================
[package]
name = "test_wasm_genesis_self_check_invalid"
version = "0.0.1"
authors = ["thedavidmeister", "thedavidmeister@gmail.com"]
edition = "2021"

[lib]
name = "test_wasm_genesis_self_check_invalid"
crate-type = ["cdylib", "rlib"]

[[example]]
name = "integrity_test_wasm_genesis_self_check_invalid"
path = "src/integrity.rs"
crate-type = ["cdylib", "rlib"]

# reminder - do not use workspace deps
[dependencies]
serde = "1.0"
hdk = { path = "../../../../hdk" }
hdi = { path = "../../../../hdi" }

[features]
default = []
mock = ["hdk/mock"]



================================================
File: crates/test_utils/wasm/wasm_workspace/genesis_self_check_invalid/src/integrity.rs
================================================
use hdi::prelude::*;

#[hdk_extern]
fn genesis_self_check(_: GenesisSelfCheckData) -> ExternResult<ValidateCallbackResult> {
    Ok(ValidateCallbackResult::Invalid("esoteric edge case".into()))
}



================================================
File: crates/test_utils/wasm/wasm_workspace/genesis_self_check_invalid/src/lib.rs
================================================



================================================
File: crates/test_utils/wasm/wasm_workspace/genesis_self_check_legacy/Cargo.toml
================================================
[package]
name = "test_wasm_genesis_self_check_legacy"
version = "0.0.1"
authors = ["thedavidmeister", "thedavidmeister@gmail.com"]
edition = "2021"

[lib]
name = "test_wasm_genesis_self_check_legacy"
crate-type = ["cdylib", "rlib"]

[[example]]
name = "integrity_test_wasm_genesis_self_check_legacy"
path = "src/integrity.rs"
crate-type = ["cdylib", "rlib"]

# reminder - do not use workspace deps
[dependencies]
serde = "1.0"
hdk = { path = "../../../../hdk" }
hdi = { path = "../../../../hdi" }

[features]
default = []
mock = ["hdk/mock"]



================================================
File: crates/test_utils/wasm/wasm_workspace/genesis_self_check_legacy/src/integrity.rs
================================================
use hdi::prelude::*;

// Written in full to avoid the renaming internal to the macro.
#[no_mangle]
pub extern "C" fn genesis_self_check(guest_ptr: usize, len: usize) -> DoubleUSize {
    map_extern_preamble!(guest_ptr, len, inner, GenesisSelfCheckDataV1, ExternResult<ValidateCallbackResult>);
    match genesis_self_check_legacy(inner) {
        Ok(v) => map_extern::encode_to_guestptrlen(v),
        Err(e) => return_err_ptr(e),
    }
}

fn genesis_self_check_legacy(data: GenesisSelfCheckDataV1) -> ExternResult<ValidateCallbackResult> {
    let GenesisSelfCheckDataV1 {
        dna_info: _dna_info,
        membrane_proof: _membrane_proof,
        agent_key: _agent_key,
    } = data;
    Ok(ValidateCallbackResult::Valid)
}



================================================
File: crates/test_utils/wasm/wasm_workspace/genesis_self_check_legacy/src/lib.rs
================================================



================================================
File: crates/test_utils/wasm/wasm_workspace/genesis_self_check_requires_properties/Cargo.toml
================================================
[package]
name = "test_wasm_genesis_self_check_requires_properties"
version = "0.0.1"
edition = "2021"

[lib]
name = "test_wasm_genesis_self_check_requires_properties"
crate-type = ["cdylib", "rlib"]

[[example]]
name = "integrity_test_wasm_genesis_self_check_requires_properties"
path = "src/integrity.rs"
crate-type = ["cdylib", "rlib"]

# reminder - do not use workspace deps
[dependencies]
serde = "1.0"
serde_yaml = "0.9"
hdk = { path = "../../../../hdk" }
hdi = { path = "../../../../hdi" }

[features]
default = []
mock = ["hdk/mock"]



================================================
File: crates/test_utils/wasm/wasm_workspace/genesis_self_check_requires_properties/src/integrity.rs
================================================
use hdi::prelude::*;

#[hdk_extern]
fn genesis_self_check(_: GenesisSelfCheckData) -> ExternResult<ValidateCallbackResult> {
    let props = dna_info()?.modifiers.properties;

    // The default value is `()` which is serialized to `null`
    if props.bytes().len() == 1 {
        Ok(ValidateCallbackResult::Invalid("No properties".into()))
    } else {
        Ok(ValidateCallbackResult::Valid)
    }
}



================================================
File: crates/test_utils/wasm/wasm_workspace/genesis_self_check_requires_properties/src/lib.rs
================================================



================================================
File: crates/test_utils/wasm/wasm_workspace/genesis_self_check_valid/Cargo.toml
================================================
[package]
name = "test_wasm_genesis_self_check_valid"
version = "0.0.1"
authors = ["thedavidmeister", "thedavidmeister@gmail.com"]
edition = "2021"

[lib]
name = "test_wasm_genesis_self_check_valid"
crate-type = ["cdylib", "rlib"]

[[example]]
name = "integrity_test_wasm_genesis_self_check_valid"
path = "src/integrity.rs"
crate-type = ["cdylib", "rlib"]

# reminder - do not use workspace deps
[dependencies]
serde = "1.0"
hdk = { path = "../../../../hdk" }
hdi = { path = "../../../../hdi" }

[features]
default = []
mock = ["hdk/mock"]



================================================
File: crates/test_utils/wasm/wasm_workspace/genesis_self_check_valid/src/integrity.rs
================================================
use hdi::prelude::*;

#[hdk_extern]
fn genesis_self_check(data: GenesisSelfCheckData) -> ExternResult<ValidateCallbackResult> {
    let GenesisSelfCheckDataV2 {
        membrane_proof: _maybe_membrane_proof,
        agent_key: _agent_key,
    } = data;
    let _dna_info: DnaInfoV2 = dna_info()?;
    Ok(ValidateCallbackResult::Valid)
}



================================================
File: crates/test_utils/wasm/wasm_workspace/genesis_self_check_valid/src/lib.rs
================================================




================================================
File: crates/test_utils/wasm/wasm_workspace/hash_entry/Cargo.toml
================================================
[package]
name = "test_wasm_hash_entry"
version = "0.0.1"
authors = ["thedavidmeister", "thedavidmeister@gmail.com"]
edition = "2021"

[lib]
name = "test_wasm_hash_entry"
crate-type = ["cdylib", "rlib"]

[[example]]
name = "integrity_test_wasm_hash_entry"
path = "src/integrity.rs"
crate-type = ["cdylib", "rlib"]

# reminder - do not use workspace deps
[dependencies]
serde = "1.0"
hdk = { path = "../../../../hdk", optional = true }
hdi = { path = "../../../../hdi" }

[features]
default = ["hdk"]
integrity = []
mock = ["hdk/mock"]

[dev-dependencies]
hdk = { path = "../../../../hdk", features = ["fixturators"] }
fixt = { path = "../../../../fixt" }



================================================
File: crates/test_utils/wasm/wasm_workspace/hash_entry/src/coordinator.rs
================================================
use crate::integrity::*;
use hdk::prelude::*;
use EntryZomes::*;

#[hdk_dependent_entry_types]
enum EntryZomes {
    IntegrityHashEntry(EntryTypes),
}

fn temperature() -> Temperature {
    Temperature(32, TemperatureUnit::Celcius)
}

#[hdk_extern]
fn twenty_three_degrees_entry_hash(_: ()) -> ExternResult<EntryHash> {
    let temp = temperature();
    let action_hash: ActionHash = create_entry(&IntegrityHashEntry(EntryTypes::Temperature(temp)))?;
    let record: Record = get(action_hash, GetOptions::local())?.unwrap();
    match record.entry() {
        RecordEntry::Present(entry) => hdk::prelude::hash_entry(entry.clone()),
        _ => unreachable!(),
    }
}

#[hdk_extern]
fn twenty_three_degrees_hash(_: ()) -> ExternResult<EntryHash> {
    hdk::prelude::hash_entry(&temperature())
}

#[hdk_extern]
fn hash_entry(entry: Entry) -> ExternResult<EntryHash> {
    hdk::prelude::hash_entry(entry)
}

#[cfg(all(test, feature = "mock"))]
mod tests {
    use ::fixt::prelude::*;
    use hdk::prelude::*;

    #[test]
    fn hash_entry_smoke() {
        let mut mock_hdk = hdk::prelude::MockHdkT::new();

        let input_entry = fixt!(Entry);
        let output_hash = fixt!(EntryHash);
        let output_hash_closure = output_hash.clone();
        mock_hdk
            .expect_hash()
            .with(hdk::prelude::mockall::predicate::eq(HashInput::Entry(
                input_entry.clone(),
            )))
            .times(1)
            .return_once(move |_| Ok(HashOutput::Entry(output_hash_closure)));

        hdk::prelude::set_hdk(mock_hdk);

        let result = super::hash_entry(input_entry);

        assert_eq!(result, Ok(output_hash))
    }
}



================================================
File: crates/test_utils/wasm/wasm_workspace/hash_entry/src/integrity.rs
================================================
use hdi::prelude::*;

#[derive(Serialize, Deserialize, Debug)]
pub enum TemperatureUnit {
    Kelvin,
    Farenheit,
    Celcius,
}

#[hdk_entry_helper]
pub struct Temperature(pub u32, pub TemperatureUnit);

#[hdk_entry_types]
#[unit_enum(EntryTypesUnit)]
pub enum EntryTypes {
    Temperature(Temperature),
}



================================================
File: crates/test_utils/wasm/wasm_workspace/hash_entry/src/lib.rs
================================================
pub mod integrity;

#[cfg(not(feature = "integrity"))]
pub mod coordinator;



================================================
File: crates/test_utils/wasm/wasm_workspace/hash_path/Cargo.toml
================================================
[package]
name = "test_wasm_hash_path"
version = "0.0.1"
authors = ["thedavidmeister", "thedavidmeister@gmail.com"]
edition = "2021"

[lib]
name = "test_wasm_hash_path"
crate-type = ["cdylib", "rlib"]

[[example]]
name = "integrity_test_wasm_hash_path"
path = "src/integrity.rs"
crate-type = ["cdylib", "rlib"]

# reminder - do not use workspace deps
[dependencies]
hdk = { path = "../../../../hdk" }
serde = "1.0"
holochain_test_wasm_common = { path = "../../../wasm_common" }

[features]
default = []
mock = ["hdk/mock"]



================================================
File: crates/test_utils/wasm/wasm_workspace/hash_path/src/integrity.rs
================================================
use hdk::prelude::hdi::prelude::*;

#[hdk_link_types]
pub enum LinkTypes {
    Path,
}



================================================
File: crates/test_utils/wasm/wasm_workspace/hash_path/src/lib.rs
================================================
use hdk::prelude::*;
use integrity::LinkTypes;

mod integrity;

#[hdk_extern]
fn path_entry_hash(path_string: String) -> ExternResult<EntryHash> {
    Path::from(path_string).path_entry_hash()
}

#[hdk_extern]
fn exists(path_string: String) -> ExternResult<bool> {
    debug!(%path_string);
    let p = Path::from(path_string).typed(LinkTypes::Path)?;
    debug!(?p);
    p.exists()
}

#[hdk_extern]
fn ensure(path_string: String) -> ExternResult<()> {
    Path::from(path_string).typed(LinkTypes::Path)?.ensure()
}

#[hdk_extern]
fn delete_link(delete_link: ActionHash) -> ExternResult<ActionHash> {
    hdk::prelude::delete_link(delete_link)
}

#[hdk_extern]
fn children(path_string: String) -> ExternResult<Vec<Link>> {
    Path::from(path_string).typed(LinkTypes::Path)?.children()
}

#[hdk_extern]
fn children_details(path_string: String) -> ExternResult<LinkDetails> {
    Path::from(path_string)
        .typed(LinkTypes::Path)?
        .children_details()
}



================================================
File: crates/test_utils/wasm/wasm_workspace/hc-stress-test-coordinator/Cargo.toml
================================================
[package]
name = "files"
version = "0.0.1"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]
name = "files"

# reminder - do not use workspace deps
[dependencies]
hdk = { path = "../../../../hdk" }

serde = "1.0"

# workaround to make it slightly easier to import hc-scress-test zomes
files_integrity = { path = "../hc-stress-test-integrity" }



================================================
File: crates/test_utils/wasm/wasm_workspace/hc-stress-test-coordinator/src/all_images.rs
================================================
use hdk::prelude::*;
use files_integrity::*;
#[hdk_extern]
pub fn get_all_images(_: ()) -> ExternResult<Vec<ActionHash>> {
    let path = Path::from("all_images");
    let links = get_links(GetLinksInputBuilder::try_new(
        path.path_entry_hash()?,
        LinkTypes::AllImages,
    )?.build())?;
    let get_input: Vec<GetInput> = links
        .into_iter()
        .map(|link| {

            let target_hash = match link.target.into_any_dht_hash() {
                Some(hash) => hash,
                None => return None
            };

            Some(GetInput::new(
            target_hash,
            GetOptions::default(),
            ))
        }).filter_map(|l| l)
        .collect();
    let records = HDK.with(|hdk| hdk.borrow().get(get_input))?;
    let hashes: Vec<ActionHash> = records
        .into_iter()
        .filter_map(|r| r)
        .map(|r| r.action_address().clone())
        .collect();
    Ok(hashes)
}



================================================
File: crates/test_utils/wasm/wasm_workspace/hc-stress-test-coordinator/src/file.rs
================================================
use hdk::prelude::*;
use files_integrity::*;
#[hdk_extern]
pub fn create_file(file: File) -> ExternResult<Record> {
    let file_hash = create_entry(&EntryTypes::File(file.clone()))?;
    let record = get(file_hash.clone(), GetOptions::default())?
        .ok_or(
            wasm_error!(
                WasmErrorInner::Guest(String::from("Could not find the newly created File"))
            ),
        )?;
    let path = Path::from("all_images");
    create_link(path.path_entry_hash()?, file_hash.clone(), LinkTypes::AllImages, ())?;
    Ok(record)
}
#[hdk_extern]
pub fn get_file(original_file_hash: ActionHash) -> ExternResult<Option<Record>> {
    let links = get_links(GetLinksInputBuilder::try_new(
        original_file_hash.clone(),
        LinkTypes::FileUpdates,
    )?.build())?;
    let latest_link = links
        .into_iter()
        .max_by(|link_a, link_b| link_b.timestamp.cmp(&link_a.timestamp));
    let latest_file_hash = match latest_link {
        Some(link) => link.target.into_any_dht_hash().ok_or(wasm_error!(WasmErrorInner::Guest(String::from("Failed to convert link target to AnyDhtHash"))))?,
        None => AnyDhtHash::from(original_file_hash),
    };
    get(latest_file_hash, GetOptions::default())
}
#[derive(Serialize, Deserialize, Debug)]
pub struct UpdateFileInput {
    pub original_file_hash: ActionHash,
    pub previous_file_hash: ActionHash,
    pub updated_file: File,
}
#[hdk_extern]
pub fn update_file(input: UpdateFileInput) -> ExternResult<Record> {
    let updated_file_hash = update_entry(
        input.previous_file_hash.clone(),
        &input.updated_file,
    )?;
    create_link(
        input.original_file_hash.clone(),
        updated_file_hash.clone(),
        LinkTypes::FileUpdates,
        (),
    )?;
    let record = get(updated_file_hash.clone(), GetOptions::default())?
        .ok_or(
            wasm_error!(
                WasmErrorInner::Guest(String::from("Could not find the newly updated File"))
            ),
        )?;
    Ok(record)
}
#[hdk_extern]
pub fn delete_file(original_file_hash: ActionHash) -> ExternResult<ActionHash> {
    delete_entry(original_file_hash)
}



================================================
File: crates/test_utils/wasm/wasm_workspace/hc-stress-test-coordinator/src/lib.rs
================================================
pub mod all_images;
pub mod file;
use hdk::prelude::*;
#[hdk_extern]
pub fn init(_: ()) -> ExternResult<InitCallbackResult> {
    Ok(InitCallbackResult::Pass)
}



================================================
File: crates/test_utils/wasm/wasm_workspace/hc-stress-test-integrity/Cargo.toml
================================================
[package]
name = "files_integrity"
version = "0.0.1"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]
name = "files_integrity"

# reminder - do not use workspace deps
[dependencies]
hdi = { path = "../../../../hdi" }

serde = "1.0"



================================================
File: crates/test_utils/wasm/wasm_workspace/hc-stress-test-integrity/src/file.rs
================================================
use hdi::prelude::*;
#[hdk_entry_helper]
#[derive(Clone)]
pub struct File {
    pub data: SerializedBytes,
    pub uid: i64,
}
pub fn validate_create_link_all_images(
    _base: AnyLinkableHash,
    _target: AnyLinkableHash,
) -> ExternResult<ValidateCallbackResult> {
    Ok(ValidateCallbackResult::Valid)
}
pub fn validate_delete_link_all_images(
    _base: AnyLinkableHash,
    _target: AnyLinkableHash,
) -> ExternResult<ValidateCallbackResult> {
    Ok(ValidateCallbackResult::Invalid(String::from(
        "AllImages links cannot be deleted",
    )))
}



================================================
File: crates/test_utils/wasm/wasm_workspace/hc-stress-test-integrity/src/lib.rs
================================================
pub mod file;
pub use file::*;
use hdi::prelude::*;
#[hdk_entry_types]
#[unit_enum(UnitEntryTypes)]
pub enum EntryTypes {
    File(File),
}
#[hdk_link_types]
pub enum LinkTypes {
    FileUpdates,
    AllFiles,
    AllImages,
}



