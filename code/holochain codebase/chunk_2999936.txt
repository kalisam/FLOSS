                    "get_agent_activity",
                    GetAgentActivityInput {
                        agent_pubkey: alice_pubkey.clone(),
                        chain_query_filter: ChainQueryFilter::new(),
                        activity_request: ActivityRequest::Full,
                    },
                )
                .await;

            // And bob's.
            let bob_activity: AgentActivity = alice_conductor
                .call(
                    &alice,
                    "get_agent_activity",
                    GetAgentActivityInput {
                        agent_pubkey: bob_pubkey.clone(),
                        chain_query_filter: ChainQueryFilter::new(),
                        activity_request: ActivityRequest::Full,
                    },
                )
                .await;

            assert_eq!(
                alice_activity.valid_activity.len(),
                alice_activity_pre.valid_activity.len() + 2,
                "Expected alice's activity to have {} items but was {}, have got this activity {:?}",
                alice_activity_pre.valid_activity.len() + 2,
                alice_activity.valid_activity.len(),
                alice_activity,
            );
            assert_eq!(
                bob_activity.valid_activity.len(),
                bob_activity_pre.valid_activity.len() + 2,
                "Expected bob's activity to have {} items but was {}, have got this activity {:?}",
                bob_activity_pre.valid_activity.len() + 2,
                bob_activity.valid_activity.len(),
                bob_activity,
            );
        }

        // ENZYMATIC

        {
            // Start an enzymatic session
            let preflight_request: PreflightRequest = alice_conductor
                .call(
                    &alice,
                    "generate_countersigning_preflight_request_enzymatic",
                    vec![
                        // Alice is enzyme
                        (alice_pubkey.clone(), vec![Role(0)]),
                        (bob_pubkey.clone(), vec![]),
                    ],
                )
                .await;

            // Alice can accept.
            let alice_acceptance: PreflightRequestAcceptance = alice_conductor
                .call(
                    &alice,
                    "accept_countersigning_preflight_request",
                    preflight_request.clone(),
                )
                .await;
            let alice_response =
                if let PreflightRequestAcceptance::Accepted(ref response) = alice_acceptance {
                    response
                } else {
                    unreachable!();
                };

            // Bob can also accept the preflight request.
            let bob_acceptance: PreflightRequestAcceptance = bob_conductor
                .call(
                    &bob,
                    "accept_countersigning_preflight_request",
                    preflight_request.clone(),
                )
                .await;
            let bob_response =
                if let PreflightRequestAcceptance::Accepted(ref response) = bob_acceptance {
                    response
                } else {
                    unreachable!();
                };

            // Alice commits the action.
            let _countersigned_action_hash_alice: ActionHash = alice_conductor
                .call(
                    &alice,
                    "create_a_countersigned_thing",
                    vec![alice_response.clone(), bob_response.clone()],
                )
                .await;

            // The countersigned entry does NOT appear in alice's activity yet.
            let alice_activity_pre: AgentActivity = bob_conductor
                .call(
                    &bob,
                    "get_agent_activity",
                    GetAgentActivityInput {
                        agent_pubkey: alice_pubkey.clone(),
                        chain_query_filter: ChainQueryFilter::new(),
                        activity_request: ActivityRequest::Full,
                    },
                )
                .await;
            // Nor bob's.
            let bob_activity_pre: AgentActivity = alice_conductor
                .call(
                    &alice,
                    "get_agent_activity",
                    GetAgentActivityInput {
                        agent_pubkey: bob_pubkey.clone(),
                        chain_query_filter: ChainQueryFilter::new(),
                        activity_request: ActivityRequest::Full,
                    },
                )
                .await;

            // Bob commits the action also.
            let _countersigned_action_hash_bob: ActionHash = bob_conductor
                .call(
                    &bob,
                    "create_a_countersigned_thing",
                    vec![alice_response, bob_response],
                )
                .await;

            // Now the action DOES NOT appear in alice's activty, due to the
            // partition blocking the enzyme push.
            let alice_activity: AgentActivity = bob_conductor
                .call(
                    &bob,
                    "get_agent_activity",
                    GetAgentActivityInput {
                        agent_pubkey: alice_pubkey.clone(),
                        chain_query_filter: ChainQueryFilter::new(),
                        activity_request: ActivityRequest::Full,
                    },
                )
                .await;
            // Same for bob's.
            let bob_activity: AgentActivity = alice_conductor
                .call(
                    &alice,
                    "get_agent_activity",
                    GetAgentActivityInput {
                        agent_pubkey: bob_pubkey.clone(),
                        chain_query_filter: ChainQueryFilter::new(),
                        activity_request: ActivityRequest::Full,
                    },
                )
                .await;

            assert_eq!(
                alice_activity.valid_activity.len(),
                alice_activity_pre.valid_activity.len()
            );
            assert_eq!(
                bob_activity.valid_activity.len(),
                bob_activity_pre.valid_activity.len()
            );
        }
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/agent_info.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::HostFnAccess;
use crate::core::ribosome::RibosomeError;
use crate::core::ribosome::RibosomeT;
use holochain_types::prelude::*;
use holochain_wasmer_host::prelude::*;
use std::sync::Arc;
use wasmer::RuntimeError;

pub fn agent_info(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    _input: (),
) -> Result<AgentInfo, RuntimeError> {
    match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            agent_info: Permission::Allow,
            ..
        } => {
            let agent_pubkey = call_context
                .host_context
                .workspace()
                .source_chain()
                .as_ref()
                .expect("Must have source chain if agent_info access is given")
                .agent_pubkey()
                .clone();
            let head = call_context
                .host_context
                .workspace()
                .source_chain()
                .as_ref()
                .expect("Must have source chain if agent_info access is given")
                .chain_head_nonempty()
                .map_err(|e| wasm_error!(WasmErrorInner::Host(e.to_string())))?;
            Ok(AgentInfo {
                agent_initial_pubkey: agent_pubkey.clone(),
                agent_latest_pubkey: agent_pubkey,
                chain_head: head.into_tuple(),
            })
        }
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "agent_info".into()
            )
            .to_string()
        ))
        .into()),
    }
}

#[cfg(test)]
#[cfg(feature = "slow_tests")]
pub mod test {
    use crate::core::ribosome::wasm_test::RibosomeTestFixture;
    use hdk::prelude::*;
    use holochain_wasm_test_utils::TestWasm;

    #[tokio::test(flavor = "multi_thread")]
    async fn host_fn_agent_info_test() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor,
            alice,
            alice_pubkey,
            ..
        } = RibosomeTestFixture::new(TestWasm::AgentInfo).await;

        let call_info: CallInfo = conductor.call(&alice, "call_info", ()).await;
        let agent_info: AgentInfo = conductor.call(&alice, "agent_info", ()).await;
        assert_eq!(agent_info.agent_initial_pubkey, alice_pubkey);
        assert_eq!(agent_info.agent_latest_pubkey, alice_pubkey);

        assert_eq!(agent_info.chain_head.1, call_info.as_at.1 + 1,);

        let call_info_1: CallInfo = conductor.call(&alice, "call_info", ()).await;
        let agent_info_1: AgentInfo = conductor.call(&alice, "agent_info", ()).await;
        assert_eq!(agent_info_1.chain_head.1, call_info_1.as_at.1 + 1,);
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/block_agent.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::RibosomeT;
use holochain_types::prelude::*;
use holochain_wasmer_host::prelude::*;
use holochain_zome_types::block::Block;
use holochain_zome_types::block::BlockTarget;
use holochain_zome_types::block::CellBlockReason;
use std::sync::Arc;
use wasmer::RuntimeError;

pub fn block_agent(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    input: holochain_zome_types::block::BlockAgentInput,
) -> Result<(), RuntimeError> {
    tokio_helper::block_forever_on(async move {
        call_context
            .host_context()
            .call_zome_handle()
            .block(Block::new(
                BlockTarget::Cell(
                    CellId::new(
                        call_context
                            .host_context()
                            .call_zome_handle()
                            .cell_id()
                            .dna_hash()
                            .clone(),
                        input.target,
                    ),
                    CellBlockReason::App(input.reason),
                ),
                input.interval,
            ))
            .await
            .map_err(|e| -> RuntimeError { wasm_error!(e.to_string()).into() })
    })
}

#[cfg(test)]
mod test {
    use crate::conductor::api::error::ConductorApiResult;
    use crate::core::ribosome::wasm_test::RibosomeTestFixture;
    use crate::sweettest::*;
    use holo_hash::ActionHash;
    use holo_hash::AgentPubKey;
    use holochain_types::prelude::CapSecret;
    use holochain_types::prelude::Record;
    use holochain_types::prelude::ZomeCallResponse;
    use holochain_wasm_test_utils::TestWasm;

    #[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
    pub struct CapFor(CapSecret, AgentPubKey);

    #[cfg(feature = "unstable-functions")]
    #[tokio::test(flavor = "multi_thread")]
    async fn zome_call_verify_block() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor,
            alice,
            alice_pubkey,
            bob,
            bob_pubkey,
            ..
        } = RibosomeTestFixture::new(TestWasm::Capability).await;

        let secret: CapSecret = conductor.call(&bob, "cap_secret", ()).await;
        let _action_hash: ActionHash = conductor.call(&bob, "transferable_cap_grant", secret).await;
        let cap_for = CapFor(secret, bob_pubkey);
        let _response0: ZomeCallResponse = conductor
            .call(&alice, "try_cap_claim", cap_for.clone())
            .await;
        let _response1: ZomeCallResponse = conductor
            .call(&alice, "try_cap_claim", cap_for.clone())
            .await;

        let _: () = conductor
            .call(&bob, "block_agent", alice_pubkey.clone())
            .await;

        let response2: ConductorApiResult<ZomeCallResponse> = conductor
            .call_fallible(&alice, "try_cap_claim", cap_for.clone())
            .await;
        assert!(response2.is_err());

        let _: () = conductor.call(&bob, "unblock_agent", alice_pubkey).await;

        let _response3: ZomeCallResponse = conductor.call(&alice, "try_cap_claim", cap_for).await;
    }

    #[tokio::test(flavor = "multi_thread")]
    #[cfg(feature = "slow_tests")]
    async fn zome_call_get_block() {
        holochain_trace::test_run();

        let (dna_file, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::Create]).await;

        let config = SweetConductorConfig::standard().no_dpki()
            .tune(|tune| {
                tune.gossip_peer_on_success_next_gossip_delay_ms = 1000;
                tune.gossip_peer_on_error_next_gossip_delay_ms = 1000;
                tune.gossip_round_timeout_ms = 3000;
            })
            .tune_conductor(|c| {
                c.sys_validation_retry_delay = Some(std::time::Duration::from_secs(1));
            });
        let mut conductors = SweetConductorBatch::from_config(3, config).await;
        let apps = conductors.setup_app("create", [&dna_file]).await.unwrap();


        let ((alice_cell,), (bob_cell,), (carol_cell,)) = apps.into_tuples();

        let alice = alice_cell.zome(TestWasm::Create);
        let bob = bob_cell.zome(TestWasm::Create);

        let bob_pubkey = bob_cell.cell_id().agent_pubkey();

        conductors.reveal_peer_info(0, 1).await;
        conductors.reveal_peer_info(1, 0).await;

        let alice_conductor = conductors.get(0).unwrap();
        let bob_conductor = conductors.get(1).unwrap();

        let action0: ActionHash = alice_conductor.call(&alice, "create_entry", ()).await;

        await_consistency(10, [&alice_cell, &bob_cell])
            .await
            .unwrap();

        // Before bob is blocked he can get posts just fine.
        let bob_get0: Option<Record> = bob_conductor.call(&bob, "get_post", action0).await;
        // Await bob's init to propagate to alice.
        await_consistency(10, [&alice_cell, &bob_cell])
            .await
            .unwrap();
        assert!(bob_get0.is_some());

        // Bob gets blocked by alice.
        let _block: () = alice_conductor
            .call(&alice, "block_agent", bob_pubkey)
            .await;

        let action1: ActionHash = alice_conductor.call(&alice, "create_entry", ()).await;

        // Now that bob is blocked by alice he cannot get data from alice.
        await_consistency_advanced(10, vec![], [(&alice_cell, true), (&bob_cell, false)])
            .await
            .unwrap();
        let bob_get1: Option<Record> = bob_conductor.call(&bob, "get_post", action1.clone()).await;

        assert!(bob_get1.is_none());

        // If carol joins the party but DOES NOT block bob then she will
        // give access to data once more for bob.

        conductors.exchange_peer_info().await;

        await_consistency(60, [&alice_cell, &bob_cell, &carol_cell])
            .await
            .unwrap();

        // Bob can get data from alice via. carol.
        let bob_get2: Option<Record> = bob_conductor.call(&bob, "get_post", action1).await;
        assert!(bob_get2.is_some());
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/call.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::HostFnAccess;
use crate::core::ribosome::RibosomeError;
use crate::core::ribosome::RibosomeT;
use crate::core::ribosome::ZomeCallParamsSigned;
use futures::future::join_all;
use holochain_nonce::fresh_nonce;
use holochain_types::prelude::*;
use holochain_wasmer_host::prelude::*;
use std::sync::Arc;
use wasmer::RuntimeError;

pub fn call(
    ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    inputs: Vec<Call>,
) -> Result<Vec<ZomeCallResponse>, RuntimeError> {
    let results: Vec<Result<ZomeCallResponse, RuntimeError>> =
        tokio_helper::block_forever_on(async move {
            join_all(inputs.into_iter().map(|input| async {
                // The line below was added when migrating to rust edition 2021, per
                // https://doc.rust-lang.org/edition-guide/rust-2021/disjoint-capture-in-closures.html#migration
                let _ = &input;
                let Call {
                    target,
                    zome_name,
                    fn_name,
                    cap_secret,
                    payload,
                } = input;

                match (&target, HostFnAccess::from(&call_context.host_context())) {
                    (
                        CallTarget::ConductorCell(_),
                        HostFnAccess {
                            write_workspace: Permission::Allow,
                            agent_info: Permission::Allow,
                            ..
                        },
                    )
                    | (
                        CallTarget::NetworkAgent(_),
                        HostFnAccess {
                            write_network: Permission::Allow,
                            agent_info: Permission::Allow,
                            ..
                        },
                    ) => {
                        let provenance = call_context
                            .host_context
                            .workspace()
                            .source_chain()
                            .as_ref()
                            .expect("Must have source chain to know provenance")
                            .agent_pubkey()
                            .clone();
                        let (nonce, expires_at) =
                            fresh_nonce(Timestamp::now()).map_err(|e| -> RuntimeError {
                                wasm_error!(WasmErrorInner::Host(e.to_string())).into()
                            })?;

                        let result: Result<ZomeCallResponse, RuntimeError> = match target {
                            CallTarget::NetworkAgent(target_agent) => {
                                let zome_call_params = ZomeCallParams {
                                    provenance: provenance.clone(),
                                    cell_id: CellId::new(
                                        ribosome.dna_def().as_hash().clone(),
                                        target_agent.clone(),
                                    ),
                                    zome_name,
                                    fn_name,
                                    cap_secret,
                                    payload,
                                    nonce,
                                    expires_at,
                                };
                                let zome_call_payload = ZomeCallParamsSigned::try_from_params(
                                    call_context.host_context.keystore(),
                                    zome_call_params.clone(),
                                )
                                .await
                                .map_err(|e| -> RuntimeError {
                                    wasm_error!(WasmErrorInner::Host(e.to_string())).into()
                                })?;
                                match call_context
                                    .host_context()
                                    .network()
                                    .call_remote(
                                        target_agent,
                                        zome_call_payload.bytes,
                                        zome_call_payload.signature,
                                    )
                                    .await
                                {
                                    Ok(serialized_bytes) => {
                                        ZomeCallResponse::try_from(serialized_bytes)
                                            .map_err(|e| -> RuntimeError { wasm_error!(e).into() })
                                    }
                                    Err(e) => Ok(ZomeCallResponse::NetworkError(e.to_string())),
                                }
                            }
                            CallTarget::ConductorCell(target_cell) => {
                                let cell_id_result: Result<CellId, RuntimeError> = match target_cell
                                {
                                    CallTargetCell::OtherRole(role_name) => {
                                        let this_cell_id = call_context
                                            .host_context()
                                            .call_zome_handle()
                                            .cell_id()
                                            .clone();
                                        call_context
                                            .host_context()
                                            .call_zome_handle()
                                            .find_cell_with_role_alongside_cell(
                                                &this_cell_id,
                                                &role_name,
                                            )
                                            .await
                                            .map_err(|e| -> RuntimeError { wasm_error!(e).into() })
                                            .and_then(|c| {
                                                c.ok_or_else(|| {
                                                    wasmer::RuntimeError::from(wasm_error!(
                                                        WasmErrorInner::Host(format!(
                                                            "Role not found: {role_name}"
                                                        ))
                                                    ))
                                                })
                                            })
                                    }
                                    CallTargetCell::OtherCell(cell_id) => Ok(cell_id),
                                    CallTargetCell::Local => Ok(call_context
                                        .host_context()
                                        .call_zome_handle()
                                        .cell_id()
                                        .clone()),
                                };
                                match cell_id_result {
                                    Ok(cell_id) => {
                                        let zome_call_params = ZomeCallParams {
                                            cell_id,
                                            zome_name,
                                            fn_name,
                                            payload,
                                            cap_secret,
                                            provenance,
                                            nonce,
                                            expires_at,
                                        };
                                        match call_context
                                            .host_context()
                                            .call_zome_handle()
                                            .call_zome(
                                                zome_call_params,
                                                call_context
                                                    .host_context()
                                                    .workspace_write()
                                                    .clone()
                                                    .try_into()
                                                    .expect(
                                                        "Must have source chain to make zome call",
                                                    ),
                                            )
                                            .await
                                        {
                                            Ok(Ok(zome_call_response)) => Ok(zome_call_response),
                                            Ok(Err(ribosome_error)) => Err(wasm_error!(
                                                WasmErrorInner::Host(ribosome_error.to_string())
                                            )
                                            .into()),
                                            Err(conductor_api_error) => {
                                                Err(wasm_error!(WasmErrorInner::Host(
                                                    conductor_api_error.to_string()
                                                ))
                                                .into())
                                            }
                                        }
                                    }
                                    Err(e) => Err(e),
                                }
                            }
                        };
                        result
                    }
                    _ => Err(wasm_error!(WasmErrorInner::Host(
                        RibosomeError::HostFnPermissions(
                            call_context.zome.zome_name().clone(),
                            call_context.function_name().clone(),
                            "call".into(),
                        )
                        .to_string(),
                    ))
                    .into()),
                }
            }))
            .await
        });
    let results: Result<Vec<_>, _> = results.into_iter().collect();
    results
}

#[cfg(test)]
pub mod wasm_test {
    use crate::sweettest::SweetConductor;
    use crate::sweettest::SweetDnaFile;
    use hdk::prelude::AgentInfo;
    use holo_hash::ActionHash;
    use holochain_types::prelude::*;
    use holochain_wasm_test_utils::TestWasm;
    use matches::assert_matches;
    use rusqlite::named_params;

    use crate::core::ribosome::wasm_test::RibosomeTestFixture;
    use crate::test_utils::new_zome_call_params;
    use holochain_sqlite::prelude::DatabaseResult;

    #[tokio::test(flavor = "multi_thread")]
    async fn call_test() {
        holochain_trace::test_run();
        let test_wasm = TestWasm::WhoAmI;
        let (dna_file_1, _, _) = SweetDnaFile::unique_from_test_wasms(vec![test_wasm]).await;

        let dna_file_2 = dna_file_1
            .clone()
            .with_network_seed("CLONE".to_string())
            .await;

        let mut conductor = SweetConductor::from_standard_config().await;

        let app = conductor
            .setup_app(
                "app-",
                [
                    &("role1".to_string(), dna_file_1),
                    &("role2".to_string(), dna_file_2),
                ],
            )
            .await
            .unwrap();

        let agent_pubkey = app.agent().clone();
        let (cell1, cell2) = app.into_tuple();

        let zome1 = cell1.zome(test_wasm);
        let zome2 = cell2.zome(test_wasm);

        let _: () = conductor.call(&zome2, "set_access", ()).await;

        {
            let agent_info: AgentInfo = conductor
                .call(&zome1, "who_are_they_local", cell2.cell_id())
                .await;
            assert_eq!(agent_info.agent_initial_pubkey, agent_pubkey);
            assert_eq!(agent_info.agent_latest_pubkey, agent_pubkey);
        }
        {
            let agent_info: AgentInfo = conductor.call(&zome1, "who_are_they_role", "role2").await;
            assert_eq!(agent_info.agent_initial_pubkey, agent_pubkey);
            assert_eq!(agent_info.agent_latest_pubkey, agent_pubkey);
        }
    }

    /// When calling the same cell we need to make sure
    /// the "as at" doesn't cause the original zome call to fail
    /// when they are both writing (moving the source chain forward)
    #[tokio::test(flavor = "multi_thread")]
    async fn call_the_same_cell() {
        holochain_trace::test_run();

        let zomes = vec![TestWasm::WhoAmI, TestWasm::Create];
        let (dna, _, _) = SweetDnaFile::unique_from_test_wasms(zomes).await;
        let mut conductor = SweetConductor::from_standard_config().await;
        let (alice,) = conductor
            .setup_app("app", &[dna])
            .await
            .unwrap()
            .into_tuple();

        let handle = conductor.raw_handle();

        let zome_call_params =
            new_zome_call_params(alice.cell_id(), "call_create_entry", (), TestWasm::Create)
                .unwrap();
        let result = handle.call_zome(zome_call_params).await;
        assert_matches!(result, Ok(Ok(ZomeCallResponse::Ok(_))));

        // Get the action hash of that entry
        let action_hash: ActionHash =
            unwrap_to::unwrap_to!(result.unwrap().unwrap() => ZomeCallResponse::Ok)
                .decode()
                .unwrap();

        // Check alice's source chain contains the new value
        let has_hash: bool = handle
            .get_spaces()
            .get_or_create_authored_db(alice.dna_hash(), alice.agent_pubkey().clone())
            .unwrap()
            .read_async(move |txn| -> DatabaseResult<bool> {
                Ok(txn.query_row(
                    "SELECT EXISTS(SELECT 1 FROM DhtOp WHERE action_hash = :hash)",
                    named_params! {
                        ":hash": action_hash
                    },
                    |row| row.get(0),
                )?)
            })
            .await
            .unwrap();
        assert!(has_hash);
    }

    /// test calling a different zome
    /// in a different cell.
    // FIXME: we should NOT be able to do a "bridge" call to another cell in a different app, by a different agent!
    //        Local bridge calls are always within the same app. So this test is testing something that should
    //        not be supported.
    #[tokio::test(flavor = "multi_thread")]
    async fn bridge_call() {
        holochain_trace::test_run();

        let (dna_file, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::Create]).await;

        let mut conductor = SweetConductor::from_standard_config().await;

        let apps = conductor.setup_apps("app", 2, &[dna_file]).await.unwrap();
        let ((alice,), (bobbo,)) = apps.into_tuples();
        let bob_pubkey = bobbo.agent_pubkey().clone();

        let (dna_file, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::WhoAmI]).await;
        let apps = conductor
            .setup_app_for_agents("app2", &[bob_pubkey], &[dna_file])
            .await
            .unwrap();
        let ((bobbo2,),) = apps.into_tuples();
        let action_hash: ActionHash = conductor
            .call(
                &bobbo2.zome(TestWasm::WhoAmI),
                "call_create_entry",
                alice.cell_id().clone(),
            )
            .await;

        // Check alice's source chain contains the new value
        let has_hash: bool = alice
            .dht_db()
            .read_async(move |txn| -> DatabaseResult<bool> {
                Ok(txn.query_row(
                    "SELECT EXISTS(SELECT 1 FROM DhtOp WHERE action_hash = :hash)",
                    named_params! {
                        ":hash": action_hash
                    },
                    |row| row.get(0),
                )?)
            })
            .await
            .unwrap();
        assert!(has_hash);
    }

    #[tokio::test(flavor = "multi_thread")]
    /// we can call a fn on a remote
    async fn call_remote_test() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor,
            alice,
            bob,
            bob_pubkey,
            ..
        } = RibosomeTestFixture::new(TestWasm::WhoAmI).await;

        let _: () = conductor.call(&bob, "set_access", ()).await;
        let agent_info: AgentInfo = conductor
            .call(&alice, "whoarethey", bob_pubkey.clone())
            .await;
        assert_eq!(agent_info.agent_initial_pubkey, bob_pubkey);
        assert_eq!(agent_info.agent_latest_pubkey, bob_pubkey);
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/call_info.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::InvocationAuth;
use crate::core::ribosome::RibosomeError;
use crate::core::ribosome::RibosomeT;
use holochain_state::source_chain::SourceChainError;
use holochain_types::prelude::*;
use holochain_wasmer_host::prelude::*;
use holochain_zome_types::info::CallInfo;
use std::sync::Arc;
use wasmer::RuntimeError;

pub fn call_info(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    _input: (),
) -> Result<CallInfo, RuntimeError> {
    match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            bindings: Permission::Allow,
            ..
        } => {
            let (provenance, cap_grant) = {
                match call_context.auth() {
                    InvocationAuth::Cap(provenance, cap_secret) => {
                        let check_function = (
                            call_context.zome.zome_name().clone(),
                            call_context.function_name().clone(),
                        );
                        let check_agent = provenance.clone();
                        let call_context = call_context.clone();
                        let cap_grant = tokio_helper::block_forever_on(async move {
                            Result::<_, WasmHostError>::Ok(call_context
                            .host_context
                            .workspace()
                            .source_chain()
                            .as_ref()
                            .expect("Must have source chain if bindings access is given")
                            .valid_cap_grant(
                                check_function,
                                check_agent,
                                cap_secret,
                            ).await.map_err(|e| wasm_error!(WasmErrorInner::Host(e.to_string())))?
                            // This is really a problem.
                            // It means that the host function calling into `call_info`
                            // is using a cap secret that never had authorization to call in the first place.
                            // The host must NEVER allow this so `None` is a critical bug.
                            .expect("The host is using an unauthorized cap_secret, which should never happen"))
                        })?;
                        (provenance, cap_grant)
                    }
                    InvocationAuth::LocalCallback => {
                        let author = call_context
                            .host_context
                            .workspace()
                            .source_chain()
                            .as_ref()
                            .expect("Must have source chain if bindings access is given")
                            .agent_pubkey()
                            .clone();
                        (author.clone(), CapGrant::ChainAuthor(author))
                    }
                }
            };
            Ok(CallInfo {
                function_name: call_context.function_name.clone(),
                as_at: call_context
                    .host_context
                    .workspace()
                    .source_chain()
                    .as_ref()
                    .expect("Must have source chain if bindings access is given")
                    .persisted_head_info()
                    .ok_or(wasm_error!(WasmErrorInner::Host(
                        SourceChainError::ChainEmpty.to_string()
                    )))?
                    .into_tuple(),
                provenance,
                cap_grant,
            })
        }
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "call_info".into()
            )
            .to_string()
        ))
        .into()),
    }
}

#[cfg(test)]
#[cfg(feature = "slow_tests")]
pub mod test {
    use crate::core::ribosome::wasm_test::RibosomeTestFixture;
    use holochain_wasm_test_utils::TestWasm;
    use holochain_zome_types::prelude::*;

    #[tokio::test(flavor = "multi_thread")]
    async fn call_info_test() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor, alice, ..
        } = RibosomeTestFixture::new(TestWasm::ZomeInfo).await;

        let call_info: CallInfo = conductor.call(&alice, "call_info", ()).await;
        assert_eq!(call_info.as_at.1, 3);
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn call_info_provenance_test() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor,
            alice,
            alice_pubkey,
            bob,
            bob_pubkey,
            ..
        } = RibosomeTestFixture::new(TestWasm::ZomeInfo).await;

        let _: () = conductor.call(&alice, "set_access", ()).await;
        let _: () = conductor.call(&bob, "set_access", ()).await;

        let alice_call_info: CallInfo = conductor.call(&alice, "call_info", ()).await;
        let bob_call_info: CallInfo = conductor.call(&bob, "call_info", ()).await;
        let bob_call_alice_call_info: CallInfo = conductor
            .call(&bob, "remote_call_info", alice_pubkey.clone())
            .await;
        let alice_call_bob_call_alice_call_info: CallInfo = conductor
            .call(&alice, "remote_remote_call_info", bob_pubkey.clone())
            .await;

        // direct calls to alice/bob should have their own provenance
        assert_eq!(alice_call_info.provenance, alice_pubkey);
        assert_eq!(bob_call_info.provenance, bob_pubkey);
        // Bob calling into alice should have bob provenance.
        assert_eq!(bob_call_alice_call_info.provenance, bob_pubkey);
        // Alice calling back into herself via. bob should have bob provenance.
        assert_eq!(alice_call_bob_call_alice_call_info.provenance, bob_pubkey);
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/capability_claims.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::RibosomeT;
use std::sync::Arc;
use wasmer::RuntimeError;

/// lists all the local claims filtered by tag
pub fn capability_claims(
    _ribosome: Arc<impl RibosomeT>,
    _call_context: Arc<CallContext>,
    _input: (),
) -> Result<(), RuntimeError> {
    unimplemented!();
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/capability_grants.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::RibosomeT;
use std::sync::Arc;
use wasmer::RuntimeError;

/// list all the grants stored locally in the chain filtered by tag
/// this is only the current grants as per local CRUD
pub fn capability_grants(
    _ribosome: Arc<impl RibosomeT>,
    _call_context: Arc<CallContext>,
    _input: (),
) -> Result<(), RuntimeError> {
    unimplemented!();
}

#[cfg(test)]
#[cfg(feature = "slow_tests")]
pub mod wasm_test {
    use crate::core::ribosome::wasm_test::RibosomeTestFixture;
    use ::fixt::prelude::*;
    use hdk::prelude::*;
    use holochain_types::fixt::CapSecretFixturator;
    use holochain_wasm_test_utils::TestWasm;

    use matches::assert_matches;

    #[tokio::test(flavor = "multi_thread")]
    async fn ribosome_capability_secret_test() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor, alice, ..
        } = RibosomeTestFixture::new(TestWasm::Capability).await;

        let _: CapSecret = conductor.call(&alice, "cap_secret", ()).await;
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn ribosome_transferable_cap_grant() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor, alice, ..
        } = RibosomeTestFixture::new(TestWasm::Capability).await;

        let secret: CapSecret = conductor.call(&alice, "cap_secret", ()).await;
        let action: ActionHash = conductor
            .call(&alice, "transferable_cap_grant", secret)
            .await;
        let maybe_record: Option<Record> = conductor.call(&alice, "get_entry", action).await;
        let entry_secret: CapSecret = maybe_record
            .and_then(|record| {
                let cap_grant_entry = record.entry().to_grant_option().unwrap();
                match cap_grant_entry.access {
                    CapAccess::Transferable { secret, .. } => Some(secret),
                    _ => None,
                }
            })
            .unwrap();
        assert_eq!(entry_secret, secret);
    }

    // MAYBE: [ B-03669 ] can move this to an integration test (may need to switch to using a RibosomeStore)
    #[tokio::test(flavor = "multi_thread")]
    async fn ribosome_authorized_call() -> anyhow::Result<()> {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor,
            alice,
            bob,
            bob_pubkey,
            ..
        } = RibosomeTestFixture::new(TestWasm::Capability).await;

        // ALICE FAILING AN UNAUTHED CALL

        #[derive(serde::Serialize, serde::Deserialize, SerializedBytes, Debug)]
        pub struct CapFor(CapSecret, AgentPubKey);

        let original_secret = CapSecretFixturator::new(Unpredictable).next().unwrap();

        let output: ZomeCallResponse = conductor
            .call(
                &alice,
                "try_cap_claim",
                CapFor(original_secret, bob_pubkey.clone()),
            )
            .await;

        assert_matches!(output, ZomeCallResponse::Unauthorized(..));

        // BOB COMMITS A TRANSFERABLE GRANT WITH THE SECRET SHARED WITH ALICE

        let original_grant_hash: ActionHash = conductor
            .call(&bob, "transferable_cap_grant", original_secret)
            .await;

        // ALICE CAN NOW CALL THE AUTHED REMOTE FN

        let response: ZomeCallResponse = conductor
            .call(
                &alice,
                "try_cap_claim",
                CapFor(original_secret, bob_pubkey.clone()),
            )
            .await;

        assert_eq!(
            response,
            ZomeCallResponse::Ok(ExternIO::encode(()).unwrap()),
        );

        // BOB ROLLS THE GRANT SO ONLY THE NEW ONE WILL WORK FOR ALICE

        let new_grant_action_hash: ActionHash = conductor
            .call(&bob, "roll_cap_grant", original_grant_hash)
            .await;

        let output: Option<Record> = conductor
            .call(&bob, "get_entry", new_grant_action_hash.clone())
            .await;

        let new_secret: CapSecret = match output {
            Some(record) => match record.entry().to_grant_option() {
                Some(zome_call_cap_grant) => match zome_call_cap_grant.access {
                    CapAccess::Transferable { secret, .. } => secret,
                    _ => unreachable!(),
                },
                _ => unreachable!(),
            },
            _ => unreachable!("Couldn't get {:?}", new_grant_action_hash),
        };

        let output: ZomeCallResponse = conductor
            .call(
                &alice,
                "try_cap_claim",
                CapFor(original_secret, bob_pubkey.clone()),
            )
            .await;

        assert_matches!(output, ZomeCallResponse::Unauthorized(..));

        let output: ZomeCallResponse = conductor
            .call(
                &alice,
                "try_cap_claim",
                CapFor(new_secret, bob_pubkey.clone()),
            )
            .await;
        assert_eq!(output, ZomeCallResponse::Ok(ExternIO::encode(()).unwrap()),);

        // BOB DELETES THE GRANT SO NO SECRETS WORK

        let _: ActionHash = conductor
            .call(&bob, "delete_cap_grant", new_grant_action_hash)
            .await;

        let output: ZomeCallResponse = conductor
            .call(
                &alice,
                "try_cap_claim",
                CapFor(original_secret, bob_pubkey.clone()),
            )
            .await;

        assert_matches!(output, ZomeCallResponse::Unauthorized(..));

        let output: ZomeCallResponse = conductor
            .call(
                &alice,
                "try_cap_claim",
                CapFor(new_secret, bob_pubkey.clone()),
            )
            .await;

        // the inner response should be unauthorized
        assert_matches!(output, ZomeCallResponse::Unauthorized(..));

        let mut conductor = conductor;
        conductor.shutdown().await;

        Ok(())
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/capability_info.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::RibosomeT;
use std::sync::Arc;
use wasmer::RuntimeError;

/// return the access info used for this call
/// also return who is originated the call (pubkey)
pub fn capability_info(
    _ribosome: Arc<impl RibosomeT>,
    _call_context: Arc<CallContext>,
    _input: (),
) -> Result<(), RuntimeError> {
    unimplemented!();
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/close_chain.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::HostFnAccess;
use crate::core::ribosome::RibosomeError;
use crate::core::ribosome::RibosomeT;
use holochain_wasmer_host::prelude::*;

use holochain_types::prelude::*;
use std::sync::Arc;
use wasmer::RuntimeError;

pub fn close_chain(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    input: CloseChainInput,
) -> Result<ActionHash, RuntimeError> {
    match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            write_workspace: Permission::Allow,
            ..
        } => {
            // Construct the close chain action
            let action_builder = builder::CloseChain::new(input.new_target);

            let action_hash = tokio_helper::block_forever_on(tokio::task::spawn(async move {
                // push the action into the source chain
                let action_hash = call_context
                    .host_context
                    .workspace_write()
                    .source_chain()
                    .as_ref()
                    .expect("Must have source chain if write_workspace access is given")
                    .put_weightless(action_builder, None, ChainTopOrdering::Strict)
                    .await?;
                Ok::<ActionHash, RibosomeError>(action_hash)
            }))
            .map_err(|join_error| -> RuntimeError {
                wasm_error!(WasmErrorInner::Host(join_error.to_string())).into()
            })?
            .map_err(|ribosome_error| -> RuntimeError {
                wasm_error!(WasmErrorInner::Host(ribosome_error.to_string())).into()
            })?;

            // Return the hash of the chain close
            Ok(action_hash)
        }
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "close_chain".into()
            )
            .to_string()
        ))
        .into()),
    }
}

#[cfg(test)]
mod tests {
    use super::close_chain;
    use crate::fixt::ZomeCallHostAccessFixturator;
    use crate::fixt::{CallContextFixturator, RealRibosomeFixturator};
    use ::fixt::Predictable;
    use ::fixt::{fixt, Unpredictable};
    use holochain_util::tokio_helper;
    use holochain_wasm_test_utils::{TestWasm, TestWasmPair};
    use holochain_zome_types::prelude::*;
    use std::sync::Arc;

    #[tokio::test(flavor = "multi_thread")]
    async fn call_close_chain() {
        // Note that any zome will do here, we're not calling its functions!
        let ribosome =
            RealRibosomeFixturator::new(crate::fixt::curve::Zomes(vec![TestWasm::MigrateInitial]))
                .next()
                .unwrap();
        let mut call_context = CallContextFixturator::new(Unpredictable).next().unwrap();
        call_context.zome =
            TestWasmPair::<IntegrityZome, CoordinatorZome>::from(TestWasm::MigrateInitial)
                .coordinator
                .erase_type();
        let host_access = fixt!(ZomeCallHostAccess, Predictable);
        let mut input = CloseChainInput {
            new_target: None,
        };

        // If this is an agent migration, the agent keypair needs to exist
        // so the Close can be signed.
        if let Some(MigrationTarget::Agent(agent)) = input.new_target.as_mut() {
            *agent = host_access
                .keystore
                .new_sign_keypair_random()
                .await
                .unwrap();
        }

        let host_access_2 = host_access.clone();
        call_context.host_context = host_access.into();

        let output = close_chain(Arc::new(ribosome), Arc::new(call_context), input).unwrap();

        // the chain head should be the committed chain close action
        let chain_head = tokio_helper::block_forever_on(async move {
            host_access_2
                .workspace
                .source_chain()
                .as_ref()
                .unwrap()
                .chain_head()
                .unwrap()
                .unwrap()
                .action
        });

        assert_eq!(chain_head, output);
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/count_links.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::HostFnAccess;
use crate::core::ribosome::RibosomeError;
use crate::core::ribosome::RibosomeT;
use holochain_cascade::CascadeImpl;
use holochain_types::prelude::*;
use holochain_wasmer_host::prelude::*;
use std::sync::Arc;
use wasmer::RuntimeError;

/// Count links
#[allow(clippy::extra_unused_lifetimes)]
#[cfg_attr(feature = "instrument", tracing::instrument(skip(_ribosome, call_context), fields(? call_context.zome, function = ? call_context.function_name)))]
pub fn count_links<'a>(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    query: LinkQuery,
) -> Result<usize, RuntimeError> {
    tracing::debug!(msg = "Counting links", ?query);
    match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            read_workspace: Permission::Allow,
            ..
        } => tokio_helper::block_forever_on(async move {
            let wire_query = WireLinkQuery {
                base: query.base,
                link_type: query.link_type,
                tag_prefix: query.tag_prefix,
                before: query.before,
                after: query.after,
                author: query.author,
            };

            CascadeImpl::from_workspace_and_network(
                &call_context.host_context.workspace(),
                call_context.host_context.network().to_owned(),
            )
            .dht_count_links(wire_query)
            .await
            .map_err(|cascade_error| {
                wasm_error!(WasmErrorInner::Host(cascade_error.to_string())).into()
            })
        }),
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "count_links".into(),
            )
            .to_string(),
        ))
        .into()),
    }
}

#[cfg(test)]
#[cfg(feature = "slow_tests")]
mod tests {
    use crate::core::ribosome::wasm_test::RibosomeTestFixture;
    use crate::sweettest::{SweetConductorHandle, SweetZome};
    use hdk::prelude::*;
    use holochain_wasm_test_utils::TestWasm;
    use tokio::time::error::Elapsed;

    #[tokio::test(flavor = "multi_thread")]
    async fn count_links() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor,
            alice,
            bob,
            ..
        } = RibosomeTestFixture::new(TestWasm::Link).await;

        // Create a link for Alice
        let _: ActionHash = conductor.call(&alice, "create_link", ()).await;

        let base: AnyLinkableHash = conductor.call(&alice, "get_base_hash", ()).await;

        let count: usize = conductor
            .call(
                &alice,
                "get_count",
                LinkQuery::new(
                    base.clone(),
                    LinkTypeFilter::Dependencies(vec![ZomeIndex(0)]),
                ),
            )
            .await;
        assert_eq!(1, count);

        // Create a link for Bob
        let _: ActionHash = conductor.call(&bob, "create_link", ()).await;

        // Check that Alice can see her link and Bob's
        wait_for_link_count(conductor.sweet_handle(), &alice, base, 2)
            .await
            .expect("Timed out waiting for agent to see both links");
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn count_links_filtered_by_author() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor,
            alice,
            bob,
            ..
        } = RibosomeTestFixture::new(TestWasm::Link).await;

        // Create a link for Alice
        let _: ActionHash = conductor.call(&alice, "create_link", ()).await;

        let base: AnyLinkableHash = conductor.call(&alice, "get_base_hash", ()).await;

        let count: usize = conductor
            .call(
                &alice,
                "get_count",
                LinkQuery::new(
                    base.clone(),
                    LinkTypeFilter::Dependencies(vec![ZomeIndex(0)]),
                ),
            )
            .await;
        assert_eq!(1, count);

        // Create a link for Bob
        let _: ActionHash = conductor.call(&bob, "create_link", ()).await;

        // Check that Alice can count her link and Bob's
        wait_for_link_count(conductor.sweet_handle(), &alice, base.clone(), 2)
            .await
            .expect("Timed out waiting for alice to see both links");

        // Only count Alice's links
        let count: usize = conductor
            .call(
                &alice,
                "get_count",
                LinkQuery::new(
                    base.clone(),
                    LinkTypeFilter::Dependencies(vec![ZomeIndex(0)]),
                )
                .author(alice.cell_id().agent_pubkey().clone()),
            )
            .await;
        assert_eq!(1, count);

        // Only count Bob's links
        let count: usize = conductor
            .call(
                &bob,
                "get_count",
                LinkQuery::new(base, LinkTypeFilter::Dependencies(vec![ZomeIndex(0)]))
                    .author(bob.cell_id().agent_pubkey().clone()),
            )
            .await;
        assert_eq!(1, count);
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn count_links_filtered_by_timestamp() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor,
            alice,
            bob,
            ..
        } = RibosomeTestFixture::new(TestWasm::Link).await;

        // Create a link for Alice
        let _: ActionHash = conductor.call(&alice, "create_link", ()).await;

        let base: AnyLinkableHash = conductor.call(&alice, "get_base_hash", ()).await;

        let count: usize = conductor
            .call(
                &alice,
                "get_count",
                LinkQuery::new(
                    base.clone(),
                    LinkTypeFilter::Dependencies(vec![ZomeIndex(0)]),
                ),
            )
            .await;
        assert_eq!(1, count);

        let mid_time = Timestamp::now();

        // Create a link for Bob
        let _: ActionHash = conductor.call(&bob, "create_link", ()).await;

        // Check that Alice can count her link and Bob's
        wait_for_link_count(
            conductor.sweet_handle(),
            &alice,
            base.clone(),
            2,
        ).await.expect("Timed out waiting for alice to see both links");

        // Get links created before the mid-time (only Alice's)
        let count: usize = conductor
            .call(
                &alice,
                "get_count",
                LinkQuery::new(
                    base.clone(),
                    LinkTypeFilter::Dependencies(vec![ZomeIndex(0)]),
                )
                .after(mid_time),
            )
            .await;
        assert_eq!(1, count);

        // Get links created after the mid-time (only Bob's)
        let count: usize = conductor
            .call(
                &bob,
                "get_count",
                LinkQuery::new(base, LinkTypeFilter::Dependencies(vec![ZomeIndex(0)]))
                    .before(mid_time),
            )
            .await;
        assert_eq!(1, count);
    }

    async fn wait_for_link_count(
        conductor: SweetConductorHandle,
        zome: &SweetZome,
        base: AnyLinkableHash,
        count: usize,
    ) -> Result<(), Elapsed> {
        tokio::time::timeout(std::time::Duration::from_secs(10), async move {
            loop {
                let current_count: usize = conductor
                    .call(
                        zome,
                        "get_count",
                        LinkQuery::new(
                            base.clone(),
                            LinkTypeFilter::Dependencies(vec![ZomeIndex(0)]),
                        ),
                    )
                    .await;

                if current_count == count {
                    break;
                }

                tokio::time::sleep(std::time::Duration::from_millis(50)).await;
            }
        })
            .await
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/create.rs
================================================
use crate::core::ribosome::weigh_placeholder;
use crate::core::ribosome::CallContext;
use crate::core::ribosome::HostFnAccess;
use crate::core::ribosome::RibosomeError;
use crate::core::ribosome::RibosomeT;
use holochain_types::prelude::*;
use holochain_wasmer_host::prelude::*;
use std::sync::Arc;
use wasmer::RuntimeError;

/// create record
#[allow(clippy::extra_unused_lifetimes)]
pub fn create<'a>(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    input: CreateInput,
) -> Result<ActionHash, RuntimeError> {
    match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            write_workspace: Permission::Allow,
            ..
        } => {
            let CreateInput {
                entry_location,
                entry_visibility,
                entry,
                chain_top_ordering,
            } = input;

            let weight = weigh_placeholder();

            // Countersigned entries have different action handling.
            match entry {
                Entry::CounterSign(_, _) => tokio_helper::block_forever_on(async move {
                    call_context
                        .host_context
                        .workspace_write()
                        .source_chain()
                        .as_ref()
                        .expect("Must have source chain if write_workspace access is given")
                        .put_countersigned(entry, chain_top_ordering, weight)
                        .await
                        .map_err(|source_chain_error| -> RuntimeError {
                            wasm_error!(WasmErrorInner::Host(source_chain_error.to_string())).into()
                        })
                }),
                _ => {
                    // build the entry hash
                    let entry_hash = EntryHash::with_data_sync(&entry);

                    // extract the entry defs for a zome
                    let entry_type = match entry_location {
                        EntryDefLocation::App(AppEntryDefLocation {
                            zome_index,
                            entry_def_index,
                        }) => {
                            let app_entry_def =
                                AppEntryDef::new(entry_def_index, zome_index, entry_visibility);
                            EntryType::App(app_entry_def)
                        }
                        EntryDefLocation::CapGrant => EntryType::CapGrant,
                        EntryDefLocation::CapClaim => EntryType::CapClaim,
                    };

                    // build an action for the entry being committed
                    let action_builder = builder::Create {
                        entry_type,
                        entry_hash,
                    };

                    // return the hash of the committed entry
                    // note that validation is handled by the workflow
                    // if the validation fails this commit will be rolled back by virtue of the DB transaction
                    // being atomic
                    tokio_helper::block_forever_on(async move {
                        // push the action and the entry into the source chain
                        call_context
                            .host_context
                            .workspace_write()
                            .source_chain()
                            .as_ref()
                            .expect("Must have source chain if write_workspace access is given")
                            .put_weightless(action_builder, Some(entry), chain_top_ordering)
                            .await
                            .map_err(|source_chain_error| -> RuntimeError {
                                wasm_error!(WasmErrorInner::Host(source_chain_error.to_string()))
                                    .into()
                            })
                    })
                }
            }
        }
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "create".into(),
            )
            .to_string(),
        ))
        .into()),
    }
}

#[cfg(test)]
#[cfg(feature = "slow_tests")]
pub mod wasm_test {
    use super::create;
    use crate::core::ribosome::wasm_test::RibosomeTestFixture;
    use crate::fixt::*;
    use crate::sweettest::*;
    use ::fixt::prelude::*;
    use hdk::prelude::*;
    use holo_hash::AnyDhtHash;
    use holo_hash::EntryHash;
    use holochain_state::source_chain::SourceChainResult;
    use holochain_trace;
    use holochain_types::prelude::*;
    use holochain_wasm_test_utils::TestWasm;
    use holochain_wasm_test_utils::TestWasmPair;
    use std::sync::Arc;

    #[tokio::test(flavor = "multi_thread")]
    /// we can get an entry hash out of the fn directly
    async fn create_entry_test() {
        let ribosome =
            RealRibosomeFixturator::new(crate::fixt::curve::Zomes(vec![TestWasm::Create]))
                .next()
                .unwrap();
        let mut call_context = CallContextFixturator::new(Unpredictable).next().unwrap();
        call_context.zome = TestWasmPair::<IntegrityZome, CoordinatorZome>::from(TestWasm::Create)
            .coordinator
            .erase_type();
        let host_access = fixt!(ZomeCallHostAccess, Predictable);
        let host_access_2 = host_access.clone();
        call_context.host_context = host_access.into();
        let app_entry = EntryFixturator::new(AppEntry).next().unwrap();
        let input = CreateInput::new(
            EntryDefLocation::app(0, 0),
            EntryVisibility::Public,
            app_entry.clone(),
            ChainTopOrdering::default(),
        );

        let output = create(Arc::new(ribosome), Arc::new(call_context), input).unwrap();

        // the chain head should be the committed entry action
        let chain_head = tokio_helper::block_forever_on(async move {
            // The line below was added when migrating to rust edition 2021, per
            // https://doc.rust-lang.org/edition-guide/rust-2021/disjoint-capture-in-closures.html#migration
            let _ = &host_access_2;
            SourceChainResult::Ok(
                host_access_2
                    .workspace
                    .source_chain()
                    .as_ref()
                    .unwrap()
                    .chain_head()
                    .unwrap()
                    .unwrap()
                    .action,
            )
        })
        .unwrap();

        assert_eq!(chain_head, output);
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn ribosome_create_entry_test() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor, alice, ..
        } = RibosomeTestFixture::new(TestWasm::Create).await;

        // get the result of a commit entry
        let _output: ActionHash = conductor.call(&alice, "create_entry", ()).await;

        // entry should be gettable.
        let round: Option<Record> = conductor.call(&alice, "get_entry", ()).await;

        let round_twice: Vec<Option<Record>> = conductor.call(&alice, "get_entry_twice", ()).await;

        let bytes: Vec<u8> = match round.clone().and_then(|el| el.into()) {
            Some(holochain_zome_types::entry::Entry::App(entry_bytes)) => {
                entry_bytes.bytes().to_vec()
            }
            other => panic!("unexpected output: {:?}", other),
        };
        // this should be the content "foo" of the committed post
        assert_eq!(vec![163, 102, 111, 111], bytes);

        assert_eq!(round_twice, vec![round.clone(), round],);
    }

    #[tokio::test(flavor = "multi_thread")]
    // TODO: rewrite with sweettest and check if still flaky.
    // maackle: this consistently passes for me with n = 37
    //          but starts to randomly lock up at n = 38,
    //          and fails consistently for higher values
    async fn multiple_create_entry_limit_test() {
        const N: u32 = 50;

        holochain_trace::test_run();
        let mut conductor = SweetConductor::from_standard_config().await;
        let (dna, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::MultipleCalls]).await;

        let app = conductor.setup_app("app", [&dna]).await.unwrap();
        let (cell,) = app.into_tuple();

        let _: () = conductor
            .call(
                &cell.zome(TestWasm::MultipleCalls),
                "create_entry_multiple",
                N,
            )
            .await;

        let output: holochain_zome_types::bytes::Bytes = conductor
            .call(&cell.zome(TestWasm::MultipleCalls), "get_entry_multiple", N)
            .await;

        let expected: Vec<u8> = (0..N).flat_map(|i| i.to_le_bytes()).collect();

        assert_eq!(output.into_vec(), expected);
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn test_serialize_bytes_hash() {
        holochain_trace::test_run();
        #[derive(Default, SerializedBytes, Serialize, Deserialize, Debug)]
        #[repr(transparent)]
        #[serde(transparent)]
        struct Post(String);
        impl TryFrom<&Post> for Entry {
            type Error = EntryError;
            fn try_from(post: &Post) -> Result<Self, Self::Error> {
                Entry::app(post.try_into()?)
            }
        }

        // This is normal trip that works as expected
        let entry: Entry = (&Post("foo".into())).try_into().unwrap();
        let entry_hash = EntryHash::with_data_sync(&entry);
        assert_eq!(
            "uhCEkPjYXxw4ztKx3wBsxzm-q3Rfoy1bXWbIQohifqC3_HNle3-SO",
            &entry_hash.to_string()
        );
        let sb: SerializedBytes = entry_hash.try_into().unwrap();
        let entry_hash: EntryHash = sb.try_into().unwrap();
        assert_eq!(
            "uhCEkPjYXxw4ztKx3wBsxzm-q3Rfoy1bXWbIQohifqC3_HNle3-SO",
            &entry_hash.to_string()
        );

        // Now I can convert to AnyDhtHash
        let any_hash: AnyDhtHash = entry_hash.clone().into();
        assert_eq!(
            "uhCEkPjYXxw4ztKx3wBsxzm-q3Rfoy1bXWbIQohifqC3_HNle3-SO",
            &entry_hash.to_string()
        );

        // The trip works as expected
        let sb: SerializedBytes = any_hash.try_into().unwrap();
        tracing::debug!(any_sb = ?sb);
        let any_hash: AnyDhtHash = sb.try_into().unwrap();
        assert_eq!(
            "uhCEkPjYXxw4ztKx3wBsxzm-q3Rfoy1bXWbIQohifqC3_HNle3-SO",
            &any_hash.to_string()
        );

        // Converting directly works
        let any_hash: AnyDhtHash = entry_hash.clone().into();
        assert_eq!(
            "uhCEkPjYXxw4ztKx3wBsxzm-q3Rfoy1bXWbIQohifqC3_HNle3-SO",
            &any_hash.to_string()
        );
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/create_clone_cell.rs
================================================
use std::sync::Arc;

use crate::core::ribosome::{
    check_clone_access::check_clone_access, error::RibosomeError, CallContext, RibosomeT,
};
use holochain_types::{
    access::{HostFnAccess, Permission},
    app::CreateCloneCellPayload,
};
use holochain_util::tokio_helper;
use holochain_wasmer_host::prelude::*;
use holochain_zome_types::clone::{ClonedCell, CreateCloneCellInput};
use wasmer::RuntimeError;

#[cfg_attr(feature = "instrument", tracing::instrument(skip(_ribosome, call_context), fields(? call_context.zome, function = ? call_context.function_name)))]
pub fn create_clone_cell(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    input: CreateCloneCellInput,
) -> Result<ClonedCell, RuntimeError> {
    match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            write_workspace: Permission::Allow,
            ..
        } => {
            let host_context = call_context.host_context();

            let conductor_handle = host_context.call_zome_handle();
            let (installed_app_id, role_name) =
                check_clone_access(&input.cell_id, conductor_handle)?;

            tokio_helper::block_forever_on(async move {
                conductor_handle
                    .create_clone_cell(&installed_app_id, CreateCloneCellPayload {
                        role_name,
                        modifiers: input.modifiers,
                        membrane_proof: input.membrane_proof,
                        name: input.name,
                    })
                    .await
            })
            .map_err(|conductor_error| -> RuntimeError {
                wasm_error!(WasmErrorInner::Host(conductor_error.to_string())).into()
            })
        }
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "create_clone_cell".into(),
            )
            .to_string(),
        ))
        .into()),
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/create_link.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::HostFnAccess;
use crate::core::ribosome::RibosomeError;
use crate::core::ribosome::RibosomeT;
use holochain_wasmer_host::prelude::*;

use holochain_types::prelude::*;
use std::sync::Arc;
use wasmer::RuntimeError;

#[allow(clippy::extra_unused_lifetimes)]
pub fn create_link<'a>(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    input: CreateLinkInput,
) -> Result<ActionHash, RuntimeError> {
    match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            write_workspace: Permission::Allow,
            ..
        } => {
            let CreateLinkInput {
                base_address,
                target_address,
                zome_index,
                link_type,
                tag,
                chain_top_ordering,
            } = input;

            // Construct the link add
            let action_builder =
                builder::CreateLink::new(base_address, target_address, zome_index, link_type, tag);

            let action_hash = tokio_helper::block_forever_on(tokio::task::spawn(async move {
                // push the action into the source chain
                let action_hash = call_context
                    .host_context
                    .workspace_write()
                    .source_chain()
                    .as_ref()
                    .expect("Must have source chain if write_workspace access is given")
                    .put_weightless(action_builder, None, chain_top_ordering)
                    .await?;
                Ok::<ActionHash, RibosomeError>(action_hash)
            }))
            .map_err(|join_error| -> RuntimeError {
                wasm_error!(WasmErrorInner::Host(join_error.to_string())).into()
            })?
            .map_err(|ribosome_error| -> RuntimeError {
                wasm_error!(WasmErrorInner::Host(ribosome_error.to_string())).into()
            })?;

            // return the hash of the committed link
            // note that validation is handled by the workflow
            // if the validation fails this commit will be rolled back by virtue of the DB transaction
            // being atomic
            Ok(action_hash)
        }
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "create_link".into()
            )
            .to_string()
        ))
        .into()),
    }
}

// we rely on the tests for get_links and get_link_details



================================================
File: crates/holochain/src/core/ribosome/host_fn/create_x25519_keypair.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::HostFnAccess;
use crate::core::ribosome::RibosomeError;
use crate::core::ribosome::RibosomeT;
use holochain_types::prelude::*;
use holochain_util::tokio_helper;
use holochain_wasmer_host::prelude::*;
use std::sync::Arc;
use wasmer::RuntimeError;

pub fn create_x25519_keypair(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    _input: (),
) -> Result<X25519PubKey, RuntimeError> {
    match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            keystore: Permission::Allow,
            ..
        } => tokio_helper::block_forever_on(async move {
            call_context
                .host_context
                .keystore()
                .new_x25519_keypair_random()
                .await
                .map(|k| (*k).into())
        })
        .map_err(|keystore_error| {
            wasm_error!(WasmErrorInner::Host(keystore_error.to_string())).into()
        }),
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "create_x25519_keypair".into()
            )
            .to_string()
        ))
        .into()),
    }
}

// See x_25519_x_salsa20_poly1305_encrypt for testing encryption using created keypairs.



================================================
File: crates/holochain/src/core/ribosome/host_fn/delete.rs
================================================
use crate::core::ribosome::error::RibosomeError;
use crate::core::ribosome::CallContext;
use crate::core::ribosome::RibosomeT;
use holochain_cascade::error::CascadeError;
use holochain_cascade::CascadeImpl;
use holochain_wasmer_host::prelude::*;

use crate::core::ribosome::HostFnAccess;
use holo_hash::ActionHash;
use holo_hash::EntryHash;
use holochain_types::prelude::*;
use std::sync::Arc;
use wasmer::RuntimeError;

#[allow(clippy::extra_unused_lifetimes)]
pub fn delete<'a>(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    input: DeleteInput,
) -> Result<ActionHash, RuntimeError> {
    match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            write_workspace: Permission::Allow,
            ..
        } => {
            let DeleteInput {
                deletes_action_hash,
                chain_top_ordering,
            } = input;
            let (deletes_entry_address, _) =
                get_original_entry_data(call_context.clone(), deletes_action_hash.clone())?;

            let host_access = call_context.host_context();

            // handle timeouts at the source chain layer
            tokio_helper::block_forever_on(async move {
                let source_chain = host_access
                    .workspace_write()
                    .source_chain()
                    .as_ref()
                    .expect("Must have source chain if write_workspace access is given");
                let action_builder = builder::Delete {
                    deletes_address: deletes_action_hash,
                    deletes_entry_address,
                };
                let action_hash = source_chain
                    .put_weightless(action_builder, None, chain_top_ordering)
                    .await
                    .map_err(|source_chain_error| {
                        wasm_error!(WasmErrorInner::Host(source_chain_error.to_string()))
                    })?;
                Ok(action_hash)
            })
        }
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "delete".into(),
            )
            .to_string(),
        ))
        .into()),
    }
}

pub(crate) fn get_original_entry_data(
    call_context: Arc<CallContext>,
    address: ActionHash,
) -> Result<(EntryHash, EntryType), WasmHostError> {
    let network = call_context.host_context.network().clone();
    let workspace = call_context.host_context.workspace();

    tokio_helper::block_forever_on(async move {
        let cascade = CascadeImpl::from_workspace_and_network(&workspace, network);
        let maybe_original_record: Option<SignedActionHashed> = cascade
            .get_details(address.clone().into(), GetOptions::local())
            .await?
            .map(|el| {
                match el {
                    holochain_zome_types::metadata::Details::Record(e) => {
                        Ok(e.record.into_inner().0)
                    }
                    // Should not be trying to get original actions via EntryHash
                    holochain_zome_types::metadata::Details::Entry(_) => {
                        Err(CascadeError::InvalidResponse(address.clone().into()))
                    }
                }
            })
            .transpose()?;

        match maybe_original_record {
            Some(SignedActionHashed {
                hashed: ActionHashed {
                    content: action, ..
                },
                ..
            }) => match action.into_entry_data() {
                Some((entry_hash, entry_type)) => Ok((entry_hash, entry_type)),
                _ => Err(RibosomeError::RecordDeps(address.into())),
            },
            None => Err(RibosomeError::RecordDeps(address.into())),
        }
    })
    .map_err(|ribosome_error| wasm_error!(WasmErrorInner::Host(ribosome_error.to_string())))
}

#[cfg(test)]
#[cfg(feature = "slow_tests")]
pub mod wasm_test {
    use crate::core::ribosome::wasm_test::RibosomeTestFixture;
    use hdk::prelude::*;
    use holochain_wasm_test_utils::TestWasm;

    #[tokio::test(flavor = "multi_thread")]
    async fn ribosome_delete_entry_test() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor, alice, ..
        } = RibosomeTestFixture::new(TestWasm::Crd).await;

        let thing_a: ActionHash = conductor.call(&alice, "create", ()).await;
        let get_thing: Option<Record> = conductor.call(&alice, "reed", thing_a.clone()).await;
        match get_thing {
            Some(record) => assert!(record.entry().as_option().is_some()),

            None => unreachable!(),
        }

        let _: ActionHash = conductor
            .call(&alice, "delete_via_hash", thing_a.clone())
            .await;

        let get_thing: Option<Record> = conductor.call(&alice, "reed", thing_a).await;
        match get_thing {
            None => {
                // this is what we want, deletion => None for a get
            }
            _ => unreachable!(),
        }
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/delete_clone_cell.rs
================================================
use std::sync::Arc;

use crate::core::ribosome::{
    check_clone_access::check_clone_access, error::RibosomeError, CallContext, RibosomeT,
};
use holochain_types::{
    access::{HostFnAccess, Permission},
    app::DeleteCloneCellPayload,
};
use holochain_util::tokio_helper;
use holochain_wasmer_host::prelude::*;
use holochain_zome_types::clone::DeleteCloneCellInput;
use wasmer::RuntimeError;

#[cfg_attr(feature = "instrument", tracing::instrument(skip(_ribosome, call_context), fields(? call_context.zome, function = ? call_context.function_name)))]
pub fn delete_clone_cell(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    input: DeleteCloneCellInput,
) -> Result<(), RuntimeError> {
    match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            write_workspace: Permission::Allow,
            ..
        } => {
            let host_context = call_context.host_context();

            let conductor_handle = host_context.call_zome_handle();
            let (installed_app_id, _) =
                check_clone_access(conductor_handle.cell_id(), conductor_handle)?;

            tokio_helper::block_forever_on(async move {
                conductor_handle
                    .delete_clone_cell(DeleteCloneCellPayload {
                        app_id: installed_app_id,
                        clone_cell_id: input.clone_cell_id,
                    })
                    .await
            })
            .map_err(|conductor_error| -> RuntimeError {
                wasm_error!(WasmErrorInner::Host(conductor_error.to_string())).into()
            })
        }
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "delete_clone_cell".into(),
            )
            .to_string(),
        ))
        .into()),
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/delete_link.rs
================================================
use crate::core::ribosome::error::RibosomeError;
use crate::core::ribosome::CallContext;
use crate::core::ribosome::HostFnAccess;
use crate::core::ribosome::RibosomeT;
use holochain_cascade::error::CascadeResult;
use holochain_cascade::CascadeImpl;
use holochain_types::prelude::*;
use holochain_wasmer_host::prelude::*;
use std::sync::Arc;
use wasmer::RuntimeError;

#[allow(clippy::extra_unused_lifetimes)]
pub fn delete_link<'a>(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    input: DeleteLinkInput,
) -> Result<ActionHash, RuntimeError> {
    match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            write_workspace: Permission::Allow,
            ..
        } => {
            let DeleteLinkInput {
                address,
                chain_top_ordering,
            } = input;
            // get the base address from the add link action
            // don't allow the wasm developer to get this wrong
            // it is never valid to have divergent base address for add/remove links
            // the subconscious will validate the base address match but we need to fetch it here to
            // include it in the remove link action
            let network = call_context.host_context.network().clone();
            let call_context_2 = call_context.clone();

            // handle timeouts at the network layer
            let address_2 = address.clone();
            let maybe_add_link: Option<SignedActionHashed> =
                tokio_helper::block_forever_on(async move {
                    let workspace = call_context_2.host_context.workspace();
                    CascadeResult::Ok(
                        CascadeImpl::from_workspace_and_network(&workspace, network)
                            .dht_get(address_2.into(), GetOptions::local())
                            .await?
                            .map(|el| el.into_inner().0),
                    )
                })
                .map_err(|cascade_error| -> RuntimeError {
                    wasm_error!(WasmErrorInner::Host(cascade_error.to_string())).into()
                })?;

            let base_address = match maybe_add_link {
                Some(add_link_signed_action_hash) => {
                    match add_link_signed_action_hash.action() {
                        Action::CreateLink(link_add_action) => {
                            Ok(link_add_action.base_address.clone())
                        }
                        // the add link action hash provided was found but didn't point to an AddLink
                        // action (it is something else) so we cannot proceed
                        _ => Err(RibosomeError::RecordDeps(address.clone().into())),
                    }
                }
                // the add link action hash could not be found
                // it's unlikely that a wasm call would have a valid add link action hash from "somewhere"
                // that isn't also discoverable in either the cache or DHT, but it _is_ possible so we have
                // to fail in that case (e.g. the local cache could have GC'd at the same moment the
                // network connection dropped out)
                None => Err(RibosomeError::RecordDeps(address.clone().into())),
            }
            .map_err(|ribosome_error| -> RuntimeError {
                wasm_error!(WasmErrorInner::Host(ribosome_error.to_string())).into()
            })?;

            let source_chain = call_context
                .host_context
                .workspace_write()
                .source_chain()
                .as_ref()
                .expect("Must have source chain if write_workspace access is given");

            // handle timeouts at the source chain layer

            // add a DeleteLink to the source chain
            tokio_helper::block_forever_on(async move {
                let action_builder = builder::DeleteLink {
                    link_add_address: address,
                    base_address,
                };
                let action_hash = source_chain
                    .put(action_builder, None, chain_top_ordering)
                    .await
                    .map_err(|source_chain_error| -> RuntimeError {
                        wasm_error!(WasmErrorInner::Host(source_chain_error.to_string())).into()
                    })?;
                Ok(action_hash)
            })
        }
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "delete_link".into(),
            )
            .to_string(),
        ))
        .into()),
    }
}

#[cfg(test)]
#[cfg(feature = "slow_tests")]
pub mod slow_tests {
    use crate::core::ribosome::wasm_test::RibosomeTestFixture;
    use hdk::prelude::*;
    use holo_hash::ActionHash;
    use holochain_wasm_test_utils::TestWasm;

    #[tokio::test(flavor = "multi_thread")]
    async fn ribosome_delete_link_add_remove() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor, alice, ..
        } = RibosomeTestFixture::new(TestWasm::Link).await;

        // links should start empty
        let links: Vec<Vec<Link>> = conductor.call(&alice, "get_links", ()).await;

        assert!(links.is_empty());

        // add a couple of links
        let mut link_actions: Vec<ActionHash> = Vec::new();
        for _ in 0..2 {
            link_actions.push(conductor.call(&alice, "create_link", ()).await)
        }

        let links: Vec<Link> = conductor.call(&alice, "get_links", ()).await;

        assert!(links.len() == 2);

        // remove a link
        let _: ActionHash = conductor
            .call(&alice, "delete_link", link_actions[0].clone())
            .await;

        let links: Vec<Link> = conductor.call(&alice, "get_links", ()).await;

        assert!(links.len() == 1);

        // remove a link
        let _: ActionHash = conductor
            .call(&alice, "delete_link", link_actions[1].clone())
            .await;

        let links: Vec<Link> = conductor.call(&alice, "get_links", ()).await;

        assert!(links.is_empty());

        // Add some links then delete them all
        let _h: ActionHash = conductor.call(&alice, "create_link", ()).await;
        let _h: ActionHash = conductor.call(&alice, "create_link", ()).await;

        let links: Vec<Link> = conductor.call(&alice, "get_links", ()).await;

        assert!(links.len() == 2);

        let _: () = conductor.call(&alice, "delete_all_links", ()).await;

        // Should be no links left
        let links: Vec<Link> = conductor.call(&alice, "get_links", ()).await;

        assert!(links.is_empty());
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/disable_clone_cell.rs
================================================
use std::sync::Arc;

use crate::core::ribosome::{
    check_clone_access::check_clone_access, error::RibosomeError, CallContext, RibosomeT,
};
use holochain_types::{
    access::{HostFnAccess, Permission},
    app::DisableCloneCellPayload,
};
use holochain_util::tokio_helper;
use holochain_wasmer_host::prelude::*;
use holochain_zome_types::clone::DisableCloneCellInput;
use wasmer::RuntimeError;

#[cfg_attr(feature = "instrument", tracing::instrument(skip(_ribosome, call_context), fields(? call_context.zome, function = ? call_context.function_name)))]
pub fn disable_clone_cell(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    input: DisableCloneCellInput,
) -> Result<(), RuntimeError> {
    match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            write_workspace: Permission::Allow,
            ..
        } => {
            let host_context = call_context.host_context();

            tracing::info!("Starting disable clone cell");

            let conductor_handle = host_context.call_zome_handle();
            let (installed_app_id, _) =
                check_clone_access(conductor_handle.cell_id(), conductor_handle)?;

            tokio_helper::block_forever_on(async move {
                conductor_handle
                    .disable_clone_cell(
                        &installed_app_id,
                        DisableCloneCellPayload {
                            clone_cell_id: input.clone_cell_id,
                        },
                    )
                    .await
            })
            .map_err(|conductor_error| -> RuntimeError {
                wasm_error!(WasmErrorInner::Host(conductor_error.to_string())).into()
            })
        }
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "disable_clone_cell".into(),
            )
            .to_string(),
        ))
        .into()),
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/dna_info_1.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::HostFnAccess;
use crate::core::ribosome::RibosomeError;
use crate::core::ribosome::RibosomeT;
use holo_hash::HasHash;
use holochain_types::prelude::*;
use holochain_wasmer_host::prelude::*;
use holochain_zome_types::info::DnaInfoV1;
use std::sync::Arc;
use wasmer::RuntimeError;

pub fn dna_info_1(
    ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    _input: (),
) -> Result<DnaInfoV1, RuntimeError> {
    match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            bindings_deterministic: Permission::Allow,
            ..
        } => Ok(DnaInfoV1 {
            name: ribosome.dna_def().name.clone(),
            hash: ribosome.dna_def().as_hash().clone(),
            properties: ribosome.dna_def().modifiers.properties.clone(),
            zome_names: ribosome
                .dna_def()
                .integrity_zomes
                .iter()
                .map(|(zome_name, _zome_def)| zome_name.to_owned())
                .collect(),
        }),
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "dna_info".into(),
            )
            .to_string(),
        ))
        .into()),
    }
}

#[cfg(test)]
#[cfg(feature = "slow_tests")]
pub mod test {
    use crate::sweettest::SweetConductor;
    use crate::sweettest::SweetDnaFile;
    use crate::sweettest::SweetZome;
    use holochain_wasm_test_utils::TestWasm;
    use holochain_zome_types::prelude::*;

    async fn test_conductor(properties: SerializedBytes) -> (SweetConductor, SweetZome) {
        let (dna_file, _, _) = SweetDnaFile::from_test_wasms(
            random_network_seed(),
            vec![TestWasm::ZomeInfo],
            properties,
        )
        .await;

        let mut conductor = SweetConductor::from_standard_config().await;
        let apps = conductor.setup_apps("app-", 2, &[dna_file]).await.unwrap();

        let ((alice,), (bobbo,)) = apps.into_tuples();
        let alice = alice.zome(TestWasm::ZomeInfo);
        let _bobbo = bobbo.zome(TestWasm::ZomeInfo);
        (conductor, alice)
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn dna_info_test_1() {
        holochain_trace::test_run();

        let (conductor, alice) = test_conductor(SerializedBytes::default()).await;

        let dna_info: DnaInfoV1 = conductor.call(&alice, "dna_info_1", ()).await;
        assert_eq!(dna_info.name, String::from("Generated DnaDef"));

        let (conductor, alice) = test_conductor(SerializedBytes::default()).await;

        let dna_info: DnaInfoV1 = conductor.call(&alice, "dna_info_1", ()).await;
        assert_eq!(dna_info.name, String::from("Generated DnaDef"));
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/dna_info_2.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::HostFnAccess;
use crate::core::ribosome::RibosomeError;
use crate::core::ribosome::RibosomeT;
use holo_hash::HasHash;
use holochain_types::prelude::*;
use holochain_wasmer_host::prelude::*;
use holochain_zome_types::info::DnaInfoV2;
use std::sync::Arc;
use wasmer::RuntimeError;

pub fn dna_info_2(
    ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    _input: (),
) -> Result<DnaInfoV2, RuntimeError> {
    match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            bindings_deterministic: Permission::Allow,
            ..
        } => Ok(DnaInfoV2 {
            name: ribosome.dna_def().name.clone(),
            hash: ribosome.dna_def().as_hash().clone(),
            modifiers: ribosome.dna_def().modifiers.clone(),
            zome_names: ribosome
                .dna_def()
                .integrity_zomes
                .iter()
                .map(|(zome_name, _zome_def)| zome_name.to_owned())
                .collect(),
        }),
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "dna_info".into(),
            )
            .to_string(),
        ))
        .into()),
    }
}

#[cfg(test)]
#[cfg(feature = "slow_tests")]
pub mod test {
    use crate::sweettest::SweetConductor;
    use crate::sweettest::SweetDnaFile;
    use crate::sweettest::SweetZome;
    use holochain_wasm_test_utils::TestWasm;
    use holochain_zome_types::prelude::*;

    async fn test_conductor(properties: SerializedBytes) -> (SweetConductor, SweetZome) {
        let (dna_file, _, _) = SweetDnaFile::from_test_wasms(
            random_network_seed(),
            vec![TestWasm::ZomeInfo],
            properties,
        )
        .await;

        let mut conductor = SweetConductor::from_standard_config().await;
        let apps = conductor.setup_apps("app-", 2, &[dna_file]).await.unwrap();

        let ((alice,), (bobbo,)) = apps.into_tuples();
        let alice = alice.zome(TestWasm::ZomeInfo);
        let _bobbo = bobbo.zome(TestWasm::ZomeInfo);
        (conductor, alice)
    }

    #[tokio::test(flavor = "multi_thread")]
    #[cfg_attr(target_os = "macos", ignore = "flaky on macos")]
    async fn dna_info_test_2() {
        holochain_trace::test_run();
        // let RibosomeTestFixture {
        //     conductor, alice, ..
        // } = RibosomeTestFixture::new(TestWasm::ZomeInfo).await;

        let (conductor, alice) = test_conductor(SerializedBytes::default()).await;

        let dna_info: DnaInfo = conductor.call(&alice, "dna_info", ()).await;
        assert_eq!(dna_info.name, String::from("Generated DnaDef"));

        let (conductor, alice) = test_conductor(SerializedBytes::default()).await;

        let dna_info: DnaInfo = conductor.call(&alice, "dna_info", ()).await;
        assert_eq!(dna_info.name, String::from("Generated DnaDef"));

        let dna_info_foo: Option<String> = conductor.call(&alice, "dna_info_value", "foo").await;
        assert_eq!(dna_info_foo, None);
        let dna_info_foo_direct: Option<String> =
            conductor.call(&alice, "dna_info_foo_direct", ()).await;
        assert_eq!(dna_info_foo_direct, None);

        let dna_info_bar: Option<String> = conductor.call(&alice, "dna_info_value", "bar").await;
        assert_eq!(dna_info_bar, None);
        let dna_info_bar_direct: Option<String> =
            conductor.call(&alice, "dna_info_bar_direct", ()).await;
        assert_eq!(dna_info_bar_direct, None);

        let yaml = "foo: bar";
        let (conductor, alice) = test_conductor(
            YamlProperties::new(serde_yaml::from_str(yaml).unwrap())
                .try_into()
                .unwrap(),
        )
        .await;
        let dna_info_foo: Option<String> = conductor.call(&alice, "dna_info_value", "foo").await;
        assert_eq!(dna_info_foo, Some("bar".into()));
        let dna_info_foo_direct: Option<String> =
            conductor.call(&alice, "dna_info_foo_direct", ()).await;
        assert_eq!(dna_info_foo_direct, Some("bar".into()));

        let dna_info_bar: Option<String> = conductor.call(&alice, "dna_info_value", "bar").await;
        assert_eq!(dna_info_bar, None);
        let dna_info_bar_direct: Option<String> =
            conductor.call(&alice, "dna_info_bar_direct", ()).await;
        assert_eq!(dna_info_bar_direct, None);

        let yaml = "foo: 1\nbar: bing";
        let (conductor, alice) = test_conductor(
            YamlProperties::new(serde_yaml::from_str(yaml).unwrap())
                .try_into()
                .unwrap(),
        )
        .await;
        let dna_info_foo: Option<u64> = conductor.call(&alice, "dna_info_value", "foo").await;
        assert_eq!(dna_info_foo, Some(1));
        let dna_info_foo_direct: Option<u64> =
            conductor.call(&alice, "dna_info_foo_direct", ()).await;
        assert_eq!(dna_info_foo_direct, Some(1));

        let dna_info_bar: Option<String> = conductor.call(&alice, "dna_info_value", "bar").await;
        assert_eq!(dna_info_bar, Some("bing".into()));
        let dna_info_bar_direct: Option<String> =
            conductor.call(&alice, "dna_info_bar_direct", ()).await;
        assert_eq!(dna_info_bar_direct, Some("bing".into()));

        let yaml = "baz: \n  foo: \n   bar: 1";
        let (conductor, alice) = test_conductor(
            YamlProperties::new(serde_yaml::from_str(yaml).unwrap())
                .try_into()
                .unwrap(),
        )
        .await;
        let nested: Option<i64> = conductor.call(&alice, "dna_info_nested", ()).await;
        assert_eq!(nested, Some(1));
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/ed_25519_x_salsa20_poly1305_decrypt.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::HostFnAccess;
use crate::core::ribosome::RibosomeError;
use crate::core::ribosome::RibosomeT;
use holochain_types::prelude::*;
use holochain_wasmer_host::prelude::*;
use holochain_wasmer_host::wasm_host_error as wasm_error;
use std::sync::Arc;
use wasmer::RuntimeError;

pub fn ed_25519_x_salsa20_poly1305_decrypt(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    input: Ed25519XSalsa20Poly1305Decrypt,
) -> Result<XSalsa20Poly1305Data, RuntimeError> {
    match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            keystore_deterministic: Permission::Allow,
            ..
        } => {
            tokio_helper::block_forever_on(async move {
                let client = call_context
                    .host_context
                    .keystore()
                    .lair_client();

                let mut send = [0; 32];
                send.copy_from_slice(input.as_sender_ref().get_raw_32());
                let mut recv = [0; 32];
                recv.copy_from_slice(input.as_recipient_ref().get_raw_32());
                let mut nonce = [0; 24];
                nonce.copy_from_slice(input.as_encrypted_data_ref().as_nonce_ref().as_ref());

                let res = client.crypto_box_xsalsa_open_by_sign_pub_key(
                    send.into(),
                    recv.into(),
                    None,
                    nonce,
                    input.as_encrypted_data_ref().as_encrypted_data_ref().to_vec().into(),
                ).await?;

                holochain_keystore::LairResult::Ok(res.to_vec().into())
            })
            .map_err(|keystore_error| -> RuntimeError { wasm_error!(WasmErrorInner::Host(keystore_error.to_string())).into() })
        }
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "ed_25519_x_salsa20_poly1305_decrypt".into()
            )
            .to_string()
        ))
        .into()),
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/ed_25519_x_salsa20_poly1305_encrypt.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::HostFnAccess;
use crate::core::ribosome::RibosomeError;
use crate::core::ribosome::RibosomeT;
use holochain_types::prelude::*;
use holochain_wasmer_host::prelude::*;
use std::sync::Arc;
use wasmer::RuntimeError;

pub fn ed_25519_x_salsa20_poly1305_encrypt(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    input: Ed25519XSalsa20Poly1305Encrypt,
) -> Result<XSalsa20Poly1305EncryptedData, RuntimeError> {
    match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            keystore: Permission::Allow,
            ..
        } => {
            tokio_helper::block_forever_on(async move {
                let client = call_context
                    .host_context
                    .keystore()
                    .lair_client();

                let mut send = [0; 32];
                send.copy_from_slice(input.as_sender_ref().get_raw_32());
                let mut recv = [0; 32];
                recv.copy_from_slice(input.as_recipient_ref().get_raw_32());

                let (nonce, cipher) = client.crypto_box_xsalsa_by_sign_pub_key(
                    send.into(),
                    recv.into(),
                    None,
                    input.as_data_ref().as_ref().to_vec().into(),
                ).await?;

                holochain_keystore::LairResult::Ok(XSalsa20Poly1305EncryptedData::new(
                    nonce.into(),
                    cipher.to_vec(),
                ))
            })
            .map_err(|keystore_error| -> RuntimeError {
                wasm_error!(WasmErrorInner::Host(keystore_error.to_string())).into()
            })
        }
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "ed_25519_x_salsa20_poly1305_encrypt".into(),
            )
            .to_string(),
        ))
        .into()),
    }
}

#[cfg(test)]
#[cfg(feature = "slow_tests")]
pub mod wasm_test {

    use crate::core::ribosome::wasm_test::RibosomeTestFixture;
    use hdk::prelude::*;
    use holochain_wasm_test_utils::TestWasm;

    #[tokio::test(flavor = "multi_thread")]
    async fn invoke_import_ed_25519_x_salsa20_poly1305_encrypt_decrypt_test() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor, alice, alice_pubkey, bob_pubkey, ..
        } = RibosomeTestFixture::new(TestWasm::XSalsa20Poly1305).await;

        let data = XSalsa20Poly1305Data::from(vec![1, 2, 3, 4]);

        let encrypt_input = Ed25519XSalsa20Poly1305Encrypt::new(
            alice_pubkey.clone(),
            bob_pubkey.clone(),
            data.clone(),
        );

        let encrypt_output: XSalsa20Poly1305EncryptedData = conductor
            .call(&alice, "ed_25519_x_salsa20_poly1305_encrypt", encrypt_input)
            .await;

        let decrypt_input =
            holochain_zome_types::x_salsa20_poly1305::Ed25519XSalsa20Poly1305Decrypt::new(
                bob_pubkey.clone(),
                alice_pubkey.clone(),
                encrypt_output.clone(),
            );

        let decrypt_output: Option<XSalsa20Poly1305Data> = conductor
            .call(&alice, "ed_25519_x_salsa20_poly1305_decrypt", decrypt_input)
            .await;

        assert_eq!(decrypt_output, Some(data.clone()),);
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/emit_signal.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::HostFnAccess;
use crate::core::ribosome::RibosomeError;
use crate::core::ribosome::RibosomeT;
use holochain_types::prelude::*;
use holochain_types::signal::Signal;
use holochain_wasmer_host::prelude::*;
use std::sync::Arc;
use wasmer::RuntimeError;

pub fn emit_signal(
    ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    input: AppSignal,
) -> Result<(), RuntimeError> {
    match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            non_determinism: Permission::Allow,
            ..
        } => {
            let cell_id = CellId::new(
                ribosome.dna_def().as_hash().clone(),
                call_context
                    .host_context
                    .workspace()
                    .source_chain()
                    .as_ref()
                    .expect("Must have a source chain to emit signals")
                    .agent_pubkey()
                    .clone(),
            );
            let signal = Signal::App {
                cell_id,
                zome_name: call_context.zome.zome_name().clone(),
                signal: input,
            };
            call_context
                .host_context()
                .signal_tx()
                .send(signal)
                // Only possible error here is a `SendError` which is expected if no clients are
                // connected and listening.
                .ok();
            Ok(())
        }
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "emit_signal".into()
            )
            .to_string()
        ))
        .into()),
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/enable_clone_cell.rs
================================================
use std::sync::Arc;

use crate::core::ribosome::{
    check_clone_access::check_clone_access, error::RibosomeError, CallContext, RibosomeT,
};
use holochain_types::{
    access::{HostFnAccess, Permission},
    app::EnableCloneCellPayload,
};
use holochain_util::tokio_helper;
use holochain_wasmer_host::prelude::*;
use holochain_zome_types::clone::{ClonedCell, EnableCloneCellInput};
use wasmer::RuntimeError;

#[cfg_attr(feature = "instrument", tracing::instrument(skip(_ribosome, call_context), fields(? call_context.zome, function = ? call_context.function_name)))]
pub fn enable_clone_cell(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    input: EnableCloneCellInput,
) -> Result<ClonedCell, RuntimeError> {
    match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            write_workspace: Permission::Allow,
            ..
        } => {
            let host_context = call_context.host_context();

            let conductor_handle = host_context.call_zome_handle();
            let (installed_app_id, _) =
                check_clone_access(conductor_handle.cell_id(), conductor_handle)?;

            tokio_helper::block_forever_on(async move {
                conductor_handle
                    .enable_clone_cell(
                        &installed_app_id,
                        EnableCloneCellPayload {
                            clone_cell_id: input.clone_cell_id,
                        },
                    )
                    .await
            })
            .map_err(|conductor_error| -> RuntimeError {
                wasm_error!(WasmErrorInner::Host(conductor_error.to_string())).into()
            })
        }
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "enable_clone_cell".into(),
            )
            .to_string(),
        ))
        .into()),
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/get.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::HostFnAccess;
use crate::core::ribosome::RibosomeError;
use crate::core::ribosome::RibosomeT;
use futures::StreamExt;
use holochain_cascade::CascadeImpl;
use holochain_types::prelude::*;
use holochain_wasmer_host::prelude::*;
use std::sync::Arc;
use wasmer::RuntimeError;

#[cfg_attr(feature = "instrument", tracing::instrument(skip(_ribosome, call_context), fields(?call_context.zome, function = ?call_context.function_name)))]
pub fn get(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    inputs: Vec<GetInput>,
) -> Result<Vec<Option<Record>>, RuntimeError> {
    let num_requests = inputs.len();
    tracing::debug!("Starting with {} requests.", num_requests);
    match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            read_workspace: Permission::Allow,
            ..
        } => {
            let results: Vec<Result<Option<Record>, _>> =
                tokio_helper::block_forever_on(async move {
                    futures::stream::iter(inputs.into_iter().map(|input| async {
                        let GetInput {
                            any_dht_hash,
                            get_options,
                        } = input;
                        CascadeImpl::from_workspace_and_network(
                            &call_context.host_context.workspace(),
                            call_context.host_context.network().clone(),
                        )
                        .dht_get(any_dht_hash, get_options)
                        .await
                    }))
                    // Limit concurrent calls to 10 as each call
                    // can spawn multiple connections.
                    .buffered(10)
                    .collect()
                    .await
                });
            let results: Result<Vec<_>, RuntimeError> = results
                .into_iter()
                .map(|result| match result {
                    Ok(v) => Ok(v),
                    Err(cascade_error) => {
                        Err(wasm_error!(WasmErrorInner::Host(cascade_error.to_string())).into())
                    }
                })
                .collect();
            let results = results?;
            tracing::debug!(
                "Ending with {} out of {} results and {} total responses.",
                results.iter().filter(|r| r.is_some()).count(),
                num_requests,
                results.len(),
            );
            Ok(results)
        }
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "get".into(),
            )
            .to_string(),
        ))
        .into()),
    }
}

// we are relying on the create tests to show the commit/get round trip
// See create.rs

#[cfg(test)]
#[cfg(feature = "slow_tests")]
pub mod slow_tests {
    use crate::sweettest::{SweetConductorBatch, SweetConductorConfig, SweetDnaFile};
    use holo_hash::ActionHash;
    use holochain_wasm_test_utils::TestWasm;
    use holochain_zome_types::record::Record;

    #[tokio::test(flavor = "multi_thread")]
    async fn get_action_entry_local_only() {
        holochain_trace::test_run();
        // agents should not pass around data
        let config = SweetConductorConfig::rendezvous(false)
            .tune(|config| {
                config.disable_historical_gossip = true;
                config.disable_recent_gossip = true;
                config.disable_publish = true;
            })
            .no_dpki();
        let mut conductors = SweetConductorBatch::from_config_rendezvous(2, config).await;
        let (dna_file, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::Create]).await;
        let apps = conductors.setup_app("test", &[dna_file]).await.unwrap();

        // alice creates an entry
        let zome_alice = apps[0].cells()[0].zome(TestWasm::Create.coordinator_zome_name());
        let entry_action_hash: ActionHash =
            conductors[0].call(&zome_alice, "create_entry", ()).await;
        let local_record_by_action_hash: Option<Record> = conductors[0]
            .call(&zome_alice, "get_post", entry_action_hash.clone())
            .await;
        // alice can get the record
        assert!(local_record_by_action_hash.is_some());

        // now make both agents aware of each other
        conductors.exchange_peer_info().await;

        // bob gets record by action hash from local databases
        let zome_bob = apps[1].cells()[0].zome(TestWasm::Create.coordinator_zome_name());
        let local_record_by_action_hash: Option<Record> = conductors[1]
            .call(&zome_bob, "get_post", entry_action_hash)
            .await;
        // record should be none
        assert!(local_record_by_action_hash.is_none());

        // bob gets record by entry hash from local databases
        let zome_bob = apps[1].cells()[0].zome(TestWasm::Create.coordinator_zome_name());
        let local_record_by_entry_hash: Option<Record> =
            conductors[1].call(&zome_bob, "get_entry", ()).await;
        // record should be none
        assert!(local_record_by_entry_hash.is_none());
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/get_agent_activity.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::HostFnAccess;
use crate::core::ribosome::RibosomeError;
use crate::core::ribosome::RibosomeT;
use holochain_cascade::CascadeImpl;
use holochain_p2p::actor::GetActivityOptions;
use holochain_types::prelude::*;
use holochain_wasmer_host::prelude::*;
use std::sync::Arc;
use wasmer::RuntimeError;

pub fn get_agent_activity(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    input: GetAgentActivityInput,
) -> Result<AgentActivity, RuntimeError> {
    match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            read_workspace: Permission::Allow,
            ..
        } => {
            let GetAgentActivityInput {
                agent_pubkey,
                chain_query_filter,
                activity_request,
            } = input;
            let options = match activity_request {
                ActivityRequest::Status => GetActivityOptions {
                    include_valid_activity: false,
                    include_rejected_activity: false,
                    get_options: GetOptions::local(),
                    ..Default::default()
                },
                ActivityRequest::Full => GetActivityOptions {
                    include_valid_activity: true,
                    include_rejected_activity: true,
                    get_options: GetOptions::local(),
                    ..Default::default()
                },
            };

            // Get the network from the context
            let network = call_context.host_context.network().clone();

            // timeouts must be handled by the network
            tokio_helper::block_forever_on(async move {
                let workspace = call_context.host_context.workspace();
                let cascade = CascadeImpl::from_workspace_and_network(&workspace, network);
                let activity = cascade
                    .get_agent_activity(agent_pubkey, chain_query_filter, options)
                    .await
                    .map_err(|cascade_error| {
                        wasm_error!(WasmErrorInner::Host(cascade_error.to_string()))
                    })?;

                Ok(activity.into())
            })
        }
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "get_agent_activity".into()
            )
            .to_string()
        ))
        .into()),
    }
}

// we are relying on the create tests to show the commit/get round trip
// See commit_entry.rs



================================================
File: crates/holochain/src/core/ribosome/host_fn/get_agent_key_lineage.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::RibosomeError;
use crate::core::ribosome::RibosomeT;
use holochain_types::prelude::*;
use holochain_wasmer_host::prelude::*;
use std::sync::Arc;
use wasmer::RuntimeError;

pub fn get_agent_key_lineage(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    input: AgentPubKey,
) -> Result<Vec<AgentPubKey>, RuntimeError> {
    match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            agent_info: Permission::Allow,
            ..
        } => match call_context.host_context.maybe_dpki() {
            // If DPKI is not installed, agents cannot update keys. The lineage is just the one agent key.
            None => Ok(vec![input]),
            Some(dpki) => tokio_helper::block_forever_on(async move {
                let state = dpki.state().await;
                state
                    .get_agent_key_lineage(input)
                    .await
                    .map_err(|error| RuntimeError::new(error.to_string()))
            }),
        },
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "get_agent_key_lineage".into()
            )
            .to_string()
        ))
        .into()),
    }
}

#[cfg(test)]
#[cfg(all(feature = "slow_tests", feature = "unstable-functions"))]
pub mod test {
    use crate::core::ribosome::wasm_test::RibosomeTestFixture;
    use hdk::prelude::*;
    use holochain_wasm_test_utils::TestWasm;

    #[tokio::test(flavor = "multi_thread")]
    async fn host_fn_get_agent_key_lineage() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor,
            alice,
            alice_pubkey,
            ..
        } = RibosomeTestFixture::new(TestWasm::AgentKeyLineage).await;

        let agent_key_lineage: Vec<AgentPubKey> = conductor
            .call(&alice, "get_lineage_of_agent_keys", alice_pubkey.clone())
            .await;
        assert_eq!(agent_key_lineage, vec![alice_pubkey]);

        // TODO: When adding a function to update an agent key to DPKI service, append to this test
        // a key update and make sure it's included in the key lineage in the correct order.
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/get_details.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::HostFnAccess;
use crate::core::ribosome::RibosomeError;
use crate::core::ribosome::RibosomeT;
use futures::future::join_all;
use holochain_cascade::CascadeImpl;
use holochain_types::prelude::*;
use holochain_wasmer_host::prelude::*;
use std::sync::Arc;
use wasmer::RuntimeError;

pub fn get_details(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    inputs: Vec<GetInput>,
) -> Result<Vec<Option<Details>>, RuntimeError> {
    match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            read_workspace: Permission::Allow,
            ..
        } => {
            let results: Vec<Result<Option<Details>, _>> =
                tokio_helper::block_forever_on(async move {
                    join_all(inputs.into_iter().map(|input| async {
                        let GetInput {
                            any_dht_hash,
                            get_options,
                        } = input;
                        CascadeImpl::from_workspace_and_network(
                            &call_context.host_context.workspace(),
                            call_context.host_context.network().to_owned(),
                        )
                        .get_details(any_dht_hash, get_options)
                        .await
                    }))
                    .await
                });
            let results: Result<Vec<_>, _> = results
                .into_iter()
                .map(|result| {
                    result.map_err(|cascade_error| {
                        wasm_error!(WasmErrorInner::Host(cascade_error.to_string()))
                    })
                })
                .collect();
            Ok(results?)
        }
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "get_details".into(),
            )
            .to_string(),
        ))
        .into()),
    }
}

#[cfg(test)]
#[cfg(feature = "slow_tests")]
pub mod wasm_test {
    use crate::core::ribosome::wasm_test::RibosomeTestFixture;
    use hdk::prelude::*;
    use holochain_wasm_test_utils::TestWasm;

    #[tokio::test(flavor = "multi_thread")]
    async fn ribosome_get_details_test() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor, alice, ..
        } = RibosomeTestFixture::new(TestWasm::Crud).await;

        // simple replica of the internal type for the TestWasm::Crud entry
        #[derive(Clone, Copy, Serialize, Deserialize, SerializedBytes, Debug, PartialEq)]
        struct CounTree(u32);

        let check = |details: &Option<Details>, count, delete| match details {
            Some(Details::Record(ref record_details)) => {
                match record_details.record.entry().to_app_option::<CounTree>() {
                    Ok(Some(CounTree(u))) => assert_eq!(u, count),
                    _ => panic!("failed to deserialize {:?}, {}, {}", details, count, delete),
                }
                assert_eq!(record_details.deletes.len(), delete);
            }
            _ => panic!("no record"),
        };

        let check_entry = |details: &Option<Details>, count, update, delete, line| match details {
            Some(Details::Entry(ref entry_details)) => {
                match entry_details.entry {
                    Entry::App(ref eb) => {
                        let countree = CounTree::try_from(eb.clone().into_sb()).unwrap();
                        assert_eq!(countree, CounTree(count));
                    }
                    _ => panic!(
                        "failed to deserialize {:?}, {}, {}, {}",
                        details, count, update, delete
                    ),
                }
                assert_eq!(entry_details.updates.len(), update, "{}", line);
                assert_eq!(entry_details.deletes.len(), delete, "{}", line);
            }
            _ => panic!("no entry"),
        };

        let zero_hash: EntryHash = conductor.call(&alice, "entry_hash", CounTree(0)).await;
        let one_hash: EntryHash = conductor.call(&alice, "entry_hash", CounTree(1)).await;
        let two_hash: EntryHash = conductor.call(&alice, "entry_hash", CounTree(2)).await;

        let zero_a: ActionHash = conductor.call(&alice, "new", ()).await;
        let action_details_0: Vec<Option<Details>> = conductor
            .call(&alice, "action_details", vec![zero_a.clone()])
            .await;
        let entry_details_0: Vec<Option<Details>> = conductor
            .call(&alice, "entry_details", vec![zero_hash.clone()])
            .await;
        check(&action_details_0[0], 0, 0);
        check_entry(&entry_details_0[0], 0, 0, 0, line!());

        let one_a: ActionHash = conductor.call(&alice, "inc", zero_a.clone()).await;
        let action_details_1: Vec<Option<Details>> = conductor
            .call(
                &alice,
                "action_details",
                vec![zero_a.clone(), one_a.clone()],
            )
            .await;
        let entry_details_1: Vec<Option<Details>> = conductor
            .call(
                &alice,
                "entry_details",
                vec![zero_hash.clone(), one_hash.clone()],
            )
            .await;
        check(&action_details_1[0], 0, 0);
        check(&action_details_1[1], 1, 0);
        check_entry(&entry_details_1[0], 0, 1, 0, line!());
        check_entry(&entry_details_1[1], 1, 0, 0, line!());

        let one_b: ActionHash = conductor.call(&alice, "inc", zero_a.clone()).await;
        let action_details_2: Vec<Option<Details>> = conductor
            .call(
                &alice,
                "action_details",
                vec![zero_a.clone(), one_b.clone()],
            )
            .await;
        let entry_details_2: Vec<Option<Details>> = conductor
            .call(
                &alice,
                "entry_details",
                vec![zero_hash.clone(), one_hash.clone()],
            )
            .await;
        check(&action_details_2[0], 0, 0);
        check(&action_details_2[1], 1, 0);
        check_entry(&entry_details_2[0], 0, 2, 0, line!());
        check_entry(&entry_details_2[1], 1, 0, 0, line!());

        let two: ActionHash = conductor.call(&alice, "inc", one_b.clone()).await;
        let action_details_3: Vec<Option<Details>> = conductor
            .call(&alice, "action_details", vec![one_b.clone(), two])
            .await;
        let entry_details_3: Vec<Option<Details>> = conductor
            .call(
                &alice,
                "entry_details",
                vec![zero_hash.clone(), one_hash.clone(), two_hash.clone()],
            )
            .await;
        check(&action_details_3[0], 1, 0);
        check(&action_details_3[1], 2, 0);
        check_entry(&entry_details_3[0], 0, 2, 0, line!());
        check_entry(&entry_details_3[1], 1, 1, 0, line!());
        check_entry(&entry_details_3[2], 2, 0, 0, line!());

        let zero_b: ActionHash = conductor.call(&alice, "dec", one_a.clone()).await;
        let action_details_4: Vec<Option<Details>> = conductor
            .call(&alice, "action_details", vec![one_a, one_b, zero_b])
            .await;
        let entry_details_4: Vec<Option<Details>> = conductor
            .call(&alice, "entry_details", vec![zero_hash, one_hash, two_hash])
            .await;
        check(&action_details_4[0], 1, 1);
        check(&action_details_4[1], 1, 0);
        check_entry(&entry_details_4[0], 0, 2, 0, line!());
        check_entry(&entry_details_4[1], 1, 1, 1, line!());
        check_entry(&entry_details_4[2], 2, 0, 0, line!());

        match action_details_4[2] {
            Some(Details::Record(ref record_details)) => {
                match record_details.record.entry().as_option() {
                    None => {
                        // this is the delete so it should be none
                    }
                    _ => panic!("delete had a record"),
                }
            }
            _ => panic!("no record"),
        }
    }
}

#[cfg(test)]
#[cfg(feature = "slow_tests")]
pub mod slow_tests {
    use crate::sweettest::*;
    use holo_hash::ActionHash;
    use holochain_wasm_test_utils::TestWasm;
    use holochain_zome_types::metadata::Details;

    #[tokio::test(flavor = "multi_thread")]
    async fn get_action_entry_local_only() {
        holochain_trace::test_run();
        // agents should not pass around data
        let config = SweetConductorConfig::rendezvous(false)
            .tune(|config| {
                config.disable_historical_gossip = true;
                config.disable_recent_gossip = true;
                config.disable_publish = true;
            })
            .no_dpki();
        let mut conductors = SweetConductorBatch::from_config_rendezvous(2, config).await;
        let (dna_file, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::Crud]).await;
        let apps = conductors.setup_app("test", &[dna_file]).await.unwrap();

        // alice creates an entry
        let zome_alice = apps[0].cells()[0].zome(TestWasm::Crud.coordinator_zome_name());
        let entry_action_hash: ActionHash = conductors[0].call(&zome_alice, "new", ()).await;
        let local_entries_with_details: Vec<Option<Details>> = conductors[0]
            .call(
                &zome_alice,
                "action_details",
                vec![entry_action_hash.clone()],
            )
            .await;
        // alice can get details of the entry
        assert_eq!(local_entries_with_details.len(), 1);
        assert!(local_entries_with_details[0].is_some());

        // now make both agents aware of each other
        conductors.exchange_peer_info().await;

        // bob gets details by action hash from local databases
        let zome_bob = apps[1].cells()[0].zome(TestWasm::Crud.coordinator_zome_name());
        let local_entries_with_details: Vec<Option<Details>> = conductors[1]
            .call(&zome_bob, "action_details", vec![entry_action_hash])
            .await;
        // entry should be none
        assert_eq!(local_entries_with_details.len(), 1);
        assert!(local_entries_with_details[0].is_none());

        // bob gets details by entry hash from local databases
        let zome_bob = apps[1].cells()[0].zome(TestWasm::Crud.coordinator_zome_name());
        let local_entries_with_details: Vec<Option<Details>> = conductors[1]
            .call(&zome_bob, "entry_details_local_only", ())
            .await;
        // entry should be none
        assert_eq!(local_entries_with_details.len(), 1);
        assert!(local_entries_with_details[0].is_none());
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/get_link_details.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::HostFnAccess;
use crate::core::ribosome::RibosomeError;
use crate::core::ribosome::RibosomeT;
use futures::future::join_all;
use holochain_cascade::CascadeImpl;
use holochain_p2p::actor::GetLinksOptions;
use holochain_types::prelude::*;
use holochain_wasmer_host::prelude::*;
use std::sync::Arc;
use wasmer::RuntimeError;

pub fn get_link_details(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    inputs: Vec<GetLinksInput>,
) -> Result<Vec<LinkDetails>, RuntimeError> {
    match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            read_workspace: Permission::Allow,
            ..
        } => {
            let results: Vec<Result<Vec<_>, RibosomeError>> =
                tokio_helper::block_forever_on(async move {
                    join_all(inputs.into_iter().map(|input| async {
                        let GetLinksInput {
                            base_address,
                            get_options,
                            link_type,
                            tag_prefix,
                            ..
                        } = input;

                        let key = WireLinkKey {
                            base: base_address,
                            type_query: link_type,
                            tag: tag_prefix,
                            after: None,
                            before: None,
                            author: None,
                        };
                        Ok(CascadeImpl::from_workspace_and_network(
                            &call_context.host_context.workspace(),
                            call_context.host_context.network().to_owned(),
                        )
                        .get_link_details(
                            key,
                            GetLinksOptions {
                                get_options,
                                ..Default::default()
                            },
                        )
                        .await?)
                    }))
                    .await
                });
            let results: Result<Vec<_>, RuntimeError> = results
                .into_iter()
                .map(|result| match result {
                    Ok(v) => Ok(v.into()),
                    Err(cascade_error) => {
                        Err(wasm_error!(WasmErrorInner::Host(cascade_error.to_string())).into())
                    }
                })
                .collect();
            Ok(results?)
        }
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "get_link_details".into(),
            )
            .to_string(),
        ))
        .into()),
    }
}

#[cfg(test)]
#[cfg(feature = "slow_tests")]
pub mod slow_tests {
    use crate::core::ribosome::wasm_test::RibosomeTestFixture;
    use crate::sweettest::{SweetConductorBatch, SweetConductorConfig, SweetDnaFile};
    use holo_hash::ActionHash;
    use holochain_wasm_test_utils::TestWasm;
    use holochain_zome_types::link::LinkDetails;
    use holochain_zome_types::record::SignedActionHashed;
    use holochain_zome_types::Action;

    #[tokio::test(flavor = "multi_thread")]
    async fn ribosome_entry_hash_path_children_details() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor, alice, ..
        } = RibosomeTestFixture::new(TestWasm::HashPath).await;

        // ensure foo.bar twice to ensure idempotency
        let _: () = conductor
            .call(&alice, "ensure", "foo.bar".to_string())
            .await;

        let _: () = conductor
            .call(&alice, "ensure", "foo.bar".to_string())
            .await;

        // ensure foo.baz
        let _: () = conductor
            .call(&alice, "ensure", "foo.baz".to_string())
            .await;

        let exists_output: bool = conductor.call(&alice, "exists", "foo".to_string()).await;

        assert!(exists_output);

        let _foo_bar: holo_hash::EntryHash = conductor
            .call(&alice, "path_entry_hash", "foo.bar".to_string())
            .await;

        let _foo_baz: holo_hash::EntryHash = conductor
            .call(&alice, "path_entry_hash", "foo.baz".to_string())
            .await;

        let children_details_output: holochain_zome_types::link::LinkDetails = conductor
            .call(&alice, "children_details", "foo".to_string())
            .await;

        let link_details = children_details_output.into_inner();

        let to_remove: SignedActionHashed = (link_details[0]).0.clone();

        let to_remove_hash = to_remove.as_hash().clone();

        let _remove_hash: holo_hash::ActionHash = conductor
            .call(&alice, "delete_link", to_remove_hash.clone())
            .await;

        let children_details_output_2: holochain_zome_types::link::LinkDetails = conductor
            .call(&alice, "children_details", "foo".to_string())
            .await;

        let children_details_output_2_vec = children_details_output_2.into_inner();
        assert_eq!(2, children_details_output_2_vec.len());

        let mut remove_happened = false;
        for (_, removes) in children_details_output_2_vec {
            if !removes.is_empty() {
                remove_happened = true;

                let link_add_address = unwrap_to
                    ::unwrap_to!(removes[0].action() => Action::DeleteLink)
                .link_add_address
                .clone();
                assert_eq!(link_add_address, to_remove_hash,);
            }
        }
        assert!(remove_happened);
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn get_link_details_local_only() {
        holochain_trace::test_run();
        // agents should not pass around data
        let config = SweetConductorConfig::rendezvous(false)
            .no_dpki()
            .tune(|config| {
                config.disable_historical_gossip = true;
                config.disable_recent_gossip = true;
                config.disable_publish = true;
            });
        let mut conductors = SweetConductorBatch::from_config_rendezvous(2, config).await;
        let (dna_file, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::Link]).await;
        let apps = conductors.setup_app("test", &[dna_file]).await.unwrap();

        // alice creates a link
        let zome_alice = apps[0].cells()[0].zome(TestWasm::Link.coordinator_zome_name());
        let _: ActionHash = conductors[0].call(&zome_alice, "create_link", ()).await;

        // now make both agents aware of each other
        conductors.exchange_peer_info().await;

        // bob gets link details locally only
        let zome_bob = apps[1].cells()[0].zome(TestWasm::Link.coordinator_zome_name());
        let local_link_details: LinkDetails = conductors[1]
            .call(&zome_bob, "get_link_details_local_only", ())
            .await;
        // link details should be empty
        assert_eq!(local_link_details.into_inner().len(), 0);
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/get_links.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::HostFnAccess;
use crate::core::ribosome::RibosomeError;
use crate::core::ribosome::RibosomeT;
use futures::StreamExt;
use holochain_cascade::CascadeImpl;
use holochain_p2p::actor::GetLinksOptions;
use holochain_types::prelude::*;
use holochain_wasmer_host::prelude::*;
use std::sync::Arc;
use wasmer::RuntimeError;

#[cfg_attr(feature = "instrument", tracing::instrument(skip(_ribosome, call_context), fields(?call_context.zome, function = ?call_context.function_name)))]
pub fn get_links(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    inputs: Vec<GetLinksInput>,
) -> Result<Vec<Vec<Link>>, RuntimeError> {
    let num_requests = inputs.len();
    tracing::debug!("Starting with {} requests.", num_requests);
    match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            read_workspace: Permission::Allow,
            ..
        } => {
            let results: Vec<Result<Vec<Link>, RibosomeError>> =
                tokio_helper::block_forever_on(async move {
                    let call_context_iter = std::iter::from_fn(|| Some(call_context.clone()));
                    futures::stream::iter(
                        std::iter::zip(inputs.into_iter(), call_context_iter).map(
                            |(input, call_context)| async move {
                                let GetLinksInput {
                                    base_address,
                                    link_type,
                                    get_options,
                                    tag_prefix,
                                    after,
                                    before,
                                    author,
                                } = input;

                                let key = WireLinkKey {
                                    base: base_address,
                                    type_query: link_type,
                                    tag: tag_prefix,
                                    after,
                                    before,
                                    author,
                                };
                                Ok(CascadeImpl::from_workspace_and_network(
                                    &call_context.host_context.workspace(),
                                    call_context.host_context.network().to_owned(),
                                )
                                .dht_get_links(
                                    key,
                                    GetLinksOptions {
                                        get_options,
                                        ..Default::default()
                                    },
                                )
                                .await?)
                            },
                        ),
                    )
                    // Limit concurrent calls to 10 as each call
                    // can spawn multiple connections.
                    .buffered(10)
                    .collect()
                    .await
                });
            let results: Result<Vec<_>, RuntimeError> = results
                .into_iter()
                .map(|result| match result {
                    Ok(links_vec) => Ok(links_vec),
                    Err(cascade_error) => {
                        Err(wasm_error!(WasmErrorInner::Host(cascade_error.to_string())).into())
                    }
                })
                .collect();
            let results = results?;
            tracing::debug!(
                "Ending with {} out of {} results, {} total links and {} total responses.",
                results.iter().filter(|r| !r.is_empty()).count(),
                num_requests,
                results.iter().map(|r| r.len()).sum::<usize>(),
                results.len(),
            );
            Ok(results)
        }
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "get_links".into(),
            )
            .to_string(),
        ))
        .into()),
    }
}

#[cfg(test)]
#[cfg(feature = "slow_tests")]
pub mod slow_tests {
    use crate::{
        core::ribosome::wasm_test::RibosomeTestFixture,
        sweettest::{SweetConductorBatch, SweetConductorConfig, SweetDnaFile},
    };
    use hdk::prelude::*;
    use holochain_test_wasm_common::*;
    use holochain_wasm_test_utils::TestWasm;

    #[tokio::test(flavor = "multi_thread")]
    async fn ribosome_entry_hash_path_children() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor, alice, ..
        } = RibosomeTestFixture::new(TestWasm::HashPath).await;

        // ensure foo.bar twice to ensure idempotency
        for _ in 0..2 {
            let _: () = conductor
                .call(&alice, "ensure", "foo.bar".to_string())
                .await;
        }

        // ensure foo.baz
        let _: () = conductor
            .call(&alice, "ensure", "foo.baz".to_string())
            .await;

        let exists_output: bool = conductor.call(&alice, "exists", "foo".to_string()).await;

        assert!(exists_output);

        let foo_bar: holo_hash::AnyLinkableHash = conductor
            .call(&alice, "path_entry_hash", "foo.bar".to_string())
            .await;

        let foo_baz: holo_hash::AnyLinkableHash = conductor
            .call(&alice, "path_entry_hash", "foo.baz".to_string())
            .await;

        let links: Vec<holochain_zome_types::link::Link> =
            conductor.call(&alice, "children", "foo".to_string()).await;

        assert_eq!(2, links.len());
        assert_eq!(links[0].target, foo_bar);
        assert_eq!(links[1].target, foo_baz);
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn hash_path_anchor_list_anchors() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor, alice, ..
        } = RibosomeTestFixture::new(TestWasm::Anchor).await;

        // anchor foo bar
        let anchor_address_one: EntryHash = conductor
            .call(
                &alice,
                "anchor",
                AnchorInput("foo".to_string(), "bar".to_string()),
            )
            .await;

        let expect = Path::from(vec![
            hdk::prelude::Component::new(hdi::hash_path::anchor::ROOT.to_vec()),
            hdk::prelude::Component::from("foo".as_bytes().to_vec()),
            hdk::prelude::Component::from("bar".as_bytes().to_vec()),
        ]);
        assert_eq!(
            anchor_address_one,
            EntryHash::with_data_sync(&Entry::App(AppEntryBytes(expect.try_into().unwrap())))
        );

        // anchor foo baz
        let anchor_address_two: EntryHash = conductor
            .call(
                &alice,
                "anchor",
                AnchorInput("foo".to_string(), "baz".to_string()),
            )
            .await;

        let expect = Path::from(vec![
            hdk::prelude::Component::new(hdi::hash_path::anchor::ROOT.to_vec()),
            hdk::prelude::Component::from("foo".as_bytes().to_vec()),
            hdk::prelude::Component::from("baz".as_bytes().to_vec()),
        ]);
        assert_eq!(
            anchor_address_two,
            EntryHash::with_data_sync(&Entry::App(AppEntryBytes(expect.try_into().unwrap())))
        );

        let list_anchor_type_addresses_output: EntryHashes = conductor
            .call(&alice, "list_anchor_type_addresses", ())
            .await;

        let expect = Path::from(vec![
            hdk::prelude::Component::new(hdi::hash_path::anchor::ROOT.to_vec()),
            hdk::prelude::Component::from("foo".as_bytes().to_vec()),
        ]);
        // should be 1 anchor type, "foo"
        assert_eq!(list_anchor_type_addresses_output.0.len(), 1);
        assert_eq!(
            (list_anchor_type_addresses_output.0)[0],
            EntryHash::with_data_sync(&Entry::App(AppEntryBytes(expect.try_into().unwrap())))
        );

        let list_anchor_addresses_output: EntryHashes = conductor
            .call(&alice, "list_anchor_addresses", "foo".to_string())
            .await;

        // should be 2 anchors under "foo" sorted by hash
        assert_eq!(list_anchor_addresses_output.0.len(), 2);
        assert_eq!(
            (list_anchor_addresses_output.0)[0].get_raw_32().to_vec(),
            anchor_address_one.get_raw_32().to_vec(),
        );
        assert_eq!(
            (list_anchor_addresses_output.0)[1].get_raw_32().to_vec(),
            anchor_address_two.get_raw_32().to_vec(),
        );

        let list_anchor_tags_output: Vec<String> = conductor
            .call(&alice, "list_anchor_tags", "foo".to_string())
            .await;

        assert_eq!(
            vec!["bar".to_string(), "baz".to_string()],
            list_anchor_tags_output,
        );
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn baseless_get_links() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor, alice, ..
        } = RibosomeTestFixture::new(TestWasm::Link).await;

        let action_hash: ActionHash = conductor.call(&alice, "create_baseless_link", ()).await;
        let links: Vec<Link> = conductor.call(&alice, "get_baseless_links", ()).await;

        assert_eq!(links[0].create_link_hash, action_hash);
        assert_eq!(
            links[0].target,
            EntryHash::from_raw_36([2_u8; 36].to_vec()).into(),
        );
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn external_get_links() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor, alice, ..
        } = RibosomeTestFixture::new(TestWasm::Link).await;

        let action_hash: ActionHash = conductor
            .call(&alice, "create_external_base_link", ())
            .await;
        let links: Vec<Link> = conductor.call(&alice, "get_external_links", ()).await;

        assert_eq!(links[0].create_link_hash, action_hash);
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn multi_get_links() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor, alice, ..
        } = RibosomeTestFixture::new(TestWasm::Link).await;

        let t1: Timestamp = conductor.call(&alice, "get_time", ()).await;
        let _: ActionHash = conductor.call(&alice, "create_link", ()).await;
        let t2: Timestamp = conductor.call(&alice, "get_time", ()).await;
        let _: ActionHash = conductor.call(&alice, "create_back_link", ()).await;
        let t3: Timestamp = conductor.call(&alice, "get_time", ()).await;
        let forward_links: Vec<Link> = conductor.call(&alice, "get_links", ()).await;
        let back_links: Vec<Link> = conductor.call(&alice, "get_back_links", ()).await;
        let links_bidi: Vec<Vec<Link>> = conductor.call(&alice, "get_links_bidi", ()).await;
        let hash_path_a: holo_hash::AnyLinkableHash =
            conductor.call(&alice, "get_path_hash", "a").await;
        let hash_path_b: holo_hash::AnyLinkableHash =
            conductor.call(&alice, "get_path_hash", "b").await;

        let forward_link_0 = forward_links.first().unwrap();
        assert_eq!(forward_link_0.base, hash_path_a);
        assert_eq!(forward_link_0.target, hash_path_b);
        assert_eq!(
            forward_link_0.author,
            alice.cell_id().agent_pubkey().clone()
        );
        assert_eq!(forward_link_0.tag, LinkTag::from(()));
        assert_eq!(forward_link_0.link_type, LinkType(0));
        assert_eq!(forward_link_0.zome_index, ZomeIndex(0));
        assert!(t1 <= forward_link_0.timestamp && t2 >= forward_link_0.timestamp);

        let back_link_0 = back_links.first().unwrap();
        assert_eq!(back_link_0.base, hash_path_b);
        assert_eq!(back_link_0.target, hash_path_a);
        assert_eq!(back_link_0.author, alice.cell_id().agent_pubkey().clone());
        assert_eq!(back_link_0.tag, LinkTag::from(()));
        assert_eq!(back_link_0.link_type, LinkType(0));
        assert_eq!(back_link_0.zome_index, ZomeIndex(0));
        assert!(t2 <= back_link_0.timestamp && t3 >= back_link_0.timestamp);
        assert_eq!(links_bidi, vec![forward_links.clone(), back_links.clone()]);

        let forward_link_details: LinkDetails =
            conductor.call(&alice, "get_link_details", ()).await;
        let back_link_details: LinkDetails =
            conductor.call(&alice, "get_back_link_details", ()).await;
        let link_details_bidi: Vec<LinkDetails> =
            conductor.call(&alice, "get_link_details_bidi", ()).await;

        assert_eq!(
            link_details_bidi,
            vec![forward_link_details, back_link_details],
        );
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn dup_path_test() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor, alice, ..
        } = RibosomeTestFixture::new(TestWasm::Link).await;

        for _ in 0..2 {
            let _result: () = conductor.call(&alice, "commit_existing_path", ()).await;
        }

        let links: Vec<hdk::prelude::Link> = conductor.call(&alice, "get_long_path", ()).await;
        assert_eq!(links.len(), 1);
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn get_links_filtered_by_tag_prefix() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor,
            alice,
            bob,
            ..
        } = RibosomeTestFixture::new(TestWasm::Link).await;

        let hash_a: ActionHash = conductor
            .call(&alice, "create_tagged_link", "a".to_string())
            .await;

        let hash_a_b: ActionHash = conductor
            .call(&bob, "create_tagged_link", "a.b".to_string())
            .await;

        let hash_a_b_c: ActionHash = conductor
            .call(&bob, "create_tagged_link", "a.b.c".to_string())
            .await;

        let hash_b: ActionHash = conductor
            .call(&alice, "create_tagged_link", "b".to_string())
            .await;

        let hash_b_a: ActionHash = conductor
            .call(&bob, "create_tagged_link", "b.a".to_string())
            .await;

        // Get the base all the links are attached from
        let base: AnyLinkableHash = conductor.call(&alice, "get_base_hash", ()).await;

        // Get all the links to check they've been created as expected
        let links: Vec<Link> = conductor
            .call(
                &alice,
                "get_links_with_query",
                GetLinksInputBuilder::try_new(
                    base.clone(),
                    LinkTypeFilter::Dependencies(vec![ZomeIndex(0)]),
                )
                .unwrap()
                .build(),
            )
            .await;
        assert_eq!(5, links.len());

        let links: Vec<Link> = conductor
            .call(
                &alice,
                "get_links_with_query",
                GetLinksInputBuilder::try_new(
                    base.clone(),
                    LinkTypeFilter::Dependencies(vec![ZomeIndex(0)]),
                )
                .unwrap()
                .tag_prefix(LinkTag::new("a"))
                .build(),
            )
            .await;
        assert_eq!(
            vec![hash_a.clone(), hash_a_b.clone(), hash_a_b_c.clone()],
            links
                .into_iter()
                .map(|l| l.create_link_hash)
                .collect::<Vec<ActionHash>>()
        );

        let links: Vec<Link> = conductor
            .call(
                &alice,
                "get_links_with_query",
                GetLinksInputBuilder::try_new(
                    base.clone(),
                    LinkTypeFilter::Dependencies(vec![ZomeIndex(0)]),
                )
                .unwrap()
                .tag_prefix(LinkTag::new("a.b"))
                .build(),
            )
            .await;
        assert_eq!(
            vec![hash_a_b, hash_a_b_c],
            links
                .into_iter()
                .map(|l| l.create_link_hash)
                .collect::<Vec<ActionHash>>()
        );

        let links: Vec<Link> = conductor
            .call(
                &alice,
                "get_links_with_query",
                GetLinksInputBuilder::try_new(
                    base.clone(),
                    LinkTypeFilter::Dependencies(vec![ZomeIndex(0)]),
                )
                .unwrap()
                .tag_prefix(LinkTag::new("b"))
                .build(),
            )
            .await;
        assert_eq!(
            vec![hash_b, hash_b_a],
            links
                .into_iter()
                .map(|l| l.create_link_hash)
                .collect::<Vec<ActionHash>>()
        );
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn get_links_filtered_by_timestamp_and_author() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor,
            alice,
            bob,
            ..
        } = RibosomeTestFixture::new(TestWasm::Link).await;

        let hash_a: ActionHash = conductor
            .call(&alice, "create_tagged_link", "a".to_string())
            .await;

        let hash_b: ActionHash = conductor
            .call(&bob, "create_tagged_link", "b".to_string())
            .await;

        let mid_time = Timestamp::now();

        let hash_c: ActionHash = conductor
            .call(&alice, "create_tagged_link", "c".to_string())
            .await;

        let hash_d: ActionHash = conductor
            .call(&bob, "create_tagged_link", "d".to_string())
            .await;

        // Get the base all the links are attached from
        let base: AnyLinkableHash = conductor.call(&alice, "get_base_hash", ()).await;

        // Get all the links to check they've been created as expected
        let links: Vec<Link> = conductor
            .call(
                &alice,
                "get_links_with_query",
                GetLinksInputBuilder::try_new(
                    base.clone(),
                    LinkTypeFilter::Dependencies(vec![ZomeIndex(0)]),
                )
                .unwrap()
                .build(),
            )
            .await;
        assert_eq!(4, links.len());

        // Filter by created before
        let links: Vec<Link> = conductor
            .call(
                &alice,
                "get_links_with_query",
                GetLinksInputBuilder::try_new(
                    base.clone(),
                    LinkTypeFilter::Dependencies(vec![ZomeIndex(0)]),
                )
                .unwrap()
                .before(mid_time)
                .build(),
            )
            .await;
        assert_eq!(
            vec![hash_a.clone(), hash_b],
            links
                .into_iter()
                .map(|l| l.create_link_hash)
                .collect::<Vec<ActionHash>>()
        );

        // Filter by created after
        let links: Vec<Link> = conductor
            .call(
                &alice,
                "get_links_with_query",
                GetLinksInputBuilder::try_new(
                    base.clone(),
                    LinkTypeFilter::Dependencies(vec![ZomeIndex(0)]),
                )
                .unwrap()
                .after(mid_time)
                .build(),
            )
            .await;
        assert_eq!(
            vec![hash_c.clone(), hash_d],
            links
                .into_iter()
                .map(|l| l.create_link_hash)
                .collect::<Vec<ActionHash>>()
        );

        // Filter by author
        let links: Vec<Link> = conductor
            .call(
                &alice,
                "get_links_with_query",
                GetLinksInputBuilder::try_new(
                    base,
                    LinkTypeFilter::Dependencies(vec![ZomeIndex(0)]),
                )
                .unwrap()
                .author(alice.cell_id().agent_pubkey().clone())
                .build(),
            )
            .await;
        assert_eq!(
            vec![hash_a, hash_c],
            links
                .into_iter()
                .map(|l| l.create_link_hash)
                .collect::<Vec<ActionHash>>()
        );
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn get_links_local_only() {
        holochain_trace::test_run();
        // agents should not pass around data
        let config = SweetConductorConfig::rendezvous(false)
            .no_dpki()
            .tune(|config| {
                config.disable_historical_gossip = true;
                config.disable_recent_gossip = true;
                config.disable_publish = true;
            });
        let mut conductors = SweetConductorBatch::from_config_rendezvous(2, config).await;
        let (dna_file, _, _) = SweetDnaFile::unique_from_test_wasms(vec![TestWasm::Link]).await;
        let apps = conductors.setup_app("test", &[dna_file]).await.unwrap();

        // alice creates a link
        let zome_alice = apps[0].cells()[0].zome(TestWasm::Link.coordinator_zome_name());
        let _: ActionHash = conductors[0].call(&zome_alice, "create_link", ()).await;

        // now make both agents aware of each other
        conductors.exchange_peer_info().await;

        // bob gets links locally only
        let zome_bob = apps[1].cells()[0].zome(TestWasm::Link.coordinator_zome_name());
        let local_links: Vec<Link> = conductors[1]
            .call(&zome_bob, "get_links_local_only", ())
            .await;
        // links should be empty
        assert_eq!(local_links.len(), 0);
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/get_validation_receipts.rs
================================================
use crate::core::ribosome::error::RibosomeError;
use crate::core::ribosome::{CallContext, RibosomeT};
use holochain_sqlite::db::DbKindDht;
use holochain_sqlite::prelude::DbRead;
use holochain_state::prelude::validation_receipts_for_action;
use holochain_types::access::{HostFnAccess, Permission};
use holochain_util::tokio_helper;
use holochain_wasmer_host::prelude::{wasm_error, WasmError, WasmErrorInner, WasmHostError};
use holochain_zome_types::prelude::{GetValidationReceiptsInput, ValidationReceiptSet};
use std::sync::Arc;
use wasmer::RuntimeError;

#[cfg_attr(feature = "instrument", tracing::instrument(skip(_ribosome, call_context), fields(?call_context.zome, function = ?call_context.function_name)))]
pub fn get_validation_receipts(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    input: GetValidationReceiptsInput,
) -> Result<Vec<ValidationReceiptSet>, RuntimeError> {
    match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            read_workspace: Permission::Allow,
            ..
        } => {
            let results = tokio_helper::block_forever_on(async move {
                let dht_db: DbRead<DbKindDht> = call_context.host_context.workspace().databases().1;

                dht_db
                    .read_async(move |txn| {
                        validation_receipts_for_action(txn, input.action_hash.clone())
                    })
                    .await
            })
            .map_err(|e| wasm_error!(WasmErrorInner::Host(e.to_string())))?;

            Ok(results)
        }
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "get_validation_receipts".into(),
            )
            .to_string(),
        ))
        .into()),
    }
}

#[cfg(test)]
mod tests {
    use crate::core::ribosome::host_fn::create::create;
    use crate::core::ribosome::host_fn::get_validation_receipts::get_validation_receipts;
    use crate::fixt::ZomeCallHostAccessFixturator;
    use crate::fixt::{CallContextFixturator, RealRibosomeFixturator};
    use ::fixt::Predictable;
    use ::fixt::{fixt, Unpredictable};
    use holochain_wasm_test_utils::{TestWasm, TestWasmPair};
    use holochain_zome_types::prelude::*;
    use std::sync::Arc;

    #[tokio::test(flavor = "multi_thread")]
    async fn call_get_validation_receipts() {
        let ribosome = RealRibosomeFixturator::new(crate::fixt::curve::Zomes(vec![TestWasm::Crd]))
            .next()
            .unwrap();
        let mut call_context = CallContextFixturator::new(Unpredictable).next().unwrap();
        call_context.zome = TestWasmPair::<IntegrityZome, CoordinatorZome>::from(TestWasm::Crd)
            .coordinator
            .erase_type();
        let host_access = fixt!(ZomeCallHostAccess, Predictable);
        call_context.host_context = host_access.into();

        let app_entry = EntryFixturator::new(AppEntry).next().unwrap();
        let input = CreateInput::new(
            EntryDefLocation::app(0, 0),
            EntryVisibility::Public,
            app_entry.clone(),
            ChainTopOrdering::default(),
        );
        let ribosome_handle = Arc::new(ribosome);
        let action_hash = create(
            ribosome_handle.clone(),
            Arc::new(call_context.clone()),
            input,
        )
        .unwrap();

        let receipts = get_validation_receipts(
            ribosome_handle.clone(),
            Arc::new(call_context.clone()),
            GetValidationReceiptsInput::new(action_hash),
        )
        .unwrap();

        // Not the most useful test/assertion. Just checking that this doesn't error and checking
        // that this gives back validation receipts will require an integration test.
        assert!(receipts.is_empty());
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/hash.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::RibosomeT;
use holo_hash::encode::blake2b_n;
use holo_hash::HasHash;
use holochain_wasmer_host::prelude::*;
use holochain_zome_types::prelude::*;
use std::sync::Arc;
use sha3::Digest;
use wasmer::RuntimeError;

pub fn hash(
    _ribosome: Arc<impl RibosomeT>,
    _call_context: Arc<CallContext>,
    input: HashInput,
) -> Result<HashOutput, RuntimeError> {
    Ok(match input {
        HashInput::Entry(entry) => HashOutput::Entry(
            holochain_zome_types::entry::EntryHashed::from_content_sync(entry).into_hash(),
        ),
        HashInput::Action(action) => HashOutput::Action(
            holochain_zome_types::action::ActionHashed::from_content_sync(action).into_hash(),
        ),
        HashInput::Blake2B(data, output_len) => {
            HashOutput::Blake2B(blake2b_n(&data, output_len as usize).map_err(
                |e| -> RuntimeError { wasm_error!(WasmErrorInner::Host(e.to_string())).into() },
            )?)
        }
        HashInput::Keccak256(data) => HashOutput::Keccak256({
            let mut hasher = sha3::Keccak256::new();
            hasher.update(data);

            hasher.finalize().as_slice().try_into().map_err(|e| {
                wasm_error!(WasmErrorInner::Host(format!(
                    "Failed to convert keccak256 output: {:?}",
                    e
                )))
            })?
        }),
        HashInput::Sha3256(data) => HashOutput::Sha3256({
            let mut hasher = sha3::Sha3_256::new();
            hasher.update(data);
            hasher.finalize().as_slice().try_into().map_err(|e| {
                wasm_error!(WasmErrorInner::Host(format!(
                    "Failed to convert sha3-256 output: {:?}",
                    e
                )))
            })?
        }),
        _ => {
            return Err(wasm_error!(WasmErrorInner::Host(format!(
                "Unimplemented hashing algorithm {:?}",
                input
            )))
            .into())
        }
    })
}

#[cfg(test)]
#[cfg(feature = "slow_tests")]
pub mod wasm_test {
    use super::*;
    use crate::core::ribosome::host_fn::hash::hash;

    use crate::core::ribosome::wasm_test::RibosomeTestFixture;
    use crate::fixt::CallContextFixturator;
    use crate::fixt::EntryFixturator;
    use crate::fixt::RealRibosomeFixturator;
    use ::fixt::prelude::*;
    use hdk::prelude::*;
    use holo_hash::EntryHash;
    use holochain_wasm_test_utils::TestWasm;
    use std::sync::Arc;

    #[tokio::test(flavor = "multi_thread")]
    /// we can get an entry hash out of the fn directly
    async fn hash_test() {
        let ribosome = Arc::new(
            RealRibosomeFixturator::new(crate::fixt::curve::Zomes(vec![]))
                .next()
                .unwrap(),
        );
        let call_context = Arc::new(
            CallContextFixturator::new(::fixt::Unpredictable)
                .next()
                .unwrap(),
        );
        let entry_input =
            HashInput::Entry(EntryFixturator::new(::fixt::Predictable).next().unwrap());

        let entry_output: EntryHash = match hash(
            Arc::clone(&ribosome),
            Arc::clone(&call_context),
            entry_input,
        )
        .unwrap()
        {
            HashOutput::Entry(output) => output,
            _ => unreachable!(),
        };

        assert_eq!(*entry_output.hash_type(), holo_hash::hash_type::Entry);

        let action_input = HashInput::Action(fixt!(Action));

        let action_output: ActionHash = match hash(
            Arc::clone(&ribosome),
            Arc::clone(&call_context),
            action_input,
        )
        .unwrap()
        {
            HashOutput::Action(output) => output,
            _ => unreachable!(),
        };

        assert_eq!(*action_output.hash_type(), holo_hash::hash_type::Action);

        let blake2b_input = HashInput::Blake2B(vec![1, 2, 3], 5);

        let blake2b_output: Vec<u8> = match hash(
            Arc::clone(&ribosome),
            Arc::clone(&call_context),
            blake2b_input,
        )
        .unwrap()
        {
            HashOutput::Blake2B(output) => output,
            _ => unreachable!(),
        };

        // a lovely 5 byte blake2b hash.
        assert_eq!(blake2b_output, vec![89, 41, 133, 48, 237,]);

        let keccak_input = HashInput::Keccak256(vec![0]);

        let keccak_output: Hash256Bits = match hash(
            Arc::clone(&ribosome),
            Arc::clone(&call_context),
            keccak_input,
        )
        .unwrap()
        {
            HashOutput::Keccak256(output) => output,
            _ => unreachable!(),
        };

        // https://emn178.github.io/online-tools/keccak_256.html
        // bc36789e7a1e281436464229828f817d6612f7b477d66591ff96a9e064bcc98a
        assert_eq!(
            keccak_output,
            [
                0xbc, 0x36, 0x78, 0x9e, 0x7a, 0x1e, 0x28, 0x14, 0x36, 0x46, 0x42, 0x29, 0x82, 0x8f,
                0x81, 0x7d, 0x66, 0x12, 0xf7, 0xb4, 0x77, 0xd6, 0x65, 0x91, 0xff, 0x96, 0xa9, 0xe0,
                0x64, 0xbc, 0xc9, 0x8a
            ]
            .into(),
        );

        let sha3_input = HashInput::Sha3256(vec![0]);

        let sha3_output: Hash256Bits =
            match hash(Arc::clone(&ribosome), Arc::clone(&call_context), sha3_input).unwrap() {
                HashOutput::Sha3256(output) => output,
                _ => unreachable!(),
            };

        // https://emn178.github.io/online-tools/sha3_256.html
        // 5d53469f20fef4f8eab52b88044ede69c77a6a68a60728609fc4a65ff531e7d0
        assert_eq!(
            sha3_output,
            [
                0x5d, 0x53, 0x46, 0x9f, 0x20, 0xfe, 0xf4, 0xf8, 0xea, 0xb5, 0x2b, 0x88, 0x04, 0x4e,
                0xde, 0x69, 0xc7, 0x7a, 0x6a, 0x68, 0xa6, 0x07, 0x28, 0x60, 0x9f, 0xc4, 0xa6, 0x5f,
                0xf5, 0x31, 0xe7, 0xd0
            ]
            .into(),
        );
    }

    #[tokio::test(flavor = "multi_thread")]
    /// we can get an entry hash out of the fn via. a wasm call
    async fn ribosome_hash_entry_test() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor, alice, ..
        } = RibosomeTestFixture::new(TestWasm::HashEntry).await;
        let input = EntryFixturator::new(::fixt::Predictable).next().unwrap();
        let output: EntryHash = conductor.call(&alice, "hash_entry", input).await;
        assert_eq!(*output.hash_type(), holo_hash::hash_type::Entry);

        let entry_hash_output: EntryHash = conductor
            .call(&alice, "twenty_three_degrees_entry_hash", ())
            .await;

        let hash_output: EntryHash = conductor
            .call(&alice, "twenty_three_degrees_hash", ())
            .await;

        assert_eq!(entry_hash_output, hash_output);
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/is_same_agent.rs
================================================
use crate::core::ribosome::guest_callback::validate::ValidateHostAccess;
use crate::core::ribosome::CallContext;
use crate::core::ribosome::HostContext;
use crate::core::ribosome::RibosomeError;
use crate::core::ribosome::RibosomeT;
use holochain_types::prelude::*;
use holochain_wasmer_host::prelude::*;
use std::sync::Arc;
use wasmer::RuntimeError;

pub fn is_same_agent(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    input: (AgentPubKey, AgentPubKey),
) -> Result<bool, RuntimeError> {
    match &call_context.host_context() {
        HostContext::Validate(ValidateHostAccess { dpki, .. }) => {
            match dpki {
                // If DPKI is not installed, compare input agent keys directly. Returns `true` only
                // when agent keys are identical.
                None => Ok(input.0 == input.1),
                // DPKI is installed, call Deepkey function.
                Some(dpki) => tokio_helper::block_forever_on(async move {
                    let state = dpki.state().await;
                    state
                        .is_same_agent(input.0, input.1)
                        .await
                        .map_err(|error| RuntimeError::new(error.to_string()))
                }),
            }
        }
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "is_same_agent".into()
            )
            .to_string()
        ))
        .into()),
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/must_get_action.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::HostContext;
use crate::core::ribosome::RibosomeError;
use crate::core::ribosome::RibosomeT;
use holochain_cascade::{Cascade, CascadeImpl};
use holochain_p2p::actor::GetOptions as NetworkGetOptions;
use holochain_types::prelude::*;
use holochain_wasmer_host::prelude::*;
use std::sync::Arc;
use wasmer::RuntimeError;

#[cfg_attr(
    feature = "instrument",
    tracing::instrument(skip(_ribosome, call_context))
)]
pub fn must_get_action(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    input: MustGetActionInput,
) -> Result<SignedActionHashed, RuntimeError> {
    tracing::debug!("begin must_get_action");
    let ret = match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            read_workspace_deterministic: Permission::Allow,
            ..
        } => {
            let action_hash = input.into_inner();

            // timeouts must be handled by the network
            tokio_helper::block_forever_on(async move {
                let workspace = call_context.host_context.workspace();
                use crate::core::ribosome::ValidateHostAccess;
                let cascade = match call_context.host_context {
                    HostContext::Validate(ValidateHostAccess { is_inline, .. }) => {
                        if is_inline {
                            CascadeImpl::from_workspace_and_network(
                                &workspace,
                                call_context.host_context.network().clone(),
                            )
                        } else {
                            CascadeImpl::from_workspace_stores(workspace.stores(), None)
                        }
                    }
                    _ => CascadeImpl::from_workspace_and_network(
                        &workspace,
                        call_context.host_context.network().clone(),
                    ),
                };
                match cascade
                    .retrieve_action(action_hash.clone(), NetworkGetOptions::must_get_options())
                    .await
                    .map_err(|cascade_error| -> RuntimeError {
                        wasm_error!(WasmErrorInner::Host(cascade_error.to_string())).into()
                    })? {
                    Some((action, _)) => Ok(action),
                    None => match call_context.host_context {
                        HostContext::EntryDefs(_)
                        | HostContext::GenesisSelfCheckV1(_)
                        | HostContext::GenesisSelfCheckV2(_)
                        | HostContext::PostCommit(_)
                        | HostContext::ZomeCall(_) => Err(wasm_error!(WasmErrorInner::Host(
                            format!("Failed to get SignedActionHashed {}", action_hash)
                        ))
                        .into()),
                        HostContext::Init(_) => Err(wasm_error!(WasmErrorInner::HostShortCircuit(
                            holochain_serialized_bytes::encode(
                                &ExternIO::encode(InitCallbackResult::UnresolvedDependencies(
                                    UnresolvedDependencies::Hashes(vec![action_hash.into()],)
                                ))
                                .map_err(|e| -> RuntimeError { wasm_error!(e).into() })?,
                            )
                            .map_err(|e| -> RuntimeError { wasm_error!(e).into() })?
                        ))
                        .into()),
                        HostContext::Validate(_) => {
                            Err(wasm_error!(WasmErrorInner::HostShortCircuit(
                                holochain_serialized_bytes::encode(
                                    &ExternIO::encode(
                                        ValidateCallbackResult::UnresolvedDependencies(
                                            UnresolvedDependencies::Hashes(
                                                vec![action_hash.into()],
                                            )
                                        )
                                    )
                                    .map_err(|e| -> RuntimeError { wasm_error!(e).into() })?,
                                )
                                .map_err(|e| -> RuntimeError { wasm_error!(e).into() })?
                            ))
                            .into())
                        }
                    },
                }
            })
        }
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "must_get_action".into(),
            )
            .to_string(),
        ))
        .into()),
    };
    tracing::debug!(?ret);
    ret
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/must_get_agent_activity.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::HostContext;
use crate::core::ribosome::HostFnAccess;
use crate::core::ribosome::RibosomeError;
use crate::core::ribosome::RibosomeT;
use holochain_cascade::CascadeImpl;
use holochain_state::mutations::insert_op_cache;
use holochain_types::prelude::*;
use holochain_wasmer_host::prelude::*;
use std::sync::Arc;
use wasmer::RuntimeError;

#[cfg_attr(
    feature = "instrument",
    tracing::instrument(skip(_ribosome, call_context))
)]
pub fn must_get_agent_activity(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    input: MustGetAgentActivityInput,
) -> Result<Vec<RegisterAgentActivity>, RuntimeError> {
    tracing::debug!("begin must_get_agent_activity");
    let ret = match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            read_workspace_deterministic: Permission::Allow,
            ..
        } => {
            let MustGetAgentActivityInput {
                author,
                chain_filter,
            } = input;

            // timeouts must be handled by the network
            tokio_helper::block_forever_on(async move {
                let workspace = call_context.host_context.workspace();
                use crate::core::ribosome::ValidateHostAccess;
                let cascade = match call_context.host_context {
                    HostContext::Validate(ValidateHostAccess { is_inline, .. }) => {
                        if is_inline {
                            CascadeImpl::from_workspace_and_network(
                                &workspace,
                                call_context.host_context.network().clone(),
                            )
                        } else {
                            CascadeImpl::from_workspace_stores(workspace.stores(), None)
                        }
                    }
                    _ => CascadeImpl::from_workspace_and_network(
                        &workspace,
                        call_context.host_context.network().clone(),
                    ),
                };
                let result = cascade
                    .must_get_agent_activity(author.clone(), chain_filter.clone())
                    .await
                    .map_err(|cascade_error| -> RuntimeError {
                        wasm_error!(WasmErrorInner::Host(cascade_error.to_string())).into()
                    })?;

                use MustGetAgentActivityResponse::*;

                let result: Result<_, RuntimeError> = match (result, &call_context.host_context) {
                    (Activity {activity, warrants}, _) => {
                        if !warrants.is_empty() {
                            if let Some(db) = cascade.cache() {
                                db.write_async(|txn| {
                                    for warrant in warrants {
                                        insert_op_cache(txn, &DhtOpHashed::from_content_sync(warrant))?;
                                    }
                                    crate::conductor::error::ConductorResult::Ok(())
                                }).await.map_err(|e| -> RuntimeError { wasm_error!(e).into() })?;
                            }
                        }
                        Ok(activity)},
                    (IncompleteChain | ChainTopNotFound(_), HostContext::Init(_)) => {
                        Err(wasm_error!(WasmErrorInner::HostShortCircuit(
                            holochain_serialized_bytes::encode(
                                &ExternIO::encode(InitCallbackResult::UnresolvedDependencies(
                                    UnresolvedDependencies::AgentActivity(author, chain_filter)
                                ))
                                .map_err(|e| -> RuntimeError { wasm_error!(e).into() })?,
                            )
                            .map_err(|e| -> RuntimeError { wasm_error!(e).into() })?
                        ))
                        .into())
                    }
                    (IncompleteChain | ChainTopNotFound(_), HostContext::Validate(_)) => {
                        Err(wasm_error!(WasmErrorInner::HostShortCircuit(
                            holochain_serialized_bytes::encode(
                                &ExternIO::encode(ValidateCallbackResult::UnresolvedDependencies(
                                    UnresolvedDependencies::AgentActivity(author, chain_filter)
                                ))
                                .map_err(|e| -> RuntimeError { wasm_error!(e).into() })?,
                            )
                            .map_err(|e| -> RuntimeError { wasm_error!(e).into() })?
                        ))
                        .into())
                    }
                    (IncompleteChain, _) => Err(wasm_error!(WasmErrorInner::Host(format!(
                        "must_get_agent_activity chain is incomplete for author {} and filter {:?}",
                        author, chain_filter
                    )))
                    .into()),
                    (ChainTopNotFound(missing_action), _) => Err(wasm_error!(WasmErrorInner::Host(format!(
                        "must_get_agent_activity is missing action {} for author {} and filter {:?}",
                        missing_action, author, chain_filter
                    )))
                    .into()),
                    (EmptyRange, _) => Err(wasm_error!(WasmErrorInner::Host(format!(
                        "must_get_agent_activity chain has produced an invalid range because the range is empty for author {} and filter {:?}",
                        author, chain_filter
                    )))
                    .into()),
                };

                result
            })
        }
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "must_get_agent_activity".into(),
            )
            .to_string(),
        ))
        .into()),
    };
    tracing::debug!(?ret);
    ret
}

#[cfg(test)]
pub mod test {
    use crate::core::ribosome::wasm_test::RibosomeTestFixture;
    use hdk::prelude::*;
    use holochain_wasm_test_utils::TestWasm;

    /// Mimics inside the must_get wasm.
    #[derive(serde::Serialize, serde::Deserialize, SerializedBytes, Debug, PartialEq)]
    struct Something(#[serde(with = "serde_bytes")] Vec<u8>);

    /// Test that validation can get the currently-being-validated agent's
    /// activity.
    #[tokio::test(flavor = "multi_thread")]
    async fn ribosome_must_get_agent_activity_self() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor, alice, ..
        } = RibosomeTestFixture::new(TestWasm::MustGet).await;

        // This test is a repro of some issue where the init being inline with
        // the commit being validated may or may not be important. For that
        // reason this test should not be merged with other tests/assertions.
        let _: () = conductor
            .call(&alice, "commit_require_self_agents_chain", ())
            .await;
    }

    /// Test that validation can get the currently-being-validated agent's
    /// previous action bounded activity.
    #[tokio::test(flavor = "multi_thread")]
    async fn ribosome_must_get_agent_activity_self_prev() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor, alice, ..
        } = RibosomeTestFixture::new(TestWasm::MustGet).await;

        // This test is a repro of some issue where the init being inline with
        // the commit being validated may or may not be important. For that
        // reason this test should not be merged with other tests/assertions.
        let _: () = conductor
            .call(&alice, "commit_require_self_prev_agents_chain", ())
            .await;
    }

    #[tokio::test(flavor = "multi_thread")]
    #[cfg_attr(target_os = "macos", ignore = "flaky")]
    async fn ribosome_must_get_agent_activity() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor,
            alice,
            bob,
            ..
        } = RibosomeTestFixture::new(TestWasm::MustGet).await;

        let a: ActionHash = conductor
            .call(&bob, "commit_something", Something(vec![1]))
            .await;

        let b: ActionHash = conductor
            .call(&bob, "commit_something", Something(vec![2]))
            .await;

        let c: ActionHash = conductor
            .call(&bob, "commit_something", Something(vec![3]))
            .await;

        let filter = ChainFilter::new(a.clone());

        let _: ActionHash = conductor
            .call(
                &alice,
                "commit_require_agents_chain",
                (bob.cell_id().agent_pubkey().clone(), filter.clone()),
            )
            .await;

        // Try the same filter but on alice's chain.
        // This will fail because alice does not have `a` hash in her chain.
        let err: Result<ActionHash, _> = conductor
            .call_fallible(
                &alice,
                "commit_require_agents_chain",
                (alice.cell_id().agent_pubkey().clone(), filter),
            )
            .await;

        err.unwrap_err();

        let _: ActionHash = conductor
            .call(
                &alice,
                "commit_require_agents_chain_recursive",
                (bob.cell_id().agent_pubkey().clone(), c.clone()),
            )
            .await;

        for i in 3..30 {
            let _: ActionHash = conductor
                .call(&bob, "commit_something", Something(vec![i]))
                .await;
        }

        let d: ActionHash = conductor
            .call(&bob, "commit_something", Something(vec![21]))
            .await;

        // Give bob time to integrate
        tokio::time::sleep(std::time::Duration::from_secs(1)).await;

        let _: ActionHash = conductor
            .call(
                &alice,
                "commit_require_agents_chain_recursive",
                (bob.cell_id().agent_pubkey().clone(), d.clone()),
            )
            .await;

        let filter = ChainFilter::new(c.clone()).until(a.clone());

        let r: Vec<RegisterAgentActivity> = conductor
            .call(
                &alice,
                "call_must_get_agent_activity",
                (bob.cell_id().agent_pubkey().clone(), filter.clone()),
            )
            .await;

        assert_eq!(
            r.into_iter()
                .map(|op| op.action.hashed.hash)
                .collect::<Vec<_>>(),
            vec![c, b, a]
        )
    }
}



================================================
File: crates/holochain/src/core/ribosome/host_fn/must_get_entry.rs
================================================
use crate::core::ribosome::CallContext;
use crate::core::ribosome::HostContext;
use crate::core::ribosome::RibosomeError;
use crate::core::ribosome::RibosomeT;
use holochain_cascade::{Cascade, CascadeImpl};
use holochain_p2p::actor::GetOptions as NetworkGetOptions;
use holochain_types::prelude::*;
use holochain_wasmer_host::prelude::*;
use std::sync::Arc;
use wasmer::RuntimeError;

#[cfg_attr(
    feature = "instrument",
    tracing::instrument(skip(_ribosome, call_context))
)]
pub fn must_get_entry(
    _ribosome: Arc<impl RibosomeT>,
    call_context: Arc<CallContext>,
    input: MustGetEntryInput,
) -> Result<EntryHashed, RuntimeError> {
    tracing::debug!("begin must_get_entry");
    let ret = match HostFnAccess::from(&call_context.host_context()) {
        HostFnAccess {
            read_workspace_deterministic: Permission::Allow,
            ..
        } => {
            let entry_hash = input.into_inner();
            // timeouts must be handled by the network
            tokio_helper::block_forever_on(async move {
                let workspace = call_context.host_context.workspace();
                use crate::core::ribosome::ValidateHostAccess;
                let cascade = match call_context.host_context {
                    HostContext::Validate(ValidateHostAccess { is_inline, .. }) => {
                        if is_inline {
                            CascadeImpl::from_workspace_and_network(
                                &workspace,
                                call_context.host_context.network().clone(),
                            )
                        } else {
                            CascadeImpl::from_workspace_stores(workspace.stores(), None)
                        }
                    }
                    _ => CascadeImpl::from_workspace_and_network(
                        &workspace,
                        call_context.host_context.network().clone(),
                    ),
                };
                match cascade
                    .retrieve_entry(entry_hash.clone(), NetworkGetOptions::must_get_options())
                    .await
                    .map_err(|cascade_error| -> RuntimeError {
                        wasm_error!(WasmErrorInner::Host(cascade_error.to_string())).into()
                    })? {
                    Some((entry, _)) => Ok(entry),
                    None => match call_context.host_context {
                        HostContext::EntryDefs(_)
                        | HostContext::GenesisSelfCheckV1(_)
                        | HostContext::GenesisSelfCheckV2(_)
                        | HostContext::PostCommit(_)
                        | HostContext::ZomeCall(_) => Err(wasm_error!(WasmErrorInner::Host(
                            format!("Failed to get EntryHashed {}", entry_hash)
                        ))
                        .into()),
                        HostContext::Init(_) => Err(wasm_error!(WasmErrorInner::HostShortCircuit(
                            holochain_serialized_bytes::encode(
                                &ExternIO::encode(InitCallbackResult::UnresolvedDependencies(
                                    UnresolvedDependencies::Hashes(vec![entry_hash.into()],)
                                ))
                                .map_err(|e| -> RuntimeError { wasm_error!(e).into() })?,
                            )
                            .map_err(|e| -> RuntimeError { wasm_error!(e).into() })?
                        ))
                        .into()),
                        HostContext::Validate(_) => {
                            Err(wasm_error!(WasmErrorInner::HostShortCircuit(
                                holochain_serialized_bytes::encode(
                                    &ExternIO::encode(
                                        ValidateCallbackResult::UnresolvedDependencies(
                                            UnresolvedDependencies::Hashes(
                                                vec![entry_hash.into(),]
                                            )
                                        ),
                                    )
                                    .map_err(|e| -> RuntimeError { wasm_error!(e).into() })?
                                )
                                .map_err(|e| -> RuntimeError { wasm_error!(e).into() })?,
                            ))
                            .into())
                        }
                    },
                }
            })
        }
        _ => Err(wasm_error!(WasmErrorInner::Host(
            RibosomeError::HostFnPermissions(
                call_context.zome.zome_name().clone(),
                call_context.function_name().clone(),
                "must_get_entry".into(),
            )
            .to_string(),
        ))
        .into()),
    };
    tracing::debug!(?ret);
    ret
}

#[cfg(test)]
pub mod test {
    use crate::core::ribosome::wasm_test::RibosomeTestFixture;
    use crate::test_entry_impl;
    use hdk::prelude::*;
    use holochain_state::prelude::*;
    use holochain_wasm_test_utils::TestWasm;
    use unwrap_to::unwrap_to;

    /// Mimics inside the must_get wasm.
    #[derive(serde::Serialize, serde::Deserialize, SerializedBytes, Debug, PartialEq)]
    struct Something(#[serde(with = "serde_bytes")] Vec<u8>);

    test_entry_impl!(Something);

    #[tokio::test(flavor = "multi_thread")]
    async fn ribosome_must_get_entry_test() {
        holochain_trace::test_run();
        let RibosomeTestFixture {
            conductor,
            alice,
            bob,
            alice_host_fn_caller,
            ..
        } = RibosomeTestFixture::new(TestWasm::MustGet).await;

        let entry = Entry::try_from(Something(vec![1, 2, 3])).unwrap();
        let action_hash = alice_host_fn_caller
            .commit_entry(
                entry.clone(),
                EntryDefLocation::app(0, EntryDefIndex(0)),
                EntryVisibility::Public,
            )
            .await;

        let dht_db = conductor
            .raw_handle()
            .get_dht_db(alice.cell_id().dna_hash())
            .unwrap();

        // When we first get the record it will return because we haven't yet
        // set the validation status.
        let record: Record = conductor
            .call(&bob, "must_get_valid_record", action_hash.clone())
            .await;

        let signature = record.signature().clone();
        let action = record.action().clone();
        let record_entry: RecordEntry = record.entry().clone();
        let entry = record_entry.clone().into_option().unwrap();
        let entry_state = DhtOpHashed::from_content_sync(ChainOp::StoreEntry(
            signature.clone(),
            NewEntryAction::try_from(action.clone()).unwrap(),
            entry.clone(),
        ));
        let record_state = DhtOpHashed::from_content_sync(ChainOp::StoreRecord(
            signature,
            action.clone(),
            record_entry,
        ));
        dht_db
            .write_async(move |txn| -> StateMutationResult<()> {
                set_validation_status(txn, record_state.as_hash(), ValidationStatus::Rejected)?;
                set_validation_status(txn, entry_state.as_hash(), ValidationStatus::Rejected)?;

                Ok(())
            })
            .await
            .unwrap();

        // Must get entry returns the entry if it exists regardless of the
        // validation status.
        let must_get_entry: EntryHashed = conductor
